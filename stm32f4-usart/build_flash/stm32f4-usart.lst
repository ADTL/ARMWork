
stm32f4-usart.elf:     file format elf32-littlearm


Disassembly of section .text:

08000188 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8000188:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 800018c:	4b02      	ldr	r3, [pc, #8]	; (8000198 <NVIC_PriorityGroupConfig+0x10>)
 800018e:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8000192:	60d8      	str	r0, [r3, #12]
 8000194:	4770      	bx	lr
 8000196:	bf00      	nop
 8000198:	e000ed00 	.word	0xe000ed00

0800019c <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 800019c:	78c3      	ldrb	r3, [r0, #3]
 800019e:	b30b      	cbz	r3, 80001e4 <NVIC_Init+0x48>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80001a0:	4b16      	ldr	r3, [pc, #88]	; (80001fc <NVIC_Init+0x60>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80001a2:	7841      	ldrb	r1, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80001a4:	68db      	ldr	r3, [r3, #12]
 80001a6:	43db      	mvns	r3, r3
 80001a8:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
 80001ac:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80001b0:	b2d2      	uxtb	r2, r2
 80001b2:	fa01 f202 	lsl.w	r2, r1, r2
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 80001b6:	210f      	movs	r1, #15
 80001b8:	fa41 f303 	asr.w	r3, r1, r3

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80001bc:	7881      	ldrb	r1, [r0, #2]
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80001be:	b2d2      	uxtb	r2, r2
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80001c0:	400b      	ands	r3, r1
 80001c2:	431a      	orrs	r2, r3
        
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80001c4:	7803      	ldrb	r3, [r0, #0]
 80001c6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80001ca:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    tmpsub = tmpsub >> tmppriority;

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
        
    tmppriority = tmppriority << 0x04;
 80001ce:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80001d0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001d4:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80001d6:	2201      	movs	r2, #1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001d8:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80001da:	f003 031f 	and.w	r3, r3, #31
 80001de:	fa02 f303 	lsl.w	r3, r2, r3
 80001e2:	e007      	b.n	80001f4 <NVIC_Init+0x58>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001e4:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80001e6:	2201      	movs	r2, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001e8:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80001ea:	f003 031f 	and.w	r3, r3, #31
 80001ee:	fa02 f303 	lsl.w	r3, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001f2:	3120      	adds	r1, #32
 80001f4:	4a02      	ldr	r2, [pc, #8]	; (8000200 <NVIC_Init+0x64>)
 80001f6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 80001fa:	4770      	bx	lr
 80001fc:	e000ed00 	.word	0xe000ed00
 8000200:	e000e100 	.word	0xe000e100

08000204 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8000204:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8000208:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 800020c:	4b01      	ldr	r3, [pc, #4]	; (8000214 <NVIC_SetVectorTable+0x10>)
 800020e:	4308      	orrs	r0, r1
 8000210:	6098      	str	r0, [r3, #8]
 8000212:	4770      	bx	lr
 8000214:	e000ed00 	.word	0xe000ed00

08000218 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8000218:	4b04      	ldr	r3, [pc, #16]	; (800022c <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 800021a:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 800021c:	b109      	cbz	r1, 8000222 <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 800021e:	4310      	orrs	r0, r2
 8000220:	e001      	b.n	8000226 <NVIC_SystemLPConfig+0xe>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8000222:	ea22 0000 	bic.w	r0, r2, r0
 8000226:	6118      	str	r0, [r3, #16]
 8000228:	4770      	bx	lr
 800022a:	bf00      	nop
 800022c:	e000ed00 	.word	0xe000ed00

08000230 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8000230:	4b04      	ldr	r3, [pc, #16]	; (8000244 <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8000232:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8000234:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8000236:	bf0c      	ite	eq
 8000238:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 800023c:	f022 0204 	bicne.w	r2, r2, #4
 8000240:	601a      	str	r2, [r3, #0]
 8000242:	4770      	bx	lr
 8000244:	e000e010 	.word	0xe000e010

08000248 <ADC_DeInit>:
  *         values.
  * @param  None
  * @retval None
  */
void ADC_DeInit(void)
{
 8000248:	b508      	push	{r3, lr}
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
 800024a:	2101      	movs	r1, #1
 800024c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000250:	f003 fac4 	bl	80037dc <RCC_APB2PeriphResetCmd>
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 8000254:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000258:	2100      	movs	r1, #0
}
 800025a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 800025e:	f003 babd 	b.w	80037dc <RCC_APB2PeriphResetCmd>

08000262 <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8000262:	6842      	ldr	r2, [r0, #4]
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8000264:	680b      	ldr	r3, [r1, #0]
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8000266:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 800026a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 800026e:	4313      	orrs	r3, r2
 8000270:	790a      	ldrb	r2, [r1, #4]
 8000272:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8000276:	6043      	str	r3, [r0, #4]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8000278:	68ca      	ldr	r2, [r1, #12]
 800027a:	690b      	ldr	r3, [r1, #16]
 800027c:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 800027e:	688b      	ldr	r3, [r1, #8]
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8000280:	b510      	push	{r4, lr}
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8000282:	431a      	orrs	r2, r3
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8000284:	6884      	ldr	r4, [r0, #8]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8000286:	4b08      	ldr	r3, [pc, #32]	; (80002a8 <ADC_Init+0x46>)
 8000288:	4023      	ands	r3, r4
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 800028a:	4313      	orrs	r3, r2
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 800028c:	794a      	ldrb	r2, [r1, #5]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 800028e:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8000292:	6083      	str	r3, [r0, #8]
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8000294:	7d0b      	ldrb	r3, [r1, #20]
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8000296:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8000298:	3b01      	subs	r3, #1
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 800029a:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 800029e:	b2db      	uxtb	r3, r3
 80002a0:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 80002a4:	62c3      	str	r3, [r0, #44]	; 0x2c
 80002a6:	bd10      	pop	{r4, pc}
 80002a8:	c0fff7fd 	.word	0xc0fff7fd

080002ac <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 80002ac:	2300      	movs	r3, #0
 80002ae:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 80002b0:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 80002b2:	7143      	strb	r3, [r0, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 80002b4:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 80002b6:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 80002b8:	6103      	str	r3, [r0, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 80002ba:	2301      	movs	r3, #1
 80002bc:	7503      	strb	r3, [r0, #20]
 80002be:	4770      	bx	lr

080002c0 <ADC_CommonInit>:
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 80002c0:	4a07      	ldr	r2, [pc, #28]	; (80002e0 <ADC_CommonInit+0x20>)
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 80002c2:	4b08      	ldr	r3, [pc, #32]	; (80002e4 <ADC_CommonInit+0x24>)
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 80002c4:	6851      	ldr	r1, [r2, #4]
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 80002c6:	b510      	push	{r4, lr}
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 80002c8:	400b      	ands	r3, r1
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80002ca:	e890 0012 	ldmia.w	r0, {r1, r4}
 80002ce:	430c      	orrs	r4, r1
                        ADC_CommonInitStruct->ADC_Prescaler | 
 80002d0:	6881      	ldr	r1, [r0, #8]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80002d2:	68c0      	ldr	r0, [r0, #12]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 80002d4:	4321      	orrs	r1, r4
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 80002d6:	4301      	orrs	r1, r0
 80002d8:	430b      	orrs	r3, r1
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 80002da:	6053      	str	r3, [r2, #4]
 80002dc:	bd10      	pop	{r4, pc}
 80002de:	bf00      	nop
 80002e0:	40012300 	.word	0x40012300
 80002e4:	fffc30e0 	.word	0xfffc30e0

080002e8 <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 80002e8:	2300      	movs	r3, #0
 80002ea:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 80002ec:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 80002ee:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 80002f0:	60c3      	str	r3, [r0, #12]
 80002f2:	4770      	bx	lr

080002f4 <ADC_Cmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 80002f4:	6883      	ldr	r3, [r0, #8]
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80002f6:	b111      	cbz	r1, 80002fe <ADC_Cmd+0xa>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 80002f8:	f043 0301 	orr.w	r3, r3, #1
 80002fc:	e001      	b.n	8000302 <ADC_Cmd+0xe>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 80002fe:	f023 0301 	bic.w	r3, r3, #1
 8000302:	6083      	str	r3, [r0, #8]
 8000304:	4770      	bx	lr

08000306 <ADC_AnalogWatchdogCmd>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 8000306:	6843      	ldr	r3, [r0, #4]
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  tmpreg &= CR1_AWDMode_RESET;
 8000308:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 800030c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8000310:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8000312:	6041      	str	r1, [r0, #4]
 8000314:	4770      	bx	lr

08000316 <ADC_AnalogWatchdogThresholdsConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 8000316:	6241      	str	r1, [r0, #36]	; 0x24
  
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 8000318:	6282      	str	r2, [r0, #40]	; 0x28
 800031a:	4770      	bx	lr

0800031c <ADC_AnalogWatchdogSingleChannelConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 800031c:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_RESET;
 800031e:	f023 031f 	bic.w	r3, r3, #31
  
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 8000322:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8000324:	6041      	str	r1, [r0, #4]
 8000326:	4770      	bx	lr

08000328 <ADC_TempSensorVrefintCmd>:
  * @param  NewState: new state of the temperature sensor and Vrefint channels.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
 8000328:	4b04      	ldr	r3, [pc, #16]	; (800033c <ADC_TempSensorVrefintCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 800032a:	685a      	ldr	r2, [r3, #4]
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800032c:	b110      	cbz	r0, 8000334 <ADC_TempSensorVrefintCmd+0xc>
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 800032e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8000332:	e001      	b.n	8000338 <ADC_TempSensorVrefintCmd+0x10>
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 8000334:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8000338:	605a      	str	r2, [r3, #4]
 800033a:	4770      	bx	lr
 800033c:	40012300 	.word	0x40012300

08000340 <ADC_VBATCmd>:
  * @param  NewState: new state of the VBAT channel.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
 8000340:	4b04      	ldr	r3, [pc, #16]	; (8000354 <ADC_VBATCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 8000342:	685a      	ldr	r2, [r3, #4]
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000344:	b110      	cbz	r0, 800034c <ADC_VBATCmd+0xc>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 8000346:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800034a:	e001      	b.n	8000350 <ADC_VBATCmd+0x10>
  }
  else
  {
    /* Disable the VBAT channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
 800034c:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8000350:	605a      	str	r2, [r3, #4]
 8000352:	4770      	bx	lr
 8000354:	40012300 	.word	0x40012300

08000358 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8000358:	2909      	cmp	r1, #9
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 800035a:	b570      	push	{r4, r5, r6, lr}
 800035c:	b20c      	sxth	r4, r1
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800035e:	d90e      	bls.n	800037e <ADC_RegularChannelConfig+0x26>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8000360:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8000364:	3c1e      	subs	r4, #30
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8000366:	68c6      	ldr	r6, [r0, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8000368:	2507      	movs	r5, #7
 800036a:	fa05 f504 	lsl.w	r5, r5, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800036e:	ea26 0505 	bic.w	r5, r6, r5
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8000372:	fa03 f304 	lsl.w	r3, r3, r4
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000376:	ea45 0403 	orr.w	r4, r5, r3
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800037a:	60c4      	str	r4, [r0, #12]
 800037c:	e00b      	b.n	8000396 <ADC_RegularChannelConfig+0x3e>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 800037e:	6906      	ldr	r6, [r0, #16]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8000380:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8000384:	2507      	movs	r5, #7
 8000386:	fa05 f504 	lsl.w	r5, r5, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800038a:	ea26 0505 	bic.w	r5, r6, r5
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 800038e:	fa03 f404 	lsl.w	r4, r3, r4
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000392:	432c      	orrs	r4, r5
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8000394:	6104      	str	r4, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8000396:	2a06      	cmp	r2, #6
 8000398:	d80e      	bhi.n	80003b8 <ADC_RegularChannelConfig+0x60>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 800039a:	2305      	movs	r3, #5
 800039c:	3a01      	subs	r2, #1
 800039e:	435a      	muls	r2, r3
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 80003a0:	6b44      	ldr	r4, [r0, #52]	; 0x34
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 80003a2:	231f      	movs	r3, #31
 80003a4:	fa03 f302 	lsl.w	r3, r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80003a8:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 80003ac:	fa01 f102 	lsl.w	r1, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80003b0:	ea43 0201 	orr.w	r2, r3, r1
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80003b4:	6342      	str	r2, [r0, #52]	; 0x34
 80003b6:	bd70      	pop	{r4, r5, r6, pc}
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 80003b8:	2a0c      	cmp	r2, #12
 80003ba:	b212      	sxth	r2, r2
 80003bc:	d80e      	bhi.n	80003dc <ADC_RegularChannelConfig+0x84>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 80003be:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80003c2:	3a23      	subs	r2, #35	; 0x23
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 80003c4:	6b04      	ldr	r4, [r0, #48]	; 0x30
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 80003c6:	231f      	movs	r3, #31
 80003c8:	fa03 f302 	lsl.w	r3, r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80003cc:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 80003d0:	fa01 f102 	lsl.w	r1, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80003d4:	ea43 0201 	orr.w	r2, r3, r1
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 80003d8:	6302      	str	r2, [r0, #48]	; 0x30
 80003da:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 80003dc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80003e0:	3a41      	subs	r2, #65	; 0x41
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 80003e2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 80003e4:	231f      	movs	r3, #31
 80003e6:	fa03 f302 	lsl.w	r3, r3, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80003ea:	ea24 0303 	bic.w	r3, r4, r3
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 80003ee:	fa01 f102 	lsl.w	r1, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80003f2:	ea43 0201 	orr.w	r2, r3, r1
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 80003f6:	62c2      	str	r2, [r0, #44]	; 0x2c
 80003f8:	bd70      	pop	{r4, r5, r6, pc}

080003fa <ADC_SoftwareStartConv>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80003fa:	6883      	ldr	r3, [r0, #8]
 80003fc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000400:	6083      	str	r3, [r0, #8]
 8000402:	4770      	bx	lr

08000404 <ADC_GetSoftwareStartConvStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 8000404:	6880      	ldr	r0, [r0, #8]
    bitstatus = RESET;
  }
  
  /* Return the SWSTART bit status */
  return  bitstatus;
}
 8000406:	f3c0 5080 	ubfx	r0, r0, #22, #1
 800040a:	4770      	bx	lr

0800040c <ADC_EOCOnEachRegularChannelCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 800040c:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800040e:	b111      	cbz	r1, 8000416 <ADC_EOCOnEachRegularChannelCmd+0xa>
  {
    /* Enable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 8000410:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000414:	e001      	b.n	800041a <ADC_EOCOnEachRegularChannelCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
 8000416:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800041a:	6083      	str	r3, [r0, #8]
 800041c:	4770      	bx	lr

0800041e <ADC_ContinuousModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 800041e:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000420:	b111      	cbz	r1, 8000428 <ADC_ContinuousModeCmd+0xa>
  {
    /* Enable the selected ADC continuous conversion mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 8000422:	f043 0302 	orr.w	r3, r3, #2
 8000426:	e001      	b.n	800042c <ADC_ContinuousModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC continuous conversion mode */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
 8000428:	f023 0302 	bic.w	r3, r3, #2
 800042c:	6083      	str	r3, [r0, #8]
 800042e:	4770      	bx	lr

08000430 <ADC_DiscModeChannelCountConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 8000430:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 8000432:	3901      	subs	r1, #1
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
 8000434:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
 8000438:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 800043c:	6043      	str	r3, [r0, #4]
 800043e:	4770      	bx	lr

08000440 <ADC_DiscModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8000440:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000442:	b111      	cbz	r1, 800044a <ADC_DiscModeCmd+0xa>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8000444:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000448:	e001      	b.n	800044e <ADC_DiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
 800044a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800044e:	6043      	str	r3, [r0, #4]
 8000450:	4770      	bx	lr

08000452 <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8000452:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
 8000454:	b280      	uxth	r0, r0
 8000456:	4770      	bx	lr

08000458 <ADC_GetMultiModeConversionValue>:
  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
  */
uint32_t ADC_GetMultiModeConversionValue(void)
{
  /* Return the multi mode conversion value */
  return (*(__IO uint32_t *) CDR_ADDRESS);
 8000458:	4b01      	ldr	r3, [pc, #4]	; (8000460 <ADC_GetMultiModeConversionValue+0x8>)
 800045a:	6818      	ldr	r0, [r3, #0]
}
 800045c:	4770      	bx	lr
 800045e:	bf00      	nop
 8000460:	40012308 	.word	0x40012308

08000464 <ADC_DMACmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8000464:	6883      	ldr	r3, [r0, #8]
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000466:	b111      	cbz	r1, 800046e <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8000468:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800046c:	e001      	b.n	8000472 <ADC_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 800046e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000472:	6083      	str	r3, [r0, #8]
 8000474:	4770      	bx	lr

08000476 <ADC_DMARequestAfterLastTransferCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 8000476:	6883      	ldr	r3, [r0, #8]
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000478:	b111      	cbz	r1, 8000480 <ADC_DMARequestAfterLastTransferCmd+0xa>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 800047a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800047e:	e001      	b.n	8000484 <ADC_DMARequestAfterLastTransferCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 8000480:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000484:	6083      	str	r3, [r0, #8]
 8000486:	4770      	bx	lr

08000488 <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
  *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
  * @retval None
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
 8000488:	4b04      	ldr	r3, [pc, #16]	; (800049c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 800048a:	685a      	ldr	r2, [r3, #4]
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800048c:	b110      	cbz	r0, 8000494 <ADC_MultiModeDMARequestAfterLastTransferCmd+0xc>
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 800048e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000492:	e001      	b.n	8000498 <ADC_MultiModeDMARequestAfterLastTransferCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8000494:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8000498:	605a      	str	r2, [r3, #4]
 800049a:	4770      	bx	lr
 800049c:	40012300 	.word	0x40012300

080004a0 <ADC_InjectedChannelConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80004a0:	2909      	cmp	r1, #9
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80004a2:	b570      	push	{r4, r5, r6, lr}
 80004a4:	b20c      	sxth	r4, r1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80004a6:	d90e      	bls.n	80004c6 <ADC_InjectedChannelConfig+0x26>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 80004a8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80004ac:	3c1e      	subs	r4, #30
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80004ae:	68c6      	ldr	r6, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 80004b0:	2507      	movs	r5, #7
 80004b2:	fa05 f504 	lsl.w	r5, r5, r4
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80004b6:	ea26 0505 	bic.w	r5, r6, r5
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 80004ba:	fa03 f304 	lsl.w	r3, r3, r4
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80004be:	ea45 0403 	orr.w	r4, r5, r3
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 80004c2:	60c4      	str	r4, [r0, #12]
 80004c4:	e00b      	b.n	80004de <ADC_InjectedChannelConfig+0x3e>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 80004c6:	6906      	ldr	r6, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 80004c8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80004cc:	2507      	movs	r5, #7
 80004ce:	fa05 f504 	lsl.w	r5, r5, r4
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80004d2:	ea26 0505 	bic.w	r5, r6, r5
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 80004d6:	fa03 f404 	lsl.w	r4, r3, r4
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80004da:	432c      	orrs	r4, r5
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 80004dc:	6104      	str	r4, [r0, #16]
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 80004de:	6b84      	ldr	r4, [r0, #56]	; 0x38
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
 80004e0:	f3c4 5301 	ubfx	r3, r4, #20, #2
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 80004e4:	1ad3      	subs	r3, r2, r3
 80004e6:	3302      	adds	r3, #2
 80004e8:	b2db      	uxtb	r3, r3
 80004ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80004ee:	221f      	movs	r2, #31
 80004f0:	fa02 f203 	lsl.w	r2, r2, r3
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 80004f4:	ea24 0402 	bic.w	r4, r4, r2
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 80004f8:	fa01 f103 	lsl.w	r1, r1, r3
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 80004fc:	ea44 0301 	orr.w	r3, r4, r1
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8000500:	6383      	str	r3, [r0, #56]	; 0x38
 8000502:	bd70      	pop	{r4, r5, r6, pc}

08000504 <ADC_InjectedSequencerLengthConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8000504:	6b83      	ldr	r3, [r0, #56]	; 0x38
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
 8000506:	3901      	subs	r1, #1
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
 8000508:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
 800050c:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8000510:	6383      	str	r3, [r0, #56]	; 0x38
 8000512:	4770      	bx	lr

08000514 <ADC_SetInjectedOffset>:
  * @param  Offset: the offset value for the selected ADC injected channel
  *          This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
 8000514:	b082      	sub	sp, #8
    __IO uint32_t tmp = 0;
 8000516:	2300      	movs	r3, #0
 8000518:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));
  
  tmp = (uint32_t)ADCx;
 800051a:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel;
 800051c:	9b01      	ldr	r3, [sp, #4]
 800051e:	18c9      	adds	r1, r1, r3
 8000520:	9101      	str	r1, [sp, #4]
  
  /* Set the selected injected channel data offset */
 *(__IO uint32_t *) tmp = (uint32_t)Offset;
 8000522:	9b01      	ldr	r3, [sp, #4]
 8000524:	601a      	str	r2, [r3, #0]
}
 8000526:	b002      	add	sp, #8
 8000528:	4770      	bx	lr

0800052a <ADC_ExternalTrigInjectedConvConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 800052a:	6883      	ldr	r3, [r0, #8]
  
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_RESET;
 800052c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 8000530:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 8000532:	6081      	str	r1, [r0, #8]
 8000534:	4770      	bx	lr

08000536 <ADC_ExternalTrigInjectedConvEdgeConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 8000536:	6883      	ldr	r3, [r0, #8]
  /* Clear the old external trigger edge for injected group */
  tmpreg &= CR2_JEXTEN_RESET;
 8000538:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  /* Set the new external trigger edge for injected group */
  tmpreg |= ADC_ExternalTrigInjecConvEdge;
 800053c:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 800053e:	6081      	str	r1, [r0, #8]
 8000540:	4770      	bx	lr

08000542 <ADC_SoftwareStartInjectedConv>:
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC conversion for injected group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
 8000542:	6883      	ldr	r3, [r0, #8]
 8000544:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000548:	6083      	str	r3, [r0, #8]
 800054a:	4770      	bx	lr

0800054c <ADC_GetSoftwareStartInjectedConvCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 800054c:	6880      	ldr	r0, [r0, #8]
    /* JSWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
}
 800054e:	f3c0 5080 	ubfx	r0, r0, #22, #1
 8000552:	4770      	bx	lr

08000554 <ADC_AutoInjectedConvCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 8000554:	6843      	ldr	r3, [r0, #4]
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000556:	b111      	cbz	r1, 800055e <ADC_AutoInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 8000558:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800055c:	e001      	b.n	8000562 <ADC_AutoInjectedConvCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
 800055e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000562:	6043      	str	r3, [r0, #4]
 8000564:	4770      	bx	lr

08000566 <ADC_InjectedDiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 8000566:	6843      	ldr	r3, [r0, #4]
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000568:	b111      	cbz	r1, 8000570 <ADC_InjectedDiscModeCmd+0xa>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 800056a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800056e:	e001      	b.n	8000574 <ADC_InjectedDiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
 8000570:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000574:	6043      	str	r3, [r0, #4]
 8000576:	4770      	bx	lr

08000578 <ADC_GetInjectedConversionValue>:
  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
 8000578:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 800057a:	2300      	movs	r3, #0
 800057c:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
 800057e:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel + JDR_OFFSET;
 8000580:	9b01      	ldr	r3, [sp, #4]
 8000582:	3328      	adds	r3, #40	; 0x28
 8000584:	1859      	adds	r1, r3, r1
 8000586:	9101      	str	r1, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp); 
 8000588:	9b01      	ldr	r3, [sp, #4]
 800058a:	6818      	ldr	r0, [r3, #0]
}
 800058c:	b280      	uxth	r0, r0
 800058e:	b002      	add	sp, #8
 8000590:	4770      	bx	lr

08000592 <ADC_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
  itmask = (uint32_t)0x01 << itmask;    
 8000592:	2301      	movs	r3, #1
 8000594:	b2c9      	uxtb	r1, r1
 8000596:	fa03 f101 	lsl.w	r1, r3, r1

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 800059a:	6843      	ldr	r3, [r0, #4]

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
  itmask = (uint32_t)0x01 << itmask;    

  if (NewState != DISABLE)
 800059c:	b10a      	cbz	r2, 80005a2 <ADC_ITConfig+0x10>
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 800059e:	4319      	orrs	r1, r3
 80005a0:	e001      	b.n	80005a6 <ADC_ITConfig+0x14>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
 80005a2:	ea23 0101 	bic.w	r1, r3, r1
 80005a6:	6041      	str	r1, [r0, #4]
 80005a8:	4770      	bx	lr

080005aa <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 80005aa:	6803      	ldr	r3, [r0, #0]
 80005ac:	4219      	tst	r1, r3
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 80005ae:	bf0c      	ite	eq
 80005b0:	2000      	moveq	r0, #0
 80005b2:	2001      	movne	r0, #1
 80005b4:	4770      	bx	lr

080005b6 <ADC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
 80005b6:	43c9      	mvns	r1, r1
 80005b8:	6001      	str	r1, [r0, #0]
 80005ba:	4770      	bx	lr

080005bc <ADC_GetITStatus>:

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 80005bc:	6843      	ldr	r3, [r0, #4]

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 80005be:	6800      	ldr	r0, [r0, #0]
 80005c0:	ea10 2011 	ands.w	r0, r0, r1, lsr #8
 80005c4:	d007      	beq.n	80005d6 <ADC_GetITStatus+0x1a>

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 80005c6:	2201      	movs	r2, #1
 80005c8:	b2c9      	uxtb	r1, r1
 80005ca:	fa02 f101 	lsl.w	r1, r2, r1

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 80005ce:	4219      	tst	r1, r3
  {
    /* ADC_IT is set */
    bitstatus = SET;
 80005d0:	bf0c      	ite	eq
 80005d2:	2000      	moveq	r0, #0
 80005d4:	2001      	movne	r0, #1
    /* ADC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
 80005d6:	4770      	bx	lr

080005d8 <ADC_ClearITPendingBit>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT)); 
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
 80005d8:	ea6f 2111 	mvn.w	r1, r1, lsr #8
 80005dc:	6001      	str	r1, [r0, #0]
 80005de:	4770      	bx	lr

080005e0 <CAN_DeInit>:
  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
  * @retval None.
  */
void CAN_DeInit(CAN_TypeDef* CANx)
{
 80005e0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
 
  if (CANx == CAN1)
 80005e2:	4b0b      	ldr	r3, [pc, #44]	; (8000610 <CAN_DeInit+0x30>)
 80005e4:	4298      	cmp	r0, r3
 80005e6:	d107      	bne.n	80005f8 <CAN_DeInit+0x18>
  {
    /* Enable CAN1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
 80005e8:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80005ec:	2101      	movs	r1, #1
 80005ee:	f003 f8e9 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    /* Release CAN1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
 80005f2:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80005f6:	e006      	b.n	8000606 <CAN_DeInit+0x26>
  }
  else
  {  
    /* Enable CAN2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
 80005f8:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80005fc:	2101      	movs	r1, #1
 80005fe:	f003 f8e1 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    /* Release CAN2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
 8000602:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8000606:	2100      	movs	r1, #0
  }
}
 8000608:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {  
    /* Enable CAN2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    /* Release CAN2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
 800060c:	f003 b8da 	b.w	80037c4 <RCC_APB1PeriphResetCmd>
 8000610:	40006400 	.word	0x40006400

08000614 <CAN_Init>:
  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));

  /* Exit from sleep mode */
  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 8000614:	6803      	ldr	r3, [r0, #0]
 8000616:	f023 0302 	bic.w	r3, r3, #2
 800061a:	6003      	str	r3, [r0, #0]

  /* Request initialisation */
  CANx->MCR |= CAN_MCR_INRQ ;
 800061c:	6803      	ldr	r3, [r0, #0]
 800061e:	f043 0301 	orr.w	r3, r3, #1
 8000622:	6003      	str	r3, [r0, #0]

  /* Wait the acknowledge */
  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 8000624:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000628:	6842      	ldr	r2, [r0, #4]
 800062a:	07d2      	lsls	r2, r2, #31
 800062c:	d401      	bmi.n	8000632 <CAN_Init+0x1e>
 800062e:	3b01      	subs	r3, #1
 8000630:	d1fa      	bne.n	8000628 <CAN_Init+0x14>
  {
    wait_ack++;
  }

  /* Check acknowledge */
  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 8000632:	6843      	ldr	r3, [r0, #4]
 8000634:	f013 0301 	ands.w	r3, r3, #1
 8000638:	d055      	beq.n	80006e6 <CAN_Init+0xd2>
    InitStatus = CAN_InitStatus_Failed;
  }
  else 
  {
    /* Set the time triggered communication mode */
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
 800063a:	798b      	ldrb	r3, [r1, #6]
 800063c:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_TTCM;
 800063e:	6803      	ldr	r3, [r0, #0]
 8000640:	bf0c      	ite	eq
 8000642:	f043 0380 	orreq.w	r3, r3, #128	; 0x80
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 8000646:	f023 0380 	bicne.w	r3, r3, #128	; 0x80
 800064a:	6003      	str	r3, [r0, #0]
    }

    /* Set the automatic bus-off management */
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
 800064c:	79cb      	ldrb	r3, [r1, #7]
 800064e:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_ABOM;
 8000650:	6803      	ldr	r3, [r0, #0]
 8000652:	bf0c      	ite	eq
 8000654:	f043 0340 	orreq.w	r3, r3, #64	; 0x40
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 8000658:	f023 0340 	bicne.w	r3, r3, #64	; 0x40
 800065c:	6003      	str	r3, [r0, #0]
    }

    /* Set the automatic wake-up mode */
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
 800065e:	7a0b      	ldrb	r3, [r1, #8]
 8000660:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_AWUM;
 8000662:	6803      	ldr	r3, [r0, #0]
 8000664:	bf0c      	ite	eq
 8000666:	f043 0320 	orreq.w	r3, r3, #32
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 800066a:	f023 0320 	bicne.w	r3, r3, #32
 800066e:	6003      	str	r3, [r0, #0]
    }

    /* Set the no automatic retransmission */
    if (CAN_InitStruct->CAN_NART == ENABLE)
 8000670:	7a4b      	ldrb	r3, [r1, #9]
 8000672:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_NART;
 8000674:	6803      	ldr	r3, [r0, #0]
 8000676:	bf0c      	ite	eq
 8000678:	f043 0310 	orreq.w	r3, r3, #16
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
 800067c:	f023 0310 	bicne.w	r3, r3, #16
 8000680:	6003      	str	r3, [r0, #0]
    }

    /* Set the receive FIFO locked mode */
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
 8000682:	7a8b      	ldrb	r3, [r1, #10]
 8000684:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_RFLM;
 8000686:	6803      	ldr	r3, [r0, #0]
 8000688:	bf0c      	ite	eq
 800068a:	f043 0308 	orreq.w	r3, r3, #8
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 800068e:	f023 0308 	bicne.w	r3, r3, #8
 8000692:	6003      	str	r3, [r0, #0]
    }

    /* Set the transmit FIFO priority */
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
 8000694:	7acb      	ldrb	r3, [r1, #11]
 8000696:	2b01      	cmp	r3, #1
    {
      CANx->MCR |= CAN_MCR_TXFP;
 8000698:	6803      	ldr	r3, [r0, #0]
 800069a:	bf0c      	ite	eq
 800069c:	f043 0304 	orreq.w	r3, r3, #4
    }
    else
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 80006a0:	f023 0304 	bicne.w	r3, r3, #4
 80006a4:	6003      	str	r3, [r0, #0]
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 80006a6:	788b      	ldrb	r3, [r1, #2]
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 80006a8:	78ca      	ldrb	r2, [r1, #3]
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 80006aa:	079b      	lsls	r3, r3, #30
 80006ac:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 80006b0:	790a      	ldrb	r2, [r1, #4]
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 80006b2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 80006b6:	794a      	ldrb	r2, [r1, #5]
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 80006b8:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
 80006bc:	880a      	ldrh	r2, [r1, #0]
 80006be:	3a01      	subs	r2, #1

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 80006c0:	4313      	orrs	r3, r2
    {
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    }

    /* Set the bit timing register */
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 80006c2:	61c3      	str	r3, [r0, #28]
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);

    /* Request leave initialisation */
    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 80006c4:	6803      	ldr	r3, [r0, #0]
 80006c6:	f023 0301 	bic.w	r3, r3, #1
 80006ca:	6003      	str	r3, [r0, #0]

   /* Wait the acknowledge */
   wait_ack = 0;

   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 80006cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80006d0:	6842      	ldr	r2, [r0, #4]
 80006d2:	07d2      	lsls	r2, r2, #31
 80006d4:	d501      	bpl.n	80006da <CAN_Init+0xc6>
 80006d6:	3b01      	subs	r3, #1
 80006d8:	d1fa      	bne.n	80006d0 <CAN_Init+0xbc>
   {
     wait_ack++;
   }

    /* ...and check acknowledged */
    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 80006da:	6840      	ldr	r0, [r0, #4]
 80006dc:	f000 0001 	and.w	r0, r0, #1
  }

  /* Check acknowledge */
  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
  {
    InitStatus = CAN_InitStatus_Failed;
 80006e0:	f080 0001 	eor.w	r0, r0, #1
 80006e4:	4770      	bx	lr
 80006e6:	4618      	mov	r0, r3
    }
  }

  /* At this step, return the status of initialization */
  return InitStatus;
}
 80006e8:	4770      	bx	lr

080006ea <CAN_FilterInit>:
  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));

  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
 80006ea:	7a83      	ldrb	r3, [r0, #10]
 80006ec:	2101      	movs	r1, #1
 80006ee:	fa01 f103 	lsl.w	r1, r1, r3

  /* Initialisation mode for the filter */
  CAN1->FMR |= FMR_FINIT;
 80006f2:	4b35      	ldr	r3, [pc, #212]	; (80007c8 <CAN_FilterInit+0xde>)
 80006f4:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80006f8:	f042 0201 	orr.w	r2, r2, #1
  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
  *         contains the configuration information.
  * @retval None
  */
void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
{
 80006fc:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));

  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;

  /* Initialisation mode for the filter */
  CAN1->FMR |= FMR_FINIT;
 80006fe:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

  /* Filter Deactivation */
  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
 8000702:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8000706:	43cc      	mvns	r4, r1
 8000708:	4022      	ands	r2, r4
 800070a:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

  /* Filter Scale */
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
 800070e:	7b02      	ldrb	r2, [r0, #12]
 8000710:	b9aa      	cbnz	r2, 800073e <CAN_FilterInit+0x54>
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
 8000712:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8000716:	88c6      	ldrh	r6, [r0, #6]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 8000718:	8845      	ldrh	r5, [r0, #2]

  /* Filter Scale */
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
  {
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
 800071a:	4022      	ands	r2, r4
 800071c:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8000720:	7a82      	ldrb	r2, [r0, #10]
 8000722:	3248      	adds	r2, #72	; 0x48
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8000724:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
    /* 16-bit scale for the filter */
    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;

    /* First 16-bit identifier and First 16-bit mask */
    /* Or First 16-bit identifier and Second 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8000728:	f843 5032 	str.w	r5, [r3, r2, lsl #3]

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
 800072c:	8803      	ldrh	r3, [r0, #0]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 800072e:	8882      	ldrh	r2, [r0, #4]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8000730:	7a85      	ldrb	r5, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000732:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);

    /* Second 16-bit identifier and Second 16-bit mask */
    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8000736:	4b25      	ldr	r3, [pc, #148]	; (80007cc <CAN_FilterInit+0xe2>)
 8000738:	00ed      	lsls	r5, r5, #3
 800073a:	18eb      	adds	r3, r5, r3
 800073c:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
  }

  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
 800073e:	7b03      	ldrb	r3, [r0, #12]
 8000740:	2b01      	cmp	r3, #1
 8000742:	d116      	bne.n	8000772 <CAN_FilterInit+0x88>
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filter_number_bit_pos;
 8000744:	4b20      	ldr	r3, [pc, #128]	; (80007c8 <CAN_FilterInit+0xde>)
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8000746:	8806      	ldrh	r6, [r0, #0]
  }

  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filter_number_bit_pos;
 8000748:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 800074c:	8845      	ldrh	r5, [r0, #2]
  }

  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filter_number_bit_pos;
 800074e:	430a      	orrs	r2, r1
 8000750:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8000754:	7a82      	ldrb	r2, [r0, #10]
 8000756:	3248      	adds	r2, #72	; 0x48
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8000758:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
  {
    /* 32-bit scale for the filter */
    CAN1->FS1R |= filter_number_bit_pos;
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 800075c:	f843 5032 	str.w	r5, [r3, r2, lsl #3]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
 8000760:	88c3      	ldrh	r3, [r0, #6]
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000762:	8882      	ldrh	r2, [r0, #4]
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8000764:	7a85      	ldrb	r5, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000766:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    /* 32-bit identifier or First 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    /* 32-bit mask or Second 32-bit identifier */
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 800076a:	4b18      	ldr	r3, [pc, #96]	; (80007cc <CAN_FilterInit+0xe2>)
 800076c:	00ed      	lsls	r5, r5, #3
 800076e:	18eb      	adds	r3, r5, r3
 8000770:	605a      	str	r2, [r3, #4]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
  }

  /* Filter Mode */
  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
 8000772:	7ac3      	ldrb	r3, [r0, #11]
 8000774:	4a14      	ldr	r2, [pc, #80]	; (80007c8 <CAN_FilterInit+0xde>)
 8000776:	b91b      	cbnz	r3, 8000780 <CAN_FilterInit+0x96>
  {
    /*Id/Mask mode for the filter*/
    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
 8000778:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
 800077c:	4023      	ands	r3, r4
 800077e:	e002      	b.n	8000786 <CAN_FilterInit+0x9c>
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
 8000780:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
 8000784:	430b      	orrs	r3, r1
  }

  /* Filter FIFO assignment */
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 8000786:	8905      	ldrh	r5, [r0, #8]
    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
  }
  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
  {
    /*Identifier list mode for the filter*/
    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
 8000788:	f8c2 3204 	str.w	r3, [r2, #516]	; 0x204
 800078c:	4b0e      	ldr	r3, [pc, #56]	; (80007c8 <CAN_FilterInit+0xde>)
  }

  /* Filter FIFO assignment */
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 800078e:	b92d      	cbnz	r5, 800079c <CAN_FilterInit+0xb2>
  {
    /* FIFO 0 assignation for the filter */
    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
 8000790:	f8d2 5214 	ldr.w	r5, [r2, #532]	; 0x214
 8000794:	402c      	ands	r4, r5
 8000796:	f8c2 4214 	str.w	r4, [r2, #532]	; 0x214
 800079a:	e006      	b.n	80007aa <CAN_FilterInit+0xc0>
  }

  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
 800079c:	2d01      	cmp	r5, #1
 800079e:	d104      	bne.n	80007aa <CAN_FilterInit+0xc0>
  {
    /* FIFO 1 assignation for the filter */
    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
 80007a0:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 80007a4:	430a      	orrs	r2, r1
 80007a6:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  }
  
  /* Filter activation */
  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
 80007aa:	7b42      	ldrb	r2, [r0, #13]
 80007ac:	2a01      	cmp	r2, #1
 80007ae:	d104      	bne.n	80007ba <CAN_FilterInit+0xd0>
  {
    CAN1->FA1R |= filter_number_bit_pos;
 80007b0:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80007b4:	4311      	orrs	r1, r2
 80007b6:	f8c3 121c 	str.w	r1, [r3, #540]	; 0x21c
  }

  /* Leave the initialisation mode for the filter */
  CAN1->FMR &= ~FMR_FINIT;
 80007ba:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80007be:	f022 0201 	bic.w	r2, r2, #1
 80007c2:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
 80007c6:	bd70      	pop	{r4, r5, r6, pc}
 80007c8:	40006400 	.word	0x40006400
 80007cc:	40006640 	.word	0x40006640

080007d0 <CAN_StructInit>:
void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
{
  /* Reset CAN init structure parameters values */
  
  /* Initialize the time triggered communication mode */
  CAN_InitStruct->CAN_TTCM = DISABLE;
 80007d0:	2300      	movs	r3, #0
 80007d2:	7183      	strb	r3, [r0, #6]
  
  /* Initialize the automatic bus-off management */
  CAN_InitStruct->CAN_ABOM = DISABLE;
 80007d4:	71c3      	strb	r3, [r0, #7]
  
  /* Initialize the automatic wake-up mode */
  CAN_InitStruct->CAN_AWUM = DISABLE;
 80007d6:	7203      	strb	r3, [r0, #8]
  
  /* Initialize the no automatic retransmission */
  CAN_InitStruct->CAN_NART = DISABLE;
 80007d8:	7243      	strb	r3, [r0, #9]
  
  /* Initialize the receive FIFO locked mode */
  CAN_InitStruct->CAN_RFLM = DISABLE;
 80007da:	7283      	strb	r3, [r0, #10]
  
  /* Initialize the transmit FIFO priority */
  CAN_InitStruct->CAN_TXFP = DISABLE;
 80007dc:	72c3      	strb	r3, [r0, #11]
  
  /* Initialize the CAN_Mode member */
  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
 80007de:	7083      	strb	r3, [r0, #2]
  
  /* Initialize the CAN_SJW member */
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
 80007e0:	70c3      	strb	r3, [r0, #3]
  
  /* Initialize the CAN_BS1 member */
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
 80007e2:	2303      	movs	r3, #3
 80007e4:	7103      	strb	r3, [r0, #4]
  
  /* Initialize the CAN_BS2 member */
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
 80007e6:	2302      	movs	r3, #2
 80007e8:	7143      	strb	r3, [r0, #5]
  
  /* Initialize the CAN_Prescaler member */
  CAN_InitStruct->CAN_Prescaler = 1;
 80007ea:	2301      	movs	r3, #1
 80007ec:	8003      	strh	r3, [r0, #0]
 80007ee:	4770      	bx	lr

080007f0 <CAN_SlaveStartBank>:
{
  /* Check the parameters */
  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
  
  /* Enter Initialisation mode for the filter */
  CAN1->FMR |= FMR_FINIT;
 80007f0:	4b0d      	ldr	r3, [pc, #52]	; (8000828 <CAN_SlaveStartBank+0x38>)
 80007f2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80007f6:	f042 0201 	orr.w	r2, r2, #1
 80007fa:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  
  /* Select the start slave bank */
  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
 80007fe:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000802:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 8000806:	f022 020e 	bic.w	r2, r2, #14
 800080a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
 800080e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000812:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8000816:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
  
  /* Leave Initialisation mode for the filter */
  CAN1->FMR &= ~FMR_FINIT;
 800081a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 800081e:	f022 0201 	bic.w	r2, r2, #1
 8000822:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
 8000826:	4770      	bx	lr
 8000828:	40006400 	.word	0x40006400

0800082c <CAN_DBGFreeze>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Debug Freeze  */
    CANx->MCR |= MCR_DBF;
 800082c:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800082e:	b111      	cbz	r1, 8000836 <CAN_DBGFreeze+0xa>
  {
    /* Enable Debug Freeze  */
    CANx->MCR |= MCR_DBF;
 8000830:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000834:	e001      	b.n	800083a <CAN_DBGFreeze+0xe>
  }
  else
  {
    /* Disable Debug Freeze */
    CANx->MCR &= ~MCR_DBF;
 8000836:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800083a:	6003      	str	r3, [r0, #0]
 800083c:	4770      	bx	lr

0800083e <CAN_TTComModeCmd>:
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the TTCM mode */
    CANx->MCR |= CAN_MCR_TTCM;
 800083e:	6803      	ldr	r3, [r0, #0]
void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000840:	b199      	cbz	r1, 800086a <CAN_TTComModeCmd+0x2c>
  {
    /* Enable the TTCM mode */
    CANx->MCR |= CAN_MCR_TTCM;
 8000842:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000846:	6003      	str	r3, [r0, #0]

    /* Set TGT bits */
    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
 8000848:	f8d0 3184 	ldr.w	r3, [r0, #388]	; 0x184
 800084c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000850:	f8c0 3184 	str.w	r3, [r0, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
 8000854:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
 8000858:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800085c:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
 8000860:	f8d0 31a4 	ldr.w	r3, [r0, #420]	; 0x1a4
 8000864:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000868:	e012      	b.n	8000890 <CAN_TTComModeCmd+0x52>
  }
  else
  {
    /* Disable the TTCM mode */
    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
 800086a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800086e:	6003      	str	r3, [r0, #0]

    /* Reset TGT bits */
    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
 8000870:	f8d0 3184 	ldr.w	r3, [r0, #388]	; 0x184
 8000874:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000878:	f8c0 3184 	str.w	r3, [r0, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
 800087c:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
 8000880:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000884:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
 8000888:	f8d0 31a4 	ldr.w	r3, [r0, #420]	; 0x1a4
 800088c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000890:	f8c0 31a4 	str.w	r3, [r0, #420]	; 0x1a4
 8000894:	4770      	bx	lr

08000896 <CAN_Transmit>:
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 8000896:	6882      	ldr	r2, [r0, #8]
  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
  * @retval The number of the mailbox that is used for transmission or
  *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
  */
uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
{
 8000898:	4603      	mov	r3, r0
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 800089a:	0150      	lsls	r0, r2, #5
  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
  * @retval The number of the mailbox that is used for transmission or
  *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
  */
uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
{
 800089c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
  assert_param(IS_CAN_RTR(TxMessage->RTR));
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 800089e:	d446      	bmi.n	800092e <CAN_Transmit+0x98>
  {
    transmit_mailbox = 0;
  }
  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 80008a0:	689a      	ldr	r2, [r3, #8]
 80008a2:	0112      	lsls	r2, r2, #4
 80008a4:	d445      	bmi.n	8000932 <CAN_Transmit+0x9c>
  {
    transmit_mailbox = 1;
  }
  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 80008a6:	689a      	ldr	r2, [r3, #8]
 80008a8:	00d0      	lsls	r0, r2, #3
 80008aa:	d444      	bmi.n	8000936 <CAN_Transmit+0xa0>
  {
    transmit_mailbox = 2;
  }
  else
  {
    transmit_mailbox = CAN_TxStatus_NoMailBox;
 80008ac:	2004      	movs	r0, #4
 80008ae:	bd70      	pop	{r4, r5, r6, pc}
    /* Set up the Id */
    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    if (TxMessage->IDE == CAN_Id_Standard)
    {
      assert_param(IS_CAN_STDID(TxMessage->StdId));  
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 80008b0:	680c      	ldr	r4, [r1, #0]
 80008b2:	7a4e      	ldrb	r6, [r1, #9]
 80008b4:	589d      	ldr	r5, [r3, r2]
 80008b6:	ea46 5444 	orr.w	r4, r6, r4, lsl #21
 80008ba:	432c      	orrs	r4, r5
 80008bc:	e006      	b.n	80008cc <CAN_Transmit+0x36>
                                                  TxMessage->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 80008be:	684d      	ldr	r5, [r1, #4]
 80008c0:	589e      	ldr	r6, [r3, r2]
 80008c2:	ea44 04c5 	orr.w	r4, r4, r5, lsl #3
                                                  TxMessage->IDE | \
 80008c6:	4334      	orrs	r4, r6
 80008c8:	7a4e      	ldrb	r6, [r1, #9]
                                                  TxMessage->RTR);
    }
    else
    {
      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 80008ca:	4334      	orrs	r4, r6
 80008cc:	509c      	str	r4, [r3, r2]
                                                  TxMessage->IDE | \
                                                  TxMessage->RTR);
    }
    
    /* Set up the DLC */
    TxMessage->DLC &= (uint8_t)0x0000000F;
 80008ce:	7a8a      	ldrb	r2, [r1, #10]
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 80008d0:	f100 0418 	add.w	r4, r0, #24
 80008d4:	0124      	lsls	r4, r4, #4
                                                  TxMessage->IDE | \
                                                  TxMessage->RTR);
    }
    
    /* Set up the DLC */
    TxMessage->DLC &= (uint8_t)0x0000000F;
 80008d6:	f002 020f 	and.w	r2, r2, #15
 80008da:	728a      	strb	r2, [r1, #10]
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 80008dc:	191a      	adds	r2, r3, r4
 80008de:	6855      	ldr	r5, [r2, #4]
 80008e0:	f025 050f 	bic.w	r5, r5, #15
 80008e4:	6055      	str	r5, [r2, #4]
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
 80008e6:	6855      	ldr	r5, [r2, #4]
 80008e8:	7a8e      	ldrb	r6, [r1, #10]
 80008ea:	4335      	orrs	r5, r6
 80008ec:	6055      	str	r5, [r2, #4]

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 80008ee:	7b4e      	ldrb	r6, [r1, #13]
    TxMessage->DLC &= (uint8_t)0x0000000F;
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 80008f0:	7b8a      	ldrb	r2, [r1, #14]
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 80008f2:	0436      	lsls	r6, r6, #16
    TxMessage->DLC &= (uint8_t)0x0000000F;
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 80008f4:	ea46 6602 	orr.w	r6, r6, r2, lsl #24
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
 80008f8:	7aca      	ldrb	r2, [r1, #11]
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 80008fa:	4316      	orrs	r6, r2
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
 80008fc:	7b0a      	ldrb	r2, [r1, #12]
 80008fe:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
    TxMessage->DLC &= (uint8_t)0x0000000F;
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;

    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8000902:	eb03 1200 	add.w	r2, r3, r0, lsl #4
 8000906:	f502 75c4 	add.w	r5, r2, #392	; 0x188
 800090a:	f8c2 6188 	str.w	r6, [r2, #392]	; 0x188
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 800090e:	7c4a      	ldrb	r2, [r1, #17]
    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000910:	7c8e      	ldrb	r6, [r1, #18]
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 8000912:	0412      	lsls	r2, r2, #16
    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000914:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
                                             ((uint32_t)TxMessage->Data[6] << 16) |
                                             ((uint32_t)TxMessage->Data[5] << 8) |
                                             ((uint32_t)TxMessage->Data[4]));
 8000918:	7bce      	ldrb	r6, [r1, #15]
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
                                             ((uint32_t)TxMessage->Data[6] << 16) |
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 800091a:	7c09      	ldrb	r1, [r1, #16]
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 800091c:	4332      	orrs	r2, r6
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 800091e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    /* Set up the data field */
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
                                             ((uint32_t)TxMessage->Data[2] << 16) |
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
                                             ((uint32_t)TxMessage->Data[0]));
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000922:	606a      	str	r2, [r5, #4]
                                             ((uint32_t)TxMessage->Data[6] << 16) |
                                             ((uint32_t)TxMessage->Data[5] << 8) |
                                             ((uint32_t)TxMessage->Data[4]));
    /* Request transmission */
    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
 8000924:	591a      	ldr	r2, [r3, r4]
 8000926:	f042 0201 	orr.w	r2, r2, #1
 800092a:	511a      	str	r2, [r3, r4]
 800092c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_CAN_DLC(TxMessage->DLC));

  /* Select one empty transmit mailbox */
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
  {
    transmit_mailbox = 0;
 800092e:	2000      	movs	r0, #0
 8000930:	e002      	b.n	8000938 <CAN_Transmit+0xa2>
  }
  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
  {
    transmit_mailbox = 1;
 8000932:	2001      	movs	r0, #1
 8000934:	e000      	b.n	8000938 <CAN_Transmit+0xa2>
  }
  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
  {
    transmit_mailbox = 2;
 8000936:	2002      	movs	r0, #2
  }

  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
  {
    /* Set up the Id */
    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
 8000938:	f100 0218 	add.w	r2, r0, #24
 800093c:	0112      	lsls	r2, r2, #4
 800093e:	589c      	ldr	r4, [r3, r2]
 8000940:	f004 0401 	and.w	r4, r4, #1
 8000944:	509c      	str	r4, [r3, r2]
    if (TxMessage->IDE == CAN_Id_Standard)
 8000946:	7a0c      	ldrb	r4, [r1, #8]
 8000948:	2c00      	cmp	r4, #0
 800094a:	d0b1      	beq.n	80008b0 <CAN_Transmit+0x1a>
 800094c:	e7b7      	b.n	80008be <CAN_Transmit+0x28>

0800094e <CAN_TransmitStatus>:

  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
 
  switch (TransmitMailbox)
 800094e:	2901      	cmp	r1, #1
 8000950:	d006      	beq.n	8000960 <CAN_TransmitStatus+0x12>
 8000952:	d302      	bcc.n	800095a <CAN_TransmitStatus+0xc>
 8000954:	2902      	cmp	r1, #2
 8000956:	d117      	bne.n	8000988 <CAN_TransmitStatus+0x3a>
 8000958:	e005      	b.n	8000966 <CAN_TransmitStatus+0x18>
  {
    case (CAN_TXMAILBOX_0): 
      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
 800095a:	6882      	ldr	r2, [r0, #8]
 800095c:	4b0c      	ldr	r3, [pc, #48]	; (8000990 <CAN_TransmitStatus+0x42>)
 800095e:	e004      	b.n	800096a <CAN_TransmitStatus+0x1c>
      break;
    case (CAN_TXMAILBOX_1): 
      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
 8000960:	6882      	ldr	r2, [r0, #8]
 8000962:	4b0c      	ldr	r3, [pc, #48]	; (8000994 <CAN_TransmitStatus+0x46>)
 8000964:	e001      	b.n	800096a <CAN_TransmitStatus+0x1c>
      break;
    case (CAN_TXMAILBOX_2): 
      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
 8000966:	6882      	ldr	r2, [r0, #8]
 8000968:	4b0b      	ldr	r3, [pc, #44]	; (8000998 <CAN_TransmitStatus+0x4a>)
 800096a:	4013      	ands	r3, r2
      break;
    default:
      state = CAN_TxStatus_Failed;
      break;
  }
  switch (state)
 800096c:	4a08      	ldr	r2, [pc, #32]	; (8000990 <CAN_TransmitStatus+0x42>)
 800096e:	4293      	cmp	r3, r2
 8000970:	d008      	beq.n	8000984 <CAN_TransmitStatus+0x36>
 8000972:	d801      	bhi.n	8000978 <CAN_TransmitStatus+0x2a>
 8000974:	b143      	cbz	r3, 8000988 <CAN_TransmitStatus+0x3a>
 8000976:	e009      	b.n	800098c <CAN_TransmitStatus+0x3e>
 8000978:	4a06      	ldr	r2, [pc, #24]	; (8000994 <CAN_TransmitStatus+0x46>)
 800097a:	4293      	cmp	r3, r2
 800097c:	d002      	beq.n	8000984 <CAN_TransmitStatus+0x36>
 800097e:	4a06      	ldr	r2, [pc, #24]	; (8000998 <CAN_TransmitStatus+0x4a>)
 8000980:	4293      	cmp	r3, r2
 8000982:	d103      	bne.n	800098c <CAN_TransmitStatus+0x3e>
      /* transmit succeeded  */
    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
      break;
    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
      break;
    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
 8000984:	2001      	movs	r0, #1
      break;
 8000986:	4770      	bx	lr
      break;
  }
  switch (state)
  {
      /* transmit pending  */
    case (0x0): state = CAN_TxStatus_Pending;
 8000988:	2002      	movs	r0, #2
 800098a:	4770      	bx	lr
      break;
      /* transmit failed  */
     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
 800098c:	2000      	movs	r0, #0
      break;
    default: state = CAN_TxStatus_Failed;
      break;
  }
  return (uint8_t) state;
}
 800098e:	4770      	bx	lr
 8000990:	04000003 	.word	0x04000003
 8000994:	08000300 	.word	0x08000300
 8000998:	10030000 	.word	0x10030000

0800099c <CAN_CancelTransmit>:
{
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
  /* abort transmission */
  switch (Mailbox)
 800099c:	2901      	cmp	r1, #1
 800099e:	d007      	beq.n	80009b0 <CAN_CancelTransmit+0x14>
 80009a0:	d302      	bcc.n	80009a8 <CAN_CancelTransmit+0xc>
 80009a2:	2902      	cmp	r1, #2
 80009a4:	d10c      	bne.n	80009c0 <CAN_CancelTransmit+0x24>
 80009a6:	e007      	b.n	80009b8 <CAN_CancelTransmit+0x1c>
  {
    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
 80009a8:	6883      	ldr	r3, [r0, #8]
 80009aa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80009ae:	e006      	b.n	80009be <CAN_CancelTransmit+0x22>
      break;
    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
 80009b0:	6883      	ldr	r3, [r0, #8]
 80009b2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80009b6:	e002      	b.n	80009be <CAN_CancelTransmit+0x22>
      break;
    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
 80009b8:	6883      	ldr	r3, [r0, #8]
 80009ba:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80009be:	6083      	str	r3, [r0, #8]
 80009c0:	4770      	bx	lr

080009c2 <CAN_Receive>:
  * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
  *         CAN DLC, CAN data and FMI number.
  * @retval None
  */
void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
{
 80009c2:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  /* Get the Id */
  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
 80009c4:	f101 041b 	add.w	r4, r1, #27
 80009c8:	0123      	lsls	r3, r4, #4
 80009ca:	58c5      	ldr	r5, [r0, r3]
 80009cc:	f005 0504 	and.w	r5, r5, #4
 80009d0:	b2ed      	uxtb	r5, r5
 80009d2:	7215      	strb	r5, [r2, #8]
  if (RxMessage->IDE == CAN_Id_Standard)
  {
    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 80009d4:	58c3      	ldr	r3, [r0, r3]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  /* Get the Id */
  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
  if (RxMessage->IDE == CAN_Id_Standard)
 80009d6:	b915      	cbnz	r5, 80009de <CAN_Receive+0x1c>
  {
    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 80009d8:	0d5b      	lsrs	r3, r3, #21
 80009da:	6013      	str	r3, [r2, #0]
 80009dc:	e001      	b.n	80009e2 <CAN_Receive+0x20>
  }
  else
  {
    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
 80009de:	08db      	lsrs	r3, r3, #3
 80009e0:	6053      	str	r3, [r2, #4]
  }
  
  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
 80009e2:	0124      	lsls	r4, r4, #4
 80009e4:	1903      	adds	r3, r0, r4
 80009e6:	5904      	ldr	r4, [r0, r4]
 80009e8:	f004 0402 	and.w	r4, r4, #2
 80009ec:	7254      	strb	r4, [r2, #9]
  /* Get the DLC */
  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
 80009ee:	685c      	ldr	r4, [r3, #4]
 80009f0:	f004 040f 	and.w	r4, r4, #15
 80009f4:	7294      	strb	r4, [r2, #10]
  /* Get the FMI */
  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
 80009f6:	685b      	ldr	r3, [r3, #4]
 80009f8:	0a1b      	lsrs	r3, r3, #8
 80009fa:	74d3      	strb	r3, [r2, #19]
  /* Get the data field */
  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
 80009fc:	eb00 1301 	add.w	r3, r0, r1, lsl #4
 8000a00:	f503 74dc 	add.w	r4, r3, #440	; 0x1b8
 8000a04:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
 8000a08:	72d5      	strb	r5, [r2, #11]
  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8000a0a:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
 8000a0e:	0a2d      	lsrs	r5, r5, #8
 8000a10:	7315      	strb	r5, [r2, #12]
  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8000a12:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
 8000a16:	0c2d      	lsrs	r5, r5, #16
 8000a18:	7355      	strb	r5, [r2, #13]
  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8000a1a:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 8000a1e:	0e1b      	lsrs	r3, r3, #24
 8000a20:	7393      	strb	r3, [r2, #14]
  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
 8000a22:	6863      	ldr	r3, [r4, #4]
 8000a24:	73d3      	strb	r3, [r2, #15]
  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8000a26:	6863      	ldr	r3, [r4, #4]
 8000a28:	0a1b      	lsrs	r3, r3, #8
 8000a2a:	7413      	strb	r3, [r2, #16]
  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8000a2c:	6863      	ldr	r3, [r4, #4]
 8000a2e:	0c1b      	lsrs	r3, r3, #16
 8000a30:	7453      	strb	r3, [r2, #17]
  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8000a32:	6863      	ldr	r3, [r4, #4]
 8000a34:	0e1b      	lsrs	r3, r3, #24
 8000a36:	7493      	strb	r3, [r2, #18]
  /* Release the FIFO */
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 8000a38:	b921      	cbnz	r1, 8000a44 <CAN_Receive+0x82>
  {
    CANx->RF0R |= CAN_RF0R_RFOM0;
 8000a3a:	68c3      	ldr	r3, [r0, #12]
 8000a3c:	f043 0320 	orr.w	r3, r3, #32
 8000a40:	60c3      	str	r3, [r0, #12]
 8000a42:	bd30      	pop	{r4, r5, pc}
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CANx->RF1R |= CAN_RF1R_RFOM1;
 8000a44:	6903      	ldr	r3, [r0, #16]
 8000a46:	f043 0320 	orr.w	r3, r3, #32
 8000a4a:	6103      	str	r3, [r0, #16]
 8000a4c:	bd30      	pop	{r4, r5, pc}

08000a4e <CAN_FIFORelease>:
{
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  /* Release FIFO0 */
  if (FIFONumber == CAN_FIFO0)
 8000a4e:	b921      	cbnz	r1, 8000a5a <CAN_FIFORelease+0xc>
  {
    CANx->RF0R |= CAN_RF0R_RFOM0;
 8000a50:	68c3      	ldr	r3, [r0, #12]
 8000a52:	f043 0320 	orr.w	r3, r3, #32
 8000a56:	60c3      	str	r3, [r0, #12]
 8000a58:	4770      	bx	lr
  }
  /* Release FIFO1 */
  else /* FIFONumber == CAN_FIFO1 */
  {
    CANx->RF1R |= CAN_RF1R_RFOM1;
 8000a5a:	6903      	ldr	r3, [r0, #16]
 8000a5c:	f043 0320 	orr.w	r3, r3, #32
 8000a60:	6103      	str	r3, [r0, #16]
 8000a62:	4770      	bx	lr

08000a64 <CAN_MessagePending>:
{
  uint8_t message_pending=0;
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_FIFO(FIFONumber));
  if (FIFONumber == CAN_FIFO0)
 8000a64:	b909      	cbnz	r1, 8000a6a <CAN_MessagePending+0x6>
  {
    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
 8000a66:	68c0      	ldr	r0, [r0, #12]
 8000a68:	e002      	b.n	8000a70 <CAN_MessagePending+0xc>
  }
  else if (FIFONumber == CAN_FIFO1)
 8000a6a:	2901      	cmp	r1, #1
 8000a6c:	d103      	bne.n	8000a76 <CAN_MessagePending+0x12>
  {
    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
 8000a6e:	6900      	ldr	r0, [r0, #16]
 8000a70:	f000 0003 	and.w	r0, r0, #3
 8000a74:	4770      	bx	lr
  }
  else
  {
    message_pending = 0;
 8000a76:	2000      	movs	r0, #0
  }
  return message_pending;
}
 8000a78:	4770      	bx	lr

08000a7a <CAN_OperatingModeRequest>:

  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));

  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
 8000a7a:	b999      	cbnz	r1, 8000aa4 <CAN_OperatingModeRequest+0x2a>
  {
    /* Request initialisation */
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
 8000a7c:	6803      	ldr	r3, [r0, #0]
 8000a7e:	f023 0303 	bic.w	r3, r3, #3
 8000a82:	f043 0301 	orr.w	r3, r3, #1
 8000a86:	6003      	str	r3, [r0, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 8000a88:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000a8c:	6842      	ldr	r2, [r0, #4]
 8000a8e:	f002 0203 	and.w	r2, r2, #3
 8000a92:	2a01      	cmp	r2, #1
 8000a94:	d001      	beq.n	8000a9a <CAN_OperatingModeRequest+0x20>
 8000a96:	3b01      	subs	r3, #1
 8000a98:	d1f8      	bne.n	8000a8c <CAN_OperatingModeRequest+0x12>
    {
      timeout--;
    }
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
 8000a9a:	6840      	ldr	r0, [r0, #4]
 8000a9c:	f000 0003 	and.w	r0, r0, #3
    {
      status = CAN_ModeStatus_Failed;
    }
    else
    {
      status = CAN_ModeStatus_Success;
 8000aa0:	2801      	cmp	r0, #1
 8000aa2:	e028      	b.n	8000af6 <CAN_OperatingModeRequest+0x7c>
    }
  }
  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
 8000aa4:	2901      	cmp	r1, #1
 8000aa6:	d111      	bne.n	8000acc <CAN_OperatingModeRequest+0x52>
  {
    /* Request leave initialisation and sleep mode  and enter Normal mode */
    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
 8000aa8:	6803      	ldr	r3, [r0, #0]
 8000aaa:	f023 0303 	bic.w	r3, r3, #3
 8000aae:	6003      	str	r3, [r0, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 8000ab0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000ab4:	6842      	ldr	r2, [r0, #4]
 8000ab6:	0792      	lsls	r2, r2, #30
 8000ab8:	d001      	beq.n	8000abe <CAN_OperatingModeRequest+0x44>
 8000aba:	3b01      	subs	r3, #1
 8000abc:	d1fa      	bne.n	8000ab4 <CAN_OperatingModeRequest+0x3a>
    {
      timeout--;
    }
    if ((CANx->MSR & CAN_MODE_MASK) != 0)
 8000abe:	6843      	ldr	r3, [r0, #4]
 8000ac0:	f013 0f03 	tst.w	r3, #3
    {
      status = CAN_ModeStatus_Failed;
    }
    else
    {
      status = CAN_ModeStatus_Success;
 8000ac4:	bf14      	ite	ne
 8000ac6:	2000      	movne	r0, #0
 8000ac8:	2001      	moveq	r0, #1
 8000aca:	4770      	bx	lr
    else
    {
      status = CAN_ModeStatus_Success;
    }
  }
  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
 8000acc:	2902      	cmp	r1, #2
 8000ace:	d116      	bne.n	8000afe <CAN_OperatingModeRequest+0x84>
  {
    /* Request Sleep mode */
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8000ad0:	6803      	ldr	r3, [r0, #0]
 8000ad2:	f023 0303 	bic.w	r3, r3, #3
 8000ad6:	f043 0302 	orr.w	r3, r3, #2
 8000ada:	6003      	str	r3, [r0, #0]

    /* Wait the acknowledge */
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 8000adc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000ae0:	6842      	ldr	r2, [r0, #4]
 8000ae2:	f002 0203 	and.w	r2, r2, #3
 8000ae6:	2a02      	cmp	r2, #2
 8000ae8:	d001      	beq.n	8000aee <CAN_OperatingModeRequest+0x74>
 8000aea:	3b01      	subs	r3, #1
 8000aec:	d1f8      	bne.n	8000ae0 <CAN_OperatingModeRequest+0x66>
    {
      timeout--;
    }
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
 8000aee:	6840      	ldr	r0, [r0, #4]
 8000af0:	f000 0003 	and.w	r0, r0, #3
    {
      status = CAN_ModeStatus_Failed;
    }
    else
    {
      status = CAN_ModeStatus_Success;
 8000af4:	2802      	cmp	r0, #2
 8000af6:	bf14      	ite	ne
 8000af8:	2000      	movne	r0, #0
 8000afa:	2001      	moveq	r0, #1
 8000afc:	4770      	bx	lr
      status = CAN_ModeStatus_Success;
    }
  }
  else
  {
    status = CAN_ModeStatus_Failed;
 8000afe:	2000      	movs	r0, #0
  }

  return  (uint8_t) status;
}
 8000b00:	4770      	bx	lr

08000b02 <CAN_Sleep>:
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
    
  /* Request Sleep mode */
   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8000b02:	6803      	ldr	r3, [r0, #0]
 8000b04:	f023 0303 	bic.w	r3, r3, #3
 8000b08:	f043 0302 	orr.w	r3, r3, #2
 8000b0c:	6003      	str	r3, [r0, #0]
   
  /* Sleep mode status */
  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
 8000b0e:	6840      	ldr	r0, [r0, #4]
 8000b10:	f000 0003 	and.w	r0, r0, #3
    /* Sleep mode not entered */
    sleepstatus =  CAN_Sleep_Ok;
  }
  /* return sleep mode status */
   return (uint8_t)sleepstatus;
}
 8000b14:	1e81      	subs	r1, r0, #2
 8000b16:	4248      	negs	r0, r1
 8000b18:	4148      	adcs	r0, r1
 8000b1a:	4770      	bx	lr

08000b1c <CAN_WakeUp>:
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
    
  /* Wake up request */
  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 8000b1c:	6803      	ldr	r3, [r0, #0]
 8000b1e:	f023 0302 	bic.w	r3, r3, #2
 8000b22:	6003      	str	r3, [r0, #0]
    
  /* Sleep mode status */
  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 8000b24:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000b28:	6842      	ldr	r2, [r0, #4]
 8000b2a:	0792      	lsls	r2, r2, #30
 8000b2c:	d501      	bpl.n	8000b32 <CAN_WakeUp+0x16>
 8000b2e:	3b01      	subs	r3, #1
 8000b30:	d1fa      	bne.n	8000b28 <CAN_WakeUp+0xc>
  {
   wait_slak--;
  }
  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
 8000b32:	6840      	ldr	r0, [r0, #4]
 8000b34:	f080 0002 	eor.w	r0, r0, #2
   /* wake up done : Sleep mode exited */
    wakeupstatus = CAN_WakeUp_Ok;
  }
  /* return wakeup status */
  return (uint8_t)wakeupstatus;
}
 8000b38:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8000b3c:	4770      	bx	lr

08000b3e <CAN_GetLastErrorCode>:
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the error code*/
  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
 8000b3e:	6980      	ldr	r0, [r0, #24]
  
  /* Return the error code*/
  return errorcode;
}
 8000b40:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8000b44:	4770      	bx	lr

08000b46 <CAN_GetReceiveErrorCounter>:
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the Receive Error Counter*/
  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
 8000b46:	6980      	ldr	r0, [r0, #24]
  
  /* Return the Receive Error Counter*/
  return counter;
}
 8000b48:	0e00      	lsrs	r0, r0, #24
 8000b4a:	4770      	bx	lr

08000b4c <CAN_GetLSBTransmitErrorCounter>:
  
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  
  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
 8000b4c:	6980      	ldr	r0, [r0, #24]
  
  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
  return counter;
}
 8000b4e:	f3c0 4007 	ubfx	r0, r0, #16, #8
 8000b52:	4770      	bx	lr

08000b54 <CAN_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected CANx interrupt */
    CANx->IER |= CAN_IT;
 8000b54:	6943      	ldr	r3, [r0, #20]
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_IT(CAN_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000b56:	b10a      	cbz	r2, 8000b5c <CAN_ITConfig+0x8>
  {
    /* Enable the selected CANx interrupt */
    CANx->IER |= CAN_IT;
 8000b58:	4319      	orrs	r1, r3
 8000b5a:	e001      	b.n	8000b60 <CAN_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected CANx interrupt */
    CANx->IER &= ~CAN_IT;
 8000b5c:	ea23 0101 	bic.w	r1, r3, r1
 8000b60:	6141      	str	r1, [r0, #20]
 8000b62:	4770      	bx	lr

08000b64 <CAN_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
  

  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
 8000b64:	f411 0f70 	tst.w	r1, #15728640	; 0xf00000
 8000b68:	d001      	beq.n	8000b6e <CAN_GetFlagStatus+0xa>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000b6a:	6983      	ldr	r3, [r0, #24]
 8000b6c:	e00b      	b.n	8000b86 <CAN_GetFlagStatus+0x22>
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
 8000b6e:	01cb      	lsls	r3, r1, #7
 8000b70:	d501      	bpl.n	8000b76 <CAN_GetFlagStatus+0x12>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000b72:	6843      	ldr	r3, [r0, #4]
 8000b74:	e007      	b.n	8000b86 <CAN_GetFlagStatus+0x22>
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
 8000b76:	010a      	lsls	r2, r1, #4
 8000b78:	d501      	bpl.n	8000b7e <CAN_GetFlagStatus+0x1a>
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000b7a:	6883      	ldr	r3, [r0, #8]
 8000b7c:	e003      	b.n	8000b86 <CAN_GetFlagStatus+0x22>
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
    }
  }
  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
 8000b7e:	018b      	lsls	r3, r1, #6
  { 
    /* Check the status of the specified CAN flag */
    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000b80:	bf4c      	ite	mi
 8000b82:	68c3      	ldrmi	r3, [r0, #12]
    }
  }
  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
  { 
    /* Check the status of the specified CAN flag */
    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000b84:	6903      	ldrpl	r3, [r0, #16]
 8000b86:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000b8a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8000b8e:	420b      	tst	r3, r1
      bitstatus = SET;
    }
    else
    { 
      /* CAN_FLAG is reset */
      bitstatus = RESET;
 8000b90:	bf0c      	ite	eq
 8000b92:	2000      	moveq	r0, #0
 8000b94:	2001      	movne	r0, #1
      bitstatus = RESET;
    }
  }
  /* Return the CAN_FLAG status */
  return  bitstatus;
}
 8000b96:	4770      	bx	lr

08000b98 <CAN_ClearFlag>:
  uint32_t flagtmp=0;
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
  
  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
 8000b98:	4b0b      	ldr	r3, [pc, #44]	; (8000bc8 <CAN_ClearFlag+0x30>)
 8000b9a:	4299      	cmp	r1, r3
 8000b9c:	d102      	bne.n	8000ba4 <CAN_ClearFlag+0xc>
  {
    /* Clear the selected CAN flags */
    CANx->ESR = (uint32_t)RESET;
 8000b9e:	2300      	movs	r3, #0
 8000ba0:	6183      	str	r3, [r0, #24]
 8000ba2:	4770      	bx	lr
  }
  else /* MSR or TSR or RF0R or RF1R */
  {
    flagtmp = CAN_FLAG & 0x000FFFFF;
 8000ba4:	f021 437f 	bic.w	r3, r1, #4278190080	; 0xff000000

    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 8000ba8:	018a      	lsls	r2, r1, #6
    /* Clear the selected CAN flags */
    CANx->ESR = (uint32_t)RESET;
  }
  else /* MSR or TSR or RF0R or RF1R */
  {
    flagtmp = CAN_FLAG & 0x000FFFFF;
 8000baa:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000

    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 8000bae:	d501      	bpl.n	8000bb4 <CAN_ClearFlag+0x1c>
    {
      /* Receive Flags */
      CANx->RF0R = (uint32_t)(flagtmp);
 8000bb0:	60c3      	str	r3, [r0, #12]
 8000bb2:	4770      	bx	lr
    }
    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
 8000bb4:	014a      	lsls	r2, r1, #5
 8000bb6:	d501      	bpl.n	8000bbc <CAN_ClearFlag+0x24>
    {
      /* Receive Flags */
      CANx->RF1R = (uint32_t)(flagtmp);
 8000bb8:	6103      	str	r3, [r0, #16]
 8000bba:	4770      	bx	lr
    }
    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
 8000bbc:	010a      	lsls	r2, r1, #4
    {
      /* Transmit Flags */
      CANx->TSR = (uint32_t)(flagtmp);
 8000bbe:	bf4c      	ite	mi
 8000bc0:	6083      	strmi	r3, [r0, #8]
    }
    else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
    {
      /* Operating mode Flags */
      CANx->MSR = (uint32_t)(flagtmp);
 8000bc2:	6043      	strpl	r3, [r0, #4]
 8000bc4:	4770      	bx	lr
 8000bc6:	bf00      	nop
 8000bc8:	30f00070 	.word	0x30f00070

08000bcc <CAN_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_IT(CAN_IT));
  
  /* check the interrupt enable bit */
 if((CANx->IER & CAN_IT) != RESET)
 8000bcc:	6943      	ldr	r3, [r0, #20]
 8000bce:	400b      	ands	r3, r1
 8000bd0:	d05f      	beq.n	8000c92 <CAN_GetITStatus+0xc6>
 {
   /* in case the Interrupt is enabled, .... */
    switch (CAN_IT)
 8000bd2:	2940      	cmp	r1, #64	; 0x40
 8000bd4:	d040      	beq.n	8000c58 <CAN_GetITStatus+0x8c>
 8000bd6:	d80e      	bhi.n	8000bf6 <CAN_GetITStatus+0x2a>
 8000bd8:	2904      	cmp	r1, #4
 8000bda:	d02f      	beq.n	8000c3c <CAN_GetITStatus+0x70>
 8000bdc:	d804      	bhi.n	8000be8 <CAN_GetITStatus+0x1c>
 8000bde:	2901      	cmp	r1, #1
 8000be0:	d021      	beq.n	8000c26 <CAN_GetITStatus+0x5a>
 8000be2:	2902      	cmp	r1, #2
 8000be4:	d157      	bne.n	8000c96 <CAN_GetITStatus+0xca>
 8000be6:	e027      	b.n	8000c38 <CAN_GetITStatus+0x6c>
 8000be8:	2910      	cmp	r1, #16
 8000bea:	d02b      	beq.n	8000c44 <CAN_GetITStatus+0x78>
 8000bec:	2920      	cmp	r1, #32
 8000bee:	d02f      	beq.n	8000c50 <CAN_GetITStatus+0x84>
 8000bf0:	2908      	cmp	r1, #8
 8000bf2:	d150      	bne.n	8000c96 <CAN_GetITStatus+0xca>
 8000bf4:	e024      	b.n	8000c40 <CAN_GetITStatus+0x74>
 8000bf6:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8000bfa:	d03f      	beq.n	8000c7c <CAN_GetITStatus+0xb0>
 8000bfc:	d809      	bhi.n	8000c12 <CAN_GetITStatus+0x46>
 8000bfe:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000c02:	d035      	beq.n	8000c70 <CAN_GetITStatus+0xa4>
 8000c04:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8000c08:	d036      	beq.n	8000c78 <CAN_GetITStatus+0xac>
 8000c0a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8000c0e:	d142      	bne.n	8000c96 <CAN_GetITStatus+0xca>
 8000c10:	e02a      	b.n	8000c68 <CAN_GetITStatus+0x9c>
 8000c12:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8000c16:	d021      	beq.n	8000c5c <CAN_GetITStatus+0x90>
 8000c18:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 8000c1c:	d020      	beq.n	8000c60 <CAN_GetITStatus+0x94>
 8000c1e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8000c22:	d138      	bne.n	8000c96 <CAN_GetITStatus+0xca>
 8000c24:	e031      	b.n	8000c8a <CAN_GetITStatus+0xbe>
    {
      case CAN_IT_TME:
        /* Check CAN_TSR_RQCPx bits */
        itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
 8000c26:	6880      	ldr	r0, [r0, #8]
  */
static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
{
  ITStatus pendingbitstatus = RESET;
  
  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 8000c28:	f000 3001 	and.w	r0, r0, #16843009	; 0x1010101
 8000c2c:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
  {
    /* CAN_IT is set */
    pendingbitstatus = SET;
 8000c30:	3000      	adds	r0, #0
 8000c32:	bf18      	it	ne
 8000c34:	2001      	movne	r0, #1
 8000c36:	4770      	bx	lr
        /* Check CAN_TSR_RQCPx bits */
        itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
        break;
      case CAN_IT_FMP0:
        /* Check CAN_RF0R_FMP0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
 8000c38:	68c0      	ldr	r0, [r0, #12]
 8000c3a:	e004      	b.n	8000c46 <CAN_GetITStatus+0x7a>
        break;
      case CAN_IT_FF0:
        /* Check CAN_RF0R_FULL0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
 8000c3c:	68c0      	ldr	r0, [r0, #12]
 8000c3e:	e008      	b.n	8000c52 <CAN_GetITStatus+0x86>
        break;
      case CAN_IT_FOV0:
        /* Check CAN_RF0R_FOVR0 bit */
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
 8000c40:	68c0      	ldr	r0, [r0, #12]
 8000c42:	e00e      	b.n	8000c62 <CAN_GetITStatus+0x96>
        break;
      case CAN_IT_FMP1:
        /* Check CAN_RF1R_FMP1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
 8000c44:	6900      	ldr	r0, [r0, #16]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c46:	f010 0003 	ands.w	r0, r0, #3
 8000c4a:	bf18      	it	ne
 8000c4c:	2001      	movne	r0, #1
 8000c4e:	4770      	bx	lr
        /* Check CAN_RF1R_FMP1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
        break;
      case CAN_IT_FF1:
        /* Check CAN_RF1R_FULL1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
 8000c50:	6900      	ldr	r0, [r0, #16]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c52:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8000c56:	4770      	bx	lr
        /* Check CAN_RF1R_FULL1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
        break;
      case CAN_IT_FOV1:
        /* Check CAN_RF1R_FOVR1 bit */
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
 8000c58:	6900      	ldr	r0, [r0, #16]
 8000c5a:	e002      	b.n	8000c62 <CAN_GetITStatus+0x96>
        break;
      case CAN_IT_WKU:
        /* Check CAN_MSR_WKUI bit */
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
 8000c5c:	6840      	ldr	r0, [r0, #4]
 8000c5e:	e7f8      	b.n	8000c52 <CAN_GetITStatus+0x86>
        break;
      case CAN_IT_SLK:
        /* Check CAN_MSR_SLAKI bit */
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
 8000c60:	6840      	ldr	r0, [r0, #4]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c62:	f3c0 1000 	ubfx	r0, r0, #4, #1
 8000c66:	4770      	bx	lr
        /* Check CAN_MSR_SLAKI bit */
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
        break;
      case CAN_IT_EWG:
        /* Check CAN_ESR_EWGF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
 8000c68:	6980      	ldr	r0, [r0, #24]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c6a:	f000 0001 	and.w	r0, r0, #1
 8000c6e:	4770      	bx	lr
        /* Check CAN_ESR_EWGF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
        break;
      case CAN_IT_EPV:
        /* Check CAN_ESR_EPVF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
 8000c70:	6980      	ldr	r0, [r0, #24]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c72:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8000c76:	4770      	bx	lr
        /* Check CAN_ESR_EPVF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
        break;
      case CAN_IT_BOF:
        /* Check CAN_ESR_BOFF bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
 8000c78:	6980      	ldr	r0, [r0, #24]
 8000c7a:	e007      	b.n	8000c8c <CAN_GetITStatus+0xc0>
        break;
      case CAN_IT_LEC:
        /* Check CAN_ESR_LEC bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
 8000c7c:	6983      	ldr	r3, [r0, #24]
  */
static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
{
  ITStatus pendingbitstatus = RESET;
  
  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 8000c7e:	f013 0f70 	tst.w	r3, #112	; 0x70
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c82:	bf0c      	ite	eq
 8000c84:	2000      	moveq	r0, #0
 8000c86:	2001      	movne	r0, #1
 8000c88:	4770      	bx	lr
        /* Check CAN_ESR_LEC bit */
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
        break;
      case CAN_IT_ERR:
        /* Check CAN_MSR_ERRI bit */ 
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
 8000c8a:	6840      	ldr	r0, [r0, #4]
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 8000c8c:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8000c90:	4770      	bx	lr
    }
  }
  else
  {
   /* in case the Interrupt is not enabled, return RESET */
    itstatus  = RESET;
 8000c92:	4618      	mov	r0, r3
 8000c94:	4770      	bx	lr
        /* Check CAN_MSR_ERRI bit */ 
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
        break;
      default:
        /* in case of error, return RESET */
        itstatus = RESET;
 8000c96:	2000      	movs	r0, #0
    itstatus  = RESET;
  }
  
  /* Return the CAN_IT status */
  return  itstatus;
}
 8000c98:	4770      	bx	lr

08000c9a <CAN_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_CAN_ALL_PERIPH(CANx));
  assert_param(IS_CAN_CLEAR_IT(CAN_IT));

  switch (CAN_IT)
 8000c9a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8000c9e:	d035      	beq.n	8000d0c <CAN_ClearITPendingBit+0x72>
 8000ca0:	d80c      	bhi.n	8000cbc <CAN_ClearITPendingBit+0x22>
 8000ca2:	2908      	cmp	r1, #8
 8000ca4:	d024      	beq.n	8000cf0 <CAN_ClearITPendingBit+0x56>
 8000ca6:	d804      	bhi.n	8000cb2 <CAN_ClearITPendingBit+0x18>
 8000ca8:	2901      	cmp	r1, #1
 8000caa:	d01c      	beq.n	8000ce6 <CAN_ClearITPendingBit+0x4c>
 8000cac:	2904      	cmp	r1, #4
 8000cae:	d12f      	bne.n	8000d10 <CAN_ClearITPendingBit+0x76>
 8000cb0:	e01c      	b.n	8000cec <CAN_ClearITPendingBit+0x52>
 8000cb2:	2920      	cmp	r1, #32
 8000cb4:	d01f      	beq.n	8000cf6 <CAN_ClearITPendingBit+0x5c>
 8000cb6:	2940      	cmp	r1, #64	; 0x40
 8000cb8:	d12a      	bne.n	8000d10 <CAN_ClearITPendingBit+0x76>
 8000cba:	e01e      	b.n	8000cfa <CAN_ClearITPendingBit+0x60>
 8000cbc:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8000cc0:	d022      	beq.n	8000d08 <CAN_ClearITPendingBit+0x6e>
 8000cc2:	d806      	bhi.n	8000cd2 <CAN_ClearITPendingBit+0x38>
 8000cc4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000cc8:	d020      	beq.n	8000d0c <CAN_ClearITPendingBit+0x72>
 8000cca:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8000cce:	d11f      	bne.n	8000d10 <CAN_ClearITPendingBit+0x76>
 8000cd0:	e01c      	b.n	8000d0c <CAN_ClearITPendingBit+0x72>
 8000cd2:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8000cd6:	d013      	beq.n	8000d00 <CAN_ClearITPendingBit+0x66>
 8000cd8:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 8000cdc:	d012      	beq.n	8000d04 <CAN_ClearITPendingBit+0x6a>
 8000cde:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8000ce2:	d115      	bne.n	8000d10 <CAN_ClearITPendingBit+0x76>
 8000ce4:	e010      	b.n	8000d08 <CAN_ClearITPendingBit+0x6e>
  {
    case CAN_IT_TME:
      /* Clear CAN_TSR_RQCPx (rc_w1)*/
      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
 8000ce6:	4b0b      	ldr	r3, [pc, #44]	; (8000d14 <CAN_ClearITPendingBit+0x7a>)
 8000ce8:	6083      	str	r3, [r0, #8]
      break;
 8000cea:	4770      	bx	lr
    case CAN_IT_FF0:
      /* Clear CAN_RF0R_FULL0 (rc_w1)*/
      CANx->RF0R = CAN_RF0R_FULL0; 
 8000cec:	2308      	movs	r3, #8
 8000cee:	e000      	b.n	8000cf2 <CAN_ClearITPendingBit+0x58>
      break;
    case CAN_IT_FOV0:
      /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
      CANx->RF0R = CAN_RF0R_FOVR0; 
 8000cf0:	2310      	movs	r3, #16
 8000cf2:	60c3      	str	r3, [r0, #12]
      break;
 8000cf4:	4770      	bx	lr
    case CAN_IT_FF1:
      /* Clear CAN_RF1R_FULL1 (rc_w1)*/
      CANx->RF1R = CAN_RF1R_FULL1;  
 8000cf6:	2308      	movs	r3, #8
 8000cf8:	e000      	b.n	8000cfc <CAN_ClearITPendingBit+0x62>
      break;
    case CAN_IT_FOV1:
      /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
      CANx->RF1R = CAN_RF1R_FOVR1; 
 8000cfa:	2310      	movs	r3, #16
 8000cfc:	6103      	str	r3, [r0, #16]
      break;
 8000cfe:	4770      	bx	lr
    case CAN_IT_WKU:
      /* Clear CAN_MSR_WKUI (rc_w1)*/
      CANx->MSR = CAN_MSR_WKUI;  
 8000d00:	2308      	movs	r3, #8
 8000d02:	e004      	b.n	8000d0e <CAN_ClearITPendingBit+0x74>
      break;
    case CAN_IT_SLK:
      /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
      CANx->MSR = CAN_MSR_SLAKI;   
 8000d04:	2310      	movs	r3, #16
 8000d06:	e002      	b.n	8000d0e <CAN_ClearITPendingBit+0x74>
      /* Clear CAN_MSR_ERRI (rc_w1) */
      CANx->MSR = CAN_MSR_ERRI; 
      break;
    case CAN_IT_ERR:
      /*Clear LEC bits */
      CANx->ESR = RESET; 
 8000d08:	2300      	movs	r3, #0
 8000d0a:	6183      	str	r3, [r0, #24]
      /* Clear CAN_MSR_ERRI (rc_w1) */
      CANx->MSR = CAN_MSR_ERRI; 
 8000d0c:	2304      	movs	r3, #4
 8000d0e:	6043      	str	r3, [r0, #4]
 8000d10:	4770      	bx	lr
 8000d12:	bf00      	nop
 8000d14:	00010101 	.word	0x00010101

08000d18 <CRC_ResetDR>:
  * @retval None
  */
void CRC_ResetDR(void)
{
  /* Reset CRC generator */
  CRC->CR = CRC_CR_RESET;
 8000d18:	4b01      	ldr	r3, [pc, #4]	; (8000d20 <CRC_ResetDR+0x8>)
 8000d1a:	2201      	movs	r2, #1
 8000d1c:	609a      	str	r2, [r3, #8]
 8000d1e:	4770      	bx	lr
 8000d20:	40023000 	.word	0x40023000

08000d24 <CRC_CalcCRC>:
  * @param  Data: data word(32-bit) to compute its CRC
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcCRC(uint32_t Data)
{
  CRC->DR = Data;
 8000d24:	4b01      	ldr	r3, [pc, #4]	; (8000d2c <CRC_CalcCRC+0x8>)
 8000d26:	6018      	str	r0, [r3, #0]
  
  return (CRC->DR);
 8000d28:	6818      	ldr	r0, [r3, #0]
}
 8000d2a:	4770      	bx	lr
 8000d2c:	40023000 	.word	0x40023000

08000d30 <CRC_CalcBlockCRC>:
  * @param  pBuffer: pointer to the buffer containing the data to be computed
  * @param  BufferLength: length of the buffer to be computed					
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
 8000d30:	b510      	push	{r4, lr}
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 8000d32:	2300      	movs	r3, #0
 8000d34:	4c05      	ldr	r4, [pc, #20]	; (8000d4c <CRC_CalcBlockCRC+0x1c>)
 8000d36:	e003      	b.n	8000d40 <CRC_CalcBlockCRC+0x10>
  {
    CRC->DR = pBuffer[index];
 8000d38:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 8000d3c:	3301      	adds	r3, #1
  {
    CRC->DR = pBuffer[index];
 8000d3e:	6022      	str	r2, [r4, #0]
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 8000d40:	428b      	cmp	r3, r1
 8000d42:	d1f9      	bne.n	8000d38 <CRC_CalcBlockCRC+0x8>
  {
    CRC->DR = pBuffer[index];
  }
  return (CRC->DR);
 8000d44:	4b01      	ldr	r3, [pc, #4]	; (8000d4c <CRC_CalcBlockCRC+0x1c>)
 8000d46:	6818      	ldr	r0, [r3, #0]
}
 8000d48:	bd10      	pop	{r4, pc}
 8000d4a:	bf00      	nop
 8000d4c:	40023000 	.word	0x40023000

08000d50 <CRC_GetCRC>:
  * @param  None
  * @retval 32-bit CRC
  */
uint32_t CRC_GetCRC(void)
{
  return (CRC->DR);
 8000d50:	4b01      	ldr	r3, [pc, #4]	; (8000d58 <CRC_GetCRC+0x8>)
 8000d52:	6818      	ldr	r0, [r3, #0]
}
 8000d54:	4770      	bx	lr
 8000d56:	bf00      	nop
 8000d58:	40023000 	.word	0x40023000

08000d5c <CRC_SetIDRegister>:
  * @param  IDValue: 8-bit value to be stored in the ID register 					
  * @retval None
  */
void CRC_SetIDRegister(uint8_t IDValue)
{
  CRC->IDR = IDValue;
 8000d5c:	4b01      	ldr	r3, [pc, #4]	; (8000d64 <CRC_SetIDRegister+0x8>)
 8000d5e:	7118      	strb	r0, [r3, #4]
 8000d60:	4770      	bx	lr
 8000d62:	bf00      	nop
 8000d64:	40023000 	.word	0x40023000

08000d68 <CRC_GetIDRegister>:
  * @param  None
  * @retval 8-bit value of the ID register 
  */
uint8_t CRC_GetIDRegister(void)
{
  return (CRC->IDR);
 8000d68:	4b01      	ldr	r3, [pc, #4]	; (8000d70 <CRC_GetIDRegister+0x8>)
 8000d6a:	7918      	ldrb	r0, [r3, #4]
}
 8000d6c:	4770      	bx	lr
 8000d6e:	bf00      	nop
 8000d70:	40023000 	.word	0x40023000

08000d74 <CRYP_DeInit>:
  * @brief  Deinitializes the CRYP peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void CRYP_DeInit(void)
{
 8000d74:	b508      	push	{r3, lr}
  /* Enable CRYP reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
 8000d76:	2010      	movs	r0, #16
 8000d78:	2101      	movs	r1, #1
 8000d7a:	f002 fd0b 	bl	8003794 <RCC_AHB2PeriphResetCmd>

  /* Release CRYP from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
 8000d7e:	2010      	movs	r0, #16
 8000d80:	2100      	movs	r1, #0
}
 8000d82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Enable CRYP reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);

  /* Release CRYP from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
 8000d86:	f002 bd05 	b.w	8003794 <RCC_AHB2PeriphResetCmd>

08000d8a <CRYP_Init>:
  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));

  /* Select Algorithm mode*/  
  CRYP->CR &= ~CRYP_CR_ALGOMODE;
 8000d8a:	4b16      	ldr	r3, [pc, #88]	; (8000de4 <CRYP_Init+0x5a>)
 8000d8c:	681a      	ldr	r2, [r3, #0]
 8000d8e:	f022 0238 	bic.w	r2, r2, #56	; 0x38
  * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains
  *         the configuration information for the CRYP peripheral.
  * @retval None
  */
void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
{
 8000d92:	b510      	push	{r4, lr}
  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));

  /* Select Algorithm mode*/  
  CRYP->CR &= ~CRYP_CR_ALGOMODE;
 8000d94:	601a      	str	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
 8000d96:	6819      	ldr	r1, [r3, #0]
 8000d98:	8842      	ldrh	r2, [r0, #2]

  /* Select dataType */ 
  CRYP->CR &= ~CRYP_CR_DATATYPE;
  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
 8000d9a:	8884      	ldrh	r4, [r0, #4]
  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));

  /* Select Algorithm mode*/  
  CRYP->CR &= ~CRYP_CR_ALGOMODE;
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
 8000d9c:	4311      	orrs	r1, r2
 8000d9e:	6019      	str	r1, [r3, #0]

  /* Select dataType */ 
  CRYP->CR &= ~CRYP_CR_DATATYPE;
 8000da0:	6819      	ldr	r1, [r3, #0]
 8000da2:	f021 01c0 	bic.w	r1, r1, #192	; 0xc0
 8000da6:	6019      	str	r1, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
 8000da8:	6819      	ldr	r1, [r3, #0]
 8000daa:	3a20      	subs	r2, #32
 8000dac:	4321      	orrs	r1, r4
 8000dae:	6019      	str	r1, [r3, #0]
 8000db0:	b291      	uxth	r1, r2
 8000db2:	2918      	cmp	r1, #24
 8000db4:	d80c      	bhi.n	8000dd0 <CRYP_Init+0x46>
 8000db6:	b212      	sxth	r2, r2
 8000db8:	f04f 3180 	mov.w	r1, #2155905152	; 0x80808080
 8000dbc:	4091      	lsls	r1, r2
 8000dbe:	d507      	bpl.n	8000dd0 <CRYP_Init+0x46>
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
  {
    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
    CRYP->CR &= ~CRYP_CR_KEYSIZE;
 8000dc0:	681a      	ldr	r2, [r3, #0]
    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
 8000dc2:	88c1      	ldrh	r1, [r0, #6]
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
      (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
  {
    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
    CRYP->CR &= ~CRYP_CR_KEYSIZE;
 8000dc4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8000dc8:	601a      	str	r2, [r3, #0]
    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
 8000dca:	681a      	ldr	r2, [r3, #0]
 8000dcc:	430a      	orrs	r2, r1
 8000dce:	601a      	str	r2, [r3, #0]
                                                  configured once the key has 
                                                  been prepared */
  }

  /* Select data Direction */ 
  CRYP->CR &= ~CRYP_CR_ALGODIR;
 8000dd0:	681a      	ldr	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
 8000dd2:	8801      	ldrh	r1, [r0, #0]
                                                  configured once the key has 
                                                  been prepared */
  }

  /* Select data Direction */ 
  CRYP->CR &= ~CRYP_CR_ALGODIR;
 8000dd4:	f022 0204 	bic.w	r2, r2, #4
 8000dd8:	601a      	str	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
 8000dda:	681a      	ldr	r2, [r3, #0]
 8000ddc:	430a      	orrs	r2, r1
 8000dde:	601a      	str	r2, [r3, #0]
 8000de0:	bd10      	pop	{r4, pc}
 8000de2:	bf00      	nop
 8000de4:	50060000 	.word	0x50060000

08000de8 <CRYP_StructInit>:
  * @retval None
  */
void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
{
  /* Initialize the CRYP_AlgoDir member */
  CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8000de8:	2300      	movs	r3, #0
 8000dea:	8003      	strh	r3, [r0, #0]

  /* initialize the CRYP_AlgoMode member */
  CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 8000dec:	8043      	strh	r3, [r0, #2]

  /* initialize the CRYP_DataType member */
  CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
 8000dee:	8083      	strh	r3, [r0, #4]
  
  /* Initialize the CRYP_KeySize member */
  CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
 8000df0:	80c3      	strh	r3, [r0, #6]
 8000df2:	4770      	bx	lr

08000df4 <CRYP_KeyInit>:
  * @retval None
  */
void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
  /* Key Initialisation */
  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
 8000df4:	6802      	ldr	r2, [r0, #0]
 8000df6:	4b08      	ldr	r3, [pc, #32]	; (8000e18 <CRYP_KeyInit+0x24>)
 8000df8:	621a      	str	r2, [r3, #32]
  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
 8000dfa:	6842      	ldr	r2, [r0, #4]
 8000dfc:	625a      	str	r2, [r3, #36]	; 0x24
  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
 8000dfe:	6882      	ldr	r2, [r0, #8]
 8000e00:	629a      	str	r2, [r3, #40]	; 0x28
  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
 8000e02:	68c2      	ldr	r2, [r0, #12]
 8000e04:	62da      	str	r2, [r3, #44]	; 0x2c
  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
 8000e06:	6902      	ldr	r2, [r0, #16]
 8000e08:	631a      	str	r2, [r3, #48]	; 0x30
  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
 8000e0a:	6942      	ldr	r2, [r0, #20]
 8000e0c:	635a      	str	r2, [r3, #52]	; 0x34
  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
 8000e0e:	6982      	ldr	r2, [r0, #24]
 8000e10:	639a      	str	r2, [r3, #56]	; 0x38
  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
 8000e12:	69c2      	ldr	r2, [r0, #28]
 8000e14:	63da      	str	r2, [r3, #60]	; 0x3c
 8000e16:	4770      	bx	lr
 8000e18:	50060000 	.word	0x50060000

08000e1c <CRYP_KeyStructInit>:
  *         which will be initialized.
  * @retval None
  */
void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
 8000e1c:	2300      	movs	r3, #0
 8000e1e:	6003      	str	r3, [r0, #0]
  CRYP_KeyInitStruct->CRYP_Key0Right = 0;
 8000e20:	6043      	str	r3, [r0, #4]
  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
 8000e22:	6083      	str	r3, [r0, #8]
  CRYP_KeyInitStruct->CRYP_Key1Right = 0;
 8000e24:	60c3      	str	r3, [r0, #12]
  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
 8000e26:	6103      	str	r3, [r0, #16]
  CRYP_KeyInitStruct->CRYP_Key2Right = 0;
 8000e28:	6143      	str	r3, [r0, #20]
  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
 8000e2a:	6183      	str	r3, [r0, #24]
  CRYP_KeyInitStruct->CRYP_Key3Right = 0;
 8000e2c:	61c3      	str	r3, [r0, #28]
 8000e2e:	4770      	bx	lr

08000e30 <CRYP_IVInit>:
  *         the configuration information for the CRYP Initialization Vectors(IV).
  * @retval None
  */
void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
  CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
 8000e30:	6802      	ldr	r2, [r0, #0]
 8000e32:	4b04      	ldr	r3, [pc, #16]	; (8000e44 <CRYP_IVInit+0x14>)
 8000e34:	641a      	str	r2, [r3, #64]	; 0x40
  CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
 8000e36:	6842      	ldr	r2, [r0, #4]
 8000e38:	645a      	str	r2, [r3, #68]	; 0x44
  CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
 8000e3a:	6882      	ldr	r2, [r0, #8]
 8000e3c:	649a      	str	r2, [r3, #72]	; 0x48
  CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
 8000e3e:	68c2      	ldr	r2, [r0, #12]
 8000e40:	64da      	str	r2, [r3, #76]	; 0x4c
 8000e42:	4770      	bx	lr
 8000e44:	50060000 	.word	0x50060000

08000e48 <CRYP_IVStructInit>:
  *         Vectors(IV) structure which will be initialized.
  * @retval None
  */
void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
  CRYP_IVInitStruct->CRYP_IV0Left  = 0;
 8000e48:	2300      	movs	r3, #0
 8000e4a:	6003      	str	r3, [r0, #0]
  CRYP_IVInitStruct->CRYP_IV0Right = 0;
 8000e4c:	6043      	str	r3, [r0, #4]
  CRYP_IVInitStruct->CRYP_IV1Left  = 0;
 8000e4e:	6083      	str	r3, [r0, #8]
  CRYP_IVInitStruct->CRYP_IV1Right = 0;
 8000e50:	60c3      	str	r3, [r0, #12]
 8000e52:	4770      	bx	lr

08000e54 <CRYP_FIFOFlush>:
  * @retval None
  */
void CRYP_FIFOFlush(void)
{
  /* Reset the read and write pointers of the FIFOs */
  CRYP->CR |= CRYP_CR_FFLUSH;
 8000e54:	4b02      	ldr	r3, [pc, #8]	; (8000e60 <CRYP_FIFOFlush+0xc>)
 8000e56:	681a      	ldr	r2, [r3, #0]
 8000e58:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000e5c:	601a      	str	r2, [r3, #0]
 8000e5e:	4770      	bx	lr
 8000e60:	50060000 	.word	0x50060000

08000e64 <CRYP_Cmd>:
  * @param  NewState: new state of the CRYP peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_Cmd(FunctionalState NewState)
{
 8000e64:	4b04      	ldr	r3, [pc, #16]	; (8000e78 <CRYP_Cmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Cryptographic processor */
    CRYP->CR |= CRYP_CR_CRYPEN;
 8000e66:	681a      	ldr	r2, [r3, #0]
void CRYP_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000e68:	b110      	cbz	r0, 8000e70 <CRYP_Cmd+0xc>
  {
    /* Enable the Cryptographic processor */
    CRYP->CR |= CRYP_CR_CRYPEN;
 8000e6a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000e6e:	e001      	b.n	8000e74 <CRYP_Cmd+0x10>
  }
  else
  {
    /* Disable the Cryptographic processor */
    CRYP->CR &= ~CRYP_CR_CRYPEN;
 8000e70:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8000e74:	601a      	str	r2, [r3, #0]
 8000e76:	4770      	bx	lr
 8000e78:	50060000 	.word	0x50060000

08000e7c <CRYP_DataIn>:
  * @param  Data: data to write in Data Input register
  * @retval None
  */
void CRYP_DataIn(uint32_t Data)
{
  CRYP->DR = Data;
 8000e7c:	4b01      	ldr	r3, [pc, #4]	; (8000e84 <CRYP_DataIn+0x8>)
 8000e7e:	6098      	str	r0, [r3, #8]
 8000e80:	4770      	bx	lr
 8000e82:	bf00      	nop
 8000e84:	50060000 	.word	0x50060000

08000e88 <CRYP_DataOut>:
  * @param  None
  * @retval Last data entered into the output FIFO.
  */
uint32_t CRYP_DataOut(void)
{
  return CRYP->DOUT;
 8000e88:	4b01      	ldr	r3, [pc, #4]	; (8000e90 <CRYP_DataOut+0x8>)
 8000e8a:	68d8      	ldr	r0, [r3, #12]
}
 8000e8c:	4770      	bx	lr
 8000e8e:	bf00      	nop
 8000e90:	50060000 	.word	0x50060000

08000e94 <CRYP_SaveContext>:
  *         contains the configuration information for the CRYP Keys.  
  * @retval None
  */
ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
 8000e94:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t timeout = 0;
 8000e96:	2300      	movs	r3, #0
 8000e98:	9301      	str	r3, [sp, #4]
  uint32_t ckeckmask = 0, bitstatus;    
  ErrorStatus status = ERROR;

  /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
  CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
 8000e9a:	4b22      	ldr	r3, [pc, #136]	; (8000f24 <CRYP_SaveContext+0x90>)
 8000e9c:	691a      	ldr	r2, [r3, #16]
 8000e9e:	f022 0201 	bic.w	r2, r2, #1
 8000ea2:	611a      	str	r2, [r3, #16]
    
  /* Wait until both the IN and OUT FIFOs are empty  
    (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
     BUSY bit is cleared. */

  if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
 8000ea4:	681a      	ldr	r2, [r3, #0]
  { 
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
 8000ea6:	f012 0f08 	tst.w	r2, #8
 8000eaa:	bf0c      	ite	eq
 8000eac:	2215      	moveq	r2, #21
 8000eae:	2211      	movne	r2, #17
  do 
  {
    bitstatus = CRYP->SR & ckeckmask;
    timeout++;
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
 8000eb0:	f64f 75ff 	movw	r5, #65535	; 0xffff
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
  }           
   
  do 
  {
    bitstatus = CRYP->SR & ckeckmask;
 8000eb4:	685c      	ldr	r4, [r3, #4]
    timeout++;
 8000eb6:	9e01      	ldr	r6, [sp, #4]
 8000eb8:	3601      	adds	r6, #1
 8000eba:	9601      	str	r6, [sp, #4]
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
 8000ebc:	9e01      	ldr	r6, [sp, #4]
 8000ebe:	42ae      	cmp	r6, r5
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
  }           
   
  do 
  {
    bitstatus = CRYP->SR & ckeckmask;
 8000ec0:	ea02 0404 	and.w	r4, r2, r4
    timeout++;
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
 8000ec4:	d001      	beq.n	8000eca <CRYP_SaveContext+0x36>
 8000ec6:	2c01      	cmp	r4, #1
 8000ec8:	d1f4      	bne.n	8000eb4 <CRYP_SaveContext+0x20>
     
  if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
 8000eca:	4b16      	ldr	r3, [pc, #88]	; (8000f24 <CRYP_SaveContext+0x90>)
 8000ecc:	685c      	ldr	r4, [r3, #4]
 8000ece:	4022      	ands	r2, r4
 8000ed0:	2a01      	cmp	r2, #1
 8000ed2:	d125      	bne.n	8000f20 <CRYP_SaveContext+0x8c>
  {      
    /* Stop DMA transfers on the OUT FIFO by 
       - writing the DOEN bit to 0 in the CRYP_DMACR register 
       - and clear the CRYPEN bit. */

    CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
 8000ed4:	691c      	ldr	r4, [r3, #16]
 8000ed6:	f024 0402 	bic.w	r4, r4, #2
 8000eda:	611c      	str	r4, [r3, #16]
    CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
 8000edc:	681c      	ldr	r4, [r3, #0]
 8000ede:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
 8000ee2:	601c      	str	r4, [r3, #0]

    /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
    CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
 8000ee4:	681c      	ldr	r4, [r3, #0]
 8000ee6:	f404 747f 	and.w	r4, r4, #1020	; 0x3fc
 8000eea:	6004      	str	r4, [r0, #0]
                                                 CRYP_CR_DATATYPE | 
                                                 CRYP_CR_ALGOMODE |
                                                 CRYP_CR_ALGODIR); 

    /* and, if not in ECB mode, the initialization vectors. */
    CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
 8000eec:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8000eee:	6044      	str	r4, [r0, #4]
    CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
 8000ef0:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8000ef2:	6084      	str	r4, [r0, #8]
    CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
 8000ef4:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8000ef6:	60c4      	str	r4, [r0, #12]
    CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
 8000ef8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000efa:	6103      	str	r3, [r0, #16]

    /* save The key value */
    CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
 8000efc:	680b      	ldr	r3, [r1, #0]
 8000efe:	6143      	str	r3, [r0, #20]
    CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
 8000f00:	684b      	ldr	r3, [r1, #4]
 8000f02:	6183      	str	r3, [r0, #24]
    CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
 8000f04:	688b      	ldr	r3, [r1, #8]
 8000f06:	61c3      	str	r3, [r0, #28]
    CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
 8000f08:	68cb      	ldr	r3, [r1, #12]
 8000f0a:	6203      	str	r3, [r0, #32]
    CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
 8000f0c:	690b      	ldr	r3, [r1, #16]
 8000f0e:	6243      	str	r3, [r0, #36]	; 0x24
    CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
 8000f10:	694b      	ldr	r3, [r1, #20]
 8000f12:	6283      	str	r3, [r0, #40]	; 0x28
    CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
 8000f14:	698b      	ldr	r3, [r1, #24]
 8000f16:	62c3      	str	r3, [r0, #44]	; 0x2c
    CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
 8000f18:	69cb      	ldr	r3, [r1, #28]
 8000f1a:	6303      	str	r3, [r0, #48]	; 0x30

   /* When needed, save the DMA status (pointers for IN and OUT messages, 
      number of remaining bytes, etc.) */
     
    status = SUCCESS;
 8000f1c:	4610      	mov	r0, r2
 8000f1e:	e000      	b.n	8000f22 <CRYP_SaveContext+0x8e>
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
     
  if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
  {
    status = ERROR;
 8000f20:	2000      	movs	r0, #0
     
    status = SUCCESS;
  }

   return status;
}
 8000f22:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8000f24:	50060000 	.word	0x50060000

08000f28 <CRYP_RestoreContext>:
  */
void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
{

  /* Configure the processor with the saved configuration */
  CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
 8000f28:	6802      	ldr	r2, [r0, #0]
 8000f2a:	4b0f      	ldr	r3, [pc, #60]	; (8000f68 <CRYP_RestoreContext+0x40>)
 8000f2c:	601a      	str	r2, [r3, #0]

  /* restore The key value */
  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
 8000f2e:	6942      	ldr	r2, [r0, #20]
 8000f30:	621a      	str	r2, [r3, #32]
  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
 8000f32:	6982      	ldr	r2, [r0, #24]
 8000f34:	625a      	str	r2, [r3, #36]	; 0x24
  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
 8000f36:	69c2      	ldr	r2, [r0, #28]
 8000f38:	629a      	str	r2, [r3, #40]	; 0x28
  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
 8000f3a:	6a02      	ldr	r2, [r0, #32]
 8000f3c:	62da      	str	r2, [r3, #44]	; 0x2c
  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
 8000f3e:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000f40:	631a      	str	r2, [r3, #48]	; 0x30
  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
 8000f42:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8000f44:	635a      	str	r2, [r3, #52]	; 0x34
  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
 8000f46:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8000f48:	639a      	str	r2, [r3, #56]	; 0x38
  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
 8000f4a:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8000f4c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* and the initialization vectors. */
  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
 8000f4e:	6842      	ldr	r2, [r0, #4]
 8000f50:	641a      	str	r2, [r3, #64]	; 0x40
  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
 8000f52:	6882      	ldr	r2, [r0, #8]
 8000f54:	645a      	str	r2, [r3, #68]	; 0x44
  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
 8000f56:	68c2      	ldr	r2, [r0, #12]
 8000f58:	649a      	str	r2, [r3, #72]	; 0x48
  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
 8000f5a:	6902      	ldr	r2, [r0, #16]
 8000f5c:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Enable the cryptographic processor */
  CRYP->CR |= CRYP_CR_CRYPEN;
 8000f5e:	681a      	ldr	r2, [r3, #0]
 8000f60:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000f64:	601a      	str	r2, [r3, #0]
 8000f66:	4770      	bx	lr
 8000f68:	50060000 	.word	0x50060000

08000f6c <CRYP_DMACmd>:
  * @param  NewState: new state of the selected CRYP DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
{
 8000f6c:	4b05      	ldr	r3, [pc, #20]	; (8000f84 <CRYP_DMACmd+0x18>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected CRYP DMA request */
    CRYP->DMACR |= CRYP_DMAReq;
 8000f6e:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000f70:	b109      	cbz	r1, 8000f76 <CRYP_DMACmd+0xa>
  {
    /* Enable the selected CRYP DMA request */
    CRYP->DMACR |= CRYP_DMAReq;
 8000f72:	4310      	orrs	r0, r2
 8000f74:	e003      	b.n	8000f7e <CRYP_DMACmd+0x12>
  }
  else
  {
    /* Disable the selected CRYP DMA request */
    CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
 8000f76:	ea22 0000 	bic.w	r0, r2, r0
 8000f7a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
 8000f7e:	6118      	str	r0, [r3, #16]
 8000f80:	4770      	bx	lr
 8000f82:	bf00      	nop
 8000f84:	50060000 	.word	0x50060000

08000f88 <CRYP_ITConfig>:
  * @param  NewState: new state of the specified CRYP interrupt.
  *           This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
{
 8000f88:	4b05      	ldr	r3, [pc, #20]	; (8000fa0 <CRYP_ITConfig+0x18>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected CRYP interrupt */
    CRYP->IMSCR |= CRYP_IT;
 8000f8a:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000f8c:	b109      	cbz	r1, 8000f92 <CRYP_ITConfig+0xa>
  {
    /* Enable the selected CRYP interrupt */
    CRYP->IMSCR |= CRYP_IT;
 8000f8e:	4310      	orrs	r0, r2
 8000f90:	e003      	b.n	8000f9a <CRYP_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected CRYP interrupt */
    CRYP->IMSCR &= (uint8_t)~CRYP_IT;
 8000f92:	ea22 0000 	bic.w	r0, r2, r0
 8000f96:	f000 00ff 	and.w	r0, r0, #255	; 0xff
 8000f9a:	6158      	str	r0, [r3, #20]
 8000f9c:	4770      	bx	lr
 8000f9e:	bf00      	nop
 8000fa0:	50060000 	.word	0x50060000

08000fa4 <CRYP_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_CRYP_GET_IT(CRYP_IT));

  /* Check the status of the specified CRYP interrupt */
  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
 8000fa4:	4b03      	ldr	r3, [pc, #12]	; (8000fb4 <CRYP_GetITStatus+0x10>)
 8000fa6:	69db      	ldr	r3, [r3, #28]
 8000fa8:	4218      	tst	r0, r3
    /* CRYP_IT is reset */
    bitstatus = RESET;
  }
  /* Return the CRYP_IT status */
  return bitstatus;
}
 8000faa:	bf0c      	ite	eq
 8000fac:	2000      	moveq	r0, #0
 8000fae:	2001      	movne	r0, #1
 8000fb0:	4770      	bx	lr
 8000fb2:	bf00      	nop
 8000fb4:	50060000 	.word	0x50060000

08000fb8 <CRYP_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));

  /* check if the FLAG is in RISR register */
  if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
 8000fb8:	f000 0220 	and.w	r2, r0, #32
 8000fbc:	b2d2      	uxtb	r2, r2
 8000fbe:	4b05      	ldr	r3, [pc, #20]	; (8000fd4 <CRYP_GetFlagStatus+0x1c>)
 8000fc0:	b10a      	cbz	r2, 8000fc6 <CRYP_GetFlagStatus+0xe>
  {
    tempreg = CRYP->RISR;
 8000fc2:	699b      	ldr	r3, [r3, #24]
 8000fc4:	e000      	b.n	8000fc8 <CRYP_GetFlagStatus+0x10>
  }
  else  /* The FLAG is in SR register */
  {
    tempreg = CRYP->SR;
 8000fc6:	685b      	ldr	r3, [r3, #4]
  }


  /* Check the status of the specified CRYP flag */
  if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
 8000fc8:	4203      	tst	r3, r0
    bitstatus = RESET;
  }

  /* Return the CRYP_FLAG status */
  return  bitstatus;
}
 8000fca:	bf0c      	ite	eq
 8000fcc:	2000      	moveq	r0, #0
 8000fce:	2001      	movne	r0, #1
 8000fd0:	4770      	bx	lr
 8000fd2:	bf00      	nop
 8000fd4:	50060000 	.word	0x50060000

08000fd8 <CRYP_AES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
                         uint8_t* Input, uint32_t Ilength, uint8_t* Output)
{
 8000fd8:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
 8000fdc:	b08d      	sub	sp, #52	; 0x34
 8000fde:	4617      	mov	r7, r2
 8000fe0:	4606      	mov	r6, r0
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 8000fe2:	f04f 0a00 	mov.w	sl, #0
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8000fe6:	a804      	add	r0, sp, #16
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
                         uint8_t* Input, uint32_t Ilength, uint8_t* Output)
{
 8000fe8:	460c      	mov	r4, r1
 8000fea:	4698      	mov	r8, r3
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 8000fec:	f8cd a004 	str.w	sl, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 8000ff0:	9d15      	ldr	r5, [sp, #84]	; 0x54
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8000ff2:	f7ff ff13 	bl	8000e1c <CRYP_KeyStructInit>

  switch(Keysize)
 8000ff6:	2fc0      	cmp	r7, #192	; 0xc0
 8000ff8:	d011      	beq.n	800101e <CRYP_AES_ECB+0x46>
 8000ffa:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
 8000ffe:	d023      	beq.n	8001048 <CRYP_AES_ECB+0x70>
 8001000:	2f80      	cmp	r7, #128	; 0x80
 8001002:	d13d      	bne.n	8001080 <CRYP_AES_ECB+0xa8>
  {
    case 128:
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001004:	f8ad a00e 	strh.w	sl, [sp, #14]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
{
  uint32_t result;
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 8001008:	6823      	ldr	r3, [r4, #0]
 800100a:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800100c:	9308      	str	r3, [sp, #32]
 800100e:	6863      	ldr	r3, [r4, #4]
 8001010:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001012:	9309      	str	r3, [sp, #36]	; 0x24
 8001014:	68a3      	ldr	r3, [r4, #8]
 8001016:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001018:	930a      	str	r3, [sp, #40]	; 0x28
 800101a:	68e3      	ldr	r3, [r4, #12]
 800101c:	e02e      	b.n	800107c <CRYP_AES_ECB+0xa4>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 192:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 800101e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001022:	f8ad 300e 	strh.w	r3, [sp, #14]
 8001026:	6823      	ldr	r3, [r4, #0]
 8001028:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800102a:	9306      	str	r3, [sp, #24]
 800102c:	6863      	ldr	r3, [r4, #4]
 800102e:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001030:	9307      	str	r3, [sp, #28]
 8001032:	68a3      	ldr	r3, [r4, #8]
 8001034:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001036:	9308      	str	r3, [sp, #32]
 8001038:	68e3      	ldr	r3, [r4, #12]
 800103a:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800103c:	9309      	str	r3, [sp, #36]	; 0x24
 800103e:	6923      	ldr	r3, [r4, #16]
 8001040:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001042:	930a      	str	r3, [sp, #40]	; 0x28
 8001044:	6963      	ldr	r3, [r4, #20]
 8001046:	e019      	b.n	800107c <CRYP_AES_ECB+0xa4>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 256:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8001048:	f44f 7300 	mov.w	r3, #512	; 0x200
 800104c:	f8ad 300e 	strh.w	r3, [sp, #14]
 8001050:	6823      	ldr	r3, [r4, #0]
 8001052:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 8001054:	9304      	str	r3, [sp, #16]
 8001056:	6863      	ldr	r3, [r4, #4]
 8001058:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 800105a:	9305      	str	r3, [sp, #20]
 800105c:	68a3      	ldr	r3, [r4, #8]
 800105e:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001060:	9306      	str	r3, [sp, #24]
 8001062:	68e3      	ldr	r3, [r4, #12]
 8001064:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001066:	9307      	str	r3, [sp, #28]
 8001068:	6923      	ldr	r3, [r4, #16]
 800106a:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800106c:	9308      	str	r3, [sp, #32]
 800106e:	6963      	ldr	r3, [r4, #20]
 8001070:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001072:	9309      	str	r3, [sp, #36]	; 0x24
 8001074:	69a3      	ldr	r3, [r4, #24]
 8001076:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001078:	930a      	str	r3, [sp, #40]	; 0x28
 800107a:	69e3      	ldr	r3, [r4, #28]
 800107c:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800107e:	930b      	str	r3, [sp, #44]	; 0x2c
    default:
    break;
  }

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 8001080:	bb1e      	cbnz	r6, 80010ca <CRYP_AES_ECB+0xf2>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 8001082:	f7ff fee7 	bl	8000e54 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001086:	2304      	movs	r3, #4
 8001088:	f8ad 3008 	strh.w	r3, [sp, #8]
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
    CRYP_Init(&AES_CRYP_InitStructure);
 800108c:	a802      	add	r0, sp, #8
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 800108e:	2338      	movs	r3, #56	; 0x38
 8001090:	f8ad 300a 	strh.w	r3, [sp, #10]
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 8001094:	f8ad 600c 	strh.w	r6, [sp, #12]
    CRYP_Init(&AES_CRYP_InitStructure);
 8001098:	f7ff fe77 	bl	8000d8a <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800109c:	a804      	add	r0, sp, #16
 800109e:	f7ff fea9 	bl	8000df4 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 80010a2:	2001      	movs	r0, #1
 80010a4:	f7ff fede 	bl	8000e64 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80010a8:	2010      	movs	r0, #16
 80010aa:	f7ff ff85 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 80010ae:	9b01      	ldr	r3, [sp, #4]
 80010b0:	3301      	adds	r3, #1
 80010b2:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80010b4:	9b01      	ldr	r3, [sp, #4]
 80010b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80010ba:	d002      	beq.n	80010c2 <CRYP_AES_ECB+0xea>
 80010bc:	2800      	cmp	r0, #0
 80010be:	d1f3      	bne.n	80010a8 <CRYP_AES_ECB+0xd0>
 80010c0:	e001      	b.n	80010c6 <CRYP_AES_ECB+0xee>

    if (busystatus != RESET)
   {
       status = ERROR;
 80010c2:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80010c4:	b948      	cbnz	r0, 80010da <CRYP_AES_ECB+0x102>
       status = ERROR;
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 80010c6:	2304      	movs	r3, #4
 80010c8:	e003      	b.n	80010d2 <CRYP_AES_ECB+0xfa>
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {

    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 80010ca:	a804      	add	r0, sp, #16
 80010cc:	f7ff fe92 	bl	8000df4 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 80010d0:	2300      	movs	r3, #0
 80010d2:	f8ad 3008 	strh.w	r3, [sp, #8]
{
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 80010d6:	2701      	movs	r7, #1
 80010d8:	e7ff      	b.n	80010da <CRYP_AES_ECB+0x102>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }

  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
 80010da:	2320      	movs	r3, #32
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&AES_CRYP_InitStructure);
 80010dc:	a802      	add	r0, sp, #8

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }

  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
 80010de:	f8ad 300a 	strh.w	r3, [sp, #10]
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 80010e2:	2380      	movs	r3, #128	; 0x80
 80010e4:	f8ad 300c 	strh.w	r3, [sp, #12]
  CRYP_Init(&AES_CRYP_InitStructure);
 80010e8:	f7ff fe4f 	bl	8000d8a <CRYP_Init>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 80010ec:	f7ff feb2 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80010f0:	2001      	movs	r0, #1
 80010f2:	f7ff feb7 	bl	8000e64 <CRYP_Cmd>
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80010f6:	4644      	mov	r4, r8
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80010f8:	2600      	movs	r6, #0
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 80010fa:	e02c      	b.n	8001156 <CRYP_AES_ECB+0x17e>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80010fc:	6820      	ldr	r0, [r4, #0]
 80010fe:	f7ff febd 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001102:	6860      	ldr	r0, [r4, #4]
 8001104:	f7ff feba 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001108:	68a0      	ldr	r0, [r4, #8]
 800110a:	f7ff feb7 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800110e:	68e0      	ldr	r0, [r4, #12]
 8001110:	f7ff feb4 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
 8001114:	3410      	adds	r4, #16

    /* Wait until the complete message has been processed */
    counter = 0;
 8001116:	9601      	str	r6, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001118:	2010      	movs	r0, #16
 800111a:	f7ff ff4d 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	3301      	adds	r3, #1
 8001122:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800112a:	d002      	beq.n	8001132 <CRYP_AES_ECB+0x15a>
 800112c:	2800      	cmp	r0, #0
 800112e:	d1f3      	bne.n	8001118 <CRYP_AES_ECB+0x140>
 8001130:	e001      	b.n	8001136 <CRYP_AES_ECB+0x15e>

    if (busystatus != RESET)
   {
       status = ERROR;
 8001132:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001134:	b978      	cbnz	r0, 8001156 <CRYP_AES_ECB+0x17e>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001136:	f7ff fea7 	bl	8000e88 <CRYP_DataOut>
 800113a:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800113c:	f7ff fea4 	bl	8000e88 <CRYP_DataOut>
 8001140:	6068      	str	r0, [r5, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001142:	f7ff fea1 	bl	8000e88 <CRYP_DataOut>
 8001146:	60a8      	str	r0, [r5, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
 8001148:	f7ff fe9e 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 800114c:	3510      	adds	r5, #16
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
 800114e:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 8001152:	2701      	movs	r7, #1
 8001154:	e7ff      	b.n	8001156 <CRYP_AES_ECB+0x17e>
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 8001156:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8001158:	ebc8 0304 	rsb	r3, r8, r4
 800115c:	4293      	cmp	r3, r2
 800115e:	d201      	bcs.n	8001164 <CRYP_AES_ECB+0x18c>
 8001160:	2f00      	cmp	r7, #0
 8001162:	d1cb      	bne.n	80010fc <CRYP_AES_ECB+0x124>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8001164:	2000      	movs	r0, #0
 8001166:	f7ff fe7d 	bl	8000e64 <CRYP_Cmd>

  return status; 
}
 800116a:	4638      	mov	r0, r7
 800116c:	b00d      	add	sp, #52	; 0x34
 800116e:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}

08001172 <CRYP_AES_CBC>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001172:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
 8001176:	b090      	sub	sp, #64	; 0x40
 8001178:	4698      	mov	r8, r3
 800117a:	4682      	mov	sl, r0
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800117c:	f04f 0b00 	mov.w	fp, #0
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8001180:	a808      	add	r0, sp, #32
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001182:	460f      	mov	r7, r1
 8001184:	4614      	mov	r4, r2
 8001186:	9e18      	ldr	r6, [sp, #96]	; 0x60
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001188:	f8cd b004 	str.w	fp, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 800118c:	9d1a      	ldr	r5, [sp, #104]	; 0x68
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 800118e:	f7ff fe45 	bl	8000e1c <CRYP_KeyStructInit>

  switch(Keysize)
 8001192:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
 8001196:	d012      	beq.n	80011be <CRYP_AES_CBC+0x4c>
 8001198:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
 800119c:	d024      	beq.n	80011e8 <CRYP_AES_CBC+0x76>
 800119e:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 80011a2:	d13d      	bne.n	8001220 <CRYP_AES_CBC+0xae>
  {
    case 128:
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 80011a4:	f8ad b00e 	strh.w	fp, [sp, #14]
 80011a8:	6823      	ldr	r3, [r4, #0]
 80011aa:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80011ac:	930c      	str	r3, [sp, #48]	; 0x30
 80011ae:	6863      	ldr	r3, [r4, #4]
 80011b0:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80011b2:	930d      	str	r3, [sp, #52]	; 0x34
 80011b4:	68a3      	ldr	r3, [r4, #8]
 80011b6:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80011b8:	930e      	str	r3, [sp, #56]	; 0x38
 80011ba:	68e3      	ldr	r3, [r4, #12]
 80011bc:	e02e      	b.n	800121c <CRYP_AES_CBC+0xaa>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 192:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 80011be:	f44f 7380 	mov.w	r3, #256	; 0x100
 80011c2:	f8ad 300e 	strh.w	r3, [sp, #14]
 80011c6:	6823      	ldr	r3, [r4, #0]
 80011c8:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80011ca:	930a      	str	r3, [sp, #40]	; 0x28
 80011cc:	6863      	ldr	r3, [r4, #4]
 80011ce:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80011d0:	930b      	str	r3, [sp, #44]	; 0x2c
 80011d2:	68a3      	ldr	r3, [r4, #8]
 80011d4:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80011d6:	930c      	str	r3, [sp, #48]	; 0x30
 80011d8:	68e3      	ldr	r3, [r4, #12]
 80011da:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80011dc:	930d      	str	r3, [sp, #52]	; 0x34
 80011de:	6923      	ldr	r3, [r4, #16]
 80011e0:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80011e2:	930e      	str	r3, [sp, #56]	; 0x38
 80011e4:	6963      	ldr	r3, [r4, #20]
 80011e6:	e019      	b.n	800121c <CRYP_AES_CBC+0xaa>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 256:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 80011e8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80011ec:	f8ad 300e 	strh.w	r3, [sp, #14]
 80011f0:	6823      	ldr	r3, [r4, #0]
 80011f2:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 80011f4:	9308      	str	r3, [sp, #32]
 80011f6:	6863      	ldr	r3, [r4, #4]
 80011f8:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 80011fa:	9309      	str	r3, [sp, #36]	; 0x24
 80011fc:	68a3      	ldr	r3, [r4, #8]
 80011fe:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001200:	930a      	str	r3, [sp, #40]	; 0x28
 8001202:	68e3      	ldr	r3, [r4, #12]
 8001204:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001206:	930b      	str	r3, [sp, #44]	; 0x2c
 8001208:	6923      	ldr	r3, [r4, #16]
 800120a:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800120c:	930c      	str	r3, [sp, #48]	; 0x30
 800120e:	6963      	ldr	r3, [r4, #20]
 8001210:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001212:	930d      	str	r3, [sp, #52]	; 0x34
 8001214:	69a3      	ldr	r3, [r4, #24]
 8001216:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001218:	930e      	str	r3, [sp, #56]	; 0x38
 800121a:	69e3      	ldr	r3, [r4, #28]
 800121c:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800121e:	930f      	str	r3, [sp, #60]	; 0x3c
 8001220:	683b      	ldr	r3, [r7, #0]
 8001222:	ba1b      	rev	r3, r3
    default:
    break;
  }

  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 8001224:	9304      	str	r3, [sp, #16]
 8001226:	687b      	ldr	r3, [r7, #4]
 8001228:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800122a:	9305      	str	r3, [sp, #20]
 800122c:	68bb      	ldr	r3, [r7, #8]
 800122e:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 8001230:	9306      	str	r3, [sp, #24]
 8001232:	68fb      	ldr	r3, [r7, #12]
 8001234:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 8001236:	9307      	str	r3, [sp, #28]


  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 8001238:	f1ba 0f00 	cmp.w	sl, #0
 800123c:	d123      	bne.n	8001286 <CRYP_AES_CBC+0x114>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 800123e:	f7ff fe09 	bl	8000e54 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001242:	2304      	movs	r3, #4
 8001244:	f8ad 3008 	strh.w	r3, [sp, #8]
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;

    CRYP_Init(&AES_CRYP_InitStructure);
 8001248:	a802      	add	r0, sp, #8
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 800124a:	2338      	movs	r3, #56	; 0x38
 800124c:	f8ad 300a 	strh.w	r3, [sp, #10]
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 8001250:	f8ad a00c 	strh.w	sl, [sp, #12]

    CRYP_Init(&AES_CRYP_InitStructure);
 8001254:	f7ff fd99 	bl	8000d8a <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001258:	a808      	add	r0, sp, #32
 800125a:	f7ff fdcb 	bl	8000df4 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 800125e:	2001      	movs	r0, #1
 8001260:	f7ff fe00 	bl	8000e64 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001264:	2010      	movs	r0, #16
 8001266:	f7ff fea7 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 800126a:	9b01      	ldr	r3, [sp, #4]
 800126c:	3301      	adds	r3, #1
 800126e:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001270:	9b01      	ldr	r3, [sp, #4]
 8001272:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001276:	d002      	beq.n	800127e <CRYP_AES_CBC+0x10c>
 8001278:	2800      	cmp	r0, #0
 800127a:	d1f3      	bne.n	8001264 <CRYP_AES_CBC+0xf2>
 800127c:	e001      	b.n	8001282 <CRYP_AES_CBC+0x110>

    if (busystatus != RESET)
   {
       status = ERROR;
 800127e:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001280:	b948      	cbnz	r0, 8001296 <CRYP_AES_CBC+0x124>
       status = ERROR;
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001282:	2304      	movs	r3, #4
 8001284:	e003      	b.n	800128e <CRYP_AES_CBC+0x11c>
    }
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001286:	a808      	add	r0, sp, #32
 8001288:	f7ff fdb4 	bl	8000df4 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 800128c:	2300      	movs	r3, #0
 800128e:	f8ad 3008 	strh.w	r3, [sp, #8]
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8001292:	2701      	movs	r7, #1
 8001294:	e7ff      	b.n	8001296 <CRYP_AES_CBC+0x124>
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
 8001296:	2328      	movs	r3, #40	; 0x28
 8001298:	f8ad 300a 	strh.w	r3, [sp, #10]
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&AES_CRYP_InitStructure);
 800129c:	a802      	add	r0, sp, #8

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800129e:	2380      	movs	r3, #128	; 0x80
 80012a0:	f8ad 300c 	strh.w	r3, [sp, #12]
  CRYP_Init(&AES_CRYP_InitStructure);
 80012a4:	f7ff fd71 	bl	8000d8a <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 80012a8:	a804      	add	r0, sp, #16
 80012aa:	f7ff fdc1 	bl	8000e30 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 80012ae:	f7ff fdd1 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80012b2:	2001      	movs	r0, #1
 80012b4:	f7ff fdd6 	bl	8000e64 <CRYP_Cmd>
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80012b8:	4634      	mov	r4, r6
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    /* Wait until the complete message has been processed */
    counter = 0;
 80012ba:	f04f 0800 	mov.w	r8, #0

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);


  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 80012be:	e02d      	b.n	800131c <CRYP_AES_CBC+0x1aa>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80012c0:	6820      	ldr	r0, [r4, #0]
 80012c2:	f7ff fddb 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80012c6:	6860      	ldr	r0, [r4, #4]
 80012c8:	f7ff fdd8 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80012cc:	68a0      	ldr	r0, [r4, #8]
 80012ce:	f7ff fdd5 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80012d2:	68e0      	ldr	r0, [r4, #12]
 80012d4:	f7ff fdd2 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
 80012d8:	3410      	adds	r4, #16
    /* Wait until the complete message has been processed */
    counter = 0;
 80012da:	f8cd 8004 	str.w	r8, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80012de:	2010      	movs	r0, #16
 80012e0:	f7ff fe6a 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 80012e4:	9b01      	ldr	r3, [sp, #4]
 80012e6:	3301      	adds	r3, #1
 80012e8:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80012ea:	9b01      	ldr	r3, [sp, #4]
 80012ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80012f0:	d002      	beq.n	80012f8 <CRYP_AES_CBC+0x186>
 80012f2:	2800      	cmp	r0, #0
 80012f4:	d1f3      	bne.n	80012de <CRYP_AES_CBC+0x16c>
 80012f6:	e001      	b.n	80012fc <CRYP_AES_CBC+0x18a>

    if (busystatus != RESET)
   {
       status = ERROR;
 80012f8:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80012fa:	b978      	cbnz	r0, 800131c <CRYP_AES_CBC+0x1aa>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80012fc:	f7ff fdc4 	bl	8000e88 <CRYP_DataOut>
 8001300:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001302:	f7ff fdc1 	bl	8000e88 <CRYP_DataOut>
 8001306:	6068      	str	r0, [r5, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001308:	f7ff fdbe 	bl	8000e88 <CRYP_DataOut>
 800130c:	60a8      	str	r0, [r5, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800130e:	f7ff fdbb 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 8001312:	3510      	adds	r5, #16
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001314:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 8001318:	2701      	movs	r7, #1
 800131a:	e7ff      	b.n	800131c <CRYP_AES_CBC+0x1aa>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);


  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800131c:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800131e:	1ba3      	subs	r3, r4, r6
 8001320:	4293      	cmp	r3, r2
 8001322:	d201      	bcs.n	8001328 <CRYP_AES_CBC+0x1b6>
 8001324:	2f00      	cmp	r7, #0
 8001326:	d1cb      	bne.n	80012c0 <CRYP_AES_CBC+0x14e>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8001328:	2000      	movs	r0, #0
 800132a:	f7ff fd9b 	bl	8000e64 <CRYP_Cmd>

  return status;
}
 800132e:	4638      	mov	r0, r7
 8001330:	b010      	add	sp, #64	; 0x40
 8001332:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}

08001336 <CRYP_AES_CTR>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001336:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
 800133a:	b090      	sub	sp, #64	; 0x40
 800133c:	4698      	mov	r8, r3
 800133e:	4683      	mov	fp, r0
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001340:	f04f 0a00 	mov.w	sl, #0
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8001344:	a808      	add	r0, sp, #32
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001346:	460f      	mov	r7, r1
 8001348:	4614      	mov	r4, r2
 800134a:	9e18      	ldr	r6, [sp, #96]	; 0x60
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800134c:	f8cd a004 	str.w	sl, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 8001350:	9d1a      	ldr	r5, [sp, #104]	; 0x68
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8001352:	f7ff fd63 	bl	8000e1c <CRYP_KeyStructInit>

  switch(Keysize)
 8001356:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
 800135a:	d012      	beq.n	8001382 <CRYP_AES_CTR+0x4c>
 800135c:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
 8001360:	d024      	beq.n	80013ac <CRYP_AES_CTR+0x76>
 8001362:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 8001366:	d13d      	bne.n	80013e4 <CRYP_AES_CTR+0xae>
  {
    case 128:
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001368:	f8ad a00e 	strh.w	sl, [sp, #14]
 800136c:	6823      	ldr	r3, [r4, #0]
 800136e:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001370:	930c      	str	r3, [sp, #48]	; 0x30
 8001372:	6863      	ldr	r3, [r4, #4]
 8001374:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001376:	930d      	str	r3, [sp, #52]	; 0x34
 8001378:	68a3      	ldr	r3, [r4, #8]
 800137a:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800137c:	930e      	str	r3, [sp, #56]	; 0x38
 800137e:	68e3      	ldr	r3, [r4, #12]
 8001380:	e02e      	b.n	80013e0 <CRYP_AES_CTR+0xaa>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 192:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 8001382:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001386:	f8ad 300e 	strh.w	r3, [sp, #14]
 800138a:	6823      	ldr	r3, [r4, #0]
 800138c:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800138e:	930a      	str	r3, [sp, #40]	; 0x28
 8001390:	6863      	ldr	r3, [r4, #4]
 8001392:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001394:	930b      	str	r3, [sp, #44]	; 0x2c
 8001396:	68a3      	ldr	r3, [r4, #8]
 8001398:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800139a:	930c      	str	r3, [sp, #48]	; 0x30
 800139c:	68e3      	ldr	r3, [r4, #12]
 800139e:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80013a0:	930d      	str	r3, [sp, #52]	; 0x34
 80013a2:	6923      	ldr	r3, [r4, #16]
 80013a4:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80013a6:	930e      	str	r3, [sp, #56]	; 0x38
 80013a8:	6963      	ldr	r3, [r4, #20]
 80013aa:	e019      	b.n	80013e0 <CRYP_AES_CTR+0xaa>
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
    break;
    case 256:
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 80013ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 80013b0:	f8ad 300e 	strh.w	r3, [sp, #14]
 80013b4:	6823      	ldr	r3, [r4, #0]
 80013b6:	ba1b      	rev	r3, r3
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 80013b8:	9308      	str	r3, [sp, #32]
 80013ba:	6863      	ldr	r3, [r4, #4]
 80013bc:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 80013be:	9309      	str	r3, [sp, #36]	; 0x24
 80013c0:	68a3      	ldr	r3, [r4, #8]
 80013c2:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80013c4:	930a      	str	r3, [sp, #40]	; 0x28
 80013c6:	68e3      	ldr	r3, [r4, #12]
 80013c8:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80013ca:	930b      	str	r3, [sp, #44]	; 0x2c
 80013cc:	6923      	ldr	r3, [r4, #16]
 80013ce:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80013d0:	930c      	str	r3, [sp, #48]	; 0x30
 80013d2:	6963      	ldr	r3, [r4, #20]
 80013d4:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80013d6:	930d      	str	r3, [sp, #52]	; 0x34
 80013d8:	69a3      	ldr	r3, [r4, #24]
 80013da:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80013dc:	930e      	str	r3, [sp, #56]	; 0x38
 80013de:	69e3      	ldr	r3, [r4, #28]
 80013e0:	ba1b      	rev	r3, r3
    keyaddr+=4;
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80013e2:	930f      	str	r3, [sp, #60]	; 0x3c
 80013e4:	683b      	ldr	r3, [r7, #0]
 80013e6:	ba1b      	rev	r3, r3
    break;
    default:
    break;
  }
  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 80013e8:	9304      	str	r3, [sp, #16]
 80013ea:	687b      	ldr	r3, [r7, #4]
 80013ec:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 80013ee:	9305      	str	r3, [sp, #20]
 80013f0:	68bb      	ldr	r3, [r7, #8]
 80013f2:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 80013f4:	9306      	str	r3, [sp, #24]
 80013f6:	68fb      	ldr	r3, [r7, #12]
 80013f8:	ba1b      	rev	r3, r3
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));

  /* Key Initialisation */
  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 80013fa:	a808      	add	r0, sp, #32
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 80013fc:	9307      	str	r3, [sp, #28]

  /* Key Initialisation */
  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 80013fe:	f7ff fcf9 	bl	8000df4 <CRYP_KeyInit>

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 8001402:	f1bb 0f00 	cmp.w	fp, #0
 8001406:	d101      	bne.n	800140c <CRYP_AES_CTR+0xd6>
  {
    /* Crypto Init for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001408:	2304      	movs	r3, #4
 800140a:	e000      	b.n	800140e <CRYP_AES_CTR+0xd8>
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {
    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800140c:	2300      	movs	r3, #0
 800140e:	f8ad 3008 	strh.w	r3, [sp, #8]
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
 8001412:	2330      	movs	r3, #48	; 0x30
 8001414:	f8ad 300a 	strh.w	r3, [sp, #10]
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&AES_CRYP_InitStructure);
 8001418:	a802      	add	r0, sp, #8
  {
    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800141a:	2380      	movs	r3, #128	; 0x80
 800141c:	f8ad 300c 	strh.w	r3, [sp, #12]
  CRYP_Init(&AES_CRYP_InitStructure);
 8001420:	f7ff fcb3 	bl	8000d8a <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 8001424:	a804      	add	r0, sp, #16
 8001426:	f7ff fd03 	bl	8000e30 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 800142a:	f7ff fd13 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800142e:	2001      	movs	r0, #1
 8001430:	f7ff fd18 	bl	8000e64 <CRYP_Cmd>
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 8001434:	4634      	mov	r4, r6
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8001436:	2701      	movs	r7, #1
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    /* Wait until the complete message has been processed */
    counter = 0;
 8001438:	f04f 0800 	mov.w	r8, #0
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800143c:	e02d      	b.n	800149a <CRYP_AES_CTR+0x164>
  {

    /* Write the Input block in the IN FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800143e:	6820      	ldr	r0, [r4, #0]
 8001440:	f7ff fd1c 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001444:	6860      	ldr	r0, [r4, #4]
 8001446:	f7ff fd19 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800144a:	68a0      	ldr	r0, [r4, #8]
 800144c:	f7ff fd16 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001450:	68e0      	ldr	r0, [r4, #12]
 8001452:	f7ff fd13 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;
 8001456:	3410      	adds	r4, #16
    /* Wait until the complete message has been processed */
    counter = 0;
 8001458:	f8cd 8004 	str.w	r8, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800145c:	2010      	movs	r0, #16
 800145e:	f7ff fdab 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 8001462:	9b01      	ldr	r3, [sp, #4]
 8001464:	3301      	adds	r3, #1
 8001466:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001468:	9b01      	ldr	r3, [sp, #4]
 800146a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800146e:	d002      	beq.n	8001476 <CRYP_AES_CTR+0x140>
 8001470:	2800      	cmp	r0, #0
 8001472:	d1f3      	bne.n	800145c <CRYP_AES_CTR+0x126>
 8001474:	e001      	b.n	800147a <CRYP_AES_CTR+0x144>

    if (busystatus != RESET)
   {
       status = ERROR;
 8001476:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001478:	b978      	cbnz	r0, 800149a <CRYP_AES_CTR+0x164>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800147a:	f7ff fd05 	bl	8000e88 <CRYP_DataOut>
 800147e:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001480:	f7ff fd02 	bl	8000e88 <CRYP_DataOut>
 8001484:	6068      	str	r0, [r5, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001486:	f7ff fcff 	bl	8000e88 <CRYP_DataOut>
 800148a:	60a8      	str	r0, [r5, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800148c:	f7ff fcfc 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 8001490:	3510      	adds	r5, #16
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001492:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 8001496:	2701      	movs	r7, #1
 8001498:	e7ff      	b.n	800149a <CRYP_AES_CTR+0x164>
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800149a:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800149c:	1ba3      	subs	r3, r4, r6
 800149e:	4293      	cmp	r3, r2
 80014a0:	d201      	bcs.n	80014a6 <CRYP_AES_CTR+0x170>
 80014a2:	2f00      	cmp	r7, #0
 80014a4:	d1cb      	bne.n	800143e <CRYP_AES_CTR+0x108>
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
    }
  }
  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 80014a6:	2000      	movs	r0, #0
 80014a8:	f7ff fcdc 	bl	8000e64 <CRYP_Cmd>

  return status;
}
 80014ac:	4638      	mov	r0, r7
 80014ae:	b010      	add	sp, #64	; 0x40
 80014b0:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}

080014b4 <CRYP_DES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
                         uint32_t Ilength, uint8_t *Output)
{
 80014b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80014b8:	b08d      	sub	sp, #52	; 0x34
 80014ba:	4681      	mov	r9, r0
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 80014bc:	2600      	movs	r6, #0
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 80014be:	a804      	add	r0, sp, #16
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
                         uint32_t Ilength, uint8_t *Output)
{
 80014c0:	460c      	mov	r4, r1
 80014c2:	4617      	mov	r7, r2
 80014c4:	4698      	mov	r8, r3
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 80014c6:	9601      	str	r6, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 80014c8:	9d14      	ldr	r5, [sp, #80]	; 0x50
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 80014ca:	f7ff fca7 	bl	8000e1c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if( Mode == MODE_ENCRYPT ) /* DES encryption */
 80014ce:	f1b9 0f01 	cmp.w	r9, #1
 80014d2:	d102      	bne.n	80014da <CRYP_DES_ECB+0x26>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 80014d4:	f8ad 6008 	strh.w	r6, [sp, #8]
 80014d8:	e002      	b.n	80014e0 <CRYP_DES_ECB+0x2c>
  }
  else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
  {      
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 80014da:	2304      	movs	r3, #4
 80014dc:	f8ad 3008 	strh.w	r3, [sp, #8]
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
 80014e0:	2310      	movs	r3, #16
 80014e2:	f8ad 300a 	strh.w	r3, [sp, #10]
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&DES_CRYP_InitStructure);
 80014e6:	a802      	add	r0, sp, #8
  {      
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 80014e8:	2380      	movs	r3, #128	; 0x80
 80014ea:	f8ad 300c 	strh.w	r3, [sp, #12]
  CRYP_Init(&DES_CRYP_InitStructure);
 80014ee:	f7ff fc4c 	bl	8000d8a <CRYP_Init>
 80014f2:	6823      	ldr	r3, [r4, #0]
 80014f4:	ba1b      	rev	r3, r3

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80014f6:	9306      	str	r3, [sp, #24]
 80014f8:	6863      	ldr	r3, [r4, #4]
 80014fa:	ba1b      	rev	r3, r3
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 80014fc:	a804      	add	r0, sp, #16
  CRYP_Init(&DES_CRYP_InitStructure);

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80014fe:	9307      	str	r3, [sp, #28]
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8001500:	2400      	movs	r4, #0

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 8001502:	f7ff fc77 	bl	8000df4 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 8001506:	f7ff fca5 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800150a:	2001      	movs	r0, #1
 800150c:	f7ff fcaa 	bl	8000e64 <CRYP_Cmd>
{
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8001510:	2601      	movs	r6, #1
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;

/* Wait until the complete message has been processed */
    counter = 0;
 8001512:	46a1      	mov	r9, r4
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8001514:	e022      	b.n	800155c <CRYP_DES_ECB+0xa8>
  {

    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001516:	5938      	ldr	r0, [r7, r4]
 8001518:	f7ff fcb0 	bl	8000e7c <CRYP_DataIn>
  * @param  Output: pointer to the returned buffer.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
 800151c:	193b      	adds	r3, r7, r4
  {

    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800151e:	6858      	ldr	r0, [r3, #4]
 8001520:	f7ff fcac 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;

/* Wait until the complete message has been processed */
    counter = 0;
 8001524:	f8cd 9004 	str.w	r9, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001528:	2010      	movs	r0, #16
 800152a:	f7ff fd45 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 800152e:	9b01      	ldr	r3, [sp, #4]
 8001530:	3301      	adds	r3, #1
 8001532:	9301      	str	r3, [sp, #4]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800153a:	d002      	beq.n	8001542 <CRYP_DES_ECB+0x8e>
 800153c:	2800      	cmp	r0, #0
 800153e:	d1f3      	bne.n	8001528 <CRYP_DES_ECB+0x74>
 8001540:	e001      	b.n	8001546 <CRYP_DES_ECB+0x92>

    if (busystatus != RESET)
   {
       status = ERROR;
 8001542:	2600      	movs	r6, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001544:	b948      	cbnz	r0, 800155a <CRYP_DES_ECB+0xa6>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001546:	f7ff fc9f 	bl	8000e88 <CRYP_DataOut>
 800154a:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800154c:	f7ff fc9c 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 8001550:	3508      	adds	r5, #8
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001552:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 8001556:	2601      	movs	r6, #1
 8001558:	e7ff      	b.n	800155a <CRYP_DES_ECB+0xa6>
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800155a:	3408      	adds	r4, #8
 800155c:	4544      	cmp	r4, r8
 800155e:	d201      	bcs.n	8001564 <CRYP_DES_ECB+0xb0>
 8001560:	2e00      	cmp	r6, #0
 8001562:	d1d8      	bne.n	8001516 <CRYP_DES_ECB+0x62>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8001564:	2000      	movs	r0, #0
 8001566:	f7ff fc7d 	bl	8000e64 <CRYP_Cmd>

  return status; 
}
 800156a:	4630      	mov	r0, r6
 800156c:	b00d      	add	sp, #52	; 0x34
 800156e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08001572 <CRYP_DES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
                         uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 8001572:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
 8001576:	b091      	sub	sp, #68	; 0x44
 8001578:	4682      	mov	sl, r0
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800157a:	2700      	movs	r7, #0
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 800157c:	a808      	add	r0, sp, #32
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
                         uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 800157e:	460c      	mov	r4, r1
 8001580:	4616      	mov	r6, r2
 8001582:	4698      	mov	r8, r3
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001584:	9701      	str	r7, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 8001586:	9d19      	ldr	r5, [sp, #100]	; 0x64
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 8001588:	f7ff fc48 	bl	8000e1c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* DES encryption */
 800158c:	f1ba 0f01 	cmp.w	sl, #1
 8001590:	d102      	bne.n	8001598 <CRYP_DES_CBC+0x26>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 8001592:	f8ad 7008 	strh.w	r7, [sp, #8]
 8001596:	e002      	b.n	800159e <CRYP_DES_CBC+0x2c>
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 8001598:	2304      	movs	r3, #4
 800159a:	f8ad 3008 	strh.w	r3, [sp, #8]
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
 800159e:	2318      	movs	r3, #24
 80015a0:	f8ad 300a 	strh.w	r3, [sp, #10]
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&DES_CRYP_InitStructure);
 80015a4:	a802      	add	r0, sp, #8
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 80015a6:	2380      	movs	r3, #128	; 0x80
 80015a8:	f8ad 300c 	strh.w	r3, [sp, #12]
  CRYP_Init(&DES_CRYP_InitStructure);
 80015ac:	f7ff fbed 	bl	8000d8a <CRYP_Init>
 80015b0:	6823      	ldr	r3, [r4, #0]
 80015b2:	ba1b      	rev	r3, r3

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80015b4:	930a      	str	r3, [sp, #40]	; 0x28
 80015b6:	6863      	ldr	r3, [r4, #4]
 80015b8:	ba1b      	rev	r3, r3
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 80015ba:	a808      	add	r0, sp, #32
  CRYP_Init(&DES_CRYP_InitStructure);

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80015bc:	930b      	str	r3, [sp, #44]	; 0x2c
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 80015be:	f7ff fc19 	bl	8000df4 <CRYP_KeyInit>
 80015c2:	6833      	ldr	r3, [r6, #0]
 80015c4:	ba1b      	rev	r3, r3

  /* Initialization Vectors */
  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 80015c6:	9304      	str	r3, [sp, #16]
 80015c8:	6873      	ldr	r3, [r6, #4]
 80015ca:	ba1b      	rev	r3, r3
  ivaddr+=4;
  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
  CRYP_IVInit(&DES_CRYP_IVInitStructure);
 80015cc:	a804      	add	r0, sp, #16
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);

  /* Initialization Vectors */
  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 80015ce:	9305      	str	r3, [sp, #20]
  CRYP_FIFOFlush();
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80015d0:	2400      	movs	r4, #0

  /* Initialization Vectors */
  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
  CRYP_IVInit(&DES_CRYP_IVInitStructure);
 80015d2:	f7ff fc2d 	bl	8000e30 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 80015d6:	f7ff fc3d 	bl	8000e54 <CRYP_FIFOFlush>
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80015da:	2001      	movs	r0, #1
 80015dc:	f7ff fc42 	bl	8000e64 <CRYP_Cmd>
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 80015e0:	2601      	movs	r6, #1
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80015e2:	4627      	mov	r7, r4
  CRYP_FIFOFlush();
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80015e4:	e023      	b.n	800162e <CRYP_DES_CBC+0xbc>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015e6:	f858 0004 	ldr.w	r0, [r8, r4]
 80015ea:	f7ff fc47 	bl	8000e7c <CRYP_DataIn>
  * @param  Output: pointer to the returned buffer.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
 80015ee:	eb08 0304 	add.w	r3, r8, r4
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015f2:	6858      	ldr	r0, [r3, #4]
 80015f4:	f7ff fc42 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80015f8:	9701      	str	r7, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80015fa:	2010      	movs	r0, #16
 80015fc:	f7ff fcdc 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 8001600:	9b01      	ldr	r3, [sp, #4]
 8001602:	3301      	adds	r3, #1
 8001604:	9301      	str	r3, [sp, #4]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 8001606:	9b01      	ldr	r3, [sp, #4]
 8001608:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800160c:	d002      	beq.n	8001614 <CRYP_DES_CBC+0xa2>
 800160e:	2800      	cmp	r0, #0
 8001610:	d1f3      	bne.n	80015fa <CRYP_DES_CBC+0x88>
 8001612:	e001      	b.n	8001618 <CRYP_DES_CBC+0xa6>

    if (busystatus != RESET)
   {
       status = ERROR;
 8001614:	2600      	movs	r6, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001616:	b948      	cbnz	r0, 800162c <CRYP_DES_CBC+0xba>
       status = ERROR;
    }
    else
    {
      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001618:	f7ff fc36 	bl	8000e88 <CRYP_DataOut>
 800161c:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800161e:	f7ff fc33 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 8001622:	3508      	adds	r5, #8
    else
    {
      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001624:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 8001628:	2601      	movs	r6, #1
 800162a:	e7ff      	b.n	800162c <CRYP_DES_CBC+0xba>
  CRYP_FIFOFlush();
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800162c:	3408      	adds	r4, #8
 800162e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8001630:	429c      	cmp	r4, r3
 8001632:	d201      	bcs.n	8001638 <CRYP_DES_CBC+0xc6>
 8001634:	2e00      	cmp	r6, #0
 8001636:	d1d6      	bne.n	80015e6 <CRYP_DES_CBC+0x74>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8001638:	2000      	movs	r0, #0
 800163a:	f7ff fc13 	bl	8000e64 <CRYP_Cmd>

  return status; 
}
 800163e:	4630      	mov	r0, r6
 8001640:	b011      	add	sp, #68	; 0x44
 8001642:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}

08001646 <CRYP_TDES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
                          uint32_t Ilength, uint8_t *Output)
{
 8001646:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800164a:	b08d      	sub	sp, #52	; 0x34
 800164c:	4681      	mov	r9, r0
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 800164e:	2600      	movs	r6, #0
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 8001650:	a804      	add	r0, sp, #16
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
                          uint32_t Ilength, uint8_t *Output)
{
 8001652:	460c      	mov	r4, r1
 8001654:	4617      	mov	r7, r2
 8001656:	4698      	mov	r8, r3
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 8001658:	9601      	str	r6, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 800165a:	9d14      	ldr	r5, [sp, #80]	; 0x50
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 800165c:	f7ff fbde 	bl	8000e1c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 8001660:	f1b9 0f01 	cmp.w	r9, #1
 8001664:	d102      	bne.n	800166c <CRYP_TDES_ECB+0x26>
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8001666:	f8ad 6008 	strh.w	r6, [sp, #8]
 800166a:	e002      	b.n	8001672 <CRYP_TDES_ECB+0x2c>
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800166c:	2304      	movs	r3, #4
 800166e:	f8ad 3008 	strh.w	r3, [sp, #8]
  }

  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8001672:	2380      	movs	r3, #128	; 0x80
  CRYP_Init(&TDES_CRYP_InitStructure);
 8001674:	a802      	add	r0, sp, #8
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
  }

  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8001676:	f8ad 300c 	strh.w	r3, [sp, #12]
  else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
  }

  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 800167a:	f8ad 600a 	strh.w	r6, [sp, #10]
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
  CRYP_Init(&TDES_CRYP_InitStructure);
 800167e:	f7ff fb84 	bl	8000d8a <CRYP_Init>
 8001682:	6823      	ldr	r3, [r4, #0]
 8001684:	ba1b      	rev	r3, r3

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001686:	9306      	str	r3, [sp, #24]
 8001688:	6863      	ldr	r3, [r4, #4]
 800168a:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800168c:	9307      	str	r3, [sp, #28]
 800168e:	68a3      	ldr	r3, [r4, #8]
 8001690:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001692:	9308      	str	r3, [sp, #32]
 8001694:	68e3      	ldr	r3, [r4, #12]
 8001696:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001698:	9309      	str	r3, [sp, #36]	; 0x24
 800169a:	6923      	ldr	r3, [r4, #16]
 800169c:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800169e:	930a      	str	r3, [sp, #40]	; 0x28
 80016a0:	6963      	ldr	r3, [r4, #20]
 80016a2:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 80016a4:	a804      	add	r0, sp, #16
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80016a6:	930b      	str	r3, [sp, #44]	; 0x2c
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80016a8:	2400      	movs	r4, #0
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 80016aa:	f7ff fba3 	bl	8000df4 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 80016ae:	f7ff fbd1 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80016b2:	2001      	movs	r0, #1
 80016b4:	f7ff fbd6 	bl	8000e64 <CRYP_Cmd>
{
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 80016b8:	2601      	movs	r6, #1
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80016ba:	46a1      	mov	r9, r4
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80016bc:	e022      	b.n	8001704 <CRYP_TDES_ECB+0xbe>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80016be:	5938      	ldr	r0, [r7, r4]
 80016c0:	f7ff fbdc 	bl	8000e7c <CRYP_DataIn>
  * @param  Output: pointer to the returned buffer.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
 80016c4:	193b      	adds	r3, r7, r4
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80016c6:	6858      	ldr	r0, [r3, #4]
 80016c8:	f7ff fbd8 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80016cc:	f8cd 9004 	str.w	r9, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80016d0:	2010      	movs	r0, #16
 80016d2:	f7ff fc71 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 80016d6:	9b01      	ldr	r3, [sp, #4]
 80016d8:	3301      	adds	r3, #1
 80016da:	9301      	str	r3, [sp, #4]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80016e2:	d002      	beq.n	80016ea <CRYP_TDES_ECB+0xa4>
 80016e4:	2800      	cmp	r0, #0
 80016e6:	d1f3      	bne.n	80016d0 <CRYP_TDES_ECB+0x8a>
 80016e8:	e001      	b.n	80016ee <CRYP_TDES_ECB+0xa8>

    if (busystatus != RESET)
    {
       status = ERROR;
 80016ea:	2600      	movs	r6, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80016ec:	b948      	cbnz	r0, 8001702 <CRYP_TDES_ECB+0xbc>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80016ee:	f7ff fbcb 	bl	8000e88 <CRYP_DataOut>
 80016f2:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80016f4:	f7ff fbc8 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 80016f8:	3508      	adds	r5, #8
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80016fa:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 80016fe:	2601      	movs	r6, #1
 8001700:	e7ff      	b.n	8001702 <CRYP_TDES_ECB+0xbc>
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8001702:	3408      	adds	r4, #8
 8001704:	4544      	cmp	r4, r8
 8001706:	d201      	bcs.n	800170c <CRYP_TDES_ECB+0xc6>
 8001708:	2e00      	cmp	r6, #0
 800170a:	d1d8      	bne.n	80016be <CRYP_TDES_ECB+0x78>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800170c:	2000      	movs	r0, #0
 800170e:	f7ff fba9 	bl	8000e64 <CRYP_Cmd>

  return status; 
}
 8001712:	4630      	mov	r0, r6
 8001714:	b00d      	add	sp, #52	; 0x34
 8001716:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800171a <CRYP_TDES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 800171a:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
 800171e:	b091      	sub	sp, #68	; 0x44
 8001720:	4682      	mov	sl, r0
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001722:	2600      	movs	r6, #0
  uint32_t outputaddr = (uint32_t)Output;
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 8001724:	a808      	add	r0, sp, #32
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 8001726:	460c      	mov	r4, r1
 8001728:	4617      	mov	r7, r2
 800172a:	4698      	mov	r8, r3
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800172c:	9601      	str	r6, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;
 800172e:	9d19      	ldr	r5, [sp, #100]	; 0x64
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 8001730:	f7ff fb74 	bl	8000e1c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 8001734:	f1ba 0f01 	cmp.w	sl, #1
 8001738:	d102      	bne.n	8001740 <CRYP_TDES_CBC+0x26>
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800173a:	f8ad 6008 	strh.w	r6, [sp, #8]
 800173e:	e002      	b.n	8001746 <CRYP_TDES_CBC+0x2c>
  }
  else
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001740:	2304      	movs	r3, #4
 8001742:	f8ad 3008 	strh.w	r3, [sp, #8]
  }
  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
 8001746:	2308      	movs	r3, #8
 8001748:	f8ad 300a 	strh.w	r3, [sp, #10]
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;

  CRYP_Init(&TDES_CRYP_InitStructure);
 800174c:	a802      	add	r0, sp, #8
  else
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
  }
  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800174e:	2380      	movs	r3, #128	; 0x80
 8001750:	f8ad 300c 	strh.w	r3, [sp, #12]

  CRYP_Init(&TDES_CRYP_InitStructure);
 8001754:	f7ff fb19 	bl	8000d8a <CRYP_Init>
 8001758:	6823      	ldr	r3, [r4, #0]
 800175a:	ba1b      	rev	r3, r3

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800175c:	930a      	str	r3, [sp, #40]	; 0x28
 800175e:	6863      	ldr	r3, [r4, #4]
 8001760:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001762:	930b      	str	r3, [sp, #44]	; 0x2c
 8001764:	68a3      	ldr	r3, [r4, #8]
 8001766:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001768:	930c      	str	r3, [sp, #48]	; 0x30
 800176a:	68e3      	ldr	r3, [r4, #12]
 800176c:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800176e:	930d      	str	r3, [sp, #52]	; 0x34
 8001770:	6923      	ldr	r3, [r4, #16]
 8001772:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001774:	930e      	str	r3, [sp, #56]	; 0x38
 8001776:	6963      	ldr	r3, [r4, #20]
 8001778:	ba1b      	rev	r3, r3
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 800177a:	a808      	add	r0, sp, #32
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800177c:	930f      	str	r3, [sp, #60]	; 0x3c
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 800177e:	f7ff fb39 	bl	8000df4 <CRYP_KeyInit>
 8001782:	683b      	ldr	r3, [r7, #0]
 8001784:	ba1b      	rev	r3, r3

  /* Initialization Vectors */
  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 8001786:	9304      	str	r3, [sp, #16]
 8001788:	687b      	ldr	r3, [r7, #4]
 800178a:	ba1b      	rev	r3, r3
  ivaddr+=4;
  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
  CRYP_IVInit(&TDES_CRYP_IVInitStructure);
 800178c:	a804      	add	r0, sp, #16
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);

  /* Initialization Vectors */
  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 800178e:	9305      	str	r3, [sp, #20]
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8001790:	2400      	movs	r4, #0

  /* Initialization Vectors */
  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
  ivaddr+=4;
  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
  CRYP_IVInit(&TDES_CRYP_IVInitStructure);
 8001792:	f7ff fb4d 	bl	8000e30 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 8001796:	f7ff fb5d 	bl	8000e54 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 800179a:	2001      	movs	r0, #1
 800179c:	f7ff fb62 	bl	8000e64 <CRYP_Cmd>
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 80017a0:	2701      	movs	r7, #1
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80017a2:	4626      	mov	r6, r4
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80017a4:	e023      	b.n	80017ee <CRYP_TDES_CBC+0xd4>
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80017a6:	f858 0004 	ldr.w	r0, [r8, r4]
 80017aa:	f7ff fb67 	bl	8000e7c <CRYP_DataIn>
  * @param  Output: pointer to the returned buffer.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
 80017ae:	eb08 0304 	add.w	r3, r8, r4
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
  {
    /* Write the Input block in the Input FIFO */
    CRYP_DataIn(*(uint32_t*)(inputaddr));
    inputaddr+=4;
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80017b2:	6858      	ldr	r0, [r3, #4]
 80017b4:	f7ff fb62 	bl	8000e7c <CRYP_DataIn>
    inputaddr+=4;

    /* Wait until the complete message has been processed */
    counter = 0;
 80017b8:	9601      	str	r6, [sp, #4]
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80017ba:	2010      	movs	r0, #16
 80017bc:	f7ff fbfc 	bl	8000fb8 <CRYP_GetFlagStatus>
      counter++;
 80017c0:	9b01      	ldr	r3, [sp, #4]
 80017c2:	3301      	adds	r3, #1
 80017c4:	9301      	str	r3, [sp, #4]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 80017c6:	9b01      	ldr	r3, [sp, #4]
 80017c8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80017cc:	d002      	beq.n	80017d4 <CRYP_TDES_CBC+0xba>
 80017ce:	2800      	cmp	r0, #0
 80017d0:	d1f3      	bne.n	80017ba <CRYP_TDES_CBC+0xa0>
 80017d2:	e001      	b.n	80017d8 <CRYP_TDES_CBC+0xbe>

    if (busystatus != RESET)
   {
       status = ERROR;
 80017d4:	2700      	movs	r7, #0
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80017d6:	b948      	cbnz	r0, 80017ec <CRYP_TDES_CBC+0xd2>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80017d8:	f7ff fb56 	bl	8000e88 <CRYP_DataOut>
 80017dc:	6028      	str	r0, [r5, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80017de:	f7ff fb53 	bl	8000e88 <CRYP_DataOut>
      outputaddr+=4;
 80017e2:	3508      	adds	r5, #8
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80017e4:	f845 0c04 	str.w	r0, [r5, #-4]
      outputaddr+=4;
 80017e8:	2701      	movs	r7, #1
 80017ea:	e7ff      	b.n	80017ec <CRYP_TDES_CBC+0xd2>
  CRYP_FIFOFlush();

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);

  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80017ec:	3408      	adds	r4, #8
 80017ee:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80017f0:	429c      	cmp	r4, r3
 80017f2:	d201      	bcs.n	80017f8 <CRYP_TDES_CBC+0xde>
 80017f4:	2f00      	cmp	r7, #0
 80017f6:	d1d6      	bne.n	80017a6 <CRYP_TDES_CBC+0x8c>
      outputaddr+=4;
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 80017f8:	2000      	movs	r0, #0
 80017fa:	f7ff fb33 	bl	8000e64 <CRYP_Cmd>

  return status; 
}
 80017fe:	4638      	mov	r0, r7
 8001800:	b011      	add	sp, #68	; 0x44
 8001802:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
	...

08001808 <DAC_DeInit>:
  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void DAC_DeInit(void)
{
 8001808:	b508      	push	{r3, lr}
  /* Enable DAC reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
 800180a:	2101      	movs	r1, #1
 800180c:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8001810:	f001 ffd8 	bl	80037c4 <RCC_APB1PeriphResetCmd>
  /* Release DAC from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
 8001814:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8001818:	2100      	movs	r1, #0
}
 800181a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void DAC_DeInit(void)
{
  /* Enable DAC reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
  /* Release DAC from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
 800181e:	f001 bfd1 	b.w	80037c4 <RCC_APB1PeriphResetCmd>

08001822 <DAC_Init>:
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));

/*---------------------------- DAC CR Configuration --------------------------*/
  /* Get the DAC CR value */
  tmpreg1 = DAC->CR;
 8001822:	4b0a      	ldr	r3, [pc, #40]	; (800184c <DAC_Init+0x2a>)
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
  *         the configuration information for the  specified DAC channel.
  * @retval None
  */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
{
 8001824:	b530      	push	{r4, r5, lr}
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));

/*---------------------------- DAC CR Configuration --------------------------*/
  /* Get the DAC CR value */
  tmpreg1 = DAC->CR;
 8001826:	681a      	ldr	r2, [r3, #0]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
 8001828:	f640 75fe 	movw	r5, #4094	; 0xffe
 800182c:	fa05 f500 	lsl.w	r5, r5, r0
 8001830:	ea22 0505 	bic.w	r5, r2, r5
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 8001834:	e891 0014 	ldmia.w	r1, {r2, r4}
 8001838:	4314      	orrs	r4, r2
 800183a:	688a      	ldr	r2, [r1, #8]
 800183c:	68c9      	ldr	r1, [r1, #12]
 800183e:	4322      	orrs	r2, r4
 8001840:	430a      	orrs	r2, r1
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
             DAC_InitStruct->DAC_OutputBuffer);
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << DAC_Channel;
 8001842:	fa02 f000 	lsl.w	r0, r2, r0
 8001846:	4328      	orrs	r0, r5
  /* Write to DAC CR */
  DAC->CR = tmpreg1;
 8001848:	6018      	str	r0, [r3, #0]
 800184a:	bd30      	pop	{r4, r5, pc}
 800184c:	40007400 	.word	0x40007400

08001850 <DAC_StructInit>:
  */
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
{
/*--------------- Reset DAC init structure parameters values -----------------*/
  /* Initialize the DAC_Trigger member */
  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
 8001850:	2300      	movs	r3, #0
 8001852:	6003      	str	r3, [r0, #0]
  /* Initialize the DAC_WaveGeneration member */
  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
 8001854:	6043      	str	r3, [r0, #4]
  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
 8001856:	6083      	str	r3, [r0, #8]
  /* Initialize the DAC_OutputBuffer member */
  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 8001858:	60c3      	str	r3, [r0, #12]
 800185a:	4770      	bx	lr

0800185c <DAC_Cmd>:
  *          This parameter can be: ENABLE or DISABLE.
  * @note   When the DAC channel is enabled the trigger source can no more be modified.
  * @retval None
  */
void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 800185c:	4b07      	ldr	r3, [pc, #28]	; (800187c <DAC_Cmd+0x20>)
 800185e:	2201      	movs	r2, #1
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001860:	b121      	cbz	r1, 800186c <DAC_Cmd+0x10>
  {
    /* Enable the selected DAC channel */
    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
 8001862:	6819      	ldr	r1, [r3, #0]
 8001864:	fa02 f200 	lsl.w	r2, r2, r0
 8001868:	430a      	orrs	r2, r1
 800186a:	e004      	b.n	8001876 <DAC_Cmd+0x1a>
  }
  else
  {
    /* Disable the selected DAC channel */
    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
 800186c:	6819      	ldr	r1, [r3, #0]
 800186e:	fa02 f200 	lsl.w	r2, r2, r0
 8001872:	ea21 0202 	bic.w	r2, r1, r2
 8001876:	601a      	str	r2, [r3, #0]
 8001878:	4770      	bx	lr
 800187a:	bf00      	nop
 800187c:	40007400 	.word	0x40007400

08001880 <DAC_SoftwareTriggerCmd>:
  * @param  NewState: new state of the selected DAC channel software trigger.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 8001880:	4b07      	ldr	r3, [pc, #28]	; (80018a0 <DAC_SoftwareTriggerCmd+0x20>)
 8001882:	0900      	lsrs	r0, r0, #4
 8001884:	2201      	movs	r2, #1
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001886:	b121      	cbz	r1, 8001892 <DAC_SoftwareTriggerCmd+0x12>
  {
    /* Enable software trigger for the selected DAC channel */
    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
 8001888:	6859      	ldr	r1, [r3, #4]
 800188a:	fa02 f200 	lsl.w	r2, r2, r0
 800188e:	430a      	orrs	r2, r1
 8001890:	e004      	b.n	800189c <DAC_SoftwareTriggerCmd+0x1c>
  }
  else
  {
    /* Disable software trigger for the selected DAC channel */
    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
 8001892:	6859      	ldr	r1, [r3, #4]
 8001894:	fa02 f200 	lsl.w	r2, r2, r0
 8001898:	ea21 0202 	bic.w	r2, r1, r2
 800189c:	605a      	str	r2, [r3, #4]
 800189e:	4770      	bx	lr
 80018a0:	40007400 	.word	0x40007400

080018a4 <DAC_DualSoftwareTriggerCmd>:
  * @param  NewState: new state of the DAC channels software triggers.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
 80018a4:	4b04      	ldr	r3, [pc, #16]	; (80018b8 <DAC_DualSoftwareTriggerCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable software trigger for both DAC channels */
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 80018a6:	685a      	ldr	r2, [r3, #4]
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80018a8:	b110      	cbz	r0, 80018b0 <DAC_DualSoftwareTriggerCmd+0xc>
  {
    /* Enable software trigger for both DAC channels */
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 80018aa:	f042 0203 	orr.w	r2, r2, #3
 80018ae:	e001      	b.n	80018b4 <DAC_DualSoftwareTriggerCmd+0x10>
  }
  else
  {
    /* Disable software trigger for both DAC channels */
    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
 80018b0:	f022 0203 	bic.w	r2, r2, #3
 80018b4:	605a      	str	r2, [r3, #4]
 80018b6:	4770      	bx	lr
 80018b8:	40007400 	.word	0x40007400

080018bc <DAC_WaveGenerationCmd>:
  * @param  NewState: new state of the selected DAC channel wave generation.
  *          This parameter can be: ENABLE or DISABLE.  
  * @retval None
  */
void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
{
 80018bc:	4b05      	ldr	r3, [pc, #20]	; (80018d4 <DAC_WaveGenerationCmd+0x18>)
 80018be:	fa01 f100 	lsl.w	r1, r1, r0
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_WAVE(DAC_Wave)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80018c2:	b112      	cbz	r2, 80018ca <DAC_WaveGenerationCmd+0xe>
  {
    /* Enable the selected wave generation for the selected DAC channel */
    DAC->CR |= DAC_Wave << DAC_Channel;
 80018c4:	681a      	ldr	r2, [r3, #0]
 80018c6:	4311      	orrs	r1, r2
 80018c8:	e002      	b.n	80018d0 <DAC_WaveGenerationCmd+0x14>
  }
  else
  {
    /* Disable the selected wave generation for the selected DAC channel */
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
 80018ca:	681a      	ldr	r2, [r3, #0]
 80018cc:	ea22 0101 	bic.w	r1, r2, r1
 80018d0:	6019      	str	r1, [r3, #0]
 80018d2:	4770      	bx	lr
 80018d4:	40007400 	.word	0x40007400

080018d8 <DAC_SetChannel1Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
{  
 80018d8:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80018da:	2300      	movs	r3, #0
 80018dc:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE; 
 80018de:	4b05      	ldr	r3, [pc, #20]	; (80018f4 <DAC_SetChannel1Data+0x1c>)
 80018e0:	9301      	str	r3, [sp, #4]
  tmp += DHR12R1_OFFSET + DAC_Align;
 80018e2:	9b01      	ldr	r3, [sp, #4]
 80018e4:	3308      	adds	r3, #8
 80018e6:	1818      	adds	r0, r3, r0
 80018e8:	9001      	str	r0, [sp, #4]

  /* Set the DAC channel1 selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 80018ea:	9b01      	ldr	r3, [sp, #4]
 80018ec:	6019      	str	r1, [r3, #0]
}
 80018ee:	b002      	add	sp, #8
 80018f0:	4770      	bx	lr
 80018f2:	bf00      	nop
 80018f4:	40007400 	.word	0x40007400

080018f8 <DAC_SetChannel2Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
{
 80018f8:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80018fa:	2300      	movs	r3, #0
 80018fc:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE;
 80018fe:	4b05      	ldr	r3, [pc, #20]	; (8001914 <DAC_SetChannel2Data+0x1c>)
 8001900:	9301      	str	r3, [sp, #4]
  tmp += DHR12R2_OFFSET + DAC_Align;
 8001902:	9b01      	ldr	r3, [sp, #4]
 8001904:	3314      	adds	r3, #20
 8001906:	1818      	adds	r0, r3, r0
 8001908:	9001      	str	r0, [sp, #4]

  /* Set the DAC channel2 selected data holding register */
  *(__IO uint32_t *)tmp = Data;
 800190a:	9b01      	ldr	r3, [sp, #4]
 800190c:	6019      	str	r1, [r3, #0]
}
 800190e:	b002      	add	sp, #8
 8001910:	4770      	bx	lr
 8001912:	bf00      	nop
 8001914:	40007400 	.word	0x40007400

08001918 <DAC_SetDualChannelData>:
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (DAC_Align == DAC_Align_8b_R)
 8001918:	2808      	cmp	r0, #8
  {
    data = ((uint32_t)Data2 << 16) | Data1;
  }
  
  tmp = (uint32_t)DAC_BASE;
  tmp += DHR12RD_OFFSET + DAC_Align;
 800191a:	4b04      	ldr	r3, [pc, #16]	; (800192c <DAC_SetDualChannelData+0x14>)
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (DAC_Align == DAC_Align_8b_R)
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
 800191c:	bf0c      	ite	eq
 800191e:	ea42 2101 	orreq.w	r1, r2, r1, lsl #8
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
 8001922:	ea42 4101 	orrne.w	r1, r2, r1, lsl #16
  
  tmp = (uint32_t)DAC_BASE;
  tmp += DHR12RD_OFFSET + DAC_Align;

  /* Set the dual DAC selected data holding register */
  *(__IO uint32_t *)tmp = data;
 8001926:	50c1      	str	r1, [r0, r3]
 8001928:	4770      	bx	lr
 800192a:	bf00      	nop
 800192c:	40007420 	.word	0x40007420

08001930 <DAC_GetDataOutputValue>:
  *            @arg DAC_Channel_1: DAC Channel1 selected
  *            @arg DAC_Channel_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
{
 8001930:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8001932:	2300      	movs	r3, #0
 8001934:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  
  tmp = (uint32_t) DAC_BASE ;
 8001936:	4b06      	ldr	r3, [pc, #24]	; (8001950 <DAC_GetDataOutputValue+0x20>)
 8001938:	9301      	str	r3, [sp, #4]
  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
 800193a:	9b01      	ldr	r3, [sp, #4]
 800193c:	332c      	adds	r3, #44	; 0x2c
 800193e:	eb03 0090 	add.w	r0, r3, r0, lsr #2
 8001942:	9001      	str	r0, [sp, #4]
  
  /* Returns the DAC channel data output register value */
  return (uint16_t) (*(__IO uint32_t*) tmp);
 8001944:	9b01      	ldr	r3, [sp, #4]
 8001946:	6818      	ldr	r0, [r3, #0]
}
 8001948:	b280      	uxth	r0, r0
 800194a:	b002      	add	sp, #8
 800194c:	4770      	bx	lr
 800194e:	bf00      	nop
 8001950:	40007400 	.word	0x40007400

08001954 <DAC_DMACmd>:
  * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
  *          already configured.    
  * @retval None
  */
void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
{
 8001954:	4b07      	ldr	r3, [pc, #28]	; (8001974 <DAC_DMACmd+0x20>)
 8001956:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800195a:	b121      	cbz	r1, 8001966 <DAC_DMACmd+0x12>
  {
    /* Enable the selected DAC channel DMA request */
    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
 800195c:	6819      	ldr	r1, [r3, #0]
 800195e:	fa02 f200 	lsl.w	r2, r2, r0
 8001962:	430a      	orrs	r2, r1
 8001964:	e004      	b.n	8001970 <DAC_DMACmd+0x1c>
  }
  else
  {
    /* Disable the selected DAC channel DMA request */
    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
 8001966:	6819      	ldr	r1, [r3, #0]
 8001968:	fa02 f200 	lsl.w	r2, r2, r0
 800196c:	ea21 0202 	bic.w	r2, r1, r2
 8001970:	601a      	str	r2, [r3, #0]
 8001972:	4770      	bx	lr
 8001974:	40007400 	.word	0x40007400

08001978 <DAC_ITConfig>:
  * @param  NewState: new state of the specified DAC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */ 
void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
{
 8001978:	4b05      	ldr	r3, [pc, #20]	; (8001990 <DAC_ITConfig+0x18>)
 800197a:	fa01 f100 	lsl.w	r1, r1, r0
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_DAC_IT(DAC_IT)); 

  if (NewState != DISABLE)
 800197e:	b112      	cbz	r2, 8001986 <DAC_ITConfig+0xe>
  {
    /* Enable the selected DAC interrupts */
    DAC->CR |=  (DAC_IT << DAC_Channel);
 8001980:	681a      	ldr	r2, [r3, #0]
 8001982:	4311      	orrs	r1, r2
 8001984:	e002      	b.n	800198c <DAC_ITConfig+0x14>
  }
  else
  {
    /* Disable the selected DAC interrupts */
    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
 8001986:	681a      	ldr	r2, [r3, #0]
 8001988:	ea22 0101 	bic.w	r1, r2, r1
 800198c:	6019      	str	r1, [r3, #0]
 800198e:	4770      	bx	lr
 8001990:	40007400 	.word	0x40007400

08001994 <DAC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Check the status of the specified DAC flag */
  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
 8001994:	4b04      	ldr	r3, [pc, #16]	; (80019a8 <DAC_GetFlagStatus+0x14>)
 8001996:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001998:	fa01 f100 	lsl.w	r1, r1, r0
 800199c:	4219      	tst	r1, r3
    /* DAC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the DAC_FLAG status */
  return  bitstatus;
}
 800199e:	bf0c      	ite	eq
 80019a0:	2000      	moveq	r0, #0
 80019a2:	2001      	movne	r0, #1
 80019a4:	4770      	bx	lr
 80019a6:	bf00      	nop
 80019a8:	40007400 	.word	0x40007400

080019ac <DAC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Clear the selected DAC flags */
  DAC->SR = (DAC_FLAG << DAC_Channel);
 80019ac:	4b02      	ldr	r3, [pc, #8]	; (80019b8 <DAC_ClearFlag+0xc>)
 80019ae:	fa01 f100 	lsl.w	r1, r1, r0
 80019b2:	6359      	str	r1, [r3, #52]	; 0x34
 80019b4:	4770      	bx	lr
 80019b6:	bf00      	nop
 80019b8:	40007400 	.word	0x40007400

080019bc <DAC_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT));

  /* Get the DAC_IT enable bit status */
  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
 80019bc:	4b05      	ldr	r3, [pc, #20]	; (80019d4 <DAC_GetITStatus+0x18>)
 80019be:	fa01 f100 	lsl.w	r1, r1, r0
 80019c2:	681a      	ldr	r2, [r3, #0]
  
  /* Check the status of the specified DAC interrupt */
  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
 80019c4:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80019c6:	4008      	ands	r0, r1
 80019c8:	d003      	beq.n	80019d2 <DAC_GetITStatus+0x16>
 80019ca:	4211      	tst	r1, r2
  {
    /* DAC_IT is set */
    bitstatus = SET;
 80019cc:	bf0c      	ite	eq
 80019ce:	2000      	moveq	r0, #0
 80019d0:	2001      	movne	r0, #1
    /* DAC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DAC_IT status */
  return  bitstatus;
}
 80019d2:	4770      	bx	lr
 80019d4:	40007400 	.word	0x40007400

080019d8 <DAC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT)); 

  /* Clear the selected DAC interrupt pending bits */
  DAC->SR = (DAC_IT << DAC_Channel);
 80019d8:	4b02      	ldr	r3, [pc, #8]	; (80019e4 <DAC_ClearITPendingBit+0xc>)
 80019da:	fa01 f100 	lsl.w	r1, r1, r0
 80019de:	6359      	str	r1, [r3, #52]	; 0x34
 80019e0:	4770      	bx	lr
 80019e2:	bf00      	nop
 80019e4:	40007400 	.word	0x40007400

080019e8 <DBGMCU_GetREVID>:
  * @param  None
  * @retval Device revision identifier
  */
uint32_t DBGMCU_GetREVID(void)
{
   return(DBGMCU->IDCODE >> 16);
 80019e8:	4b01      	ldr	r3, [pc, #4]	; (80019f0 <DBGMCU_GetREVID+0x8>)
 80019ea:	6818      	ldr	r0, [r3, #0]
}
 80019ec:	0c00      	lsrs	r0, r0, #16
 80019ee:	4770      	bx	lr
 80019f0:	e0042000 	.word	0xe0042000

080019f4 <DBGMCU_GetDEVID>:
  * @param  None
  * @retval Device identifier
  */
uint32_t DBGMCU_GetDEVID(void)
{
   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
 80019f4:	4b02      	ldr	r3, [pc, #8]	; (8001a00 <DBGMCU_GetDEVID+0xc>)
 80019f6:	6818      	ldr	r0, [r3, #0]
 80019f8:	0500      	lsls	r0, r0, #20
}
 80019fa:	0d00      	lsrs	r0, r0, #20
 80019fc:	4770      	bx	lr
 80019fe:	bf00      	nop
 8001a00:	e0042000 	.word	0xe0042000

08001a04 <DBGMCU_Config>:
  * @param  NewState: new state of the specified low power mode in Debug mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 8001a04:	4b04      	ldr	r3, [pc, #16]	; (8001a18 <DBGMCU_Config+0x14>)
  /* Check the parameters */
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    DBGMCU->CR |= DBGMCU_Periph;
 8001a06:	685a      	ldr	r2, [r3, #4]
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001a08:	b109      	cbz	r1, 8001a0e <DBGMCU_Config+0xa>
  {
    DBGMCU->CR |= DBGMCU_Periph;
 8001a0a:	4310      	orrs	r0, r2
 8001a0c:	e001      	b.n	8001a12 <DBGMCU_Config+0xe>
  }
  else
  {
    DBGMCU->CR &= ~DBGMCU_Periph;
 8001a0e:	ea22 0000 	bic.w	r0, r2, r0
 8001a12:	6058      	str	r0, [r3, #4]
 8001a14:	4770      	bx	lr
 8001a16:	bf00      	nop
 8001a18:	e0042000 	.word	0xe0042000

08001a1c <DBGMCU_APB1PeriphConfig>:
  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted        
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 8001a1c:	4b04      	ldr	r3, [pc, #16]	; (8001a30 <DBGMCU_APB1PeriphConfig+0x14>)
  assert_param(IS_DBGMCU_APB1PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    DBGMCU->APB1FZ |= DBGMCU_Periph;
 8001a1e:	689a      	ldr	r2, [r3, #8]
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB1PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001a20:	b109      	cbz	r1, 8001a26 <DBGMCU_APB1PeriphConfig+0xa>
  {
    DBGMCU->APB1FZ |= DBGMCU_Periph;
 8001a22:	4310      	orrs	r0, r2
 8001a24:	e001      	b.n	8001a2a <DBGMCU_APB1PeriphConfig+0xe>
  }
  else
  {
    DBGMCU->APB1FZ &= ~DBGMCU_Periph;
 8001a26:	ea22 0000 	bic.w	r0, r2, r0
 8001a2a:	6098      	str	r0, [r3, #8]
 8001a2c:	4770      	bx	lr
 8001a2e:	bf00      	nop
 8001a30:	e0042000 	.word	0xe0042000

08001a34 <DBGMCU_APB2PeriphConfig>:
  * @param  NewState: new state of the specified peripheral in Debug mode.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
 8001a34:	4b04      	ldr	r3, [pc, #16]	; (8001a48 <DBGMCU_APB2PeriphConfig+0x14>)
  assert_param(IS_DBGMCU_APB2PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    DBGMCU->APB2FZ |= DBGMCU_Periph;
 8001a36:	68da      	ldr	r2, [r3, #12]
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB2PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001a38:	b109      	cbz	r1, 8001a3e <DBGMCU_APB2PeriphConfig+0xa>
  {
    DBGMCU->APB2FZ |= DBGMCU_Periph;
 8001a3a:	4310      	orrs	r0, r2
 8001a3c:	e001      	b.n	8001a42 <DBGMCU_APB2PeriphConfig+0xe>
  }
  else
  {
    DBGMCU->APB2FZ &= ~DBGMCU_Periph;
 8001a3e:	ea22 0000 	bic.w	r0, r2, r0
 8001a42:	60d8      	str	r0, [r3, #12]
 8001a44:	4770      	bx	lr
 8001a46:	bf00      	nop
 8001a48:	e0042000 	.word	0xe0042000

08001a4c <DCMI_DeInit>:
  * @param  None
  * @retval None
  */
void DCMI_DeInit(void)
{
  DCMI->CR = 0x0;
 8001a4c:	4b05      	ldr	r3, [pc, #20]	; (8001a64 <DCMI_DeInit+0x18>)
 8001a4e:	2200      	movs	r2, #0
  DCMI->IER = 0x0;
  DCMI->ICR = 0x1F;
 8001a50:	211f      	movs	r1, #31
  * @param  None
  * @retval None
  */
void DCMI_DeInit(void)
{
  DCMI->CR = 0x0;
 8001a52:	601a      	str	r2, [r3, #0]
  DCMI->IER = 0x0;
 8001a54:	60da      	str	r2, [r3, #12]
  DCMI->ICR = 0x1F;
 8001a56:	6159      	str	r1, [r3, #20]
  DCMI->ESCR = 0x0;
 8001a58:	619a      	str	r2, [r3, #24]
  DCMI->ESUR = 0x0;
 8001a5a:	61da      	str	r2, [r3, #28]
  DCMI->CWSTRTR = 0x0;
 8001a5c:	621a      	str	r2, [r3, #32]
  DCMI->CWSIZER = 0x0;
 8001a5e:	625a      	str	r2, [r3, #36]	; 0x24
 8001a60:	4770      	bx	lr
 8001a62:	bf00      	nop
 8001a64:	50050000 	.word	0x50050000

08001a68 <DCMI_Init>:
  assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
  assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));

  /* The DCMI configuration registers should be programmed correctly before 
  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 8001a68:	4b0e      	ldr	r3, [pc, #56]	; (8001aa4 <DCMI_Init+0x3c>)
 8001a6a:	681a      	ldr	r2, [r3, #0]
 8001a6c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001a70:	f022 0201 	bic.w	r2, r2, #1
  * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
  *         the configuration information for the DCMI.
  * @retval None
  */
void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
{
 8001a74:	b510      	push	{r4, lr}
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
                     DCMI_InitStruct->DCMI_SynchroMode |
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 8001a76:	8844      	ldrh	r4, [r0, #2]
  assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
  assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));

  /* The DCMI configuration registers should be programmed correctly before 
  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 8001a78:	601a      	str	r2, [r3, #0]
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
                     DCMI_InitStruct->DCMI_SynchroMode |
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 8001a7a:	8802      	ldrh	r2, [r0, #0]
  /* The DCMI configuration registers should be programmed correctly before 
  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
   
  /* Reset the old DCMI configuration */
  temp = DCMI->CR;
 8001a7c:	6819      	ldr	r1, [r3, #0]
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
                     DCMI_InitStruct->DCMI_SynchroMode |
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 8001a7e:	4322      	orrs	r2, r4
 8001a80:	8884      	ldrh	r4, [r0, #4]
 8001a82:	4322      	orrs	r2, r4
 8001a84:	88c4      	ldrh	r4, [r0, #6]
 8001a86:	4322      	orrs	r2, r4
 8001a88:	8904      	ldrh	r4, [r0, #8]
 8001a8a:	4322      	orrs	r2, r4
 8001a8c:	8944      	ldrh	r4, [r0, #10]
 8001a8e:	8980      	ldrh	r0, [r0, #12]
 8001a90:	4322      	orrs	r2, r4
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
   
  /* Reset the old DCMI configuration */
  temp = DCMI->CR;
  
  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
 8001a92:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
                     DCMI_InitStruct->DCMI_SynchroMode |
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 8001a96:	4302      	orrs	r2, r0
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
   
  /* Reset the old DCMI configuration */
  temp = DCMI->CR;
  
  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
 8001a98:	f021 0102 	bic.w	r1, r1, #2
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
                     DCMI_InitStruct->DCMI_SynchroMode |
                     DCMI_InitStruct->DCMI_PCKPolarity |
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
 8001a9c:	b292      	uxth	r2, r2
  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
                      DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
                      DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
                  
  /* Sets the new configuration of the DCMI peripheral */
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
 8001a9e:	430a      	orrs	r2, r1
                     DCMI_InitStruct->DCMI_VSPolarity |
                     DCMI_InitStruct->DCMI_HSPolarity |
                     DCMI_InitStruct->DCMI_CaptureRate |
                     DCMI_InitStruct->DCMI_ExtendedDataMode);

  DCMI->CR = temp;                              
 8001aa0:	601a      	str	r2, [r3, #0]
 8001aa2:	bd10      	pop	{r4, pc}
 8001aa4:	50050000 	.word	0x50050000

08001aa8 <DCMI_StructInit>:
  * @retval None
  */
void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
{
  /* Set the default configuration */
  DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
 8001aa8:	2300      	movs	r3, #0
 8001aaa:	8003      	strh	r3, [r0, #0]
  DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
 8001aac:	8043      	strh	r3, [r0, #2]
  DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
 8001aae:	8083      	strh	r3, [r0, #4]
  DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
 8001ab0:	80c3      	strh	r3, [r0, #6]
  DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
 8001ab2:	8103      	strh	r3, [r0, #8]
  DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
 8001ab4:	8143      	strh	r3, [r0, #10]
  DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
 8001ab6:	8183      	strh	r3, [r0, #12]
 8001ab8:	4770      	bx	lr

08001aba <DCMI_CROPConfig>:
  * @retval None
  */
void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
{  
  /* Sets the CROP window coordinates */
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 8001aba:	8843      	ldrh	r3, [r0, #2]
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
 8001abc:	8802      	ldrh	r2, [r0, #0]

  /* Sets the CROP window size */
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
 8001abe:	8881      	ldrh	r1, [r0, #4]
  * @retval None
  */
void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
{  
  /* Sets the CROP window coordinates */
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 8001ac0:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 8001ac4:	4b03      	ldr	r3, [pc, #12]	; (8001ad4 <DCMI_CROPConfig+0x1a>)
 8001ac6:	621a      	str	r2, [r3, #32]
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));

  /* Sets the CROP window size */
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
 8001ac8:	88c2      	ldrh	r2, [r0, #6]
 8001aca:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8001ace:	625a      	str	r2, [r3, #36]	; 0x24
 8001ad0:	4770      	bx	lr
 8001ad2:	bf00      	nop
 8001ad4:	50050000 	.word	0x50050000

08001ad8 <DCMI_CROPCmd>:
  * @param  NewState: new state of the DCMI Crop feature. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_CROPCmd(FunctionalState NewState)
{
 8001ad8:	4b04      	ldr	r3, [pc, #16]	; (8001aec <DCMI_CROPCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the DCMI Crop feature */
    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
 8001ada:	681a      	ldr	r2, [r3, #0]
void DCMI_CROPCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8001adc:	b110      	cbz	r0, 8001ae4 <DCMI_CROPCmd+0xc>
  {
    /* Enable the DCMI Crop feature */
    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
 8001ade:	f042 0204 	orr.w	r2, r2, #4
 8001ae2:	e001      	b.n	8001ae8 <DCMI_CROPCmd+0x10>
  }
  else
  {
    /* Disable the DCMI Crop feature */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
 8001ae4:	f022 0204 	bic.w	r2, r2, #4
 8001ae8:	601a      	str	r2, [r3, #0]
 8001aea:	4770      	bx	lr
 8001aec:	50050000 	.word	0x50050000

08001af0 <DCMI_SetEmbeddedSynchroCodes>:
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
 8001af0:	7882      	ldrb	r2, [r0, #2]
  * @retval None
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 8001af2:	7843      	ldrb	r3, [r0, #1]
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
 8001af4:	0412      	lsls	r2, r2, #16
  *         contains the embedded synchronization codes for the DCMI peripheral.
  * @retval None
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 8001af6:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8001afa:	7803      	ldrb	r3, [r0, #0]
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 8001afc:	431a      	orrs	r2, r3
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
 8001afe:	78c3      	ldrb	r3, [r0, #3]
  *         contains the embedded synchronization codes for the DCMI peripheral.
  * @retval None
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 8001b00:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8001b04:	4b01      	ldr	r3, [pc, #4]	; (8001b0c <DCMI_SetEmbeddedSynchroCodes+0x1c>)
 8001b06:	619a      	str	r2, [r3, #24]
 8001b08:	4770      	bx	lr
 8001b0a:	bf00      	nop
 8001b0c:	50050000 	.word	0x50050000

08001b10 <DCMI_JPEGCmd>:
  * @param  NewState: new state of the DCMI JPEG format. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_JPEGCmd(FunctionalState NewState)
{
 8001b10:	4b04      	ldr	r3, [pc, #16]	; (8001b24 <DCMI_JPEGCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 
  if (NewState != DISABLE)
  {
    /* Enable the DCMI JPEG format */
    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
 8001b12:	681a      	ldr	r2, [r3, #0]
void DCMI_JPEGCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 
  if (NewState != DISABLE)
 8001b14:	b110      	cbz	r0, 8001b1c <DCMI_JPEGCmd+0xc>
  {
    /* Enable the DCMI JPEG format */
    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
 8001b16:	f042 0208 	orr.w	r2, r2, #8
 8001b1a:	e001      	b.n	8001b20 <DCMI_JPEGCmd+0x10>
  }
  else
  {
    /* Disable the DCMI JPEG format */
    DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
 8001b1c:	f022 0208 	bic.w	r2, r2, #8
 8001b20:	601a      	str	r2, [r3, #0]
 8001b22:	4770      	bx	lr
 8001b24:	50050000 	.word	0x50050000

08001b28 <DCMI_Cmd>:
  * @param  NewState: new state of the DCMI interface. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_Cmd(FunctionalState NewState)
{
 8001b28:	4b04      	ldr	r3, [pc, #16]	; (8001b3c <DCMI_Cmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DCMI by setting ENABLE bit */
    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 8001b2a:	681a      	ldr	r2, [r3, #0]
void DCMI_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8001b2c:	b110      	cbz	r0, 8001b34 <DCMI_Cmd+0xc>
  {
    /* Enable the DCMI by setting ENABLE bit */
    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 8001b2e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b32:	e001      	b.n	8001b38 <DCMI_Cmd+0x10>
  }
  else
  {
    /* Disable the DCMI by clearing ENABLE bit */
    DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
 8001b34:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001b38:	601a      	str	r2, [r3, #0]
 8001b3a:	4770      	bx	lr
 8001b3c:	50050000 	.word	0x50050000

08001b40 <DCMI_CaptureCmd>:
  * @param  NewState: new state of the DCMI capture. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_CaptureCmd(FunctionalState NewState)
{
 8001b40:	4b04      	ldr	r3, [pc, #16]	; (8001b54 <DCMI_CaptureCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the DCMI Capture */
    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 8001b42:	681a      	ldr	r2, [r3, #0]
void DCMI_CaptureCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8001b44:	b110      	cbz	r0, 8001b4c <DCMI_CaptureCmd+0xc>
  {
    /* Enable the DCMI Capture */
    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 8001b46:	f042 0201 	orr.w	r2, r2, #1
 8001b4a:	e001      	b.n	8001b50 <DCMI_CaptureCmd+0x10>
  }
  else
  {
    /* Disable the DCMI Capture */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
 8001b4c:	f022 0201 	bic.w	r2, r2, #1
 8001b50:	601a      	str	r2, [r3, #0]
 8001b52:	4770      	bx	lr
 8001b54:	50050000 	.word	0x50050000

08001b58 <DCMI_ReadData>:
  * @param  None 
  * @retval Data register value
  */
uint32_t DCMI_ReadData(void)
{
  return DCMI->DR;
 8001b58:	4b01      	ldr	r3, [pc, #4]	; (8001b60 <DCMI_ReadData+0x8>)
 8001b5a:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 8001b5c:	4770      	bx	lr
 8001b5e:	bf00      	nop
 8001b60:	50050000 	.word	0x50050000

08001b64 <DCMI_ITConfig>:
  * @param  NewState: new state of the specified DCMI interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
{
 8001b64:	4b04      	ldr	r3, [pc, #16]	; (8001b78 <DCMI_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    DCMI->IER |= DCMI_IT;
 8001b66:	68da      	ldr	r2, [r3, #12]
{
  /* Check the parameters */
  assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8001b68:	b109      	cbz	r1, 8001b6e <DCMI_ITConfig+0xa>
  {
    /* Enable the Interrupt sources */
    DCMI->IER |= DCMI_IT;
 8001b6a:	4310      	orrs	r0, r2
 8001b6c:	e002      	b.n	8001b74 <DCMI_ITConfig+0x10>
  }
  else
  {
    /* Disable the Interrupt sources */
    DCMI->IER &= (uint16_t)(~DCMI_IT);
 8001b6e:	43c0      	mvns	r0, r0
 8001b70:	b280      	uxth	r0, r0
 8001b72:	4010      	ands	r0, r2
 8001b74:	60d8      	str	r0, [r3, #12]
 8001b76:	4770      	bx	lr
 8001b78:	50050000 	.word	0x50050000

08001b7c <DCMI_GetFlagStatus>:
  assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
  
  /* Get the DCMI register index */
  dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
  
  if (dcmireg == 0x00) /* The FLAG is in RISR register */
 8001b7c:	0b02      	lsrs	r2, r0, #12
 8001b7e:	4b06      	ldr	r3, [pc, #24]	; (8001b98 <DCMI_GetFlagStatus+0x1c>)
 8001b80:	d101      	bne.n	8001b86 <DCMI_GetFlagStatus+0xa>
  {
    tempreg= DCMI->RISR;
 8001b82:	689b      	ldr	r3, [r3, #8]
 8001b84:	e003      	b.n	8001b8e <DCMI_GetFlagStatus+0x12>
  }
  else if (dcmireg == 0x02) /* The FLAG is in SR register */
 8001b86:	2a02      	cmp	r2, #2
  {
    tempreg = DCMI->SR;
 8001b88:	bf0c      	ite	eq
 8001b8a:	685b      	ldreq	r3, [r3, #4]
  }
  else /* The FLAG is in MISR register */
  {
    tempreg = DCMI->MISR;
 8001b8c:	691b      	ldrne	r3, [r3, #16]
  }
  
  if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
 8001b8e:	4203      	tst	r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the DCMI_FLAG status */
  return  bitstatus;
}
 8001b90:	bf0c      	ite	eq
 8001b92:	2000      	moveq	r0, #0
 8001b94:	2001      	movne	r0, #1
 8001b96:	4770      	bx	lr
 8001b98:	50050000 	.word	0x50050000

08001b9c <DCMI_ClearFlag>:
  assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
  
  /* Clear the flag by writing in the ICR register 1 in the corresponding 
  Flag position*/
  
  DCMI->ICR = DCMI_FLAG;
 8001b9c:	4b01      	ldr	r3, [pc, #4]	; (8001ba4 <DCMI_ClearFlag+0x8>)
 8001b9e:	6158      	str	r0, [r3, #20]
 8001ba0:	4770      	bx	lr
 8001ba2:	bf00      	nop
 8001ba4:	50050000 	.word	0x50050000

08001ba8 <DCMI_GetITStatus>:
  uint32_t itstatus = 0;
  
  /* Check the parameters */
  assert_param(IS_DCMI_GET_IT(DCMI_IT));
  
  itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
 8001ba8:	4b03      	ldr	r3, [pc, #12]	; (8001bb8 <DCMI_GetITStatus+0x10>)
 8001baa:	691b      	ldr	r3, [r3, #16]
  
  if ((itstatus != (uint16_t)RESET))
 8001bac:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8001bae:	bf0c      	ite	eq
 8001bb0:	2000      	moveq	r0, #0
 8001bb2:	2001      	movne	r0, #1
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop
 8001bb8:	50050000 	.word	0x50050000

08001bbc <DCMI_ClearITPendingBit>:
void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
{
  /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
  corresponding pending Bit position*/
  
  DCMI->ICR = DCMI_IT;
 8001bbc:	4b01      	ldr	r3, [pc, #4]	; (8001bc4 <DCMI_ClearITPendingBit+0x8>)
 8001bbe:	6158      	str	r0, [r3, #20]
 8001bc0:	4770      	bx	lr
 8001bc2:	bf00      	nop
 8001bc4:	50050000 	.word	0x50050000

08001bc8 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 8001bc8:	6803      	ldr	r3, [r0, #0]
 8001bca:	f023 0301 	bic.w	r3, r3, #1
 8001bce:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 8001bd0:	2300      	movs	r3, #0
 8001bd2:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 8001bd4:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 8001bd6:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 8001bd8:	60c3      	str	r3, [r0, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 8001bda:	6103      	str	r3, [r0, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 8001bdc:	2321      	movs	r3, #33	; 0x21
 8001bde:	6143      	str	r3, [r0, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 8001be0:	4b2d      	ldr	r3, [pc, #180]	; (8001c98 <DMA_DeInit+0xd0>)
 8001be2:	4298      	cmp	r0, r3
 8001be4:	d100      	bne.n	8001be8 <DMA_DeInit+0x20>
 8001be6:	e01e      	b.n	8001c26 <DMA_DeInit+0x5e>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 8001be8:	4b2c      	ldr	r3, [pc, #176]	; (8001c9c <DMA_DeInit+0xd4>)
 8001bea:	4298      	cmp	r0, r3
 8001bec:	d100      	bne.n	8001bf0 <DMA_DeInit+0x28>
 8001bee:	e021      	b.n	8001c34 <DMA_DeInit+0x6c>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 8001bf0:	4b2b      	ldr	r3, [pc, #172]	; (8001ca0 <DMA_DeInit+0xd8>)
 8001bf2:	4298      	cmp	r0, r3
 8001bf4:	d100      	bne.n	8001bf8 <DMA_DeInit+0x30>
 8001bf6:	e025      	b.n	8001c44 <DMA_DeInit+0x7c>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 8001bf8:	4b2a      	ldr	r3, [pc, #168]	; (8001ca4 <DMA_DeInit+0xdc>)
 8001bfa:	4298      	cmp	r0, r3
 8001bfc:	d100      	bne.n	8001c00 <DMA_DeInit+0x38>
 8001bfe:	e029      	b.n	8001c54 <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 8001c00:	4b29      	ldr	r3, [pc, #164]	; (8001ca8 <DMA_DeInit+0xe0>)
 8001c02:	4298      	cmp	r0, r3
 8001c04:	d100      	bne.n	8001c08 <DMA_DeInit+0x40>
 8001c06:	e02d      	b.n	8001c64 <DMA_DeInit+0x9c>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 8001c08:	4b28      	ldr	r3, [pc, #160]	; (8001cac <DMA_DeInit+0xe4>)
 8001c0a:	4298      	cmp	r0, r3
 8001c0c:	d100      	bne.n	8001c10 <DMA_DeInit+0x48>
 8001c0e:	e030      	b.n	8001c72 <DMA_DeInit+0xaa>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 8001c10:	4b27      	ldr	r3, [pc, #156]	; (8001cb0 <DMA_DeInit+0xe8>)
 8001c12:	4298      	cmp	r0, r3
 8001c14:	d100      	bne.n	8001c18 <DMA_DeInit+0x50>
 8001c16:	e033      	b.n	8001c80 <DMA_DeInit+0xb8>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 8001c18:	4b26      	ldr	r3, [pc, #152]	; (8001cb4 <DMA_DeInit+0xec>)
 8001c1a:	4298      	cmp	r0, r3
 8001c1c:	d100      	bne.n	8001c20 <DMA_DeInit+0x58>
 8001c1e:	e036      	b.n	8001c8e <DMA_DeInit+0xc6>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 8001c20:	4b25      	ldr	r3, [pc, #148]	; (8001cb8 <DMA_DeInit+0xf0>)
 8001c22:	4298      	cmp	r0, r3
 8001c24:	d103      	bne.n	8001c2e <DMA_DeInit+0x66>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 8001c26:	223d      	movs	r2, #61	; 0x3d
 8001c28:	f843 2c08 	str.w	r2, [r3, #-8]
 8001c2c:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 8001c2e:	4b23      	ldr	r3, [pc, #140]	; (8001cbc <DMA_DeInit+0xf4>)
 8001c30:	4298      	cmp	r0, r3
 8001c32:	d104      	bne.n	8001c3e <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 8001c34:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8001c38:	f843 2c20 	str.w	r2, [r3, #-32]
 8001c3c:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 8001c3e:	4b20      	ldr	r3, [pc, #128]	; (8001cc0 <DMA_DeInit+0xf8>)
 8001c40:	4298      	cmp	r0, r3
 8001c42:	d104      	bne.n	8001c4e <DMA_DeInit+0x86>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 8001c44:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8001c48:	f843 2c38 	str.w	r2, [r3, #-56]
 8001c4c:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 8001c4e:	4b1d      	ldr	r3, [pc, #116]	; (8001cc4 <DMA_DeInit+0xfc>)
 8001c50:	4298      	cmp	r0, r3
 8001c52:	d104      	bne.n	8001c5e <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 8001c54:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8001c58:	f843 2c50 	str.w	r2, [r3, #-80]
 8001c5c:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8001c5e:	4b1a      	ldr	r3, [pc, #104]	; (8001cc8 <DMA_DeInit+0x100>)
 8001c60:	4298      	cmp	r0, r3
 8001c62:	d103      	bne.n	8001c6c <DMA_DeInit+0xa4>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 8001c64:	4a19      	ldr	r2, [pc, #100]	; (8001ccc <DMA_DeInit+0x104>)
 8001c66:	f843 2c64 	str.w	r2, [r3, #-100]
 8001c6a:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8001c6c:	4b18      	ldr	r3, [pc, #96]	; (8001cd0 <DMA_DeInit+0x108>)
 8001c6e:	4298      	cmp	r0, r3
 8001c70:	d103      	bne.n	8001c7a <DMA_DeInit+0xb2>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 8001c72:	4a18      	ldr	r2, [pc, #96]	; (8001cd4 <DMA_DeInit+0x10c>)
 8001c74:	f843 2c7c 	str.w	r2, [r3, #-124]
 8001c78:	4770      	bx	lr
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 8001c7a:	4b17      	ldr	r3, [pc, #92]	; (8001cd8 <DMA_DeInit+0x110>)
 8001c7c:	4298      	cmp	r0, r3
 8001c7e:	d103      	bne.n	8001c88 <DMA_DeInit+0xc0>
  {
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 8001c80:	4a16      	ldr	r2, [pc, #88]	; (8001cdc <DMA_DeInit+0x114>)
 8001c82:	f843 2c94 	str.w	r2, [r3, #-148]
 8001c86:	4770      	bx	lr
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 8001c88:	4b15      	ldr	r3, [pc, #84]	; (8001ce0 <DMA_DeInit+0x118>)
 8001c8a:	4298      	cmp	r0, r3
 8001c8c:	d103      	bne.n	8001c96 <DMA_DeInit+0xce>
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 8001c8e:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8001c92:	f843 2cac 	str.w	r2, [r3, #-172]
 8001c96:	4770      	bx	lr
 8001c98:	40026010 	.word	0x40026010
 8001c9c:	40026028 	.word	0x40026028
 8001ca0:	40026040 	.word	0x40026040
 8001ca4:	40026058 	.word	0x40026058
 8001ca8:	40026070 	.word	0x40026070
 8001cac:	40026088 	.word	0x40026088
 8001cb0:	400260a0 	.word	0x400260a0
 8001cb4:	400260b8 	.word	0x400260b8
 8001cb8:	40026410 	.word	0x40026410
 8001cbc:	40026428 	.word	0x40026428
 8001cc0:	40026440 	.word	0x40026440
 8001cc4:	40026458 	.word	0x40026458
 8001cc8:	40026470 	.word	0x40026470
 8001ccc:	2000003d 	.word	0x2000003d
 8001cd0:	40026488 	.word	0x40026488
 8001cd4:	20000f40 	.word	0x20000f40
 8001cd8:	400264a0 	.word	0x400264a0
 8001cdc:	203d0000 	.word	0x203d0000
 8001ce0:	400264b8 	.word	0x400264b8

08001ce4 <DMA_Init>:
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 8001ce4:	6802      	ldr	r2, [r0, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001ce6:	4b13      	ldr	r3, [pc, #76]	; (8001d34 <DMA_Init+0x50>)
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8001ce8:	b510      	push	{r4, lr}
  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001cea:	4013      	ands	r3, r2
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8001cec:	68cc      	ldr	r4, [r1, #12]
 8001cee:	680a      	ldr	r2, [r1, #0]
 8001cf0:	4314      	orrs	r4, r2
 8001cf2:	694a      	ldr	r2, [r1, #20]
 8001cf4:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8001cf6:	698a      	ldr	r2, [r1, #24]
 8001cf8:	4314      	orrs	r4, r2
 8001cfa:	69ca      	ldr	r2, [r1, #28]
 8001cfc:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8001cfe:	6a0a      	ldr	r2, [r1, #32]
 8001d00:	4314      	orrs	r4, r2
 8001d02:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001d04:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8001d06:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 8001d08:	4314      	orrs	r4, r2
 8001d0a:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 8001d0c:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8001d0e:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 8001d10:	4322      	orrs	r2, r4
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8001d12:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 8001d14:	6003      	str	r3, [r0, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 8001d16:	6944      	ldr	r4, [r0, #20]
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8001d18:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8001d1a:	6acb      	ldr	r3, [r1, #44]	; 0x2c
  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001d1c:	f024 0407 	bic.w	r4, r4, #7

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8001d20:	4313      	orrs	r3, r2
 8001d22:	4323      	orrs	r3, r4

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 8001d24:	6143      	str	r3, [r0, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8001d26:	690b      	ldr	r3, [r1, #16]
 8001d28:	6043      	str	r3, [r0, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8001d2a:	684b      	ldr	r3, [r1, #4]
 8001d2c:	6083      	str	r3, [r0, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 8001d2e:	688b      	ldr	r3, [r1, #8]
 8001d30:	60c3      	str	r3, [r0, #12]
 8001d32:	bd10      	pop	{r4, pc}
 8001d34:	f01c803f 	.word	0xf01c803f

08001d38 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8001d38:	2300      	movs	r3, #0
 8001d3a:	6003      	str	r3, [r0, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8001d3c:	6043      	str	r3, [r0, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 8001d3e:	6083      	str	r3, [r0, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8001d40:	60c3      	str	r3, [r0, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8001d42:	6103      	str	r3, [r0, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8001d44:	6143      	str	r3, [r0, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8001d46:	6183      	str	r3, [r0, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8001d48:	61c3      	str	r3, [r0, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8001d4a:	6203      	str	r3, [r0, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8001d4c:	6243      	str	r3, [r0, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8001d4e:	6283      	str	r3, [r0, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8001d50:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 8001d52:	6303      	str	r3, [r0, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8001d54:	6343      	str	r3, [r0, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8001d56:	6383      	str	r3, [r0, #56]	; 0x38
 8001d58:	4770      	bx	lr

08001d5a <DMA_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8001d5a:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001d5c:	b111      	cbz	r1, 8001d64 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8001d5e:	f043 0301 	orr.w	r3, r3, #1
 8001d62:	e001      	b.n	8001d68 <DMA_Cmd+0xe>
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8001d64:	f023 0301 	bic.w	r3, r3, #1
 8001d68:	6003      	str	r3, [r0, #0]
 8001d6a:	4770      	bx	lr

08001d6c <DMA_PeriphIncOffsetSizeConfig>:

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8001d6c:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 8001d6e:	b111      	cbz	r1, 8001d76 <DMA_PeriphIncOffsetSizeConfig+0xa>
  {
    /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8001d70:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001d74:	e001      	b.n	8001d7a <DMA_PeriphIncOffsetSizeConfig+0xe>
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 8001d76:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001d7a:	6003      	str	r3, [r0, #0]
 8001d7c:	4770      	bx	lr

08001d7e <DMA_FlowControllerConfig>:

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8001d7e:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 8001d80:	b111      	cbz	r1, 8001d88 <DMA_FlowControllerConfig+0xa>
  {
    /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8001d82:	f043 0320 	orr.w	r3, r3, #32
 8001d86:	e001      	b.n	8001d8c <DMA_FlowControllerConfig+0xe>
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 8001d88:	f023 0320 	bic.w	r3, r3, #32
 8001d8c:	6003      	str	r3, [r0, #0]
 8001d8e:	4770      	bx	lr

08001d90 <DMA_SetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 8001d90:	6041      	str	r1, [r0, #4]
 8001d92:	4770      	bx	lr

08001d94 <DMA_GetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 8001d94:	6840      	ldr	r0, [r0, #4]
}
 8001d96:	b280      	uxth	r0, r0
 8001d98:	4770      	bx	lr

08001d9a <DMA_DoubleBufferModeConfig>:
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 8001d9a:	6803      	ldr	r3, [r0, #0]
{  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 8001d9c:	b112      	cbz	r2, 8001da4 <DMA_DoubleBufferModeConfig+0xa>
  {
    /* Set Memory 1 as current memory address */
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 8001d9e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001da2:	e001      	b.n	8001da8 <DMA_DoubleBufferModeConfig+0xe>
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 8001da4:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8001da8:	6003      	str	r3, [r0, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 8001daa:	6101      	str	r1, [r0, #16]
 8001dac:	4770      	bx	lr

08001dae <DMA_DoubleBufferModeCmd>:

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 8001dae:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 8001db0:	b111      	cbz	r1, 8001db8 <DMA_DoubleBufferModeCmd+0xa>
  {
    /* Enable the Double buffer mode */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 8001db2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001db6:	e001      	b.n	8001dbc <DMA_DoubleBufferModeCmd+0xe>
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 8001db8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001dbc:	6003      	str	r3, [r0, #0]
 8001dbe:	4770      	bx	lr

08001dc0 <DMA_MemoryTargetConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 8001dc0:	b10a      	cbz	r2, 8001dc6 <DMA_MemoryTargetConfig+0x6>
  {
    /* Write to DMAy Streamx M1AR */
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 8001dc2:	6101      	str	r1, [r0, #16]
 8001dc4:	4770      	bx	lr
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 8001dc6:	60c1      	str	r1, [r0, #12]
 8001dc8:	4770      	bx	lr

08001dca <DMA_GetCurrentMemoryTarget>:
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 8001dca:	6800      	ldr	r0, [r0, #0]
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
  }
  return tmp;
}
 8001dcc:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 8001dd0:	4770      	bx	lr

08001dd2 <DMA_GetCmdStatus>:
  FunctionalState state = DISABLE;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 8001dd2:	6800      	ldr	r0, [r0, #0]
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
  }
  return state;
}
 8001dd4:	f000 0001 	and.w	r0, r0, #1
 8001dd8:	4770      	bx	lr

08001dda <DMA_GetFIFOStatus>:
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 8001dda:	6940      	ldr	r0, [r0, #20]
  
  return tmpreg;
}
 8001ddc:	f000 0038 	and.w	r0, r0, #56	; 0x38
 8001de0:	4770      	bx	lr

08001de2 <DMA_GetFlagStatus>:

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001de2:	4b0a      	ldr	r3, [pc, #40]	; (8001e0c <DMA_GetFlagStatus+0x2a>)
 8001de4:	4a0a      	ldr	r2, [pc, #40]	; (8001e10 <DMA_GetFlagStatus+0x2e>)
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_FLAG (SET or RESET).
  */
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8001de6:	b510      	push	{r4, lr}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001de8:	4c0a      	ldr	r4, [pc, #40]	; (8001e14 <DMA_GetFlagStatus+0x32>)
 8001dea:	42a0      	cmp	r0, r4
 8001dec:	bf8c      	ite	hi
 8001dee:	4610      	movhi	r0, r2
 8001df0:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8001df2:	008b      	lsls	r3, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 8001df4:	bf4c      	ite	mi
 8001df6:	6843      	ldrmi	r3, [r0, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
 8001df8:	6803      	ldrpl	r3, [r0, #0]
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8001dfa:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8001dfe:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 8001e02:	4219      	tst	r1, r3
    bitstatus = RESET;
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
}
 8001e04:	bf0c      	ite	eq
 8001e06:	2000      	moveq	r0, #0
 8001e08:	2001      	movne	r0, #1
 8001e0a:	bd10      	pop	{r4, pc}
 8001e0c:	40026000 	.word	0x40026000
 8001e10:	40026400 	.word	0x40026400
 8001e14:	4002640f 	.word	0x4002640f

08001e18 <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8001e18:	b510      	push	{r4, lr}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001e1a:	4b08      	ldr	r3, [pc, #32]	; (8001e3c <DMA_ClearFlag+0x24>)
 8001e1c:	4a08      	ldr	r2, [pc, #32]	; (8001e40 <DMA_ClearFlag+0x28>)
 8001e1e:	4c09      	ldr	r4, [pc, #36]	; (8001e44 <DMA_ClearFlag+0x2c>)
 8001e20:	42a0      	cmp	r0, r4
 8001e22:	bf8c      	ite	hi
 8001e24:	4610      	movhi	r0, r2
 8001e26:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8001e28:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8001e2c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8001e30:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8001e34:	bf14      	ite	ne
 8001e36:	60c1      	strne	r1, [r0, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8001e38:	6081      	streq	r1, [r0, #8]
 8001e3a:	bd10      	pop	{r4, pc}
 8001e3c:	40026000 	.word	0x40026000
 8001e40:	40026400 	.word	0x40026400
 8001e44:	4002640f 	.word	0x4002640f

08001e48 <DMA_ITConfig>:
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 8001e48:	060b      	lsls	r3, r1, #24
 8001e4a:	d511      	bpl.n	8001e70 <DMA_ITConfig+0x28>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8001e4c:	6943      	ldr	r3, [r0, #20]
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
 8001e4e:	b14a      	cbz	r2, 8001e64 <DMA_ITConfig+0x1c>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8001e50:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8001e54:	2980      	cmp	r1, #128	; 0x80
  if ((DMA_IT & DMA_IT_FE) != 0)
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8001e56:	6143      	str	r3, [r0, #20]
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8001e58:	d014      	beq.n	8001e84 <DMA_ITConfig+0x3c>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 8001e5a:	6803      	ldr	r3, [r0, #0]
 8001e5c:	f001 011e 	and.w	r1, r1, #30
 8001e60:	4319      	orrs	r1, r3
 8001e62:	e00e      	b.n	8001e82 <DMA_ITConfig+0x3a>
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8001e64:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8001e68:	2980      	cmp	r1, #128	; 0x80
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
    }    
    else 
    {
      /* Disable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8001e6a:	6143      	str	r3, [r0, #20]
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8001e6c:	d104      	bne.n	8001e78 <DMA_ITConfig+0x30>
 8001e6e:	4770      	bx	lr
 8001e70:	2980      	cmp	r1, #128	; 0x80
 8001e72:	d007      	beq.n	8001e84 <DMA_ITConfig+0x3c>
  {
    if (NewState != DISABLE)
 8001e74:	2a00      	cmp	r2, #0
 8001e76:	d1f0      	bne.n	8001e5a <DMA_ITConfig+0x12>
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8001e78:	6803      	ldr	r3, [r0, #0]
 8001e7a:	f001 011e 	and.w	r1, r1, #30
 8001e7e:	ea23 0101 	bic.w	r1, r3, r1
 8001e82:	6001      	str	r1, [r0, #0]
 8001e84:	4770      	bx	lr

08001e86 <DMA_GetITStatus>:
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001e86:	4b12      	ldr	r3, [pc, #72]	; (8001ed0 <DMA_GetITStatus+0x4a>)
 8001e88:	4a12      	ldr	r2, [pc, #72]	; (8001ed4 <DMA_GetITStatus+0x4e>)
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8001e8a:	b510      	push	{r4, lr}
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001e8c:	4c12      	ldr	r4, [pc, #72]	; (8001ed8 <DMA_GetITStatus+0x52>)
 8001e8e:	42a0      	cmp	r0, r4
 8001e90:	bf8c      	ite	hi
 8001e92:	4614      	movhi	r4, r2
 8001e94:	461c      	movls	r4, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 8001e96:	f021 23f0 	bic.w	r3, r1, #4026593280	; 0xf000f000
 8001e9a:	f023 13c3 	bic.w	r3, r3, #12779715	; 0xc300c3
 8001e9e:	b12b      	cbz	r3, 8001eac <DMA_GetITStatus+0x26>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8001ea0:	6802      	ldr	r2, [r0, #0]

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 8001ea2:	f002 021e 	and.w	r2, r2, #30
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8001ea6:	ea02 22d1 	and.w	r2, r2, r1, lsr #11
 8001eaa:	e002      	b.n	8001eb2 <DMA_GetITStatus+0x2c>
  }
  else 
  {
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8001eac:	6942      	ldr	r2, [r0, #20]
 8001eae:	f002 0280 	and.w	r2, r2, #128	; 0x80
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8001eb2:	0088      	lsls	r0, r1, #2
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 8001eb4:	bf4c      	ite	mi
 8001eb6:	6863      	ldrmi	r3, [r4, #4]
  }
  else
  {
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
 8001eb8:	6823      	ldrpl	r3, [r4, #0]
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8001eba:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8001ebe:	f021 1082 	bic.w	r0, r1, #8519810	; 0x820082

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8001ec2:	4018      	ands	r0, r3
 8001ec4:	d002      	beq.n	8001ecc <DMA_GetITStatus+0x46>
  {
    /* DMA_IT is set */
    bitstatus = SET;
 8001ec6:	1c10      	adds	r0, r2, #0
 8001ec8:	bf18      	it	ne
 8001eca:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the DMA_IT status */
  return  bitstatus;
}
 8001ecc:	bd10      	pop	{r4, pc}
 8001ece:	bf00      	nop
 8001ed0:	40026000 	.word	0x40026000
 8001ed4:	40026400 	.word	0x40026400
 8001ed8:	4002640f 	.word	0x4002640f

08001edc <DMA_ClearITPendingBit>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval None
  */
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8001edc:	b510      	push	{r4, lr}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8001ede:	4b08      	ldr	r3, [pc, #32]	; (8001f00 <DMA_ClearITPendingBit+0x24>)
 8001ee0:	4a08      	ldr	r2, [pc, #32]	; (8001f04 <DMA_ClearITPendingBit+0x28>)
 8001ee2:	4c09      	ldr	r4, [pc, #36]	; (8001f08 <DMA_ClearITPendingBit+0x2c>)
 8001ee4:	42a0      	cmp	r0, r4
 8001ee6:	bf8c      	ite	hi
 8001ee8:	4610      	movhi	r0, r2
 8001eea:	4618      	movls	r0, r3
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8001eec:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8001ef0:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
  {
    /* Set DMAy HIFCR register clear interrupt bits */
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8001ef4:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8001ef8:	bf14      	ite	ne
 8001efa:	60c1      	strne	r1, [r0, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8001efc:	6081      	streq	r1, [r0, #8]
 8001efe:	bd10      	pop	{r4, pc}
 8001f00:	40026000 	.word	0x40026000
 8001f04:	40026400 	.word	0x40026400
 8001f08:	4002640f 	.word	0x4002640f

08001f0c <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8001f0c:	4b04      	ldr	r3, [pc, #16]	; (8001f20 <EXTI_DeInit+0x14>)
 8001f0e:	2200      	movs	r2, #0
 8001f10:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8001f12:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8001f14:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8001f16:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8001f18:	4a02      	ldr	r2, [pc, #8]	; (8001f24 <EXTI_DeInit+0x18>)
 8001f1a:	615a      	str	r2, [r3, #20]
 8001f1c:	4770      	bx	lr
 8001f1e:	bf00      	nop
 8001f20:	40013c00 	.word	0x40013c00
 8001f24:	007fffff 	.word	0x007fffff

08001f28 <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001f28:	7983      	ldrb	r3, [r0, #6]
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8001f2a:	b510      	push	{r4, lr}
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8001f2c:	2b00      	cmp	r3, #0
 8001f2e:	d029      	beq.n	8001f84 <EXTI_Init+0x5c>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8001f30:	4b1a      	ldr	r3, [pc, #104]	; (8001f9c <EXTI_Init+0x74>)
 8001f32:	6801      	ldr	r1, [r0, #0]
 8001f34:	681c      	ldr	r4, [r3, #0]
 8001f36:	43ca      	mvns	r2, r1
 8001f38:	4014      	ands	r4, r2
 8001f3a:	601c      	str	r4, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8001f3c:	685c      	ldr	r4, [r3, #4]
 8001f3e:	4022      	ands	r2, r4
 8001f40:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001f42:	7902      	ldrb	r2, [r0, #4]
 8001f44:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8001f48:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8001f4c:	6814      	ldr	r4, [r2, #0]
 8001f4e:	4321      	orrs	r1, r4
 8001f50:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001f52:	6802      	ldr	r2, [r0, #0]
 8001f54:	689c      	ldr	r4, [r3, #8]
 8001f56:	43d1      	mvns	r1, r2
 8001f58:	400c      	ands	r4, r1
 8001f5a:	609c      	str	r4, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8001f5c:	68dc      	ldr	r4, [r3, #12]
 8001f5e:	4021      	ands	r1, r4
 8001f60:	60d9      	str	r1, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8001f62:	7941      	ldrb	r1, [r0, #5]
 8001f64:	2910      	cmp	r1, #16
 8001f66:	d106      	bne.n	8001f76 <EXTI_Init+0x4e>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8001f68:	6899      	ldr	r1, [r3, #8]
 8001f6a:	4311      	orrs	r1, r2
 8001f6c:	6099      	str	r1, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8001f6e:	68d9      	ldr	r1, [r3, #12]
 8001f70:	430a      	orrs	r2, r1
 8001f72:	60da      	str	r2, [r3, #12]
 8001f74:	bd10      	pop	{r4, pc}
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8001f76:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 8001f7a:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8001f7e:	6819      	ldr	r1, [r3, #0]
 8001f80:	430a      	orrs	r2, r1
 8001f82:	e008      	b.n	8001f96 <EXTI_Init+0x6e>
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001f84:	7903      	ldrb	r3, [r0, #4]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8001f86:	6801      	ldr	r1, [r0, #0]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 8001f88:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001f8c:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8001f90:	681a      	ldr	r2, [r3, #0]
 8001f92:	ea22 0201 	bic.w	r2, r2, r1
 8001f96:	601a      	str	r2, [r3, #0]
 8001f98:	bd10      	pop	{r4, pc}
 8001f9a:	bf00      	nop
 8001f9c:	40013c00 	.word	0x40013c00

08001fa0 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001fa0:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001fa2:	220c      	movs	r2, #12
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8001fa4:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8001fa6:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8001fa8:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8001faa:	7183      	strb	r3, [r0, #6]
 8001fac:	4770      	bx	lr

08001fae <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8001fae:	4b02      	ldr	r3, [pc, #8]	; (8001fb8 <EXTI_GenerateSWInterrupt+0xa>)
 8001fb0:	691a      	ldr	r2, [r3, #16]
 8001fb2:	4310      	orrs	r0, r2
 8001fb4:	6118      	str	r0, [r3, #16]
 8001fb6:	4770      	bx	lr
 8001fb8:	40013c00 	.word	0x40013c00

08001fbc <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8001fbc:	4b03      	ldr	r3, [pc, #12]	; (8001fcc <EXTI_GetFlagStatus+0x10>)
 8001fbe:	695b      	ldr	r3, [r3, #20]
 8001fc0:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8001fc2:	bf0c      	ite	eq
 8001fc4:	2000      	moveq	r0, #0
 8001fc6:	2001      	movne	r0, #1
 8001fc8:	4770      	bx	lr
 8001fca:	bf00      	nop
 8001fcc:	40013c00 	.word	0x40013c00

08001fd0 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8001fd0:	4b01      	ldr	r3, [pc, #4]	; (8001fd8 <EXTI_ClearFlag+0x8>)
 8001fd2:	6158      	str	r0, [r3, #20]
 8001fd4:	4770      	bx	lr
 8001fd6:	bf00      	nop
 8001fd8:	40013c00 	.word	0x40013c00

08001fdc <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8001fdc:	4b05      	ldr	r3, [pc, #20]	; (8001ff4 <EXTI_GetITStatus+0x18>)
 8001fde:	681a      	ldr	r2, [r3, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8001fe0:	695b      	ldr	r3, [r3, #20]
 8001fe2:	4003      	ands	r3, r0
 8001fe4:	d004      	beq.n	8001ff0 <EXTI_GetITStatus+0x14>
 8001fe6:	4210      	tst	r0, r2
  {
    bitstatus = SET;
 8001fe8:	bf0c      	ite	eq
 8001fea:	2000      	moveq	r0, #0
 8001fec:	2001      	movne	r0, #1
 8001fee:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 8001ff0:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 8001ff2:	4770      	bx	lr
 8001ff4:	40013c00 	.word	0x40013c00

08001ff8 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8001ff8:	4b01      	ldr	r3, [pc, #4]	; (8002000 <EXTI_ClearITPendingBit+0x8>)
 8001ffa:	6158      	str	r0, [r3, #20]
 8001ffc:	4770      	bx	lr
 8001ffe:	bf00      	nop
 8002000:	40013c00 	.word	0x40013c00

08002004 <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8002004:	4b01      	ldr	r3, [pc, #4]	; (800200c <FLASH_SetLatency+0x8>)
 8002006:	7018      	strb	r0, [r3, #0]
 8002008:	4770      	bx	lr
 800200a:	bf00      	nop
 800200c:	40023c00 	.word	0x40023c00

08002010 <FLASH_PrefetchBufferCmd>:
  * @param  NewState: new state of the Prefetch Buffer.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_PrefetchBufferCmd(FunctionalState NewState)
{
 8002010:	4b04      	ldr	r3, [pc, #16]	; (8002024 <FLASH_PrefetchBufferCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8002012:	681a      	ldr	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 8002014:	b110      	cbz	r0, 800201c <FLASH_PrefetchBufferCmd+0xc>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8002016:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800201a:	e001      	b.n	8002020 <FLASH_PrefetchBufferCmd+0x10>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 800201c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002020:	601a      	str	r2, [r3, #0]
 8002022:	4770      	bx	lr
 8002024:	40023c00 	.word	0x40023c00

08002028 <FLASH_InstructionCacheCmd>:
  * @param  NewState: new state of the Instruction Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
 8002028:	4b04      	ldr	r3, [pc, #16]	; (800203c <FLASH_InstructionCacheCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 800202a:	681a      	ldr	r2, [r3, #0]
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 800202c:	b110      	cbz	r0, 8002034 <FLASH_InstructionCacheCmd+0xc>
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
 800202e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002032:	e001      	b.n	8002038 <FLASH_InstructionCacheCmd+0x10>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_ICEN);
 8002034:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8002038:	601a      	str	r2, [r3, #0]
 800203a:	4770      	bx	lr
 800203c:	40023c00 	.word	0x40023c00

08002040 <FLASH_DataCacheCmd>:
  * @param  NewState: new state of the Data Cache.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_DataCacheCmd(FunctionalState NewState)
{
 8002040:	4b04      	ldr	r3, [pc, #16]	; (8002054 <FLASH_DataCacheCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 8002042:	681a      	ldr	r2, [r3, #0]
void FLASH_DataCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8002044:	b110      	cbz	r0, 800204c <FLASH_DataCacheCmd+0xc>
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
 8002046:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800204a:	e001      	b.n	8002050 <FLASH_DataCacheCmd+0x10>
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_DCEN);
 800204c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002050:	601a      	str	r2, [r3, #0]
 8002052:	4770      	bx	lr
 8002054:	40023c00 	.word	0x40023c00

08002058 <FLASH_InstructionCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_InstructionCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_ICRST;
 8002058:	4b02      	ldr	r3, [pc, #8]	; (8002064 <FLASH_InstructionCacheReset+0xc>)
 800205a:	681a      	ldr	r2, [r3, #0]
 800205c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002060:	601a      	str	r2, [r3, #0]
 8002062:	4770      	bx	lr
 8002064:	40023c00 	.word	0x40023c00

08002068 <FLASH_DataCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_DataCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_DCRST;
 8002068:	4b02      	ldr	r3, [pc, #8]	; (8002074 <FLASH_DataCacheReset+0xc>)
 800206a:	681a      	ldr	r2, [r3, #0]
 800206c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002070:	601a      	str	r2, [r3, #0]
 8002072:	4770      	bx	lr
 8002074:	40023c00 	.word	0x40023c00

08002078 <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8002078:	4b04      	ldr	r3, [pc, #16]	; (800208c <FLASH_Unlock+0x14>)
 800207a:	691a      	ldr	r2, [r3, #16]
 800207c:	2a00      	cmp	r2, #0
 800207e:	da04      	bge.n	800208a <FLASH_Unlock+0x12>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8002080:	4a03      	ldr	r2, [pc, #12]	; (8002090 <FLASH_Unlock+0x18>)
 8002082:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8002084:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002088:	605a      	str	r2, [r3, #4]
 800208a:	4770      	bx	lr
 800208c:	40023c00 	.word	0x40023c00
 8002090:	45670123 	.word	0x45670123

08002094 <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8002094:	4b02      	ldr	r3, [pc, #8]	; (80020a0 <FLASH_Lock+0xc>)
 8002096:	691a      	ldr	r2, [r3, #16]
 8002098:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800209c:	611a      	str	r2, [r3, #16]
 800209e:	4770      	bx	lr
 80020a0:	40023c00 	.word	0x40023c00

080020a4 <FLASH_OB_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
 80020a4:	4b04      	ldr	r3, [pc, #16]	; (80020b8 <FLASH_OB_Unlock+0x14>)
 80020a6:	695a      	ldr	r2, [r3, #20]
 80020a8:	07d2      	lsls	r2, r2, #31
 80020aa:	d504      	bpl.n	80020b6 <FLASH_OB_Unlock+0x12>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 80020ac:	4a03      	ldr	r2, [pc, #12]	; (80020bc <FLASH_OB_Unlock+0x18>)
 80020ae:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 80020b0:	f102 3244 	add.w	r2, r2, #1145324612	; 0x44444444
 80020b4:	609a      	str	r2, [r3, #8]
 80020b6:	4770      	bx	lr
 80020b8:	40023c00 	.word	0x40023c00
 80020bc:	08192a3b 	.word	0x08192a3b

080020c0 <FLASH_OB_Lock>:
  * @retval None
  */
void FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 80020c0:	4b02      	ldr	r3, [pc, #8]	; (80020cc <FLASH_OB_Lock+0xc>)
 80020c2:	695a      	ldr	r2, [r3, #20]
 80020c4:	f042 0201 	orr.w	r2, r2, #1
 80020c8:	615a      	str	r2, [r3, #20]
 80020ca:	4770      	bx	lr
 80020cc:	40023c00 	.word	0x40023c00

080020d0 <FLASH_OB_BORConfig>:
{
  /* Check the parameters */
  assert_param(IS_OB_BOR(OB_BOR));

  /* Set the BOR Level */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
 80020d0:	4b04      	ldr	r3, [pc, #16]	; (80020e4 <FLASH_OB_BORConfig+0x14>)
 80020d2:	781a      	ldrb	r2, [r3, #0]
 80020d4:	f002 02f3 	and.w	r2, r2, #243	; 0xf3
 80020d8:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
 80020da:	781a      	ldrb	r2, [r3, #0]
 80020dc:	4310      	orrs	r0, r2
 80020de:	7018      	strb	r0, [r3, #0]
 80020e0:	4770      	bx	lr
 80020e2:	bf00      	nop
 80020e4:	40023c14 	.word	0x40023c14

080020e8 <FLASH_OB_GetUser>:
  *         and RST_STDBY(Bit2).
  */
uint8_t FLASH_OB_GetUser(void)
{
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OPTCR >> 5);
 80020e8:	4b02      	ldr	r3, [pc, #8]	; (80020f4 <FLASH_OB_GetUser+0xc>)
 80020ea:	6958      	ldr	r0, [r3, #20]
}
 80020ec:	f3c0 1047 	ubfx	r0, r0, #5, #8
 80020f0:	4770      	bx	lr
 80020f2:	bf00      	nop
 80020f4:	40023c00 	.word	0x40023c00

080020f8 <FLASH_OB_GetWRP>:
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 80020f8:	4b01      	ldr	r3, [pc, #4]	; (8002100 <FLASH_OB_GetWRP+0x8>)
 80020fa:	8818      	ldrh	r0, [r3, #0]
}
 80020fc:	b280      	uxth	r0, r0
 80020fe:	4770      	bx	lr
 8002100:	40023c16 	.word	0x40023c16

08002104 <FLASH_OB_GetRDP>:
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;

  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
 8002104:	4b02      	ldr	r3, [pc, #8]	; (8002110 <FLASH_OB_GetRDP+0xc>)
 8002106:	7818      	ldrb	r0, [r3, #0]
  else
  {
    readstatus = RESET;
  }
  return readstatus;
}
 8002108:	38aa      	subs	r0, #170	; 0xaa
 800210a:	bf18      	it	ne
 800210c:	2001      	movne	r0, #1
 800210e:	4770      	bx	lr
 8002110:	40023c15 	.word	0x40023c15

08002114 <FLASH_OB_GetBOR>:
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
uint8_t FLASH_OB_GetBOR(void)
{
  /* Return the FLASH BOR level */
  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
 8002114:	4b02      	ldr	r3, [pc, #8]	; (8002120 <FLASH_OB_GetBOR+0xc>)
 8002116:	7818      	ldrb	r0, [r3, #0]
}
 8002118:	f000 000c 	and.w	r0, r0, #12
 800211c:	4770      	bx	lr
 800211e:	bf00      	nop
 8002120:	40023c14 	.word	0x40023c14

08002124 <FLASH_ITConfig>:
  *            @arg FLASH_IT_ERR: FLASH Error Interrupt
  *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
  * @retval None 
  */
void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
{
 8002124:	4b04      	ldr	r3, [pc, #16]	; (8002138 <FLASH_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 8002126:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 8002128:	b109      	cbz	r1, 800212e <FLASH_ITConfig+0xa>
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800212a:	4310      	orrs	r0, r2
 800212c:	e001      	b.n	8002132 <FLASH_ITConfig+0xe>
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 800212e:	ea22 0000 	bic.w	r0, r2, r0
 8002132:	6118      	str	r0, [r3, #16]
 8002134:	4770      	bx	lr
 8002136:	bf00      	nop
 8002138:	40023c00 	.word	0x40023c00

0800213c <FLASH_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 800213c:	4b03      	ldr	r3, [pc, #12]	; (800214c <FLASH_GetFlagStatus+0x10>)
 800213e:	68db      	ldr	r3, [r3, #12]
 8002140:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
}
 8002142:	bf0c      	ite	eq
 8002144:	2000      	moveq	r0, #0
 8002146:	2001      	movne	r0, #1
 8002148:	4770      	bx	lr
 800214a:	bf00      	nop
 800214c:	40023c00 	.word	0x40023c00

08002150 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8002150:	4b01      	ldr	r3, [pc, #4]	; (8002158 <FLASH_ClearFlag+0x8>)
 8002152:	60d8      	str	r0, [r3, #12]
 8002154:	4770      	bx	lr
 8002156:	bf00      	nop
 8002158:	40023c00 	.word	0x40023c00

0800215c <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 800215c:	4b0b      	ldr	r3, [pc, #44]	; (800218c <FLASH_GetStatus+0x30>)
 800215e:	68da      	ldr	r2, [r3, #12]
 8002160:	03d0      	lsls	r0, r2, #15
 8002162:	d40d      	bmi.n	8002180 <FLASH_GetStatus+0x24>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 8002164:	68da      	ldr	r2, [r3, #12]
 8002166:	06d1      	lsls	r1, r2, #27
 8002168:	d40c      	bmi.n	8002184 <FLASH_GetStatus+0x28>
    { 
      flashstatus = FLASH_ERROR_WRP;
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 800216a:	68da      	ldr	r2, [r3, #12]
 800216c:	f012 0fef 	tst.w	r2, #239	; 0xef
 8002170:	d10a      	bne.n	8002188 <FLASH_GetStatus+0x2c>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 8002172:	68db      	ldr	r3, [r3, #12]
 8002174:	f013 0f02 	tst.w	r3, #2
        {
          flashstatus = FLASH_ERROR_OPERATION;
 8002178:	bf0c      	ite	eq
 800217a:	2008      	moveq	r0, #8
 800217c:	2007      	movne	r0, #7
 800217e:	4770      	bx	lr
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
  {
    flashstatus = FLASH_BUSY;
 8002180:	2001      	movs	r0, #1
 8002182:	4770      	bx	lr
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
    { 
      flashstatus = FLASH_ERROR_WRP;
 8002184:	2005      	movs	r0, #5
 8002186:	4770      	bx	lr
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
 8002188:	2006      	movs	r0, #6
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
}
 800218a:	4770      	bx	lr
 800218c:	40023c00 	.word	0x40023c00

08002190 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8002190:	b507      	push	{r0, r1, r2, lr}
  __IO FLASH_Status status = FLASH_COMPLETE;
 8002192:	2308      	movs	r3, #8
 8002194:	f88d 3007 	strb.w	r3, [sp, #7]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
  {
    status = FLASH_GetStatus();
 8002198:	f7ff ffe0 	bl	800215c <FLASH_GetStatus>
 800219c:	f88d 0007 	strb.w	r0, [sp, #7]
  status = FLASH_GetStatus();

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 80021a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80021a4:	2b01      	cmp	r3, #1
 80021a6:	d0f7      	beq.n	8002198 <FLASH_WaitForLastOperation+0x8>
  {
    status = FLASH_GetStatus();
  }
  /* Return the operation status */
  return status;
 80021a8:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 80021ac:	bd0e      	pop	{r1, r2, r3, pc}

080021ae <FLASH_OB_Launch>:
FLASH_Status FLASH_OB_Launch(void)
{
  FLASH_Status status = FLASH_COMPLETE;

  /* Set the OPTSTRT bit in OPTCR register */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
 80021ae:	4b03      	ldr	r3, [pc, #12]	; (80021bc <FLASH_OB_Launch+0xe>)
 80021b0:	781a      	ldrb	r2, [r3, #0]
 80021b2:	f042 0202 	orr.w	r2, r2, #2
 80021b6:	701a      	strb	r2, [r3, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80021b8:	f7ff bfea 	b.w	8002190 <FLASH_WaitForLastOperation>
 80021bc:	40023c14 	.word	0x40023c14

080021c0 <FLASH_OB_UserConfig>:
  *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval None
  */
void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
{
 80021c0:	b570      	push	{r4, r5, r6, lr}
 80021c2:	4604      	mov	r4, r0
 80021c4:	460d      	mov	r5, r1
 80021c6:	4616      	mov	r6, r2
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80021c8:	f7ff ffe2 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 80021cc:	2808      	cmp	r0, #8
 80021ce:	d107      	bne.n	80021e0 <FLASH_OB_UserConfig+0x20>
  { 
    /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
 80021d0:	4b04      	ldr	r3, [pc, #16]	; (80021e4 <FLASH_OB_UserConfig+0x24>)
 80021d2:	781a      	ldrb	r2, [r3, #0]
 80021d4:	f002 020f 	and.w	r2, r2, #15

    /* Update User Option Byte */
    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
 80021d8:	4314      	orrs	r4, r2
 80021da:	4325      	orrs	r5, r4
 80021dc:	432e      	orrs	r6, r5
 80021de:	701e      	strb	r6, [r3, #0]
 80021e0:	bd70      	pop	{r4, r5, r6, pc}
 80021e2:	bf00      	nop
 80021e4:	40023c14 	.word	0x40023c14

080021e8 <FLASH_OB_RDPConfig>:
  * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval None
  */
void FLASH_OB_RDPConfig(uint8_t OB_RDP)
{
 80021e8:	b510      	push	{r4, lr}
 80021ea:	4604      	mov	r4, r0
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_RDP(OB_RDP));

  status = FLASH_WaitForLastOperation();
 80021ec:	f7ff ffd0 	bl	8002190 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 80021f0:	2808      	cmp	r0, #8
  {
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
 80021f2:	bf04      	itt	eq
 80021f4:	4b01      	ldreq	r3, [pc, #4]	; (80021fc <FLASH_OB_RDPConfig+0x14>)
 80021f6:	701c      	strbeq	r4, [r3, #0]
 80021f8:	bd10      	pop	{r4, pc}
 80021fa:	bf00      	nop
 80021fc:	40023c15 	.word	0x40023c15

08002200 <FLASH_OB_WRPConfig>:
  * @param  Newstate: new state of the Write Protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None  
  */
void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
{ 
 8002200:	b538      	push	{r3, r4, r5, lr}
 8002202:	4604      	mov	r4, r0
 8002204:	460d      	mov	r5, r1
  
  /* Check the parameters */
  assert_param(IS_OB_WRP(OB_WRP));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  status = FLASH_WaitForLastOperation();
 8002206:	f7ff ffc3 	bl	8002190 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 800220a:	2808      	cmp	r0, #8
 800220c:	d108      	bne.n	8002220 <FLASH_OB_WRPConfig+0x20>
 800220e:	4b05      	ldr	r3, [pc, #20]	; (8002224 <FLASH_OB_WRPConfig+0x24>)
  { 
    if(NewState != DISABLE)
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 8002210:	881a      	ldrh	r2, [r3, #0]
    
  status = FLASH_WaitForLastOperation();

  if(status == FLASH_COMPLETE)
  { 
    if(NewState != DISABLE)
 8002212:	b11d      	cbz	r5, 800221c <FLASH_OB_WRPConfig+0x1c>
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 8002214:	b292      	uxth	r2, r2
 8002216:	ea22 0404 	bic.w	r4, r2, r4
 800221a:	e000      	b.n	800221e <FLASH_OB_WRPConfig+0x1e>
    }
    else
    {
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 800221c:	4314      	orrs	r4, r2
 800221e:	801c      	strh	r4, [r3, #0]
 8002220:	bd38      	pop	{r3, r4, r5, pc}
 8002222:	bf00      	nop
 8002224:	40023c16 	.word	0x40023c16

08002228 <FLASH_ProgramByte>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
{
 8002228:	b570      	push	{r4, r5, r6, lr}
 800222a:	4605      	mov	r5, r0
 800222c:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800222e:	f7ff ffaf 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8002232:	2808      	cmp	r0, #8
 8002234:	d111      	bne.n	800225a <FLASH_ProgramByte+0x32>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 8002236:	4c09      	ldr	r4, [pc, #36]	; (800225c <FLASH_ProgramByte+0x34>)
 8002238:	6923      	ldr	r3, [r4, #16]
 800223a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800223e:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_BYTE;
 8002240:	6923      	ldr	r3, [r4, #16]
 8002242:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8002244:	6923      	ldr	r3, [r4, #16]
 8002246:	f043 0301 	orr.w	r3, r3, #1
 800224a:	6123      	str	r3, [r4, #16]
  
    *(__IO uint8_t*)Address = Data;
 800224c:	702e      	strb	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800224e:	f7ff ff9f 	bl	8002190 <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 8002252:	6923      	ldr	r3, [r4, #16]
 8002254:	f023 0301 	bic.w	r3, r3, #1
 8002258:	6123      	str	r3, [r4, #16]
  } 

  /* Return the Program Status */
  return status;
}
 800225a:	bd70      	pop	{r4, r5, r6, pc}
 800225c:	40023c00 	.word	0x40023c00

08002260 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 8002260:	b570      	push	{r4, r5, r6, lr}
 8002262:	4605      	mov	r5, r0
 8002264:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8002266:	f7ff ff93 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800226a:	2808      	cmp	r0, #8
 800226c:	d113      	bne.n	8002296 <FLASH_ProgramHalfWord+0x36>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800226e:	4c0a      	ldr	r4, [pc, #40]	; (8002298 <FLASH_ProgramHalfWord+0x38>)
 8002270:	6923      	ldr	r3, [r4, #16]
 8002272:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002276:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8002278:	6923      	ldr	r3, [r4, #16]
 800227a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800227e:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8002280:	6923      	ldr	r3, [r4, #16]
 8002282:	f043 0301 	orr.w	r3, r3, #1
 8002286:	6123      	str	r3, [r4, #16]
  
    *(__IO uint16_t*)Address = Data;
 8002288:	802e      	strh	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 800228a:	f7ff ff81 	bl	8002190 <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800228e:	6923      	ldr	r3, [r4, #16]
 8002290:	f023 0301 	bic.w	r3, r3, #1
 8002294:	6123      	str	r3, [r4, #16]
  } 
  /* Return the Program Status */
  return status;
}
 8002296:	bd70      	pop	{r4, r5, r6, pc}
 8002298:	40023c00 	.word	0x40023c00

0800229c <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 800229c:	b570      	push	{r4, r5, r6, lr}
 800229e:	4605      	mov	r5, r0
 80022a0:	460e      	mov	r6, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80022a2:	f7ff ff75 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 80022a6:	2808      	cmp	r0, #8
 80022a8:	d113      	bne.n	80022d2 <FLASH_ProgramWord+0x36>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 80022aa:	4c0a      	ldr	r4, [pc, #40]	; (80022d4 <FLASH_ProgramWord+0x38>)
 80022ac:	6923      	ldr	r3, [r4, #16]
 80022ae:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80022b2:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 80022b4:	6923      	ldr	r3, [r4, #16]
 80022b6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80022ba:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 80022bc:	6923      	ldr	r3, [r4, #16]
 80022be:	f043 0301 	orr.w	r3, r3, #1
 80022c2:	6123      	str	r3, [r4, #16]
  
    *(__IO uint32_t*)Address = Data;
 80022c4:	602e      	str	r6, [r5, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 80022c6:	f7ff ff63 	bl	8002190 <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 80022ca:	6923      	ldr	r3, [r4, #16]
 80022cc:	f023 0301 	bic.w	r3, r3, #1
 80022d0:	6123      	str	r3, [r4, #16]
  } 
  /* Return the Program Status */
  return status;
}
 80022d2:	bd70      	pop	{r4, r5, r6, pc}
 80022d4:	40023c00 	.word	0x40023c00

080022d8 <FLASH_ProgramDoubleWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
{
 80022d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80022da:	4607      	mov	r7, r0
 80022dc:	4614      	mov	r4, r2
 80022de:	461d      	mov	r5, r3

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80022e0:	f7ff ff56 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 80022e4:	2808      	cmp	r0, #8
 80022e6:	d114      	bne.n	8002312 <FLASH_ProgramDoubleWord+0x3a>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 80022e8:	4e0a      	ldr	r6, [pc, #40]	; (8002314 <FLASH_ProgramDoubleWord+0x3c>)
 80022ea:	6933      	ldr	r3, [r6, #16]
 80022ec:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80022f0:	6133      	str	r3, [r6, #16]
    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 80022f2:	6933      	ldr	r3, [r6, #16]
 80022f4:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 80022f8:	6133      	str	r3, [r6, #16]
    FLASH->CR |= FLASH_CR_PG;
 80022fa:	6933      	ldr	r3, [r6, #16]
 80022fc:	f043 0301 	orr.w	r3, r3, #1
 8002300:	6133      	str	r3, [r6, #16]
  
    *(__IO uint64_t*)Address = Data;
 8002302:	e9c7 4500 	strd	r4, r5, [r7]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8002306:	f7ff ff43 	bl	8002190 <FLASH_WaitForLastOperation>

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800230a:	6933      	ldr	r3, [r6, #16]
 800230c:	f023 0301 	bic.w	r3, r3, #1
 8002310:	6133      	str	r3, [r6, #16]
  } 
  /* Return the Program Status */
  return status;
}
 8002312:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002314:	40023c00 	.word	0x40023c00

08002318 <FLASH_EraseAllSectors>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
{
 8002318:	b510      	push	{r4, lr}
 800231a:	4604      	mov	r4, r0
  uint32_t tmp_psize = 0x0;
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800231c:	f7ff ff38 	bl	8002190 <FLASH_WaitForLastOperation>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8002320:	b144      	cbz	r4, 8002334 <FLASH_EraseAllSectors+0x1c>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 8002322:	2c01      	cmp	r4, #1
 8002324:	d008      	beq.n	8002338 <FLASH_EraseAllSectors+0x20>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8002326:	2c02      	cmp	r4, #2
 8002328:	bf14      	ite	ne
 800232a:	f44f 7340 	movne.w	r3, #768	; 0x300
 800232e:	f44f 7300 	moveq.w	r3, #512	; 0x200
 8002332:	e003      	b.n	800233c <FLASH_EraseAllSectors+0x24>
  status = FLASH_WaitForLastOperation();
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 8002334:	4623      	mov	r3, r4
 8002336:	e001      	b.n	800233c <FLASH_EraseAllSectors+0x24>
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8002338:	f44f 7380 	mov.w	r3, #256	; 0x100
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }  
  if(status == FLASH_COMPLETE)
 800233c:	2808      	cmp	r0, #8
 800233e:	d115      	bne.n	800236c <FLASH_EraseAllSectors+0x54>
  {
    /* if the previous operation is completed, proceed to erase all sectors */
     FLASH->CR &= CR_PSIZE_MASK;
 8002340:	4c0b      	ldr	r4, [pc, #44]	; (8002370 <FLASH_EraseAllSectors+0x58>)
 8002342:	6922      	ldr	r2, [r4, #16]
 8002344:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002348:	6122      	str	r2, [r4, #16]
     FLASH->CR |= tmp_psize;
 800234a:	6922      	ldr	r2, [r4, #16]
 800234c:	4313      	orrs	r3, r2
 800234e:	6123      	str	r3, [r4, #16]
     FLASH->CR |= FLASH_CR_MER;
 8002350:	6923      	ldr	r3, [r4, #16]
 8002352:	f043 0304 	orr.w	r3, r3, #4
 8002356:	6123      	str	r3, [r4, #16]
     FLASH->CR |= FLASH_CR_STRT;
 8002358:	6923      	ldr	r3, [r4, #16]
 800235a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800235e:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8002360:	f7ff ff16 	bl	8002190 <FLASH_WaitForLastOperation>

    /* if the erase operation is completed, disable the MER Bit */
    FLASH->CR &= (~FLASH_CR_MER);
 8002364:	6923      	ldr	r3, [r4, #16]
 8002366:	f023 0304 	bic.w	r3, r3, #4
 800236a:	6123      	str	r3, [r4, #16]

  }   
  /* Return the Erase Status */
  return status;
}
 800236c:	bd10      	pop	{r4, pc}
 800236e:	bf00      	nop
 8002370:	40023c00 	.word	0x40023c00

08002374 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 8002374:	b570      	push	{r4, r5, r6, lr}
 8002376:	4606      	mov	r6, r0

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8002378:	b141      	cbz	r1, 800238c <FLASH_EraseSector+0x18>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == VoltageRange_2)
 800237a:	2901      	cmp	r1, #1
 800237c:	d008      	beq.n	8002390 <FLASH_EraseSector+0x1c>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == VoltageRange_3)
  {
    tmp_psize = FLASH_PSIZE_WORD;
 800237e:	2902      	cmp	r1, #2
 8002380:	bf14      	ite	ne
 8002382:	f44f 7540 	movne.w	r5, #768	; 0x300
 8002386:	f44f 7500 	moveq.w	r5, #512	; 0x200
 800238a:	e003      	b.n	8002394 <FLASH_EraseSector+0x20>
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 800238c:	460d      	mov	r5, r1
 800238e:	e001      	b.n	8002394 <FLASH_EraseSector+0x20>
  }
  else if(VoltageRange == VoltageRange_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8002390:	f44f 7580 	mov.w	r5, #256	; 0x100
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 8002394:	f7ff fefc 	bl	8002190 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8002398:	2808      	cmp	r0, #8
 800239a:	d11e      	bne.n	80023da <FLASH_EraseSector+0x66>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 800239c:	4c0f      	ldr	r4, [pc, #60]	; (80023dc <FLASH_EraseSector+0x68>)
 800239e:	6923      	ldr	r3, [r4, #16]
 80023a0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80023a4:	6123      	str	r3, [r4, #16]
    FLASH->CR |= tmp_psize;
 80023a6:	6921      	ldr	r1, [r4, #16]
 80023a8:	430d      	orrs	r5, r1
 80023aa:	6125      	str	r5, [r4, #16]
    FLASH->CR &= SECTOR_MASK;
 80023ac:	6923      	ldr	r3, [r4, #16]
 80023ae:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80023b2:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 80023b4:	6923      	ldr	r3, [r4, #16]
 80023b6:	f043 0302 	orr.w	r3, r3, #2
 80023ba:	431e      	orrs	r6, r3
 80023bc:	6126      	str	r6, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 80023be:	6923      	ldr	r3, [r4, #16]
 80023c0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80023c4:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 80023c6:	f7ff fee3 	bl	8002190 <FLASH_WaitForLastOperation>
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 80023ca:	6923      	ldr	r3, [r4, #16]
 80023cc:	f023 0302 	bic.w	r3, r3, #2
 80023d0:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK; 
 80023d2:	6923      	ldr	r3, [r4, #16]
 80023d4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80023d8:	6123      	str	r3, [r4, #16]
  }
  /* Return the Erase Status */
  return status;
}
 80023da:	bd70      	pop	{r4, r5, r6, pc}
 80023dc:	40023c00 	.word	0x40023c00

080023e0 <FSMC_NORSRAMDeInit>:
  *            @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
  * @retval None
  */
void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
{
 80023e0:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
  /* Check the parameter */
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  
  /* FSMC_Bank1_NORSRAM1 */
  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
 80023e4:	b918      	cbnz	r0, 80023ee <FSMC_NORSRAMDeInit+0xe>
  {
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
 80023e6:	f243 02db 	movw	r2, #12507	; 0x30db
 80023ea:	601a      	str	r2, [r3, #0]
 80023ec:	e003      	b.n	80023f6 <FSMC_NORSRAMDeInit+0x16>
  }
  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
  else
  {   
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
 80023ee:	f243 02d2 	movw	r2, #12498	; 0x30d2
 80023f2:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
  }
  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
 80023f6:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 80023fa:	1c41      	adds	r1, r0, #1
 80023fc:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8002400:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
 8002404:	f502 7282 	add.w	r2, r2, #260	; 0x104
 8002408:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 800240c:	4770      	bx	lr

0800240e <FSMC_NORSRAMInit>:
  *         that contains the configuration information for the FSMC NOR/SRAM 
  *         specified Banks.                       
  * @retval None
  */
void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{ 
 800240e:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 8002410:	6843      	ldr	r3, [r0, #4]
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 8002412:	6884      	ldr	r4, [r0, #8]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 8002414:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 8002416:	6802      	ldr	r2, [r0, #0]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 8002418:	ea44 0503 	orr.w	r5, r4, r3
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 800241c:	68c3      	ldr	r3, [r0, #12]
 800241e:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
 8002420:	6903      	ldr	r3, [r0, #16]
 8002422:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
 8002424:	6943      	ldr	r3, [r0, #20]
 8002426:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
 8002428:	6983      	ldr	r3, [r0, #24]
 800242a:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
 800242c:	69c3      	ldr	r3, [r0, #28]
 800242e:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
 8002430:	6a03      	ldr	r3, [r0, #32]
 8002432:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
 8002434:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002436:	431d      	orrs	r5, r3
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
 8002438:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800243a:	432b      	orrs	r3, r5
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
 800243c:	ea43 0501 	orr.w	r5, r3, r1
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 8002440:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002442:	431d      	orrs	r5, r3
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 8002444:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 8002448:	2c08      	cmp	r4, #8
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800244a:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 800244e:	d105      	bne.n	800245c <FSMC_NORSRAMInit+0x4e>
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
 8002450:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8002454:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 8002458:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 800245c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800245e:	681c      	ldr	r4, [r3, #0]
 8002460:	699d      	ldr	r5, [r3, #24]
 8002462:	4325      	orrs	r5, r4
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
 8002464:	685c      	ldr	r4, [r3, #4]
 8002466:	ea45 1504 	orr.w	r5, r5, r4, lsl #4
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
 800246a:	689c      	ldr	r4, [r3, #8]
 800246c:	ea45 2504 	orr.w	r5, r5, r4, lsl #8
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
 8002470:	68dc      	ldr	r4, [r3, #12]
 8002472:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 8002476:	691c      	ldr	r4, [r3, #16]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 8002478:	695b      	ldr	r3, [r3, #20]
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 800247a:	ea45 5404 	orr.w	r4, r5, r4, lsl #20
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 800247e:	1c56      	adds	r6, r2, #1
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 8002480:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 8002484:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 8002488:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 800248c:	4635      	mov	r5, r6
 800248e:	f843 4026 	str.w	r4, [r3, r6, lsl #2]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 8002492:	d110      	bne.n	80024b6 <FSMC_NORSRAMInit+0xa8>
    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 8002494:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002496:	6819      	ldr	r1, [r3, #0]
 8002498:	6998      	ldr	r0, [r3, #24]
 800249a:	4308      	orrs	r0, r1
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
 800249c:	6859      	ldr	r1, [r3, #4]
 800249e:	ea40 1001 	orr.w	r0, r0, r1, lsl #4
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
 80024a2:	6899      	ldr	r1, [r3, #8]
 80024a4:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 80024a8:	6919      	ldr	r1, [r3, #16]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 80024aa:	695b      	ldr	r3, [r3, #20]
    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 80024ac:	ea40 5101 	orr.w	r1, r0, r1, lsl #20
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 80024b0:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80024b4:	e001      	b.n	80024ba <FSMC_NORSRAMInit+0xac>
               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
  }
  else
  {
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
 80024b6:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 80024ba:	4b02      	ldr	r3, [pc, #8]	; (80024c4 <FSMC_NORSRAMInit+0xb6>)
 80024bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80024c0:	bd70      	pop	{r4, r5, r6, pc}
 80024c2:	bf00      	nop
 80024c4:	a0000104 	.word	0xa0000104

080024c8 <FSMC_NORSRAMStructInit>:
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
 80024c8:	2202      	movs	r2, #2
 80024ca:	6042      	str	r2, [r0, #4]
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
 80024cc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80024d0:	6242      	str	r2, [r0, #36]	; 0x24
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 80024d2:	6b41      	ldr	r1, [r0, #52]	; 0x34
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 80024d4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
 80024d8:	b510      	push	{r4, lr}
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 80024da:	6282      	str	r2, [r0, #40]	; 0x28
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 80024dc:	2300      	movs	r3, #0
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 80024de:	220f      	movs	r2, #15
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 80024e0:	24ff      	movs	r4, #255	; 0xff
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 80024e2:	6003      	str	r3, [r0, #0]
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
 80024e4:	6083      	str	r3, [r0, #8]
  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 80024e6:	60c3      	str	r3, [r0, #12]
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
 80024e8:	6103      	str	r3, [r0, #16]
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
 80024ea:	6143      	str	r3, [r0, #20]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
 80024ec:	6183      	str	r3, [r0, #24]
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
 80024ee:	61c3      	str	r3, [r0, #28]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
 80024f0:	6203      	str	r3, [r0, #32]
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
 80024f2:	62c3      	str	r3, [r0, #44]	; 0x2c
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
 80024f4:	6303      	str	r3, [r0, #48]	; 0x30
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 80024f6:	600a      	str	r2, [r1, #0]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 80024f8:	604a      	str	r2, [r1, #4]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 80024fa:	608c      	str	r4, [r1, #8]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 80024fc:	60ca      	str	r2, [r1, #12]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
 80024fe:	610a      	str	r2, [r1, #16]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
 8002500:	614a      	str	r2, [r1, #20]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
 8002502:	618b      	str	r3, [r1, #24]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 8002504:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8002506:	600a      	str	r2, [r1, #0]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 8002508:	604a      	str	r2, [r1, #4]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 800250a:	608c      	str	r4, [r1, #8]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 800250c:	60ca      	str	r2, [r1, #12]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
 800250e:	610a      	str	r2, [r1, #16]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
 8002510:	614a      	str	r2, [r1, #20]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
 8002512:	618b      	str	r3, [r1, #24]
 8002514:	bd10      	pop	{r4, pc}

08002516 <FSMC_NORSRAMCmd>:
  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
 8002516:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800251a:	b121      	cbz	r1, 8002526 <FSMC_NORSRAMCmd+0x10>
  {
    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
 800251c:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 8002520:	f042 0201 	orr.w	r2, r2, #1
 8002524:	e003      	b.n	800252e <FSMC_NORSRAMCmd+0x18>
  }
  else
  {
    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
 8002526:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 800252a:	4a02      	ldr	r2, [pc, #8]	; (8002534 <FSMC_NORSRAMCmd+0x1e>)
 800252c:	400a      	ands	r2, r1
 800252e:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 8002532:	4770      	bx	lr
 8002534:	000ffffe 	.word	0x000ffffe

08002538 <FSMC_NANDDeInit>:
void FSMC_NANDDeInit(uint32_t FSMC_Bank)
{
  /* Check the parameter */
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8002538:	2810      	cmp	r0, #16
  {
    /* Set the FSMC_Bank2 registers to their reset values */
    FSMC_Bank2->PCR2 = 0x00000018;
 800253a:	bf0c      	ite	eq
 800253c:	4b05      	ldreq	r3, [pc, #20]	; (8002554 <FSMC_NANDDeInit+0x1c>)
  }
  /* FSMC_Bank3_NAND */  
  else
  {
    /* Set the FSMC_Bank3 registers to their reset values */
    FSMC_Bank3->PCR3 = 0x00000018;
 800253e:	4b06      	ldrne	r3, [pc, #24]	; (8002558 <FSMC_NANDDeInit+0x20>)
 8002540:	2240      	movs	r2, #64	; 0x40
 8002542:	2118      	movs	r1, #24
 8002544:	6019      	str	r1, [r3, #0]
    FSMC_Bank3->SR3 = 0x00000040;
 8002546:	605a      	str	r2, [r3, #4]
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
 8002548:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800254c:	609a      	str	r2, [r3, #8]
    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
 800254e:	60da      	str	r2, [r3, #12]
 8002550:	4770      	bx	lr
 8002552:	bf00      	nop
 8002554:	a0000060 	.word	0xa0000060
 8002558:	a0000080 	.word	0xa0000080

0800255c <FSMC_NANDInit>:
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
            PCR_MEMORYTYPE_NAND |
 800255c:	6842      	ldr	r2, [r0, #4]
 800255e:	6883      	ldr	r3, [r0, #8]
  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
  *         contains the configuration information for the FSMC NAND specified Banks.                       
  * @retval None
  */
void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{
 8002560:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
            PCR_MEMORYTYPE_NAND |
 8002562:	ea42 0403 	orr.w	r4, r2, r3
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
            FSMC_NANDInitStruct->FSMC_ECC |
 8002566:	68c3      	ldr	r3, [r0, #12]
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
            PCR_MEMORYTYPE_NAND |
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
 8002568:	f044 0408 	orr.w	r4, r4, #8
            FSMC_NANDInitStruct->FSMC_ECC |
 800256c:	431c      	orrs	r4, r3
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
 800256e:	6903      	ldr	r3, [r0, #16]
 8002570:	431c      	orrs	r4, r3
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
 8002572:	6943      	ldr	r3, [r0, #20]
 8002574:	ea44 2443 	orr.w	r4, r4, r3, lsl #9
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
 8002578:	6983      	ldr	r3, [r0, #24]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 800257a:	ea44 3443 	orr.w	r4, r4, r3, lsl #13
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800257e:	69c3      	ldr	r3, [r0, #28]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8002580:	689a      	ldr	r2, [r3, #8]
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8002582:	685d      	ldr	r5, [r3, #4]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 8002584:	68d9      	ldr	r1, [r3, #12]
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8002586:	0412      	lsls	r2, r2, #16
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8002588:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800258c:	681a      	ldr	r2, [r3, #0]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800258e:	6a03      	ldr	r3, [r0, #32]
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8002590:	432a      	orrs	r2, r5
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8002592:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8002596:	689a      	ldr	r2, [r3, #8]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8002598:	e893 0060 	ldmia.w	r3, {r5, r6}
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800259c:	0412      	lsls	r2, r2, #16
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800259e:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
 80025a2:	68da      	ldr	r2, [r3, #12]
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
 80025a4:	6803      	ldr	r3, [r0, #0]
 80025a6:	2b10      	cmp	r3, #16
  {
    /* FSMC_Bank2_NAND registers configuration */
    FSMC_Bank2->PCR2 = tmppcr;
 80025a8:	bf0c      	ite	eq
 80025aa:	4b04      	ldreq	r3, [pc, #16]	; (80025bc <FSMC_NANDInit+0x60>)
    FSMC_Bank2->PATT2 = tmppatt;
  }
  else
  {
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
 80025ac:	4b04      	ldrne	r3, [pc, #16]	; (80025c0 <FSMC_NANDInit+0x64>)
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80025ae:	4335      	orrs	r5, r6
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 80025b0:	ea45 6202 	orr.w	r2, r5, r2, lsl #24
    FSMC_Bank2->PATT2 = tmppatt;
  }
  else
  {
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
 80025b4:	601c      	str	r4, [r3, #0]
    FSMC_Bank3->PMEM3 = tmppmem;
 80025b6:	6099      	str	r1, [r3, #8]
    FSMC_Bank3->PATT3 = tmppatt;
 80025b8:	60da      	str	r2, [r3, #12]
 80025ba:	bd70      	pop	{r4, r5, r6, pc}
 80025bc:	a0000060 	.word	0xa0000060
 80025c0:	a0000080 	.word	0xa0000080

080025c4 <FSMC_NANDStructInit>:
  * @retval None
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
 80025c4:	2310      	movs	r3, #16
 80025c6:	6003      	str	r3, [r0, #0]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80025c8:	69c2      	ldr	r2, [r0, #28]
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 80025ca:	2300      	movs	r3, #0
 80025cc:	6043      	str	r3, [r0, #4]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 80025ce:	6083      	str	r3, [r0, #8]
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
 80025d0:	60c3      	str	r3, [r0, #12]
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
 80025d2:	6103      	str	r3, [r0, #16]
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
 80025d4:	6143      	str	r3, [r0, #20]
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
 80025d6:	6183      	str	r3, [r0, #24]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80025d8:	23fc      	movs	r3, #252	; 0xfc
 80025da:	6013      	str	r3, [r2, #0]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80025dc:	6053      	str	r3, [r2, #4]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80025de:	6093      	str	r3, [r2, #8]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80025e0:	60d3      	str	r3, [r2, #12]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80025e2:	6a02      	ldr	r2, [r0, #32]
 80025e4:	6013      	str	r3, [r2, #0]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80025e6:	6053      	str	r3, [r2, #4]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80025e8:	6093      	str	r3, [r2, #8]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
 80025ea:	60d3      	str	r3, [r2, #12]
 80025ec:	4770      	bx	lr

080025ee <FSMC_NANDCmd>:
void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80025ee:	b141      	cbz	r1, 8002602 <FSMC_NANDCmd+0x14>
  {
    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80025f0:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
 80025f2:	bf0c      	ite	eq
 80025f4:	4b07      	ldreq	r3, [pc, #28]	; (8002614 <FSMC_NANDCmd+0x26>)
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
 80025f6:	4b08      	ldrne	r3, [pc, #32]	; (8002618 <FSMC_NANDCmd+0x2a>)
 80025f8:	681a      	ldr	r2, [r3, #0]
 80025fa:	f042 0204 	orr.w	r2, r2, #4
 80025fe:	601a      	str	r2, [r3, #0]
 8002600:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8002602:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
 8002604:	bf0c      	ite	eq
 8002606:	4a03      	ldreq	r2, [pc, #12]	; (8002614 <FSMC_NANDCmd+0x26>)
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
 8002608:	4a03      	ldrne	r2, [pc, #12]	; (8002618 <FSMC_NANDCmd+0x2a>)
 800260a:	4b04      	ldr	r3, [pc, #16]	; (800261c <FSMC_NANDCmd+0x2e>)
 800260c:	6811      	ldr	r1, [r2, #0]
 800260e:	400b      	ands	r3, r1
 8002610:	6013      	str	r3, [r2, #0]
 8002612:	4770      	bx	lr
 8002614:	a0000060 	.word	0xa0000060
 8002618:	a0000080 	.word	0xa0000080
 800261c:	000ffffb 	.word	0x000ffffb

08002620 <FSMC_NANDECCCmd>:
void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002620:	b141      	cbz	r1, 8002634 <FSMC_NANDECCCmd+0x14>
  {
    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8002622:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
 8002624:	bf0c      	ite	eq
 8002626:	4b08      	ldreq	r3, [pc, #32]	; (8002648 <FSMC_NANDECCCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
 8002628:	4b08      	ldrne	r3, [pc, #32]	; (800264c <FSMC_NANDECCCmd+0x2c>)
 800262a:	681a      	ldr	r2, [r3, #0]
 800262c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002630:	601a      	str	r2, [r3, #0]
 8002632:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8002634:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
 8002636:	bf0c      	ite	eq
 8002638:	4a03      	ldreq	r2, [pc, #12]	; (8002648 <FSMC_NANDECCCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
 800263a:	4a04      	ldrne	r2, [pc, #16]	; (800264c <FSMC_NANDECCCmd+0x2c>)
 800263c:	4b04      	ldr	r3, [pc, #16]	; (8002650 <FSMC_NANDECCCmd+0x30>)
 800263e:	6811      	ldr	r1, [r2, #0]
 8002640:	400b      	ands	r3, r1
 8002642:	6013      	str	r3, [r2, #0]
 8002644:	4770      	bx	lr
 8002646:	bf00      	nop
 8002648:	a0000060 	.word	0xa0000060
 800264c:	a0000080 	.word	0xa0000080
 8002650:	000fffbf 	.word	0x000fffbf

08002654 <FSMC_GetECC>:
  */
uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
{
  uint32_t eccval = 0x00000000;
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8002654:	2810      	cmp	r0, #16
  {
    /* Get the ECCR2 register value */
    eccval = FSMC_Bank2->ECCR2;
 8002656:	bf0c      	ite	eq
 8002658:	4b01      	ldreq	r3, [pc, #4]	; (8002660 <FSMC_GetECC+0xc>)
  }
  else
  {
    /* Get the ECCR3 register value */
    eccval = FSMC_Bank3->ECCR3;
 800265a:	4b02      	ldrne	r3, [pc, #8]	; (8002664 <FSMC_GetECC+0x10>)
 800265c:	6958      	ldr	r0, [r3, #20]
  }
  /* Return the error correction code value */
  return(eccval);
}
 800265e:	4770      	bx	lr
 8002660:	a0000060 	.word	0xa0000060
 8002664:	a0000080 	.word	0xa0000080

08002668 <FSMC_PCCARDDeInit>:
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 8002668:	4b05      	ldr	r3, [pc, #20]	; (8002680 <FSMC_PCCARDDeInit+0x18>)
 800266a:	2218      	movs	r2, #24
 800266c:	601a      	str	r2, [r3, #0]
  FSMC_Bank4->SR4 = 0x00000000;	
 800266e:	2200      	movs	r2, #0
 8002670:	605a      	str	r2, [r3, #4]
  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
 8002672:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 8002676:	609a      	str	r2, [r3, #8]
  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
 8002678:	60da      	str	r2, [r3, #12]
  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
 800267a:	611a      	str	r2, [r3, #16]
 800267c:	4770      	bx	lr
 800267e:	bf00      	nop
 8002680:	a00000a0 	.word	0xa00000a0

08002684 <FSMC_PCCARDInit>:
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
                     FSMC_MemoryDataWidth_16b |  
 8002684:	6803      	ldr	r3, [r0, #0]
 8002686:	f043 0210 	orr.w	r2, r3, #16
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 800268a:	6843      	ldr	r3, [r0, #4]
 800268c:	ea42 2243 	orr.w	r2, r2, r3, lsl #9
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
 8002690:	6883      	ldr	r3, [r0, #8]
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 8002692:	ea42 3243 	orr.w	r2, r2, r3, lsl #13
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 8002696:	4b14      	ldr	r3, [pc, #80]	; (80026e8 <FSMC_PCCARDInit+0x64>)
  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
  *         that contains the configuration information for the FSMC PCCARD Bank.                       
  * @retval None
  */
void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 8002698:	b510      	push	{r4, lr}
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800269a:	601a      	str	r2, [r3, #0]
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800269c:	68c2      	ldr	r2, [r0, #12]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800269e:	6891      	ldr	r1, [r2, #8]
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026a0:	6854      	ldr	r4, [r2, #4]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026a2:	0409      	lsls	r1, r1, #16
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 80026a4:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026a8:	6811      	ldr	r1, [r2, #0]
 80026aa:	4321      	orrs	r1, r4
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 80026ac:	68d4      	ldr	r4, [r2, #12]
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 80026ae:	6902      	ldr	r2, [r0, #16]
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026b0:	ea41 6104 	orr.w	r1, r1, r4, lsl #24
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 80026b4:	6099      	str	r1, [r3, #8]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026b6:	6891      	ldr	r1, [r2, #8]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026b8:	6854      	ldr	r4, [r2, #4]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026ba:	0409      	lsls	r1, r1, #16
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 80026bc:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026c0:	6811      	ldr	r1, [r2, #0]
 80026c2:	4321      	orrs	r1, r4
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
 80026c4:	68d4      	ldr	r4, [r2, #12]
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 80026c6:	6942      	ldr	r2, [r0, #20]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026c8:	ea41 6104 	orr.w	r1, r1, r4, lsl #24
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 80026cc:	60d9      	str	r1, [r3, #12]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026ce:	6891      	ldr	r1, [r2, #8]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026d0:	6850      	ldr	r0, [r2, #4]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026d2:	0409      	lsls	r1, r1, #16
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 80026d4:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 80026d8:	6811      	ldr	r1, [r2, #0]
 80026da:	4301      	orrs	r1, r0
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
 80026dc:	68d0      	ldr	r0, [r2, #12]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80026de:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 80026e2:	6119      	str	r1, [r3, #16]
 80026e4:	bd10      	pop	{r4, pc}
 80026e6:	bf00      	nop
 80026e8:	a00000a0 	.word	0xa00000a0

080026ec <FSMC_PCCARDStructInit>:
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80026ec:	68c2      	ldr	r2, [r0, #12]
  * @retval None
  */
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 80026ee:	2300      	movs	r3, #0
 80026f0:	6003      	str	r3, [r0, #0]
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
 80026f2:	6043      	str	r3, [r0, #4]
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
 80026f4:	6083      	str	r3, [r0, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80026f6:	23fc      	movs	r3, #252	; 0xfc
 80026f8:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80026fa:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80026fc:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80026fe:	60d3      	str	r3, [r2, #12]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 8002700:	6902      	ldr	r2, [r0, #16]
 8002702:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 8002704:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 8002706:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
 8002708:	60d3      	str	r3, [r2, #12]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800270a:	6942      	ldr	r2, [r0, #20]
 800270c:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 800270e:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 8002710:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 8002712:	60d3      	str	r3, [r2, #12]
 8002714:	4770      	bx	lr

08002716 <FSMC_PCCARDCmd>:
  * @param  NewState: new state of the PCCARD Memory Bank.  
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_PCCARDCmd(FunctionalState NewState)
{
 8002716:	4b05      	ldr	r3, [pc, #20]	; (800272c <FSMC_PCCARDCmd+0x16>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002718:	b118      	cbz	r0, 8002722 <FSMC_PCCARDCmd+0xc>
  {
    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
 800271a:	681a      	ldr	r2, [r3, #0]
 800271c:	f042 0204 	orr.w	r2, r2, #4
 8002720:	e002      	b.n	8002728 <FSMC_PCCARDCmd+0x12>
  }
  else
  {
    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
 8002722:	6819      	ldr	r1, [r3, #0]
 8002724:	4a02      	ldr	r2, [pc, #8]	; (8002730 <FSMC_PCCARDCmd+0x1a>)
 8002726:	400a      	ands	r2, r1
 8002728:	601a      	str	r2, [r3, #0]
 800272a:	4770      	bx	lr
 800272c:	a00000a0 	.word	0xa00000a0
 8002730:	000ffffb 	.word	0x000ffffb

08002734 <FSMC_ITConfig>:
{
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));	
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002734:	b15a      	cbz	r2, 800274e <FSMC_ITConfig+0x1a>
  {
    /* Enable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8002736:	2810      	cmp	r0, #16
 8002738:	d101      	bne.n	800273e <FSMC_ITConfig+0xa>
    {
      FSMC_Bank2->SR2 |= FSMC_IT;
 800273a:	4b0d      	ldr	r3, [pc, #52]	; (8002770 <FSMC_ITConfig+0x3c>)
 800273c:	e004      	b.n	8002748 <FSMC_ITConfig+0x14>
    }
    /* Enable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 800273e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      FSMC_Bank3->SR3 |= FSMC_IT;
 8002742:	bf0c      	ite	eq
 8002744:	4b0b      	ldreq	r3, [pc, #44]	; (8002774 <FSMC_ITConfig+0x40>)
    }
    /* Enable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 |= FSMC_IT;    
 8002746:	4b0c      	ldrne	r3, [pc, #48]	; (8002778 <FSMC_ITConfig+0x44>)
 8002748:	685a      	ldr	r2, [r3, #4]
 800274a:	4311      	orrs	r1, r2
 800274c:	e00e      	b.n	800276c <FSMC_ITConfig+0x38>
    }
  }
  else
  {
    /* Disable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800274e:	2810      	cmp	r0, #16
 8002750:	d104      	bne.n	800275c <FSMC_ITConfig+0x28>
    {
      
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
 8002752:	4b07      	ldr	r3, [pc, #28]	; (8002770 <FSMC_ITConfig+0x3c>)
 8002754:	685a      	ldr	r2, [r3, #4]
 8002756:	ea22 0101 	bic.w	r1, r2, r1
 800275a:	e007      	b.n	800276c <FSMC_ITConfig+0x38>
    }
    /* Disable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 800275c:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
 8002760:	bf0c      	ite	eq
 8002762:	4b04      	ldreq	r3, [pc, #16]	; (8002774 <FSMC_ITConfig+0x40>)
    }
    /* Disable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
 8002764:	4b04      	ldrne	r3, [pc, #16]	; (8002778 <FSMC_ITConfig+0x44>)
 8002766:	685a      	ldr	r2, [r3, #4]
 8002768:	43c9      	mvns	r1, r1
 800276a:	4011      	ands	r1, r2
 800276c:	6059      	str	r1, [r3, #4]
 800276e:	4770      	bx	lr
 8002770:	a0000060 	.word	0xa0000060
 8002774:	a0000080 	.word	0xa0000080
 8002778:	a00000a0 	.word	0xa00000a0

0800277c <FSMC_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800277c:	2810      	cmp	r0, #16
 800277e:	d101      	bne.n	8002784 <FSMC_GetFlagStatus+0x8>
  {
    tmpsr = FSMC_Bank2->SR2;
 8002780:	4b06      	ldr	r3, [pc, #24]	; (800279c <FSMC_GetFlagStatus+0x20>)
 8002782:	e004      	b.n	800278e <FSMC_GetFlagStatus+0x12>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 8002784:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    tmpsr = FSMC_Bank3->SR3;
 8002788:	bf0c      	ite	eq
 800278a:	4b05      	ldreq	r3, [pc, #20]	; (80027a0 <FSMC_GetFlagStatus+0x24>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 800278c:	4b05      	ldrne	r3, [pc, #20]	; (80027a4 <FSMC_GetFlagStatus+0x28>)
 800278e:	685b      	ldr	r3, [r3, #4]
  } 
  
  /* Get the flag status */
  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
 8002790:	420b      	tst	r3, r1
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8002792:	bf0c      	ite	eq
 8002794:	2000      	moveq	r0, #0
 8002796:	2001      	movne	r0, #1
 8002798:	4770      	bx	lr
 800279a:	bf00      	nop
 800279c:	a0000060 	.word	0xa0000060
 80027a0:	a0000080 	.word	0xa0000080
 80027a4:	a00000a0 	.word	0xa00000a0

080027a8 <FSMC_ClearFlag>:
{
 /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80027a8:	2810      	cmp	r0, #16
 80027aa:	d104      	bne.n	80027b6 <FSMC_ClearFlag+0xe>
  {
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
 80027ac:	4b07      	ldr	r3, [pc, #28]	; (80027cc <FSMC_ClearFlag+0x24>)
 80027ae:	685a      	ldr	r2, [r3, #4]
 80027b0:	ea22 0101 	bic.w	r1, r2, r1
 80027b4:	e007      	b.n	80027c6 <FSMC_ClearFlag+0x1e>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80027b6:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
 80027ba:	bf0c      	ite	eq
 80027bc:	4b04      	ldreq	r3, [pc, #16]	; (80027d0 <FSMC_ClearFlag+0x28>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
 80027be:	4b05      	ldrne	r3, [pc, #20]	; (80027d4 <FSMC_ClearFlag+0x2c>)
 80027c0:	685a      	ldr	r2, [r3, #4]
 80027c2:	43c9      	mvns	r1, r1
 80027c4:	4011      	ands	r1, r2
 80027c6:	6059      	str	r1, [r3, #4]
 80027c8:	4770      	bx	lr
 80027ca:	bf00      	nop
 80027cc:	a0000060 	.word	0xa0000060
 80027d0:	a0000080 	.word	0xa0000080
 80027d4:	a00000a0 	.word	0xa00000a0

080027d8 <FSMC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_IT(FSMC_IT));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80027d8:	2810      	cmp	r0, #16
 80027da:	d101      	bne.n	80027e0 <FSMC_GetITStatus+0x8>
  {
    tmpsr = FSMC_Bank2->SR2;
 80027dc:	4b08      	ldr	r3, [pc, #32]	; (8002800 <FSMC_GetITStatus+0x28>)
 80027de:	e004      	b.n	80027ea <FSMC_GetITStatus+0x12>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80027e0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    tmpsr = FSMC_Bank3->SR3;
 80027e4:	bf0c      	ite	eq
 80027e6:	4b07      	ldreq	r3, [pc, #28]	; (8002804 <FSMC_GetITStatus+0x2c>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 80027e8:	4b07      	ldrne	r3, [pc, #28]	; (8002808 <FSMC_GetITStatus+0x30>)
 80027ea:	685b      	ldr	r3, [r3, #4]
  } 
  
  itstatus = tmpsr & FSMC_IT;
  
  itenable = tmpsr & (FSMC_IT >> 3);
  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
 80027ec:	ea13 0001 	ands.w	r0, r3, r1
 80027f0:	d004      	beq.n	80027fc <FSMC_GetITStatus+0x24>
 80027f2:	ea13 01d1 	ands.w	r1, r3, r1, lsr #3
  {
    bitstatus = SET;
 80027f6:	bf0c      	ite	eq
 80027f8:	2000      	moveq	r0, #0
 80027fa:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus; 
}
 80027fc:	4770      	bx	lr
 80027fe:	bf00      	nop
 8002800:	a0000060 	.word	0xa0000060
 8002804:	a0000080 	.word	0xa0000080
 8002808:	a00000a0 	.word	0xa00000a0

0800280c <FSMC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800280c:	2810      	cmp	r0, #16
 800280e:	d104      	bne.n	800281a <FSMC_ClearITPendingBit+0xe>
  {
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
 8002810:	4b07      	ldr	r3, [pc, #28]	; (8002830 <FSMC_ClearITPendingBit+0x24>)
 8002812:	685a      	ldr	r2, [r3, #4]
 8002814:	ea22 01d1 	bic.w	r1, r2, r1, lsr #3
 8002818:	e008      	b.n	800282c <FSMC_ClearITPendingBit+0x20>
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800281a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
 800281e:	bf0c      	ite	eq
 8002820:	4b04      	ldreq	r3, [pc, #16]	; (8002834 <FSMC_ClearITPendingBit+0x28>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
 8002822:	4b05      	ldrne	r3, [pc, #20]	; (8002838 <FSMC_ClearITPendingBit+0x2c>)
 8002824:	685a      	ldr	r2, [r3, #4]
 8002826:	08c9      	lsrs	r1, r1, #3
 8002828:	ea22 0101 	bic.w	r1, r2, r1
 800282c:	6059      	str	r1, [r3, #4]
 800282e:	4770      	bx	lr
 8002830:	a0000060 	.word	0xa0000060
 8002834:	a0000080 	.word	0xa0000080
 8002838:	a00000a0 	.word	0xa00000a0

0800283c <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800283c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 800283e:	4b2c      	ldr	r3, [pc, #176]	; (80028f0 <GPIO_DeInit+0xb4>)
 8002840:	4298      	cmp	r0, r3
 8002842:	d105      	bne.n	8002850 <GPIO_DeInit+0x14>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8002844:	2001      	movs	r0, #1
 8002846:	4601      	mov	r1, r0
 8002848:	f000 ff98 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800284c:	2001      	movs	r0, #1
 800284e:	e048      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOB)
 8002850:	4b28      	ldr	r3, [pc, #160]	; (80028f4 <GPIO_DeInit+0xb8>)
 8002852:	4298      	cmp	r0, r3
 8002854:	d105      	bne.n	8002862 <GPIO_DeInit+0x26>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8002856:	2002      	movs	r0, #2
 8002858:	2101      	movs	r1, #1
 800285a:	f000 ff8f 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 800285e:	2002      	movs	r0, #2
 8002860:	e03f      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOC)
 8002862:	4b25      	ldr	r3, [pc, #148]	; (80028f8 <GPIO_DeInit+0xbc>)
 8002864:	4298      	cmp	r0, r3
 8002866:	d105      	bne.n	8002874 <GPIO_DeInit+0x38>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8002868:	2004      	movs	r0, #4
 800286a:	2101      	movs	r1, #1
 800286c:	f000 ff86 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8002870:	2004      	movs	r0, #4
 8002872:	e036      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOD)
 8002874:	4b21      	ldr	r3, [pc, #132]	; (80028fc <GPIO_DeInit+0xc0>)
 8002876:	4298      	cmp	r0, r3
 8002878:	d105      	bne.n	8002886 <GPIO_DeInit+0x4a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800287a:	2008      	movs	r0, #8
 800287c:	2101      	movs	r1, #1
 800287e:	f000 ff7d 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 8002882:	2008      	movs	r0, #8
 8002884:	e02d      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOE)
 8002886:	4b1e      	ldr	r3, [pc, #120]	; (8002900 <GPIO_DeInit+0xc4>)
 8002888:	4298      	cmp	r0, r3
 800288a:	d105      	bne.n	8002898 <GPIO_DeInit+0x5c>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 800288c:	2010      	movs	r0, #16
 800288e:	2101      	movs	r1, #1
 8002890:	f000 ff74 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 8002894:	2010      	movs	r0, #16
 8002896:	e024      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOF)
 8002898:	4b1a      	ldr	r3, [pc, #104]	; (8002904 <GPIO_DeInit+0xc8>)
 800289a:	4298      	cmp	r0, r3
 800289c:	d105      	bne.n	80028aa <GPIO_DeInit+0x6e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 800289e:	2020      	movs	r0, #32
 80028a0:	2101      	movs	r1, #1
 80028a2:	f000 ff6b 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80028a6:	2020      	movs	r0, #32
 80028a8:	e01b      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOG)
 80028aa:	4b17      	ldr	r3, [pc, #92]	; (8002908 <GPIO_DeInit+0xcc>)
 80028ac:	4298      	cmp	r0, r3
 80028ae:	d105      	bne.n	80028bc <GPIO_DeInit+0x80>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 80028b0:	2040      	movs	r0, #64	; 0x40
 80028b2:	2101      	movs	r1, #1
 80028b4:	f000 ff62 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80028b8:	2040      	movs	r0, #64	; 0x40
 80028ba:	e012      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else if (GPIOx == GPIOH)
 80028bc:	4b13      	ldr	r3, [pc, #76]	; (800290c <GPIO_DeInit+0xd0>)
 80028be:	4298      	cmp	r0, r3
 80028c0:	d105      	bne.n	80028ce <GPIO_DeInit+0x92>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 80028c2:	2080      	movs	r0, #128	; 0x80
 80028c4:	2101      	movs	r1, #1
 80028c6:	f000 ff59 	bl	800377c <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80028ca:	2080      	movs	r0, #128	; 0x80
 80028cc:	e009      	b.n	80028e2 <GPIO_DeInit+0xa6>
  }
  else
  {
    if (GPIOx == GPIOI)
 80028ce:	4b10      	ldr	r3, [pc, #64]	; (8002910 <GPIO_DeInit+0xd4>)
 80028d0:	4298      	cmp	r0, r3
 80028d2:	d10b      	bne.n	80028ec <GPIO_DeInit+0xb0>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 80028d4:	f44f 7080 	mov.w	r0, #256	; 0x100
 80028d8:	2101      	movs	r1, #1
 80028da:	f000 ff4f 	bl	800377c <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80028de:	f44f 7080 	mov.w	r0, #256	; 0x100
 80028e2:	2100      	movs	r1, #0
    }
  }
}
 80028e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 80028e8:	f000 bf48 	b.w	800377c <RCC_AHB1PeriphResetCmd>
 80028ec:	bd08      	pop	{r3, pc}
 80028ee:	bf00      	nop
 80028f0:	40020000 	.word	0x40020000
 80028f4:	40020400 	.word	0x40020400
 80028f8:	40020800 	.word	0x40020800
 80028fc:	40020c00 	.word	0x40020c00
 8002900:	40021000 	.word	0x40021000
 8002904:	40021400 	.word	0x40021400
 8002908:	40021800 	.word	0x40021800
 800290c:	40021c00 	.word	0x40021c00
 8002910:	40022000 	.word	0x40022000

08002914 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8002914:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8002918:	680f      	ldr	r7, [r1, #0]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800291a:	2300      	movs	r3, #0
  {
    pos = ((uint32_t)0x01) << pinpos;
 800291c:	f04f 0c01 	mov.w	ip, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002920:	f04f 0803 	mov.w	r8, #3

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8002924:	fa0c f203 	lsl.w	r2, ip, r3
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8002928:	ea02 0507 	and.w	r5, r2, r7

    if (currentpin == pos)
 800292c:	4295      	cmp	r5, r2
 800292e:	d131      	bne.n	8002994 <GPIO_Init+0x80>
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
 8002930:	005a      	lsls	r2, r3, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002932:	6806      	ldr	r6, [r0, #0]
 8002934:	fa08 f402 	lsl.w	r4, r8, r2
 8002938:	43e4      	mvns	r4, r4
 800293a:	4026      	ands	r6, r4
 800293c:	6006      	str	r6, [r0, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800293e:	790e      	ldrb	r6, [r1, #4]
 8002940:	f8d0 9000 	ldr.w	r9, [r0]
 8002944:	fa06 fa02 	lsl.w	sl, r6, r2

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8002948:	3e01      	subs	r6, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800294a:	ea4a 0909 	orr.w	r9, sl, r9

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800294e:	2e01      	cmp	r6, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8002950:	f8c0 9000 	str.w	r9, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8002954:	d815      	bhi.n	8002982 <GPIO_Init+0x6e>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8002956:	6886      	ldr	r6, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8002958:	f891 9005 	ldrb.w	r9, [r1, #5]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800295c:	4026      	ands	r6, r4
 800295e:	6086      	str	r6, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8002960:	6886      	ldr	r6, [r0, #8]
 8002962:	fa09 f902 	lsl.w	r9, r9, r2
 8002966:	ea49 0606 	orr.w	r6, r9, r6
 800296a:	6086      	str	r6, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800296c:	6846      	ldr	r6, [r0, #4]
 800296e:	ea26 0505 	bic.w	r5, r6, r5
 8002972:	6045      	str	r5, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8002974:	798d      	ldrb	r5, [r1, #6]
 8002976:	6846      	ldr	r6, [r0, #4]
 8002978:	fa05 f503 	lsl.w	r5, r5, r3
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
}
 800297c:	b2ad      	uxth	r5, r5
        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800297e:	4335      	orrs	r5, r6
 8002980:	6045      	str	r5, [r0, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8002982:	68c5      	ldr	r5, [r0, #12]
 8002984:	402c      	ands	r4, r5
 8002986:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8002988:	79cd      	ldrb	r5, [r1, #7]
 800298a:	68c4      	ldr	r4, [r0, #12]
 800298c:	fa05 f202 	lsl.w	r2, r5, r2
 8002990:	4322      	orrs	r2, r4
 8002992:	60c2      	str	r2, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002994:	3301      	adds	r3, #1
 8002996:	2b10      	cmp	r3, #16
 8002998:	d1c4      	bne.n	8002924 <GPIO_Init+0x10>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800299a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800299e <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 800299e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80029a2:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80029a4:	2300      	movs	r3, #0
 80029a6:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 80029a8:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 80029aa:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 80029ac:	71c3      	strb	r3, [r0, #7]
 80029ae:	4770      	bx	lr

080029b0 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80029b0:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 80029b2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80029b6:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 80029b8:	9b01      	ldr	r3, [sp, #4]
 80029ba:	430b      	orrs	r3, r1
 80029bc:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80029be:	9b01      	ldr	r3, [sp, #4]
 80029c0:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 80029c2:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 80029c4:	9b01      	ldr	r3, [sp, #4]
 80029c6:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80029c8:	69c3      	ldr	r3, [r0, #28]
 80029ca:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80029cc:	69c3      	ldr	r3, [r0, #28]
 80029ce:	9301      	str	r3, [sp, #4]
}
 80029d0:	b002      	add	sp, #8
 80029d2:	4770      	bx	lr

080029d4 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80029d4:	6903      	ldr	r3, [r0, #16]
 80029d6:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80029d8:	bf0c      	ite	eq
 80029da:	2000      	moveq	r0, #0
 80029dc:	2001      	movne	r0, #1
 80029de:	4770      	bx	lr

080029e0 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 80029e0:	6900      	ldr	r0, [r0, #16]
}
 80029e2:	b280      	uxth	r0, r0
 80029e4:	4770      	bx	lr

080029e6 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80029e6:	6943      	ldr	r3, [r0, #20]
 80029e8:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 80029ea:	bf0c      	ite	eq
 80029ec:	2000      	moveq	r0, #0
 80029ee:	2001      	movne	r0, #1
 80029f0:	4770      	bx	lr

080029f2 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 80029f2:	6940      	ldr	r0, [r0, #20]
}
 80029f4:	b280      	uxth	r0, r0
 80029f6:	4770      	bx	lr

080029f8 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 80029f8:	8301      	strh	r1, [r0, #24]
 80029fa:	4770      	bx	lr

080029fc <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 80029fc:	8341      	strh	r1, [r0, #26]
 80029fe:	4770      	bx	lr

08002a00 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8002a00:	b10a      	cbz	r2, 8002a06 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
 8002a02:	8301      	strh	r1, [r0, #24]
 8002a04:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8002a06:	8341      	strh	r1, [r0, #26]
 8002a08:	4770      	bx	lr

08002a0a <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8002a0a:	6141      	str	r1, [r0, #20]
 8002a0c:	4770      	bx	lr

08002a0e <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8002a0e:	6943      	ldr	r3, [r0, #20]
 8002a10:	4059      	eors	r1, r3
 8002a12:	6141      	str	r1, [r0, #20]
 8002a14:	4770      	bx	lr

08002a16 <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002a16:	f001 0307 	and.w	r3, r1, #7
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002a1a:	08c9      	lsrs	r1, r1, #3
 8002a1c:	3108      	adds	r1, #8
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8002a1e:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002a20:	009b      	lsls	r3, r3, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002a22:	f850 5021 	ldr.w	r5, [r0, r1, lsl #2]
 8002a26:	240f      	movs	r4, #15
 8002a28:	fa04 f403 	lsl.w	r4, r4, r3
 8002a2c:	ea25 0404 	bic.w	r4, r5, r4
 8002a30:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8002a34:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002a38:	fa02 f203 	lsl.w	r2, r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8002a3c:	4314      	orrs	r4, r2
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8002a3e:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
 8002a42:	bd30      	pop	{r4, r5, pc}

08002a44 <HASH_DeInit>:
  * @brief  Deinitializes the HASH peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void HASH_DeInit(void)
{
 8002a44:	b508      	push	{r3, lr}
  /* Enable HASH reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
 8002a46:	2020      	movs	r0, #32
 8002a48:	2101      	movs	r1, #1
 8002a4a:	f000 fea3 	bl	8003794 <RCC_AHB2PeriphResetCmd>
  /* Release HASH from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
 8002a4e:	2020      	movs	r0, #32
 8002a50:	2100      	movs	r1, #0
}
 8002a52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void HASH_DeInit(void)
{
  /* Enable HASH reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
  /* Release HASH from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
 8002a56:	f000 be9d 	b.w	8003794 <RCC_AHB2PeriphResetCmd>

08002a5a <HASH_Init>:
  assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
 8002a5a:	4b0e      	ldr	r3, [pc, #56]	; (8002a94 <HASH_Init+0x3a>)
 8002a5c:	681a      	ldr	r2, [r3, #0]
 8002a5e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
  *          if the algorithm mode is HMAC.       
  * @retval None
  */
void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
{
 8002a62:	b510      	push	{r4, lr}
  assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
 8002a64:	601a      	str	r2, [r3, #0]
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8002a66:	e890 0006 	ldmia.w	r0, {r1, r2}
 8002a6a:	681c      	ldr	r4, [r3, #0]
 8002a6c:	430c      	orrs	r4, r1
               HASH_InitStruct->HASH_DataType | \
 8002a6e:	6881      	ldr	r1, [r0, #8]
 8002a70:	4321      	orrs	r1, r4
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8002a72:	4311      	orrs	r1, r2
               HASH_InitStruct->HASH_DataType | \
               HASH_InitStruct->HASH_AlgoMode);
  
  /* if algorithm mode is HMAC, set the Key */  
  if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
 8002a74:	2a40      	cmp	r2, #64	; 0x40
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8002a76:	6019      	str	r1, [r3, #0]
               HASH_InitStruct->HASH_DataType | \
               HASH_InitStruct->HASH_AlgoMode);
  
  /* if algorithm mode is HMAC, set the Key */  
  if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
 8002a78:	d107      	bne.n	8002a8a <HASH_Init+0x30>
  {
    assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
    HASH->CR &= ~HASH_CR_LKEY;
 8002a7a:	681a      	ldr	r2, [r3, #0]
 8002a7c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002a80:	601a      	str	r2, [r3, #0]
    HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
 8002a82:	6819      	ldr	r1, [r3, #0]
 8002a84:	68c2      	ldr	r2, [r0, #12]
 8002a86:	430a      	orrs	r2, r1
 8002a88:	601a      	str	r2, [r3, #0]
  }

  /* Reset the HASH processor core, so that the HASH will be ready to compute 
     the message digest of a new message */
  HASH->CR |= HASH_CR_INIT;  
 8002a8a:	681a      	ldr	r2, [r3, #0]
 8002a8c:	f042 0204 	orr.w	r2, r2, #4
 8002a90:	601a      	str	r2, [r3, #0]
 8002a92:	bd10      	pop	{r4, pc}
 8002a94:	50060400 	.word	0x50060400

08002a98 <HASH_StructInit>:
  * @retval None
  */
void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
{
  /* Initialize the HASH_AlgoSelection member */
  HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8002a98:	2300      	movs	r3, #0
 8002a9a:	6003      	str	r3, [r0, #0]

  /* Initialize the HASH_AlgoMode member */
  HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
 8002a9c:	6043      	str	r3, [r0, #4]

  /* Initialize the HASH_DataType member */
  HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
 8002a9e:	6083      	str	r3, [r0, #8]

  /* Initialize the HASH_HMACKeyType member */
  HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8002aa0:	60c3      	str	r3, [r0, #12]
 8002aa2:	4770      	bx	lr

08002aa4 <HASH_Reset>:
  * @retval None
  */
void HASH_Reset(void)
{
  /* Reset the HASH processor core */
  HASH->CR |= HASH_CR_INIT;
 8002aa4:	4b02      	ldr	r3, [pc, #8]	; (8002ab0 <HASH_Reset+0xc>)
 8002aa6:	681a      	ldr	r2, [r3, #0]
 8002aa8:	f042 0204 	orr.w	r2, r2, #4
 8002aac:	601a      	str	r2, [r3, #0]
 8002aae:	4770      	bx	lr
 8002ab0:	50060400 	.word	0x50060400

08002ab4 <HASH_SetLastWordValidBitsNbr>:
{
  /* Check the parameters */
  assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
  
  /* Configure the Number of valid bits in last word of the message */
  HASH->STR &= ~(HASH_STR_NBW);
 8002ab4:	4b04      	ldr	r3, [pc, #16]	; (8002ac8 <HASH_SetLastWordValidBitsNbr+0x14>)
 8002ab6:	689a      	ldr	r2, [r3, #8]
 8002ab8:	f022 021f 	bic.w	r2, r2, #31
 8002abc:	609a      	str	r2, [r3, #8]
  HASH->STR |= ValidNumber;
 8002abe:	689a      	ldr	r2, [r3, #8]
 8002ac0:	4310      	orrs	r0, r2
 8002ac2:	6098      	str	r0, [r3, #8]
 8002ac4:	4770      	bx	lr
 8002ac6:	bf00      	nop
 8002ac8:	50060400 	.word	0x50060400

08002acc <HASH_DataIn>:
  * @retval None
  */
void HASH_DataIn(uint32_t Data)
{
  /* Write in the DIN register a new data */
  HASH->DIN = Data;
 8002acc:	4b01      	ldr	r3, [pc, #4]	; (8002ad4 <HASH_DataIn+0x8>)
 8002ace:	6058      	str	r0, [r3, #4]
 8002ad0:	4770      	bx	lr
 8002ad2:	bf00      	nop
 8002ad4:	50060400 	.word	0x50060400

08002ad8 <HASH_GetInFIFOWordsNbr>:
  * @retval The value of words already pushed into the IN FIFO.
  */
uint8_t HASH_GetInFIFOWordsNbr(void)
{
  /* Return the value of NBW bits */
  return ((HASH->CR & HASH_CR_NBW) >> 8);
 8002ad8:	4b02      	ldr	r3, [pc, #8]	; (8002ae4 <HASH_GetInFIFOWordsNbr+0xc>)
 8002ada:	6818      	ldr	r0, [r3, #0]
}
 8002adc:	f3c0 2003 	ubfx	r0, r0, #8, #4
 8002ae0:	4770      	bx	lr
 8002ae2:	bf00      	nop
 8002ae4:	50060400 	.word	0x50060400

08002ae8 <HASH_GetDigest>:
  * @retval None
  */
void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
{
  /* Get the data field */
  HASH_MessageDigest->Data[0] = HASH->HR[0];
 8002ae8:	4b05      	ldr	r3, [pc, #20]	; (8002b00 <HASH_GetDigest+0x18>)
 8002aea:	68da      	ldr	r2, [r3, #12]
 8002aec:	6002      	str	r2, [r0, #0]
  HASH_MessageDigest->Data[1] = HASH->HR[1];
 8002aee:	691a      	ldr	r2, [r3, #16]
 8002af0:	6042      	str	r2, [r0, #4]
  HASH_MessageDigest->Data[2] = HASH->HR[2];
 8002af2:	695a      	ldr	r2, [r3, #20]
 8002af4:	6082      	str	r2, [r0, #8]
  HASH_MessageDigest->Data[3] = HASH->HR[3];
 8002af6:	699a      	ldr	r2, [r3, #24]
 8002af8:	60c2      	str	r2, [r0, #12]
  HASH_MessageDigest->Data[4] = HASH->HR[4];
 8002afa:	69db      	ldr	r3, [r3, #28]
 8002afc:	6103      	str	r3, [r0, #16]
 8002afe:	4770      	bx	lr
 8002b00:	50060400 	.word	0x50060400

08002b04 <HASH_StartDigest>:
  * @retval None
  */
void HASH_StartDigest(void)
{
  /* Start the Digest calculation */
  HASH->STR |= HASH_STR_DCAL;
 8002b04:	4b02      	ldr	r3, [pc, #8]	; (8002b10 <HASH_StartDigest+0xc>)
 8002b06:	689a      	ldr	r2, [r3, #8]
 8002b08:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002b0c:	609a      	str	r2, [r3, #8]
 8002b0e:	4770      	bx	lr
 8002b10:	50060400 	.word	0x50060400

08002b14 <HASH_SaveContext>:
void HASH_SaveContext(HASH_Context* HASH_ContextSave)
{
  uint8_t i = 0;
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
 8002b14:	4a09      	ldr	r2, [pc, #36]	; (8002b3c <HASH_SaveContext+0x28>)
 8002b16:	6a13      	ldr	r3, [r2, #32]
 8002b18:	6003      	str	r3, [r0, #0]
  HASH_ContextSave->HASH_STR = HASH->STR;      
 8002b1a:	6893      	ldr	r3, [r2, #8]
  * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
  *         the repository for current context.
  * @retval None
  */
void HASH_SaveContext(HASH_Context* HASH_ContextSave)
{
 8002b1c:	b510      	push	{r4, lr}
  uint8_t i = 0;
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
  HASH_ContextSave->HASH_STR = HASH->STR;      
 8002b1e:	6043      	str	r3, [r0, #4]
  HASH_ContextSave->HASH_CR  = HASH->CR;     
 8002b20:	6813      	ldr	r3, [r2, #0]
 8002b22:	6083      	str	r3, [r0, #8]
 8002b24:	2300      	movs	r3, #0
  for(i=0; i<=50;i++)
  {
     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
 8002b26:	f103 013e 	add.w	r1, r3, #62	; 0x3e
 8002b2a:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
  *         full and no processing is ongoing).   
  * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
  *         the repository for current context.
  * @retval None
  */
void HASH_SaveContext(HASH_Context* HASH_ContextSave)
 8002b2e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 8002b32:	3301      	adds	r3, #1
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
  HASH_ContextSave->HASH_STR = HASH->STR;      
  HASH_ContextSave->HASH_CR  = HASH->CR;     
  for(i=0; i<=50;i++)
 8002b34:	2b33      	cmp	r3, #51	; 0x33
  {
     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
 8002b36:	60cc      	str	r4, [r1, #12]
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
  HASH_ContextSave->HASH_STR = HASH->STR;      
  HASH_ContextSave->HASH_CR  = HASH->CR;     
  for(i=0; i<=50;i++)
 8002b38:	d1f5      	bne.n	8002b26 <HASH_SaveContext+0x12>
  {
     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
  }   
}
 8002b3a:	bd10      	pop	{r4, pc}
 8002b3c:	50060400 	.word	0x50060400

08002b40 <HASH_RestoreContext>:
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
{
  uint8_t i = 0;
  
  /* restore context registers */
  HASH->IMR = HASH_ContextRestore->HASH_IMR;   
 8002b40:	6802      	ldr	r2, [r0, #0]
 8002b42:	4b0b      	ldr	r3, [pc, #44]	; (8002b70 <HASH_RestoreContext+0x30>)
  * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
  *         the repository for saved context.
  * @retval None
  */
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
{
 8002b44:	b510      	push	{r4, lr}
  uint8_t i = 0;
  
  /* restore context registers */
  HASH->IMR = HASH_ContextRestore->HASH_IMR;   
 8002b46:	621a      	str	r2, [r3, #32]
  HASH->STR = HASH_ContextRestore->HASH_STR;     
 8002b48:	6842      	ldr	r2, [r0, #4]
 8002b4a:	609a      	str	r2, [r3, #8]
  HASH->CR = HASH_ContextRestore->HASH_CR;
 8002b4c:	6882      	ldr	r2, [r0, #8]
 8002b4e:	601a      	str	r2, [r3, #0]
  
  /* Initialize the hash processor */
  HASH->CR |= HASH_CR_INIT; 
 8002b50:	681a      	ldr	r2, [r3, #0]
 8002b52:	f042 0204 	orr.w	r2, r2, #4
 8002b56:	601a      	str	r2, [r3, #0]
 8002b58:	2200      	movs	r2, #0
  *         point where it has been interrupted.  
  * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
  *         the repository for saved context.
  * @retval None
  */
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
 8002b5a:	eb00 0182 	add.w	r1, r0, r2, lsl #2
  HASH->CR |= HASH_CR_INIT; 
  
   /* continue restoring context registers */     
  for(i=0; i<=50;i++)
  {
     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
 8002b5e:	68cc      	ldr	r4, [r1, #12]
 8002b60:	f102 013e 	add.w	r1, r2, #62	; 0x3e
 8002b64:	3201      	adds	r2, #1
  
  /* Initialize the hash processor */
  HASH->CR |= HASH_CR_INIT; 
  
   /* continue restoring context registers */     
  for(i=0; i<=50;i++)
 8002b66:	2a33      	cmp	r2, #51	; 0x33
  {
     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
 8002b68:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  
  /* Initialize the hash processor */
  HASH->CR |= HASH_CR_INIT; 
  
   /* continue restoring context registers */     
  for(i=0; i<=50;i++)
 8002b6c:	d1f5      	bne.n	8002b5a <HASH_RestoreContext+0x1a>
  {
     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
  }   
}
 8002b6e:	bd10      	pop	{r4, pc}
 8002b70:	50060400 	.word	0x50060400

08002b74 <HASH_DMACmd>:
  * @param  NewState: new state of the selected HASH DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void HASH_DMACmd(FunctionalState NewState)
{
 8002b74:	4b04      	ldr	r3, [pc, #16]	; (8002b88 <HASH_DMACmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the HASH DMA request */
    HASH->CR |= HASH_CR_DMAE;
 8002b76:	681a      	ldr	r2, [r3, #0]
void HASH_DMACmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002b78:	b110      	cbz	r0, 8002b80 <HASH_DMACmd+0xc>
  {
    /* Enable the HASH DMA request */
    HASH->CR |= HASH_CR_DMAE;
 8002b7a:	f042 0208 	orr.w	r2, r2, #8
 8002b7e:	e001      	b.n	8002b84 <HASH_DMACmd+0x10>
  }
  else
  {
    /* Disable the HASH DMA request */
    HASH->CR &= ~HASH_CR_DMAE;
 8002b80:	f022 0208 	bic.w	r2, r2, #8
 8002b84:	601a      	str	r2, [r3, #0]
 8002b86:	4770      	bx	lr
 8002b88:	50060400 	.word	0x50060400

08002b8c <HASH_ITConfig>:
  * @param  NewState: new state of the specified HASH interrupt.
  *           This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
{
 8002b8c:	4b05      	ldr	r3, [pc, #20]	; (8002ba4 <HASH_ITConfig+0x18>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected HASH interrupt */
    HASH->IMR |= HASH_IT;
 8002b8e:	6a1a      	ldr	r2, [r3, #32]
{
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002b90:	b109      	cbz	r1, 8002b96 <HASH_ITConfig+0xa>
  {
    /* Enable the selected HASH interrupt */
    HASH->IMR |= HASH_IT;
 8002b92:	4310      	orrs	r0, r2
 8002b94:	e003      	b.n	8002b9e <HASH_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected HASH interrupt */
    HASH->IMR &= (uint8_t) ~HASH_IT;
 8002b96:	ea22 0000 	bic.w	r0, r2, r0
 8002b9a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
 8002b9e:	6218      	str	r0, [r3, #32]
 8002ba0:	4770      	bx	lr
 8002ba2:	bf00      	nop
 8002ba4:	50060400 	.word	0x50060400

08002ba8 <HASH_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));

  /* check if the FLAG is in CR register */
  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
 8002ba8:	f400 5280 	and.w	r2, r0, #4096	; 0x1000
 8002bac:	b292      	uxth	r2, r2
 8002bae:	4b05      	ldr	r3, [pc, #20]	; (8002bc4 <HASH_GetFlagStatus+0x1c>)
 8002bb0:	b10a      	cbz	r2, 8002bb6 <HASH_GetFlagStatus+0xe>
  {
    tempreg = HASH->CR;
 8002bb2:	681b      	ldr	r3, [r3, #0]
 8002bb4:	e000      	b.n	8002bb8 <HASH_GetFlagStatus+0x10>
  }
  else /* The FLAG is in SR register */
  {
    tempreg = HASH->SR;
 8002bb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  }

  /* Check the status of the specified HASH flag */
  if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
 8002bb8:	4203      	tst	r3, r0
    bitstatus = RESET;
  }

  /* Return the HASH_FLAG status */
  return  bitstatus;
}
 8002bba:	bf0c      	ite	eq
 8002bbc:	2000      	moveq	r0, #0
 8002bbe:	2001      	movne	r0, #1
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop
 8002bc4:	50060400 	.word	0x50060400

08002bc8 <HASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
  
  /* Clear the selected HASH flags */
  HASH->SR = ~(uint32_t)HASH_FLAG;
 8002bc8:	4b01      	ldr	r3, [pc, #4]	; (8002bd0 <HASH_ClearFlag+0x8>)
 8002bca:	43c0      	mvns	r0, r0
 8002bcc:	6258      	str	r0, [r3, #36]	; 0x24
 8002bce:	4770      	bx	lr
 8002bd0:	50060400 	.word	0x50060400

08002bd4 <HASH_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_HASH_GET_IT(HASH_IT));  


  /* Check the status of the specified HASH interrupt */
  tmpreg =  HASH->SR;
 8002bd4:	4b04      	ldr	r3, [pc, #16]	; (8002be8 <HASH_GetITStatus+0x14>)
 8002bd6:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
 8002bd8:	6a1b      	ldr	r3, [r3, #32]
 8002bda:	4013      	ands	r3, r2
 8002bdc:	4203      	tst	r3, r0
    /* HASH_IT is reset */
    bitstatus = RESET;
  }
  /* Return the HASH_IT status */
  return bitstatus;
}
 8002bde:	bf0c      	ite	eq
 8002be0:	2000      	moveq	r0, #0
 8002be2:	2001      	movne	r0, #1
 8002be4:	4770      	bx	lr
 8002be6:	bf00      	nop
 8002be8:	50060400 	.word	0x50060400

08002bec <HASH_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));

  /* Clear the selected HASH interrupt pending bit */
  HASH->SR = (uint8_t)~HASH_IT;
 8002bec:	43c0      	mvns	r0, r0
 8002bee:	4b02      	ldr	r3, [pc, #8]	; (8002bf8 <HASH_ClearITPendingBit+0xc>)
 8002bf0:	b2c0      	uxtb	r0, r0
 8002bf2:	6258      	str	r0, [r3, #36]	; 0x24
 8002bf4:	4770      	bx	lr
 8002bf6:	bf00      	nop
 8002bf8:	50060400 	.word	0x50060400

08002bfc <HASH_MD5>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
 8002bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;


  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002bfe:	f001 0303 	and.w	r3, r1, #3
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
 8002c02:	b08d      	sub	sp, #52	; 0x34
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002c04:	2500      	movs	r5, #0
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;


  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002c06:	00db      	lsls	r3, r3, #3
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002c08:	f8ad 5006 	strh.w	r5, [sp, #6]
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
 8002c0c:	4607      	mov	r7, r0
 8002c0e:	460e      	mov	r6, r1
 8002c10:	4614      	mov	r4, r2
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8002c12:	9502      	str	r5, [sp, #8]
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;


  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002c14:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* HASH peripheral initialization */
  HASH_DeInit();
 8002c18:	f7ff ff14 	bl	8002a44 <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 8002c1c:	2380      	movs	r3, #128	; 0x80
 8002c1e:	9303      	str	r3, [sp, #12]
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
  HASH_Init(&MD5_HASH_InitStructure);
 8002c20:	a803      	add	r0, sp, #12
  HASH_DeInit();

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002c22:	2320      	movs	r3, #32
  /* HASH peripheral initialization */
  HASH_DeInit();

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 8002c24:	9504      	str	r5, [sp, #16]
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002c26:	9305      	str	r3, [sp, #20]
  HASH_Init(&MD5_HASH_InitStructure);
 8002c28:	f7ff ff17 	bl	8002a5a <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8002c2c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002c30:	b280      	uxth	r0, r0
 8002c32:	f7ff ff3f 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8002c36:	e003      	b.n	8002c40 <HASH_MD5+0x44>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 8002c38:	5978      	ldr	r0, [r7, r5]
 8002c3a:	f7ff ff47 	bl	8002acc <HASH_DataIn>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8002c3e:	3504      	adds	r5, #4
 8002c40:	42b5      	cmp	r5, r6
 8002c42:	d3f9      	bcc.n	8002c38 <HASH_MD5+0x3c>
    HASH_DataIn(*(uint32_t*)inputaddr);
    inputaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8002c44:	f7ff ff5e 	bl	8002b04 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002c48:	2008      	movs	r0, #8
 8002c4a:	f7ff ffad 	bl	8002ba8 <HASH_GetFlagStatus>
    counter++;
 8002c4e:	9b02      	ldr	r3, [sp, #8]
 8002c50:	3301      	adds	r3, #1
 8002c52:	9302      	str	r3, [sp, #8]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8002c54:	9b02      	ldr	r3, [sp, #8]
 8002c56:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002c5a:	d002      	beq.n	8002c62 <HASH_MD5+0x66>
 8002c5c:	2800      	cmp	r0, #0
 8002c5e:	d1f3      	bne.n	8002c48 <HASH_MD5+0x4c>
 8002c60:	e000      	b.n	8002c64 <HASH_MD5+0x68>

  if (busystatus != RESET)
 8002c62:	b980      	cbnz	r0, 8002c86 <HASH_MD5+0x8a>
     status = ERROR;
  }
  else
  {
    /* Read the message digest */
    HASH_GetDigest(&MD5_MessageDigest);
 8002c64:	a807      	add	r0, sp, #28
 8002c66:	f7ff ff3f 	bl	8002ae8 <HASH_GetDigest>
 8002c6a:	9b07      	ldr	r3, [sp, #28]
 8002c6c:	ba1b      	rev	r3, r3
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 8002c6e:	6023      	str	r3, [r4, #0]
 8002c70:	9b08      	ldr	r3, [sp, #32]
 8002c72:	ba1b      	rev	r3, r3
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 8002c74:	6063      	str	r3, [r4, #4]
 8002c76:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002c78:	ba1b      	rev	r3, r3
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 8002c7a:	60a3      	str	r3, [r4, #8]
 8002c7c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002c7e:	ba1b      	rev	r3, r3
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8002c80:	2001      	movs	r0, #1
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 8002c82:	60e3      	str	r3, [r4, #12]
 8002c84:	e000      	b.n	8002c88 <HASH_MD5+0x8c>
    counter++;
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));

  if (busystatus != RESET)
  {
     status = ERROR;
 8002c86:	2000      	movs	r0, #0
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
  }
  return status; 
}
 8002c88:	b00d      	add	sp, #52	; 0x34
 8002c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002c8c <HMAC_MD5>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
 8002c8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002c90:	4698      	mov	r8, r3
 8002c92:	b08d      	sub	sp, #52	; 0x34
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002c94:	f003 0303 	and.w	r3, r3, #3
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002c98:	2600      	movs	r6, #0
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002c9a:	00db      	lsls	r3, r3, #3
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002c9c:	f8ad 6004 	strh.w	r6, [sp, #4]
  __IO uint16_t nbvalidbitskey = 0;
 8002ca0:	f8ad 6006 	strh.w	r6, [sp, #6]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8002ca4:	9602      	str	r6, [sp, #8]
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002ca6:	f8ad 3004 	strh.w	r3, [sp, #4]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8002caa:	f001 0303 	and.w	r3, r1, #3
 8002cae:	00db      	lsls	r3, r3, #3
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
 8002cb0:	460d      	mov	r5, r1
 8002cb2:	4691      	mov	r9, r2
 8002cb4:	4607      	mov	r7, r0

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8002cb6:	f8ad 3006 	strh.w	r3, [sp, #6]
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
 8002cba:	9c14      	ldr	r4, [sp, #80]	; 0x50

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
   
  /* HASH peripheral initialization */
  HASH_DeInit();
 8002cbc:	f7ff fec2 	bl	8002a44 <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 8002cc0:	2380      	movs	r3, #128	; 0x80
 8002cc2:	9303      	str	r3, [sp, #12]
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 8002cc4:	2340      	movs	r3, #64	; 0x40
 8002cc6:	9304      	str	r3, [sp, #16]
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002cc8:	2320      	movs	r3, #32
  if(Keylen > 64)
 8002cca:	2d40      	cmp	r5, #64	; 0x40
  HASH_DeInit();

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002ccc:	9305      	str	r3, [sp, #20]
  else
  {
    /* HMAC short Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
  }
  HASH_Init(&MD5_HASH_InitStructure);
 8002cce:	a803      	add	r0, sp, #12
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
  if(Keylen > 64)
  {
    /* HMAC long Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 8002cd0:	bf86      	itte	hi
 8002cd2:	f44f 3380 	movhi.w	r3, #65536	; 0x10000
 8002cd6:	9306      	strhi	r3, [sp, #24]
  }
  else
  {
    /* HMAC short Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8002cd8:	9606      	strls	r6, [sp, #24]
  }
  HASH_Init(&MD5_HASH_InitStructure);
 8002cda:	f7ff febe 	bl	8002a5a <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8002cde:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002ce2:	b280      	uxth	r0, r0
 8002ce4:	f7ff fee6 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8002ce8:	2600      	movs	r6, #0
 8002cea:	e003      	b.n	8002cf4 <HMAC_MD5+0x68>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 8002cec:	59b8      	ldr	r0, [r7, r6]
 8002cee:	f7ff feed 	bl	8002acc <HASH_DataIn>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8002cf2:	3604      	adds	r6, #4
 8002cf4:	42ae      	cmp	r6, r5
 8002cf6:	d3f9      	bcc.n	8002cec <HMAC_MD5+0x60>
    HASH_DataIn(*(uint32_t*)keyaddr);
    keyaddr+=4;
  }
  
  /* Start the HASH processor */
  HASH_StartDigest();
 8002cf8:	f7ff ff04 	bl	8002b04 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002cfc:	2008      	movs	r0, #8
 8002cfe:	f7ff ff53 	bl	8002ba8 <HASH_GetFlagStatus>
    counter++;
 8002d02:	9b02      	ldr	r3, [sp, #8]
 8002d04:	3301      	adds	r3, #1
 8002d06:	9302      	str	r3, [sp, #8]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8002d08:	9b02      	ldr	r3, [sp, #8]
 8002d0a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002d0e:	d002      	beq.n	8002d16 <HMAC_MD5+0x8a>
 8002d10:	2800      	cmp	r0, #0
 8002d12:	d1f3      	bne.n	8002cfc <HMAC_MD5+0x70>
 8002d14:	e002      	b.n	8002d1c <HMAC_MD5+0x90>

  if (busystatus != RESET)
 8002d16:	b108      	cbz	r0, 8002d1c <HMAC_MD5+0x90>
  {
     status = ERROR;
 8002d18:	2000      	movs	r0, #0
 8002d1a:	e050      	b.n	8002dbe <HMAC_MD5+0x132>
  }
  else
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8002d1c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8002d20:	b280      	uxth	r0, r0
 8002d22:	f7ff fec7 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 8002d26:	2600      	movs	r6, #0
 8002d28:	e004      	b.n	8002d34 <HMAC_MD5+0xa8>
    {
      HASH_DataIn(*(uint32_t*)inputaddr);
 8002d2a:	f859 0006 	ldr.w	r0, [r9, r6]
 8002d2e:	f7ff fecd 	bl	8002acc <HASH_DataIn>
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 8002d32:	3604      	adds	r6, #4
 8002d34:	4546      	cmp	r6, r8
 8002d36:	d3f8      	bcc.n	8002d2a <HMAC_MD5+0x9e>
      HASH_DataIn(*(uint32_t*)inputaddr);
      inputaddr+=4;
    }

    /* Start the HASH processor */
    HASH_StartDigest();
 8002d38:	f7ff fee4 	bl	8002b04 <HASH_StartDigest>

    /* wait until the Busy flag is RESET */
    counter =0;
 8002d3c:	2300      	movs	r3, #0
 8002d3e:	9302      	str	r3, [sp, #8]
    do
    {
       busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002d40:	2008      	movs	r0, #8
 8002d42:	f7ff ff31 	bl	8002ba8 <HASH_GetFlagStatus>
       counter++;
 8002d46:	9b02      	ldr	r3, [sp, #8]
 8002d48:	3301      	adds	r3, #1
 8002d4a:	9302      	str	r3, [sp, #8]
    }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8002d4c:	9b02      	ldr	r3, [sp, #8]
 8002d4e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002d52:	d002      	beq.n	8002d5a <HMAC_MD5+0xce>
 8002d54:	2800      	cmp	r0, #0
 8002d56:	d1f3      	bne.n	8002d40 <HMAC_MD5+0xb4>
 8002d58:	e001      	b.n	8002d5e <HMAC_MD5+0xd2>

    if (busystatus != RESET)
 8002d5a:	2800      	cmp	r0, #0
 8002d5c:	d1dc      	bne.n	8002d18 <HMAC_MD5+0x8c>
      status = ERROR;
    }
    else
    {  
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8002d5e:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002d62:	b280      	uxth	r0, r0
 8002d64:	f7ff fea6 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

      /* Write the Key */
      keyaddr = (uint32_t)Key;
      for(i=0; i<Keylen; i+=4)
 8002d68:	2600      	movs	r6, #0
 8002d6a:	e003      	b.n	8002d74 <HMAC_MD5+0xe8>
      {
        HASH_DataIn(*(uint32_t*)keyaddr);
 8002d6c:	59b8      	ldr	r0, [r7, r6]
 8002d6e:	f7ff fead 	bl	8002acc <HASH_DataIn>
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);

      /* Write the Key */
      keyaddr = (uint32_t)Key;
      for(i=0; i<Keylen; i+=4)
 8002d72:	3604      	adds	r6, #4
 8002d74:	42ae      	cmp	r6, r5
 8002d76:	d3f9      	bcc.n	8002d6c <HMAC_MD5+0xe0>
        HASH_DataIn(*(uint32_t*)keyaddr);
        keyaddr+=4;
      }
  
       /* Start the HASH processor */
       HASH_StartDigest();
 8002d78:	f7ff fec4 	bl	8002b04 <HASH_StartDigest>

       /* wait until the Busy flag is RESET */
       counter =0;
 8002d7c:	2300      	movs	r3, #0
 8002d7e:	9302      	str	r3, [sp, #8]
       do
       {
          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002d80:	2008      	movs	r0, #8
 8002d82:	f7ff ff11 	bl	8002ba8 <HASH_GetFlagStatus>
          counter++;
 8002d86:	9b02      	ldr	r3, [sp, #8]
 8002d88:	3301      	adds	r3, #1
 8002d8a:	9302      	str	r3, [sp, #8]
      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8002d8c:	9b02      	ldr	r3, [sp, #8]
 8002d8e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002d92:	d002      	beq.n	8002d9a <HMAC_MD5+0x10e>
 8002d94:	2800      	cmp	r0, #0
 8002d96:	d1f3      	bne.n	8002d80 <HMAC_MD5+0xf4>
 8002d98:	e001      	b.n	8002d9e <HMAC_MD5+0x112>

      if (busystatus != RESET)
 8002d9a:	2800      	cmp	r0, #0
 8002d9c:	d1bc      	bne.n	8002d18 <HMAC_MD5+0x8c>
         status = ERROR;
      }
      else
      {
         /* Read the message digest */
         HASH_GetDigest(&MD5_MessageDigest);
 8002d9e:	a807      	add	r0, sp, #28
 8002da0:	f7ff fea2 	bl	8002ae8 <HASH_GetDigest>
 8002da4:	9b07      	ldr	r3, [sp, #28]
 8002da6:	ba1b      	rev	r3, r3
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 8002da8:	6023      	str	r3, [r4, #0]
 8002daa:	9b08      	ldr	r3, [sp, #32]
 8002dac:	ba1b      	rev	r3, r3
         outputaddr+=4;
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 8002dae:	6063      	str	r3, [r4, #4]
 8002db0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002db2:	ba1b      	rev	r3, r3
         outputaddr+=4;
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 8002db4:	60a3      	str	r3, [r4, #8]
 8002db6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002db8:	ba1b      	rev	r3, r3
  __IO uint16_t nbvalidbitsdata = 0;
  __IO uint16_t nbvalidbitskey = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8002dba:	2001      	movs	r0, #1
         outputaddr+=4;
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
         outputaddr+=4;
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
         outputaddr+=4;
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 8002dbc:	60e3      	str	r3, [r4, #12]
      }
    }
  }
  return status;  
}
 8002dbe:	b00d      	add	sp, #52	; 0x34
 8002dc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002dc4 <HASH_SHA1>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
 8002dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  ErrorStatus status = SUCCESS;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002dc6:	f001 0303 	and.w	r3, r1, #3
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
 8002dca:	b08d      	sub	sp, #52	; 0x34
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002dcc:	2500      	movs	r5, #0
  ErrorStatus status = SUCCESS;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002dce:	00db      	lsls	r3, r3, #3
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002dd0:	f8ad 5006 	strh.w	r5, [sp, #6]
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
 8002dd4:	4607      	mov	r7, r0
 8002dd6:	460e      	mov	r6, r1
 8002dd8:	4614      	mov	r4, r2
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8002dda:	9502      	str	r5, [sp, #8]
  ErrorStatus status = SUCCESS;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002ddc:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* HASH peripheral initialization */
  HASH_DeInit();
 8002de0:	f7ff fe30 	bl	8002a44 <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002de4:	2320      	movs	r3, #32
  HASH_Init(&SHA1_HASH_InitStructure);
 8002de6:	a803      	add	r0, sp, #12

  /* HASH peripheral initialization */
  HASH_DeInit();

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8002de8:	9503      	str	r5, [sp, #12]
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 8002dea:	9504      	str	r5, [sp, #16]
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002dec:	9305      	str	r3, [sp, #20]
  HASH_Init(&SHA1_HASH_InitStructure);
 8002dee:	f7ff fe34 	bl	8002a5a <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8002df2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002df6:	b280      	uxth	r0, r0
 8002df8:	f7ff fe5c 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8002dfc:	e003      	b.n	8002e06 <HASH_SHA1+0x42>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 8002dfe:	5978      	ldr	r0, [r7, r5]
 8002e00:	f7ff fe64 	bl	8002acc <HASH_DataIn>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8002e04:	3504      	adds	r5, #4
 8002e06:	42b5      	cmp	r5, r6
 8002e08:	d3f9      	bcc.n	8002dfe <HASH_SHA1+0x3a>
    HASH_DataIn(*(uint32_t*)inputaddr);
    inputaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8002e0a:	f7ff fe7b 	bl	8002b04 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002e0e:	2008      	movs	r0, #8
 8002e10:	f7ff feca 	bl	8002ba8 <HASH_GetFlagStatus>
    counter++;
 8002e14:	9b02      	ldr	r3, [sp, #8]
 8002e16:	3301      	adds	r3, #1
 8002e18:	9302      	str	r3, [sp, #8]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8002e1a:	9b02      	ldr	r3, [sp, #8]
 8002e1c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002e20:	d002      	beq.n	8002e28 <HASH_SHA1+0x64>
 8002e22:	2800      	cmp	r0, #0
 8002e24:	d1f3      	bne.n	8002e0e <HASH_SHA1+0x4a>
 8002e26:	e000      	b.n	8002e2a <HASH_SHA1+0x66>

  if (busystatus != RESET)
 8002e28:	b998      	cbnz	r0, 8002e52 <HASH_SHA1+0x8e>
     status = ERROR;
  }
  else
  {
    /* Read the message digest */
    HASH_GetDigest(&SHA1_MessageDigest);
 8002e2a:	a807      	add	r0, sp, #28
 8002e2c:	f7ff fe5c 	bl	8002ae8 <HASH_GetDigest>
 8002e30:	9b07      	ldr	r3, [sp, #28]
 8002e32:	ba1b      	rev	r3, r3
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 8002e34:	6023      	str	r3, [r4, #0]
 8002e36:	9b08      	ldr	r3, [sp, #32]
 8002e38:	ba1b      	rev	r3, r3
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 8002e3a:	6063      	str	r3, [r4, #4]
 8002e3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002e3e:	ba1b      	rev	r3, r3
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 8002e40:	60a3      	str	r3, [r4, #8]
 8002e42:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002e44:	ba1b      	rev	r3, r3
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 8002e46:	60e3      	str	r3, [r4, #12]
 8002e48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002e4a:	ba1b      	rev	r3, r3
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8002e4c:	2001      	movs	r0, #1
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 8002e4e:	6123      	str	r3, [r4, #16]
 8002e50:	e000      	b.n	8002e54 <HASH_SHA1+0x90>
    counter++;
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));

  if (busystatus != RESET)
  {
     status = ERROR;
 8002e52:	2000      	movs	r0, #0
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
  }
  return status;
}
 8002e54:	b00d      	add	sp, #52	; 0x34
 8002e56:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002e58 <HMAC_SHA1>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
 8002e58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002e5c:	4698      	mov	r8, r3
 8002e5e:	b08d      	sub	sp, #52	; 0x34
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002e60:	f003 0303 	and.w	r3, r3, #3
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002e64:	2500      	movs	r5, #0
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002e66:	00db      	lsls	r3, r3, #3
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8002e68:	f8ad 5004 	strh.w	r5, [sp, #4]
  __IO uint16_t nbvalidbitskey = 0;
 8002e6c:	f8ad 5006 	strh.w	r5, [sp, #6]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8002e70:	9502      	str	r5, [sp, #8]
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8002e72:	f8ad 3004 	strh.w	r3, [sp, #4]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8002e76:	f001 0303 	and.w	r3, r1, #3
 8002e7a:	00db      	lsls	r3, r3, #3
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
 8002e7c:	460e      	mov	r6, r1
 8002e7e:	4691      	mov	r9, r2
 8002e80:	4607      	mov	r7, r0

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8002e82:	f8ad 3006 	strh.w	r3, [sp, #6]
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
 8002e86:	9c14      	ldr	r4, [sp, #80]	; 0x50

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);

  /* HASH peripheral initialization */
  HASH_DeInit();
 8002e88:	f7ff fddc 	bl	8002a44 <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 8002e8c:	2340      	movs	r3, #64	; 0x40
 8002e8e:	9304      	str	r3, [sp, #16]
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002e90:	2320      	movs	r3, #32
  if(Keylen > 64)
 8002e92:	2e40      	cmp	r6, #64	; 0x40
  HASH_DeInit();

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8002e94:	9305      	str	r3, [sp, #20]
  else
  {
    /* HMAC short Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
  }
  HASH_Init(&SHA1_HASH_InitStructure);
 8002e96:	a803      	add	r0, sp, #12
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
  if(Keylen > 64)
  {
    /* HMAC long Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 8002e98:	bf86      	itte	hi
 8002e9a:	f44f 3380 	movhi.w	r3, #65536	; 0x10000
 8002e9e:	9306      	strhi	r3, [sp, #24]
  }
  else
  {
    /* HMAC short Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8002ea0:	9506      	strls	r5, [sp, #24]

  /* HASH peripheral initialization */
  HASH_DeInit();

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8002ea2:	9503      	str	r5, [sp, #12]
  else
  {
    /* HMAC short Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
  }
  HASH_Init(&SHA1_HASH_InitStructure);
 8002ea4:	f7ff fdd9 	bl	8002a5a <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8002ea8:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002eac:	b280      	uxth	r0, r0
 8002eae:	f7ff fe01 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8002eb2:	2500      	movs	r5, #0
 8002eb4:	e003      	b.n	8002ebe <HMAC_SHA1+0x66>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 8002eb6:	5978      	ldr	r0, [r7, r5]
 8002eb8:	f7ff fe08 	bl	8002acc <HASH_DataIn>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8002ebc:	3504      	adds	r5, #4
 8002ebe:	42b5      	cmp	r5, r6
 8002ec0:	d3f9      	bcc.n	8002eb6 <HMAC_SHA1+0x5e>
    HASH_DataIn(*(uint32_t*)keyaddr);
    keyaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8002ec2:	f7ff fe1f 	bl	8002b04 <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002ec6:	2008      	movs	r0, #8
 8002ec8:	f7ff fe6e 	bl	8002ba8 <HASH_GetFlagStatus>
    counter++;
 8002ecc:	9b02      	ldr	r3, [sp, #8]
 8002ece:	3301      	adds	r3, #1
 8002ed0:	9302      	str	r3, [sp, #8]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8002ed2:	9b02      	ldr	r3, [sp, #8]
 8002ed4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002ed8:	d002      	beq.n	8002ee0 <HMAC_SHA1+0x88>
 8002eda:	2800      	cmp	r0, #0
 8002edc:	d1f3      	bne.n	8002ec6 <HMAC_SHA1+0x6e>
 8002ede:	e002      	b.n	8002ee6 <HMAC_SHA1+0x8e>

  if (busystatus != RESET)
 8002ee0:	b108      	cbz	r0, 8002ee6 <HMAC_SHA1+0x8e>
  {
     status = ERROR;
 8002ee2:	2000      	movs	r0, #0
 8002ee4:	e053      	b.n	8002f8e <HMAC_SHA1+0x136>
  }
  else
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8002ee6:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8002eea:	b280      	uxth	r0, r0
 8002eec:	f7ff fde2 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 8002ef0:	2500      	movs	r5, #0
 8002ef2:	e004      	b.n	8002efe <HMAC_SHA1+0xa6>
    {
      HASH_DataIn(*(uint32_t*)inputaddr);
 8002ef4:	f859 0005 	ldr.w	r0, [r9, r5]
 8002ef8:	f7ff fde8 	bl	8002acc <HASH_DataIn>
  {
    /* Configure the number of valid bits in last word of the Input data */
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);

    /* Write the Input block in the IN FIFO */
    for(i=0; i<Ilen; i+=4)
 8002efc:	3504      	adds	r5, #4
 8002efe:	4545      	cmp	r5, r8
 8002f00:	d3f8      	bcc.n	8002ef4 <HMAC_SHA1+0x9c>
      HASH_DataIn(*(uint32_t*)inputaddr);
      inputaddr+=4;
    }

    /* Start the HASH processor */
    HASH_StartDigest();
 8002f02:	f7ff fdff 	bl	8002b04 <HASH_StartDigest>


    /* wait until the Busy flag is RESET */
    counter =0;
 8002f06:	2300      	movs	r3, #0
 8002f08:	9302      	str	r3, [sp, #8]
    do
    {
      busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002f0a:	2008      	movs	r0, #8
 8002f0c:	f7ff fe4c 	bl	8002ba8 <HASH_GetFlagStatus>
      counter++;
 8002f10:	9b02      	ldr	r3, [sp, #8]
 8002f12:	3301      	adds	r3, #1
 8002f14:	9302      	str	r3, [sp, #8]
    }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8002f16:	9b02      	ldr	r3, [sp, #8]
 8002f18:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002f1c:	d002      	beq.n	8002f24 <HMAC_SHA1+0xcc>
 8002f1e:	2800      	cmp	r0, #0
 8002f20:	d1f3      	bne.n	8002f0a <HMAC_SHA1+0xb2>
 8002f22:	e001      	b.n	8002f28 <HMAC_SHA1+0xd0>

    if (busystatus != RESET)
 8002f24:	2800      	cmp	r0, #0
 8002f26:	d1dc      	bne.n	8002ee2 <HMAC_SHA1+0x8a>
      status = ERROR;
    }
    else
    {  
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8002f28:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8002f2c:	b280      	uxth	r0, r0
 8002f2e:	f7ff fdc1 	bl	8002ab4 <HASH_SetLastWordValidBitsNbr>

      /* Write the Key */
      keyaddr = (uint32_t)Key;
      for(i=0; i<Keylen; i+=4)
 8002f32:	2500      	movs	r5, #0
 8002f34:	e003      	b.n	8002f3e <HMAC_SHA1+0xe6>
      {
        HASH_DataIn(*(uint32_t*)keyaddr);
 8002f36:	5978      	ldr	r0, [r7, r5]
 8002f38:	f7ff fdc8 	bl	8002acc <HASH_DataIn>
      /* Configure the number of valid bits in last word of the Key */
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);

      /* Write the Key */
      keyaddr = (uint32_t)Key;
      for(i=0; i<Keylen; i+=4)
 8002f3c:	3504      	adds	r5, #4
 8002f3e:	42b5      	cmp	r5, r6
 8002f40:	d3f9      	bcc.n	8002f36 <HMAC_SHA1+0xde>
        HASH_DataIn(*(uint32_t*)keyaddr);
        keyaddr+=4;
      }

      /* Start the HASH processor */
      HASH_StartDigest();
 8002f42:	f7ff fddf 	bl	8002b04 <HASH_StartDigest>

      /* wait until the Busy flag is RESET */
      counter =0;
 8002f46:	2300      	movs	r3, #0
 8002f48:	9302      	str	r3, [sp, #8]
      do
      {
        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8002f4a:	2008      	movs	r0, #8
 8002f4c:	f7ff fe2c 	bl	8002ba8 <HASH_GetFlagStatus>
        counter++;
 8002f50:	9b02      	ldr	r3, [sp, #8]
 8002f52:	3301      	adds	r3, #1
 8002f54:	9302      	str	r3, [sp, #8]
      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8002f56:	9b02      	ldr	r3, [sp, #8]
 8002f58:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002f5c:	d002      	beq.n	8002f64 <HMAC_SHA1+0x10c>
 8002f5e:	2800      	cmp	r0, #0
 8002f60:	d1f3      	bne.n	8002f4a <HMAC_SHA1+0xf2>
 8002f62:	e001      	b.n	8002f68 <HMAC_SHA1+0x110>

      if (busystatus != RESET)
 8002f64:	2800      	cmp	r0, #0
 8002f66:	d1bc      	bne.n	8002ee2 <HMAC_SHA1+0x8a>
        status = ERROR;
      }
      else
      {
        /* Read the message digest */
        HASH_GetDigest(&SHA1_MessageDigest);
 8002f68:	a807      	add	r0, sp, #28
 8002f6a:	f7ff fdbd 	bl	8002ae8 <HASH_GetDigest>
 8002f6e:	9b07      	ldr	r3, [sp, #28]
 8002f70:	ba1b      	rev	r3, r3
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 8002f72:	6023      	str	r3, [r4, #0]
 8002f74:	9b08      	ldr	r3, [sp, #32]
 8002f76:	ba1b      	rev	r3, r3
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 8002f78:	6063      	str	r3, [r4, #4]
 8002f7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002f7c:	ba1b      	rev	r3, r3
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 8002f7e:	60a3      	str	r3, [r4, #8]
 8002f80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002f82:	ba1b      	rev	r3, r3
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 8002f84:	60e3      	str	r3, [r4, #12]
 8002f86:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002f88:	ba1b      	rev	r3, r3
  __IO uint16_t nbvalidbitsdata = 0;
  __IO uint16_t nbvalidbitskey = 0;
  uint32_t i = 0;
  __IO uint32_t counter = 0;
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
 8002f8a:	2001      	movs	r0, #1
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
        outputaddr+=4;
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 8002f8c:	6123      	str	r3, [r4, #16]
      }
    }  
  }
  return status;  
}
 8002f8e:	b00d      	add	sp, #52	; 0x34
 8002f90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002f94 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8002f94:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 8002f96:	4b13      	ldr	r3, [pc, #76]	; (8002fe4 <I2C_DeInit+0x50>)
 8002f98:	4298      	cmp	r0, r3
 8002f9a:	d107      	bne.n	8002fac <I2C_DeInit+0x18>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 8002f9c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8002fa0:	2101      	movs	r1, #1
 8002fa2:	f000 fc0f 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 8002fa6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8002faa:	e014      	b.n	8002fd6 <I2C_DeInit+0x42>
  }
  else if (I2Cx == I2C2)
 8002fac:	4b0e      	ldr	r3, [pc, #56]	; (8002fe8 <I2C_DeInit+0x54>)
 8002fae:	4298      	cmp	r0, r3
 8002fb0:	d107      	bne.n	8002fc2 <I2C_DeInit+0x2e>
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 8002fb2:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8002fb6:	2101      	movs	r1, #1
 8002fb8:	f000 fc04 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 8002fbc:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8002fc0:	e009      	b.n	8002fd6 <I2C_DeInit+0x42>
  }
  else 
  {
    if (I2Cx == I2C3)
 8002fc2:	4b0a      	ldr	r3, [pc, #40]	; (8002fec <I2C_DeInit+0x58>)
 8002fc4:	4298      	cmp	r0, r3
 8002fc6:	d10b      	bne.n	8002fe0 <I2C_DeInit+0x4c>
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 8002fc8:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8002fcc:	2101      	movs	r1, #1
 8002fce:	f000 fbf9 	bl	80037c4 <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 8002fd2:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8002fd6:	2100      	movs	r1, #0
    }
  }
}
 8002fd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (I2Cx == I2C3)
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 8002fdc:	f000 bbf2 	b.w	80037c4 <RCC_APB1PeriphResetCmd>
 8002fe0:	bd08      	pop	{r3, pc}
 8002fe2:	bf00      	nop
 8002fe4:	40005400 	.word	0x40005400
 8002fe8:	40005800 	.word	0x40005800
 8002fec:	40005c00 	.word	0x40005c00

08002ff0 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8002ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ff2:	b085      	sub	sp, #20
 8002ff4:	4604      	mov	r4, r0
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8002ff6:	8886      	ldrh	r6, [r0, #4]
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8002ff8:	4668      	mov	r0, sp
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8002ffa:	460d      	mov	r5, r1
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8002ffc:	f000 fb12 	bl	8003624 <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 8003000:	9902      	ldr	r1, [sp, #8]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003002:	482b      	ldr	r0, [pc, #172]	; (80030b0 <I2C_Init+0xc0>)
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8003004:	682b      	ldr	r3, [r5, #0]

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8003006:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 800300a:	0436      	lsls	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 800300c:	fbb1 f0f0 	udiv	r0, r1, r0

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 8003010:	0c36      	lsrs	r6, r6, #16
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  pclk1 = rcc_clocks.PCLK1_Frequency;
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003012:	b287      	uxth	r7, r0
  tmpreg |= freqrange;
 8003014:	433e      	orrs	r6, r7
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003016:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 8003018:	8822      	ldrh	r2, [r4, #0]
 800301a:	f022 0201 	bic.w	r2, r2, #1
 800301e:	0412      	lsls	r2, r2, #16
 8003020:	0c12      	lsrs	r2, r2, #16
 8003022:	8022      	strh	r2, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8003024:	4a23      	ldr	r2, [pc, #140]	; (80030b4 <I2C_Init+0xc4>)
 8003026:	4293      	cmp	r3, r2
 8003028:	d809      	bhi.n	800303e <I2C_Init+0x4e>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 800302a:	005b      	lsls	r3, r3, #1
 800302c:	fbb1 f3f3 	udiv	r3, r1, r3
 8003030:	b29b      	uxth	r3, r3
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8003032:	3701      	adds	r7, #1
 8003034:	8427      	strh	r7, [r4, #32]
    {
      /* Set minimum allowed value */
      result = 0x04;  
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 8003036:	2b03      	cmp	r3, #3
 8003038:	bf98      	it	ls
 800303a:	2304      	movls	r3, #4
 800303c:	e01f      	b.n	800307e <I2C_Init+0x8e>
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 800303e:	88ee      	ldrh	r6, [r5, #6]
 8003040:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8003044:	4296      	cmp	r6, r2
 8003046:	d104      	bne.n	8003052 <I2C_Init+0x62>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8003048:	2203      	movs	r2, #3
 800304a:	4353      	muls	r3, r2
 800304c:	fbb1 f3f3 	udiv	r3, r1, r3
 8003050:	e005      	b.n	800305e <I2C_Init+0x6e>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8003052:	2219      	movs	r2, #25
 8003054:	4353      	muls	r3, r2
 8003056:	fbb1 f3f3 	udiv	r3, r1, r3
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 800305a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800305e:	b29b      	uxth	r3, r3
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
 8003060:	051a      	lsls	r2, r3, #20
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8003062:	f44f 7296 	mov.w	r2, #300	; 0x12c

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 8003066:	bf08      	it	eq
 8003068:	f043 0301 	orreq.w	r3, r3, #1
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 800306c:	4350      	muls	r0, r2
 800306e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003072:	fb90 f0f2 	sdiv	r0, r0, r2
 8003076:	3001      	adds	r0, #1
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 8003078:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 800307c:	8420      	strh	r0, [r4, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 800307e:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003080:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003082:	8969      	ldrh	r1, [r5, #10]
 8003084:	88aa      	ldrh	r2, [r5, #4]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003086:	b29b      	uxth	r3, r3
 8003088:	f043 0301 	orr.w	r3, r3, #1
 800308c:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 800308e:	8823      	ldrh	r3, [r4, #0]
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8003090:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8003094:	f023 0302 	bic.w	r3, r3, #2
 8003098:	041b      	lsls	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 800309a:	430a      	orrs	r2, r1

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 800309c:	0c1b      	lsrs	r3, r3, #16
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 800309e:	4313      	orrs	r3, r2
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 80030a0:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 80030a2:	892a      	ldrh	r2, [r5, #8]
 80030a4:	89ab      	ldrh	r3, [r5, #12]
 80030a6:	4313      	orrs	r3, r2
 80030a8:	8123      	strh	r3, [r4, #8]
}
 80030aa:	b005      	add	sp, #20
 80030ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80030ae:	bf00      	nop
 80030b0:	000f4240 	.word	0x000f4240
 80030b4:	000186a0 	.word	0x000186a0

080030b8 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 80030b8:	f241 3388 	movw	r3, #5000	; 0x1388
 80030bc:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 80030be:	2300      	movs	r3, #0
 80030c0:	8083      	strh	r3, [r0, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 80030c2:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 80030c6:	8103      	strh	r3, [r0, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 80030c8:	8143      	strh	r3, [r0, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80030ca:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 80030ce:	80c2      	strh	r2, [r0, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80030d0:	8183      	strh	r3, [r0, #12]
 80030d2:	4770      	bx	lr

080030d4 <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 80030d4:	8803      	ldrh	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80030d6:	b119      	cbz	r1, 80030e0 <I2C_Cmd+0xc>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 80030d8:	b29b      	uxth	r3, r3
 80030da:	f043 0301 	orr.w	r3, r3, #1
 80030de:	e003      	b.n	80030e8 <I2C_Cmd+0x14>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80030e0:	f023 0301 	bic.w	r3, r3, #1
 80030e4:	041b      	lsls	r3, r3, #16
 80030e6:	0c1b      	lsrs	r3, r3, #16
 80030e8:	8003      	strh	r3, [r0, #0]
 80030ea:	4770      	bx	lr

080030ec <I2C_GenerateSTART>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 80030ec:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80030ee:	b119      	cbz	r1, 80030f8 <I2C_GenerateSTART+0xc>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
 80030f0:	b29b      	uxth	r3, r3
 80030f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80030f6:	e003      	b.n	8003100 <I2C_GenerateSTART+0x14>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 80030f8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80030fc:	041b      	lsls	r3, r3, #16
 80030fe:	0c1b      	lsrs	r3, r3, #16
 8003100:	8003      	strh	r3, [r0, #0]
 8003102:	4770      	bx	lr

08003104 <I2C_GenerateSTOP>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8003104:	8803      	ldrh	r3, [r0, #0]
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003106:	b119      	cbz	r1, 8003110 <I2C_GenerateSTOP+0xc>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8003108:	b29b      	uxth	r3, r3
 800310a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800310e:	e003      	b.n	8003118 <I2C_GenerateSTOP+0x14>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 8003110:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003114:	041b      	lsls	r3, r3, #16
 8003116:	0c1b      	lsrs	r3, r3, #16
 8003118:	8003      	strh	r3, [r0, #0]
 800311a:	4770      	bx	lr

0800311c <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800311c:	b112      	cbz	r2, 8003124 <I2C_Send7bitAddress+0x8>
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
 800311e:	f041 0101 	orr.w	r1, r1, #1
 8003122:	e001      	b.n	8003128 <I2C_Send7bitAddress+0xc>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 8003124:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8003128:	8201      	strh	r1, [r0, #16]
 800312a:	4770      	bx	lr

0800312c <I2C_AcknowledgeConfig>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 800312c:	8803      	ldrh	r3, [r0, #0]
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800312e:	b119      	cbz	r1, 8003138 <I2C_AcknowledgeConfig+0xc>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
 8003130:	b29b      	uxth	r3, r3
 8003132:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003136:	e003      	b.n	8003140 <I2C_AcknowledgeConfig+0x14>
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 8003138:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800313c:	041b      	lsls	r3, r3, #16
 800313e:	0c1b      	lsrs	r3, r3, #16
 8003140:	8003      	strh	r3, [r0, #0]
 8003142:	4770      	bx	lr

08003144 <I2C_OwnAddress2Config>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8003144:	8983      	ldrh	r3, [r0, #12]
 8003146:	b29b      	uxth	r3, r3

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8003148:	f001 01fe 	and.w	r1, r1, #254	; 0xfe

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 800314c:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8003150:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8003152:	8183      	strh	r3, [r0, #12]
 8003154:	4770      	bx	lr

08003156 <I2C_DualAddressCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 8003156:	8983      	ldrh	r3, [r0, #12]
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003158:	b119      	cbz	r1, 8003162 <I2C_DualAddressCmd+0xc>
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 800315a:	b29b      	uxth	r3, r3
 800315c:	f043 0301 	orr.w	r3, r3, #1
 8003160:	e003      	b.n	800316a <I2C_DualAddressCmd+0x14>
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 8003162:	f023 0301 	bic.w	r3, r3, #1
 8003166:	041b      	lsls	r3, r3, #16
 8003168:	0c1b      	lsrs	r3, r3, #16
 800316a:	8183      	strh	r3, [r0, #12]
 800316c:	4770      	bx	lr

0800316e <I2C_GeneralCallCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 800316e:	8803      	ldrh	r3, [r0, #0]
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003170:	b119      	cbz	r1, 800317a <I2C_GeneralCallCmd+0xc>
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
 8003172:	b29b      	uxth	r3, r3
 8003174:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003178:	e003      	b.n	8003182 <I2C_GeneralCallCmd+0x14>
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 800317a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800317e:	041b      	lsls	r3, r3, #16
 8003180:	0c1b      	lsrs	r3, r3, #16
 8003182:	8003      	strh	r3, [r0, #0]
 8003184:	4770      	bx	lr

08003186 <I2C_SoftwareResetCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 8003186:	8803      	ldrh	r3, [r0, #0]
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003188:	b121      	cbz	r1, 8003194 <I2C_SoftwareResetCmd+0xe>
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
 800318a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800318e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003192:	e001      	b.n	8003198 <I2C_SoftwareResetCmd+0x12>
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 8003194:	045b      	lsls	r3, r3, #17
 8003196:	0c5b      	lsrs	r3, r3, #17
 8003198:	8003      	strh	r3, [r0, #0]
 800319a:	4770      	bx	lr

0800319c <I2C_StretchClockCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 800319c:	8803      	ldrh	r3, [r0, #0]
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 800319e:	b919      	cbnz	r1, 80031a8 <I2C_StretchClockCmd+0xc>
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 80031a0:	b29b      	uxth	r3, r3
 80031a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031a6:	e003      	b.n	80031b0 <I2C_StretchClockCmd+0x14>
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 80031a8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80031ac:	041b      	lsls	r3, r3, #16
 80031ae:	0c1b      	lsrs	r3, r3, #16
 80031b0:	8003      	strh	r3, [r0, #0]
 80031b2:	4770      	bx	lr

080031b4 <I2C_FastModeDutyCycleConfig>:
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 80031b4:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 80031b8:	8b83      	ldrh	r3, [r0, #28]
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 80031ba:	d004      	beq.n	80031c6 <I2C_FastModeDutyCycleConfig+0x12>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 80031bc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80031c0:	041b      	lsls	r3, r3, #16
 80031c2:	0c1b      	lsrs	r3, r3, #16
 80031c4:	e002      	b.n	80031cc <I2C_FastModeDutyCycleConfig+0x18>
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 80031c6:	b29b      	uxth	r3, r3
 80031c8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80031cc:	8383      	strh	r3, [r0, #28]
 80031ce:	4770      	bx	lr

080031d0 <I2C_NACKPositionConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 80031d0:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 80031d4:	8803      	ldrh	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 80031d6:	d103      	bne.n	80031e0 <I2C_NACKPositionConfig+0x10>
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 80031d8:	b29b      	uxth	r3, r3
 80031da:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80031de:	e003      	b.n	80031e8 <I2C_NACKPositionConfig+0x18>
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 80031e0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80031e4:	041b      	lsls	r3, r3, #16
 80031e6:	0c1b      	lsrs	r3, r3, #16
 80031e8:	8003      	strh	r3, [r0, #0]
 80031ea:	4770      	bx	lr

080031ec <I2C_SMBusAlertConfig>:
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 80031ec:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 80031f0:	8803      	ldrh	r3, [r0, #0]
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 80031f2:	d103      	bne.n	80031fc <I2C_SMBusAlertConfig+0x10>
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 80031f4:	b29b      	uxth	r3, r3
 80031f6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80031fa:	e003      	b.n	8003204 <I2C_SMBusAlertConfig+0x18>
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 80031fc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003200:	041b      	lsls	r3, r3, #16
 8003202:	0c1b      	lsrs	r3, r3, #16
 8003204:	8003      	strh	r3, [r0, #0]
 8003206:	4770      	bx	lr

08003208 <I2C_ARPCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 8003208:	8803      	ldrh	r3, [r0, #0]
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800320a:	b119      	cbz	r1, 8003214 <I2C_ARPCmd+0xc>
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
 800320c:	b29b      	uxth	r3, r3
 800320e:	f043 0310 	orr.w	r3, r3, #16
 8003212:	e003      	b.n	800321c <I2C_ARPCmd+0x14>
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 8003214:	f023 0310 	bic.w	r3, r3, #16
 8003218:	041b      	lsls	r3, r3, #16
 800321a:	0c1b      	lsrs	r3, r3, #16
 800321c:	8003      	strh	r3, [r0, #0]
 800321e:	4770      	bx	lr

08003220 <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8003220:	8201      	strh	r1, [r0, #16]
 8003222:	4770      	bx	lr

08003224 <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8003224:	8a00      	ldrh	r0, [r0, #16]
}
 8003226:	b2c0      	uxtb	r0, r0
 8003228:	4770      	bx	lr

0800322a <I2C_TransmitPEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 800322a:	8803      	ldrh	r3, [r0, #0]
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800322c:	b119      	cbz	r1, 8003236 <I2C_TransmitPEC+0xc>
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
 800322e:	b29b      	uxth	r3, r3
 8003230:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003234:	e003      	b.n	800323e <I2C_TransmitPEC+0x14>
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 8003236:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800323a:	041b      	lsls	r3, r3, #16
 800323c:	0c1b      	lsrs	r3, r3, #16
 800323e:	8003      	strh	r3, [r0, #0]
 8003240:	4770      	bx	lr

08003242 <I2C_PECPositionConfig>:
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8003242:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 8003246:	8803      	ldrh	r3, [r0, #0]
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8003248:	d103      	bne.n	8003252 <I2C_PECPositionConfig+0x10>
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
 800324a:	b29b      	uxth	r3, r3
 800324c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003250:	e003      	b.n	800325a <I2C_PECPositionConfig+0x18>
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 8003252:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003256:	041b      	lsls	r3, r3, #16
 8003258:	0c1b      	lsrs	r3, r3, #16
 800325a:	8003      	strh	r3, [r0, #0]
 800325c:	4770      	bx	lr

0800325e <I2C_CalculatePEC>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 800325e:	8803      	ldrh	r3, [r0, #0]
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003260:	b119      	cbz	r1, 800326a <I2C_CalculatePEC+0xc>
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 8003262:	b29b      	uxth	r3, r3
 8003264:	f043 0320 	orr.w	r3, r3, #32
 8003268:	e003      	b.n	8003272 <I2C_CalculatePEC+0x14>
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 800326a:	f023 0320 	bic.w	r3, r3, #32
 800326e:	041b      	lsls	r3, r3, #16
 8003270:	0c1b      	lsrs	r3, r3, #16
 8003272:	8003      	strh	r3, [r0, #0]
 8003274:	4770      	bx	lr

08003276 <I2C_GetPEC>:
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 8003276:	8b00      	ldrh	r0, [r0, #24]
}
 8003278:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800327c:	4770      	bx	lr

0800327e <I2C_DMACmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 800327e:	8883      	ldrh	r3, [r0, #4]
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003280:	b119      	cbz	r1, 800328a <I2C_DMACmd+0xc>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 8003282:	b29b      	uxth	r3, r3
 8003284:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003288:	e003      	b.n	8003292 <I2C_DMACmd+0x14>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 800328a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800328e:	041b      	lsls	r3, r3, #16
 8003290:	0c1b      	lsrs	r3, r3, #16
 8003292:	8083      	strh	r3, [r0, #4]
 8003294:	4770      	bx	lr

08003296 <I2C_DMALastTransferCmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 8003296:	8883      	ldrh	r3, [r0, #4]
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003298:	b119      	cbz	r1, 80032a2 <I2C_DMALastTransferCmd+0xc>
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
 800329a:	b29b      	uxth	r3, r3
 800329c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80032a0:	e003      	b.n	80032aa <I2C_DMALastTransferCmd+0x14>
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 80032a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80032a6:	041b      	lsls	r3, r3, #16
 80032a8:	0c1b      	lsrs	r3, r3, #16
 80032aa:	8083      	strh	r3, [r0, #4]
 80032ac:	4770      	bx	lr

080032ae <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 80032ae:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80032b0:	2300      	movs	r3, #0
 80032b2:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 80032b4:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 80032b6:	9b01      	ldr	r3, [sp, #4]
 80032b8:	18c9      	adds	r1, r1, r3
 80032ba:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 80032bc:	9b01      	ldr	r3, [sp, #4]
 80032be:	8818      	ldrh	r0, [r3, #0]
}
 80032c0:	b280      	uxth	r0, r0
 80032c2:	b002      	add	sp, #8
 80032c4:	4770      	bx	lr

080032c6 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 80032c6:	8883      	ldrh	r3, [r0, #4]
 80032c8:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 80032ca:	b10a      	cbz	r2, 80032d0 <I2C_ITConfig+0xa>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 80032cc:	4319      	orrs	r1, r3
 80032ce:	e001      	b.n	80032d4 <I2C_ITConfig+0xe>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 80032d0:	ea23 0101 	bic.w	r1, r3, r1
 80032d4:	8081      	strh	r1, [r0, #4]
 80032d6:	4770      	bx	lr

080032d8 <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80032d8:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 80032da:	8b00      	ldrh	r0, [r0, #24]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80032dc:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 80032de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80032e2:	4008      	ands	r0, r1

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 80032e4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  }
  /* Return status */
  return status;
}
 80032e8:	1a43      	subs	r3, r0, r1
 80032ea:	4258      	negs	r0, r3
 80032ec:	4158      	adcs	r0, r3
 80032ee:	4770      	bx	lr

080032f0 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80032f0:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 80032f2:	8b00      	ldrh	r0, [r0, #24]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 80032f4:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 80032f6:	ea43 4000 	orr.w	r0, r3, r0, lsl #16

  /* Return status */
  return lastevent;
}
 80032fa:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80032fe:	4770      	bx	lr

08003300 <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8003300:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 8003302:	2300      	movs	r3, #0
 8003304:	9300      	str	r3, [sp, #0]
 8003306:	9301      	str	r3, [sp, #4]

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 8003308:	0f0b      	lsrs	r3, r1, #28
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 800330a:	9001      	str	r0, [sp, #4]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 800330c:	9300      	str	r3, [sp, #0]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
  
  if(i2creg != 0)
 800330e:	9b00      	ldr	r3, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 8003310:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 8003314:	b113      	cbz	r3, 800331c <I2C_GetFlagStatus+0x1c>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 8003316:	9b01      	ldr	r3, [sp, #4]
 8003318:	3314      	adds	r3, #20
 800331a:	e002      	b.n	8003322 <I2C_GetFlagStatus+0x22>
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 800331c:	9b01      	ldr	r3, [sp, #4]
    i2cxbase += 0x14;
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 800331e:	0c09      	lsrs	r1, r1, #16
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 8003320:	3318      	adds	r3, #24
 8003322:	9301      	str	r3, [sp, #4]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8003324:	9b01      	ldr	r3, [sp, #4]
 8003326:	681b      	ldr	r3, [r3, #0]
 8003328:	4219      	tst	r1, r3
    bitstatus = RESET;
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 800332a:	bf0c      	ite	eq
 800332c:	2000      	moveq	r0, #0
 800332e:	2001      	movne	r0, #1
 8003330:	b002      	add	sp, #8
 8003332:	4770      	bx	lr

08003334 <I2C_ClearFlag>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8003334:	43c9      	mvns	r1, r1
 8003336:	8281      	strh	r1, [r0, #20]
 8003338:	4770      	bx	lr

0800333a <I2C_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 800333a:	8883      	ldrh	r3, [r0, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 800333c:	8a80      	ldrh	r0, [r0, #20]
 800333e:	b280      	uxth	r0, r0
 8003340:	4008      	ands	r0, r1
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8003342:	b29b      	uxth	r3, r3
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 8003344:	d006      	beq.n	8003354 <I2C_GetITStatus+0x1a>
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 8003346:	f001 61e0 	and.w	r1, r1, #117440512	; 0x7000000
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 800334a:	ea13 4111 	ands.w	r1, r3, r1, lsr #16
  {
    /* I2C_IT is set */
    bitstatus = SET;
 800334e:	bf0c      	ite	eq
 8003350:	2000      	moveq	r0, #0
 8003352:	2001      	movne	r0, #1
    /* I2C_IT is reset */
    bitstatus = RESET;
  }
  /* Return the I2C_IT status */
  return  bitstatus;
}
 8003354:	4770      	bx	lr

08003356 <I2C_ClearITPendingBit>:

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8003356:	43c9      	mvns	r1, r1
 8003358:	8281      	strh	r1, [r0, #20]
 800335a:	4770      	bx	lr

0800335c <IWDG_WriteAccessCmd>:
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
  IWDG->KR = IWDG_WriteAccess;
 800335c:	4b01      	ldr	r3, [pc, #4]	; (8003364 <IWDG_WriteAccessCmd+0x8>)
 800335e:	6018      	str	r0, [r3, #0]
 8003360:	4770      	bx	lr
 8003362:	bf00      	nop
 8003364:	40003000 	.word	0x40003000

08003368 <IWDG_SetPrescaler>:
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
  IWDG->PR = IWDG_Prescaler;
 8003368:	4b01      	ldr	r3, [pc, #4]	; (8003370 <IWDG_SetPrescaler+0x8>)
 800336a:	6058      	str	r0, [r3, #4]
 800336c:	4770      	bx	lr
 800336e:	bf00      	nop
 8003370:	40003000 	.word	0x40003000

08003374 <IWDG_SetReload>:
  */
void IWDG_SetReload(uint16_t Reload)
{
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
  IWDG->RLR = Reload;
 8003374:	4b01      	ldr	r3, [pc, #4]	; (800337c <IWDG_SetReload+0x8>)
 8003376:	6098      	str	r0, [r3, #8]
 8003378:	4770      	bx	lr
 800337a:	bf00      	nop
 800337c:	40003000 	.word	0x40003000

08003380 <IWDG_ReloadCounter>:
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
  IWDG->KR = KR_KEY_RELOAD;
 8003380:	4b02      	ldr	r3, [pc, #8]	; (800338c <IWDG_ReloadCounter+0xc>)
 8003382:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8003386:	601a      	str	r2, [r3, #0]
 8003388:	4770      	bx	lr
 800338a:	bf00      	nop
 800338c:	40003000 	.word	0x40003000

08003390 <IWDG_Enable>:
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
  IWDG->KR = KR_KEY_ENABLE;
 8003390:	4b02      	ldr	r3, [pc, #8]	; (800339c <IWDG_Enable+0xc>)
 8003392:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8003396:	601a      	str	r2, [r3, #0]
 8003398:	4770      	bx	lr
 800339a:	bf00      	nop
 800339c:	40003000 	.word	0x40003000

080033a0 <IWDG_GetFlagStatus>:
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
 80033a0:	4b03      	ldr	r3, [pc, #12]	; (80033b0 <IWDG_GetFlagStatus+0x10>)
 80033a2:	68db      	ldr	r3, [r3, #12]
 80033a4:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 80033a6:	bf0c      	ite	eq
 80033a8:	2000      	moveq	r0, #0
 80033aa:	2001      	movne	r0, #1
 80033ac:	4770      	bx	lr
 80033ae:	bf00      	nop
 80033b0:	40003000 	.word	0x40003000

080033b4 <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 80033b4:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80033b6:	2101      	movs	r1, #1
 80033b8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80033bc:	f000 fa02 	bl	80037c4 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80033c0:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80033c4:	2100      	movs	r1, #0
}
 80033c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void PWR_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80033ca:	f000 b9fb 	b.w	80037c4 <RCC_APB1PeriphResetCmd>

080033ce <PWR_BackupAccessCmd>:
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80033ce:	4b01      	ldr	r3, [pc, #4]	; (80033d4 <PWR_BackupAccessCmd+0x6>)
 80033d0:	6018      	str	r0, [r3, #0]
 80033d2:	4770      	bx	lr
 80033d4:	420e0020 	.word	0x420e0020

080033d8 <PWR_PVDLevelConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 80033d8:	4b03      	ldr	r3, [pc, #12]	; (80033e8 <PWR_PVDLevelConfig+0x10>)
 80033da:	681a      	ldr	r2, [r3, #0]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 80033dc:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 80033e0:	4310      	orrs	r0, r2
  
  /* Store the new value */
  PWR->CR = tmpreg;
 80033e2:	6018      	str	r0, [r3, #0]
 80033e4:	4770      	bx	lr
 80033e6:	bf00      	nop
 80033e8:	40007000 	.word	0x40007000

080033ec <PWR_PVDCmd>:
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 80033ec:	4b01      	ldr	r3, [pc, #4]	; (80033f4 <PWR_PVDCmd+0x8>)
 80033ee:	6018      	str	r0, [r3, #0]
 80033f0:	4770      	bx	lr
 80033f2:	bf00      	nop
 80033f4:	420e0010 	.word	0x420e0010

080033f8 <PWR_WakeUpPinCmd>:
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
  /* Check the parameters */  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 80033f8:	4b01      	ldr	r3, [pc, #4]	; (8003400 <PWR_WakeUpPinCmd+0x8>)
 80033fa:	6018      	str	r0, [r3, #0]
 80033fc:	4770      	bx	lr
 80033fe:	bf00      	nop
 8003400:	420e00a0 	.word	0x420e00a0

08003404 <PWR_BackupRegulatorCmd>:
void PWR_BackupRegulatorCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 8003404:	4b01      	ldr	r3, [pc, #4]	; (800340c <PWR_BackupRegulatorCmd+0x8>)
 8003406:	6018      	str	r0, [r3, #0]
 8003408:	4770      	bx	lr
 800340a:	bf00      	nop
 800340c:	420e00a4 	.word	0x420e00a4

08003410 <PWR_MainRegulatorModeConfig>:
  *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
  *                                                System frequency up to 144 MHz.    
  * @retval None
  */
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
{
 8003410:	4b04      	ldr	r3, [pc, #16]	; (8003424 <PWR_MainRegulatorModeConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
  {
    PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 8003412:	681a      	ldr	r2, [r3, #0]
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
{
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
 8003414:	b910      	cbnz	r0, 800341c <PWR_MainRegulatorModeConfig+0xc>
  {
    PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 8003416:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800341a:	e001      	b.n	8003420 <PWR_MainRegulatorModeConfig+0x10>
  }
  else
  {    
    PWR->CR |= PWR_Regulator_Voltage_Scale1;
 800341c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003420:	601a      	str	r2, [r3, #0]
 8003422:	4770      	bx	lr
 8003424:	40007000 	.word	0x40007000

08003428 <PWR_FlashPowerDownCmd>:
void PWR_FlashPowerDownCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 8003428:	4b01      	ldr	r3, [pc, #4]	; (8003430 <PWR_FlashPowerDownCmd+0x8>)
 800342a:	6018      	str	r0, [r3, #0]
 800342c:	4770      	bx	lr
 800342e:	bf00      	nop
 8003430:	420e0024 	.word	0x420e0024

08003434 <PWR_EnterSTOPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 8003434:	4b0a      	ldr	r3, [pc, #40]	; (8003460 <PWR_EnterSTOPMode+0x2c>)
 8003436:	681a      	ldr	r2, [r3, #0]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 8003438:	f022 0203 	bic.w	r2, r2, #3
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 800343c:	4310      	orrs	r0, r2
  
  /* Store the new value */
  PWR->CR = tmpreg;
 800343e:	6018      	str	r0, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8003440:	4b08      	ldr	r3, [pc, #32]	; (8003464 <PWR_EnterSTOPMode+0x30>)
 8003442:	691a      	ldr	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 8003444:	2901      	cmp	r1, #1
  
  /* Store the new value */
  PWR->CR = tmpreg;
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8003446:	f042 0204 	orr.w	r2, r2, #4
 800344a:	611a      	str	r2, [r3, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 800344c:	d101      	bne.n	8003452 <PWR_EnterSTOPMode+0x1e>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800344e:	bf30      	wfi
 8003450:	e000      	b.n	8003454 <PWR_EnterSTOPMode+0x20>
    Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
 8003452:	bf20      	wfe
  {
    /* Request Wait For Event */
    __WFE();
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 8003454:	691a      	ldr	r2, [r3, #16]
 8003456:	f022 0204 	bic.w	r2, r2, #4
 800345a:	611a      	str	r2, [r3, #16]
 800345c:	4770      	bx	lr
 800345e:	bf00      	nop
 8003460:	40007000 	.word	0x40007000
 8003464:	e000ed00 	.word	0xe000ed00

08003468 <PWR_EnterSTANDBYMode>:
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
  /* Clear Wakeup flag */
  PWR->CR |= PWR_CR_CWUF;
 8003468:	4b07      	ldr	r3, [pc, #28]	; (8003488 <PWR_EnterSTANDBYMode+0x20>)
 800346a:	681a      	ldr	r2, [r3, #0]
 800346c:	f042 0204 	orr.w	r2, r2, #4
 8003470:	601a      	str	r2, [r3, #0]
  
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 8003472:	681a      	ldr	r2, [r3, #0]
 8003474:	f042 0202 	orr.w	r2, r2, #2
 8003478:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800347a:	4b04      	ldr	r3, [pc, #16]	; (800348c <PWR_EnterSTANDBYMode+0x24>)
 800347c:	691a      	ldr	r2, [r3, #16]
 800347e:	f042 0204 	orr.w	r2, r2, #4
 8003482:	611a      	str	r2, [r3, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8003484:	bf30      	wfi
 8003486:	4770      	bx	lr
 8003488:	40007000 	.word	0x40007000
 800348c:	e000ed00 	.word	0xe000ed00

08003490 <PWR_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 8003490:	4b03      	ldr	r3, [pc, #12]	; (80034a0 <PWR_GetFlagStatus+0x10>)
 8003492:	685b      	ldr	r3, [r3, #4]
 8003494:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8003496:	bf0c      	ite	eq
 8003498:	2000      	moveq	r0, #0
 800349a:	2001      	movne	r0, #1
 800349c:	4770      	bx	lr
 800349e:	bf00      	nop
 80034a0:	40007000 	.word	0x40007000

080034a4 <PWR_ClearFlag>:
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 80034a4:	4b02      	ldr	r3, [pc, #8]	; (80034b0 <PWR_ClearFlag+0xc>)
 80034a6:	681a      	ldr	r2, [r3, #0]
 80034a8:	ea42 0080 	orr.w	r0, r2, r0, lsl #2
 80034ac:	6018      	str	r0, [r3, #0]
 80034ae:	4770      	bx	lr
 80034b0:	40007000 	.word	0x40007000

080034b4 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80034b4:	4b0a      	ldr	r3, [pc, #40]	; (80034e0 <RCC_DeInit+0x2c>)
 80034b6:	681a      	ldr	r2, [r3, #0]
 80034b8:	f042 0201 	orr.w	r2, r2, #1
 80034bc:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80034be:	2200      	movs	r2, #0
 80034c0:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80034c2:	6819      	ldr	r1, [r3, #0]
 80034c4:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 80034c8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80034cc:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80034ce:	4905      	ldr	r1, [pc, #20]	; (80034e4 <RCC_DeInit+0x30>)
 80034d0:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80034d2:	6819      	ldr	r1, [r3, #0]
 80034d4:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 80034d8:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80034da:	60da      	str	r2, [r3, #12]
 80034dc:	4770      	bx	lr
 80034de:	bf00      	nop
 80034e0:	40023800 	.word	0x40023800
 80034e4:	24003010 	.word	0x24003010

080034e8 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 80034e8:	4b02      	ldr	r3, [pc, #8]	; (80034f4 <RCC_HSEConfig+0xc>)
 80034ea:	2200      	movs	r2, #0
 80034ec:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 80034ee:	7018      	strb	r0, [r3, #0]
 80034f0:	4770      	bx	lr
 80034f2:	bf00      	nop
 80034f4:	40023802 	.word	0x40023802

080034f8 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 80034f8:	4b03      	ldr	r3, [pc, #12]	; (8003508 <RCC_AdjustHSICalibrationValue+0x10>)
 80034fa:	681a      	ldr	r2, [r3, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 80034fc:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8003500:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8003504:	6018      	str	r0, [r3, #0]
 8003506:	4770      	bx	lr
 8003508:	40023800 	.word	0x40023800

0800350c <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 800350c:	4b01      	ldr	r3, [pc, #4]	; (8003514 <RCC_HSICmd+0x8>)
 800350e:	6018      	str	r0, [r3, #0]
 8003510:	4770      	bx	lr
 8003512:	bf00      	nop
 8003514:	42470000 	.word	0x42470000

08003518 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8003518:	4b06      	ldr	r3, [pc, #24]	; (8003534 <RCC_LSEConfig+0x1c>)
 800351a:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 800351c:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800351e:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8003520:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8003522:	d002      	beq.n	800352a <RCC_LSEConfig+0x12>
 8003524:	2804      	cmp	r0, #4
 8003526:	d104      	bne.n	8003532 <RCC_LSEConfig+0x1a>
 8003528:	e001      	b.n	800352e <RCC_LSEConfig+0x16>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 800352a:	7018      	strb	r0, [r3, #0]
      break;
 800352c:	4770      	bx	lr
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 800352e:	2205      	movs	r2, #5
 8003530:	701a      	strb	r2, [r3, #0]
 8003532:	4770      	bx	lr
 8003534:	40023870 	.word	0x40023870

08003538 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8003538:	4b01      	ldr	r3, [pc, #4]	; (8003540 <RCC_LSICmd+0x8>)
 800353a:	6018      	str	r0, [r3, #0]
 800353c:	4770      	bx	lr
 800353e:	bf00      	nop
 8003540:	42470e80 	.word	0x42470e80

08003544 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8003544:	b510      	push	{r4, lr}
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8003546:	9c02      	ldr	r4, [sp, #8]
 8003548:	4301      	orrs	r1, r0
 800354a:	ea41 1282 	orr.w	r2, r1, r2, lsl #6
 800354e:	085b      	lsrs	r3, r3, #1
 8003550:	3b01      	subs	r3, #1
 8003552:	ea42 6404 	orr.w	r4, r2, r4, lsl #24
 8003556:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800355a:	4b01      	ldr	r3, [pc, #4]	; (8003560 <RCC_PLLConfig+0x1c>)
 800355c:	605c      	str	r4, [r3, #4]
 800355e:	bd10      	pop	{r4, pc}
 8003560:	40023800 	.word	0x40023800

08003564 <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8003564:	4b01      	ldr	r3, [pc, #4]	; (800356c <RCC_PLLCmd+0x8>)
 8003566:	6018      	str	r0, [r3, #0]
 8003568:	4770      	bx	lr
 800356a:	bf00      	nop
 800356c:	42470060 	.word	0x42470060

08003570 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8003570:	0180      	lsls	r0, r0, #6
 8003572:	4b03      	ldr	r3, [pc, #12]	; (8003580 <RCC_PLLI2SConfig+0x10>)
 8003574:	ea40 7101 	orr.w	r1, r0, r1, lsl #28
 8003578:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
 800357c:	4770      	bx	lr
 800357e:	bf00      	nop
 8003580:	40023800 	.word	0x40023800

08003584 <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8003584:	4b01      	ldr	r3, [pc, #4]	; (800358c <RCC_PLLI2SCmd+0x8>)
 8003586:	6018      	str	r0, [r3, #0]
 8003588:	4770      	bx	lr
 800358a:	bf00      	nop
 800358c:	42470068 	.word	0x42470068

08003590 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8003590:	4b01      	ldr	r3, [pc, #4]	; (8003598 <RCC_ClockSecuritySystemCmd+0x8>)
 8003592:	6018      	str	r0, [r3, #0]
 8003594:	4770      	bx	lr
 8003596:	bf00      	nop
 8003598:	4247004c 	.word	0x4247004c

0800359c <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 800359c:	4b03      	ldr	r3, [pc, #12]	; (80035ac <RCC_MCO1Config+0x10>)
 800359e:	689a      	ldr	r2, [r3, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 80035a0:	f022 62ec 	bic.w	r2, r2, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 80035a4:	4310      	orrs	r0, r2
 80035a6:	4301      	orrs	r1, r0

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80035a8:	6099      	str	r1, [r3, #8]
 80035aa:	4770      	bx	lr
 80035ac:	40023800 	.word	0x40023800

080035b0 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 80035b0:	4b03      	ldr	r3, [pc, #12]	; (80035c0 <RCC_MCO2Config+0x10>)
 80035b2:	689a      	ldr	r2, [r3, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 80035b4:	f022 4278 	bic.w	r2, r2, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 80035b8:	4310      	orrs	r0, r2
 80035ba:	4301      	orrs	r1, r0

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 80035bc:	6099      	str	r1, [r3, #8]
 80035be:	4770      	bx	lr
 80035c0:	40023800 	.word	0x40023800

080035c4 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 80035c4:	4b03      	ldr	r3, [pc, #12]	; (80035d4 <RCC_SYSCLKConfig+0x10>)
 80035c6:	689a      	ldr	r2, [r3, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 80035c8:	f022 0203 	bic.w	r2, r2, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80035cc:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80035ce:	6098      	str	r0, [r3, #8]
 80035d0:	4770      	bx	lr
 80035d2:	bf00      	nop
 80035d4:	40023800 	.word	0x40023800

080035d8 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 80035d8:	4b02      	ldr	r3, [pc, #8]	; (80035e4 <RCC_GetSYSCLKSource+0xc>)
 80035da:	6898      	ldr	r0, [r3, #8]
}
 80035dc:	f000 000c 	and.w	r0, r0, #12
 80035e0:	4770      	bx	lr
 80035e2:	bf00      	nop
 80035e4:	40023800 	.word	0x40023800

080035e8 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80035e8:	4b03      	ldr	r3, [pc, #12]	; (80035f8 <RCC_HCLKConfig+0x10>)
 80035ea:	689a      	ldr	r2, [r3, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 80035ec:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80035f0:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80035f2:	6098      	str	r0, [r3, #8]
 80035f4:	4770      	bx	lr
 80035f6:	bf00      	nop
 80035f8:	40023800 	.word	0x40023800

080035fc <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80035fc:	4b03      	ldr	r3, [pc, #12]	; (800360c <RCC_PCLK1Config+0x10>)
 80035fe:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8003600:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8003604:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003606:	6098      	str	r0, [r3, #8]
 8003608:	4770      	bx	lr
 800360a:	bf00      	nop
 800360c:	40023800 	.word	0x40023800

08003610 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8003610:	4b03      	ldr	r3, [pc, #12]	; (8003620 <RCC_PCLK2Config+0x10>)
 8003612:	689a      	ldr	r2, [r3, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8003614:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8003618:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800361c:	6098      	str	r0, [r3, #8]
 800361e:	4770      	bx	lr
 8003620:	40023800 	.word	0x40023800

08003624 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8003624:	4b1e      	ldr	r3, [pc, #120]	; (80036a0 <RCC_GetClocksFreq+0x7c>)
 8003626:	689a      	ldr	r2, [r3, #8]
 8003628:	f002 020c 	and.w	r2, r2, #12

  switch (tmp)
 800362c:	2a04      	cmp	r2, #4
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800362e:	b510      	push	{r4, lr}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
 8003630:	d003      	beq.n	800363a <RCC_GetClocksFreq+0x16>
 8003632:	2a08      	cmp	r2, #8
 8003634:	d003      	beq.n	800363e <RCC_GetClocksFreq+0x1a>
 8003636:	4b1b      	ldr	r3, [pc, #108]	; (80036a4 <RCC_GetClocksFreq+0x80>)
 8003638:	e018      	b.n	800366c <RCC_GetClocksFreq+0x48>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800363a:	4b1b      	ldr	r3, [pc, #108]	; (80036a8 <RCC_GetClocksFreq+0x84>)
 800363c:	e016      	b.n	800366c <RCC_GetClocksFreq+0x48>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800363e:	6859      	ldr	r1, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003640:	685a      	ldr	r2, [r3, #4]
      
      if (pllsource != 0)
 8003642:	f411 0f80 	tst.w	r1, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8003646:	6859      	ldr	r1, [r3, #4]
 8003648:	bf14      	ite	ne
 800364a:	4b17      	ldrne	r3, [pc, #92]	; (80036a8 <RCC_GetClocksFreq+0x84>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800364c:	4b15      	ldreq	r3, [pc, #84]	; (80036a4 <RCC_GetClocksFreq+0x80>)

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800364e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8003652:	fbb3 f3f2 	udiv	r3, r3, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8003656:	4a12      	ldr	r2, [pc, #72]	; (80036a0 <RCC_GetClocksFreq+0x7c>)
 8003658:	6852      	ldr	r2, [r2, #4]
 800365a:	f3c2 4201 	ubfx	r2, r2, #16, #2
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800365e:	f3c1 1188 	ubfx	r1, r1, #6, #9
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8003662:	3201      	adds	r2, #1
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8003664:	434b      	muls	r3, r1
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8003666:	0052      	lsls	r2, r2, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8003668:	fbb3 f3f2 	udiv	r3, r3, r2
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800366c:	490c      	ldr	r1, [pc, #48]	; (80036a0 <RCC_GetClocksFreq+0x7c>)
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 800366e:	6003      	str	r3, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8003670:	688b      	ldr	r3, [r1, #8]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8003672:	4a0e      	ldr	r2, [pc, #56]	; (80036ac <RCC_GetClocksFreq+0x88>)
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  tmp = tmp >> 4;
 8003674:	f3c3 1303 	ubfx	r3, r3, #4, #4
  presc = APBAHBPrescTable[tmp];
 8003678:	5cd4      	ldrb	r4, [r2, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800367a:	6803      	ldr	r3, [r0, #0]
 800367c:	fa23 f304 	lsr.w	r3, r3, r4
 8003680:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8003682:	688c      	ldr	r4, [r1, #8]
  tmp = tmp >> 10;
 8003684:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8003688:	5d14      	ldrb	r4, [r2, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800368a:	fa23 f404 	lsr.w	r4, r3, r4
 800368e:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8003690:	6889      	ldr	r1, [r1, #8]
  tmp = tmp >> 13;
 8003692:	f3c1 3142 	ubfx	r1, r1, #13, #3
  presc = APBAHBPrescTable[tmp];
 8003696:	5c52      	ldrb	r2, [r2, r1]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8003698:	fa23 f302 	lsr.w	r3, r3, r2
 800369c:	60c3      	str	r3, [r0, #12]
 800369e:	bd10      	pop	{r4, pc}
 80036a0:	40023800 	.word	0x40023800
 80036a4:	00f42400 	.word	0x00f42400
 80036a8:	007a1200 	.word	0x007a1200
 80036ac:	20000000 	.word	0x20000000

080036b0 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 80036b0:	f400 7340 	and.w	r3, r0, #768	; 0x300
 80036b4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80036b8:	4b08      	ldr	r3, [pc, #32]	; (80036dc <RCC_RTCCLKConfig+0x2c>)
 80036ba:	d108      	bne.n	80036ce <RCC_RTCCLKConfig+0x1e>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 80036bc:	6899      	ldr	r1, [r3, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80036be:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 80036c2:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 80036c6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80036ca:	430a      	orrs	r2, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 80036cc:	609a      	str	r2, [r3, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 80036ce:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80036d0:	0500      	lsls	r0, r0, #20
 80036d2:	ea42 5010 	orr.w	r0, r2, r0, lsr #20
 80036d6:	6718      	str	r0, [r3, #112]	; 0x70
 80036d8:	4770      	bx	lr
 80036da:	bf00      	nop
 80036dc:	40023800 	.word	0x40023800

080036e0 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80036e0:	4b01      	ldr	r3, [pc, #4]	; (80036e8 <RCC_RTCCLKCmd+0x8>)
 80036e2:	6018      	str	r0, [r3, #0]
 80036e4:	4770      	bx	lr
 80036e6:	bf00      	nop
 80036e8:	42470e3c 	.word	0x42470e3c

080036ec <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80036ec:	4b01      	ldr	r3, [pc, #4]	; (80036f4 <RCC_BackupResetCmd+0x8>)
 80036ee:	6018      	str	r0, [r3, #0]
 80036f0:	4770      	bx	lr
 80036f2:	bf00      	nop
 80036f4:	42470e40 	.word	0x42470e40

080036f8 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80036f8:	4b01      	ldr	r3, [pc, #4]	; (8003700 <RCC_I2SCLKConfig+0x8>)
 80036fa:	6018      	str	r0, [r3, #0]
 80036fc:	4770      	bx	lr
 80036fe:	bf00      	nop
 8003700:	4247015c 	.word	0x4247015c

08003704 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8003704:	4b04      	ldr	r3, [pc, #16]	; (8003718 <RCC_AHB1PeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8003706:	6b1a      	ldr	r2, [r3, #48]	; 0x30
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003708:	b109      	cbz	r1, 800370e <RCC_AHB1PeriphClockCmd+0xa>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 800370a:	4310      	orrs	r0, r2
 800370c:	e001      	b.n	8003712 <RCC_AHB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 800370e:	ea22 0000 	bic.w	r0, r2, r0
 8003712:	6318      	str	r0, [r3, #48]	; 0x30
 8003714:	4770      	bx	lr
 8003716:	bf00      	nop
 8003718:	40023800 	.word	0x40023800

0800371c <RCC_AHB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800371c:	4b04      	ldr	r3, [pc, #16]	; (8003730 <RCC_AHB2PeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 800371e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003720:	b109      	cbz	r1, 8003726 <RCC_AHB2PeriphClockCmd+0xa>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8003722:	4310      	orrs	r0, r2
 8003724:	e001      	b.n	800372a <RCC_AHB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8003726:	ea22 0000 	bic.w	r0, r2, r0
 800372a:	6358      	str	r0, [r3, #52]	; 0x34
 800372c:	4770      	bx	lr
 800372e:	bf00      	nop
 8003730:	40023800 	.word	0x40023800

08003734 <RCC_AHB3PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8003734:	4b04      	ldr	r3, [pc, #16]	; (8003748 <RCC_AHB3PeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8003736:	6b9a      	ldr	r2, [r3, #56]	; 0x38
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003738:	b109      	cbz	r1, 800373e <RCC_AHB3PeriphClockCmd+0xa>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 800373a:	4310      	orrs	r0, r2
 800373c:	e001      	b.n	8003742 <RCC_AHB3PeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 800373e:	ea22 0000 	bic.w	r0, r2, r0
 8003742:	6398      	str	r0, [r3, #56]	; 0x38
 8003744:	4770      	bx	lr
 8003746:	bf00      	nop
 8003748:	40023800 	.word	0x40023800

0800374c <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800374c:	4b04      	ldr	r3, [pc, #16]	; (8003760 <RCC_APB1PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800374e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003750:	b109      	cbz	r1, 8003756 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8003752:	4310      	orrs	r0, r2
 8003754:	e001      	b.n	800375a <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8003756:	ea22 0000 	bic.w	r0, r2, r0
 800375a:	6418      	str	r0, [r3, #64]	; 0x40
 800375c:	4770      	bx	lr
 800375e:	bf00      	nop
 8003760:	40023800 	.word	0x40023800

08003764 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8003764:	4b04      	ldr	r3, [pc, #16]	; (8003778 <RCC_APB2PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8003766:	6c5a      	ldr	r2, [r3, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003768:	b109      	cbz	r1, 800376e <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800376a:	4310      	orrs	r0, r2
 800376c:	e001      	b.n	8003772 <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800376e:	ea22 0000 	bic.w	r0, r2, r0
 8003772:	6458      	str	r0, [r3, #68]	; 0x44
 8003774:	4770      	bx	lr
 8003776:	bf00      	nop
 8003778:	40023800 	.word	0x40023800

0800377c <RCC_AHB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800377c:	4b04      	ldr	r3, [pc, #16]	; (8003790 <RCC_AHB1PeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 800377e:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003780:	b109      	cbz	r1, 8003786 <RCC_AHB1PeriphResetCmd+0xa>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8003782:	4310      	orrs	r0, r2
 8003784:	e001      	b.n	800378a <RCC_AHB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8003786:	ea22 0000 	bic.w	r0, r2, r0
 800378a:	6118      	str	r0, [r3, #16]
 800378c:	4770      	bx	lr
 800378e:	bf00      	nop
 8003790:	40023800 	.word	0x40023800

08003794 <RCC_AHB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 8003794:	4b04      	ldr	r3, [pc, #16]	; (80037a8 <RCC_AHB2PeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8003796:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003798:	b109      	cbz	r1, 800379e <RCC_AHB2PeriphResetCmd+0xa>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 800379a:	4310      	orrs	r0, r2
 800379c:	e001      	b.n	80037a2 <RCC_AHB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 800379e:	ea22 0000 	bic.w	r0, r2, r0
 80037a2:	6158      	str	r0, [r3, #20]
 80037a4:	4770      	bx	lr
 80037a6:	bf00      	nop
 80037a8:	40023800 	.word	0x40023800

080037ac <RCC_AHB3PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 80037ac:	4b04      	ldr	r3, [pc, #16]	; (80037c0 <RCC_AHB3PeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 80037ae:	699a      	ldr	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80037b0:	b109      	cbz	r1, 80037b6 <RCC_AHB3PeriphResetCmd+0xa>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 80037b2:	4310      	orrs	r0, r2
 80037b4:	e001      	b.n	80037ba <RCC_AHB3PeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 80037b6:	ea22 0000 	bic.w	r0, r2, r0
 80037ba:	6198      	str	r0, [r3, #24]
 80037bc:	4770      	bx	lr
 80037be:	bf00      	nop
 80037c0:	40023800 	.word	0x40023800

080037c4 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80037c4:	4b04      	ldr	r3, [pc, #16]	; (80037d8 <RCC_APB1PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80037c6:	6a1a      	ldr	r2, [r3, #32]
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80037c8:	b109      	cbz	r1, 80037ce <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80037ca:	4310      	orrs	r0, r2
 80037cc:	e001      	b.n	80037d2 <RCC_APB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80037ce:	ea22 0000 	bic.w	r0, r2, r0
 80037d2:	6218      	str	r0, [r3, #32]
 80037d4:	4770      	bx	lr
 80037d6:	bf00      	nop
 80037d8:	40023800 	.word	0x40023800

080037dc <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80037dc:	4b04      	ldr	r3, [pc, #16]	; (80037f0 <RCC_APB2PeriphResetCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80037de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80037e0:	b109      	cbz	r1, 80037e6 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80037e2:	4310      	orrs	r0, r2
 80037e4:	e001      	b.n	80037ea <RCC_APB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80037e6:	ea22 0000 	bic.w	r0, r2, r0
 80037ea:	6258      	str	r0, [r3, #36]	; 0x24
 80037ec:	4770      	bx	lr
 80037ee:	bf00      	nop
 80037f0:	40023800 	.word	0x40023800

080037f4 <RCC_AHB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80037f4:	4b04      	ldr	r3, [pc, #16]	; (8003808 <RCC_AHB1PeriphClockLPModeCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80037f6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80037f8:	b109      	cbz	r1, 80037fe <RCC_AHB1PeriphClockLPModeCmd+0xa>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80037fa:	4310      	orrs	r0, r2
 80037fc:	e001      	b.n	8003802 <RCC_AHB1PeriphClockLPModeCmd+0xe>
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 80037fe:	ea22 0000 	bic.w	r0, r2, r0
 8003802:	6518      	str	r0, [r3, #80]	; 0x50
 8003804:	4770      	bx	lr
 8003806:	bf00      	nop
 8003808:	40023800 	.word	0x40023800

0800380c <RCC_AHB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
 800380c:	4b04      	ldr	r3, [pc, #16]	; (8003820 <RCC_AHB2PeriphClockLPModeCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 800380e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003810:	b109      	cbz	r1, 8003816 <RCC_AHB2PeriphClockLPModeCmd+0xa>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8003812:	4310      	orrs	r0, r2
 8003814:	e001      	b.n	800381a <RCC_AHB2PeriphClockLPModeCmd+0xe>
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8003816:	ea22 0000 	bic.w	r0, r2, r0
 800381a:	6558      	str	r0, [r3, #84]	; 0x54
 800381c:	4770      	bx	lr
 800381e:	bf00      	nop
 8003820:	40023800 	.word	0x40023800

08003824 <RCC_AHB3PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
 8003824:	4b04      	ldr	r3, [pc, #16]	; (8003838 <RCC_AHB3PeriphClockLPModeCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8003826:	6d9a      	ldr	r2, [r3, #88]	; 0x58
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003828:	b109      	cbz	r1, 800382e <RCC_AHB3PeriphClockLPModeCmd+0xa>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 800382a:	4310      	orrs	r0, r2
 800382c:	e001      	b.n	8003832 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 800382e:	ea22 0000 	bic.w	r0, r2, r0
 8003832:	6598      	str	r0, [r3, #88]	; 0x58
 8003834:	4770      	bx	lr
 8003836:	bf00      	nop
 8003838:	40023800 	.word	0x40023800

0800383c <RCC_APB1PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 800383c:	4b04      	ldr	r3, [pc, #16]	; (8003850 <RCC_APB1PeriphClockLPModeCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 800383e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003840:	b109      	cbz	r1, 8003846 <RCC_APB1PeriphClockLPModeCmd+0xa>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8003842:	4310      	orrs	r0, r2
 8003844:	e001      	b.n	800384a <RCC_APB1PeriphClockLPModeCmd+0xe>
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8003846:	ea22 0000 	bic.w	r0, r2, r0
 800384a:	6618      	str	r0, [r3, #96]	; 0x60
 800384c:	4770      	bx	lr
 800384e:	bf00      	nop
 8003850:	40023800 	.word	0x40023800

08003854 <RCC_APB2PeriphClockLPModeCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8003854:	4b04      	ldr	r3, [pc, #16]	; (8003868 <RCC_APB2PeriphClockLPModeCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8003856:	6e5a      	ldr	r2, [r3, #100]	; 0x64
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003858:	b109      	cbz	r1, 800385e <RCC_APB2PeriphClockLPModeCmd+0xa>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 800385a:	4310      	orrs	r0, r2
 800385c:	e001      	b.n	8003862 <RCC_APB2PeriphClockLPModeCmd+0xe>
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 800385e:	ea22 0000 	bic.w	r0, r2, r0
 8003862:	6658      	str	r0, [r3, #100]	; 0x64
 8003864:	4770      	bx	lr
 8003866:	bf00      	nop
 8003868:	40023800 	.word	0x40023800

0800386c <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 800386c:	4b04      	ldr	r3, [pc, #16]	; (8003880 <RCC_ITConfig+0x14>)
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800386e:	781a      	ldrb	r2, [r3, #0]
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003870:	b109      	cbz	r1, 8003876 <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8003872:	4310      	orrs	r0, r2
 8003874:	e001      	b.n	800387a <RCC_ITConfig+0xe>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8003876:	ea22 0000 	bic.w	r0, r2, r0
 800387a:	7018      	strb	r0, [r3, #0]
 800387c:	4770      	bx	lr
 800387e:	bf00      	nop
 8003880:	4002380d 	.word	0x4002380d

08003884 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8003884:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8003886:	2b01      	cmp	r3, #1
 8003888:	4a07      	ldr	r2, [pc, #28]	; (80038a8 <RCC_GetFlagStatus+0x24>)
 800388a:	d101      	bne.n	8003890 <RCC_GetFlagStatus+0xc>
  {
    statusreg = RCC->CR;
 800388c:	6813      	ldr	r3, [r2, #0]
 800388e:	e003      	b.n	8003898 <RCC_GetFlagStatus+0x14>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8003890:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8003892:	bf0c      	ite	eq
 8003894:	6f13      	ldreq	r3, [r2, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8003896:	6f53      	ldrne	r3, [r2, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8003898:	f000 001f 	and.w	r0, r0, #31
 800389c:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 80038a0:	f000 0001 	and.w	r0, r0, #1
 80038a4:	4770      	bx	lr
 80038a6:	bf00      	nop
 80038a8:	40023800 	.word	0x40023800

080038ac <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80038ac:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t startupcounter = 0;
 80038ae:	2300      	movs	r3, #0
 80038b0:	9301      	str	r3, [sp, #4]
  ErrorStatus status = ERROR;
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 80038b2:	2031      	movs	r0, #49	; 0x31
 80038b4:	f7ff ffe6 	bl	8003884 <RCC_GetFlagStatus>
    startupcounter++;
 80038b8:	9b01      	ldr	r3, [sp, #4]
 80038ba:	3301      	adds	r3, #1
 80038bc:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 80038be:	9b01      	ldr	r3, [sp, #4]
 80038c0:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80038c4:	d001      	beq.n	80038ca <RCC_WaitForHSEStartUp+0x1e>
 80038c6:	2800      	cmp	r0, #0
 80038c8:	d0f3      	beq.n	80038b2 <RCC_WaitForHSEStartUp+0x6>

  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80038ca:	2031      	movs	r0, #49	; 0x31
 80038cc:	f7ff ffda 	bl	8003884 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }
  return (status);
}
 80038d0:	3000      	adds	r0, #0
 80038d2:	bf18      	it	ne
 80038d4:	2001      	movne	r0, #1
 80038d6:	bd0e      	pop	{r1, r2, r3, pc}

080038d8 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 80038d8:	4b02      	ldr	r3, [pc, #8]	; (80038e4 <RCC_ClearFlag+0xc>)
 80038da:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80038dc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80038e0:	675a      	str	r2, [r3, #116]	; 0x74
 80038e2:	4770      	bx	lr
 80038e4:	40023800 	.word	0x40023800

080038e8 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80038e8:	4b03      	ldr	r3, [pc, #12]	; (80038f8 <RCC_GetITStatus+0x10>)
 80038ea:	68db      	ldr	r3, [r3, #12]
 80038ec:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 80038ee:	bf0c      	ite	eq
 80038f0:	2000      	moveq	r0, #0
 80038f2:	2001      	movne	r0, #1
 80038f4:	4770      	bx	lr
 80038f6:	bf00      	nop
 80038f8:	40023800 	.word	0x40023800

080038fc <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80038fc:	4b01      	ldr	r3, [pc, #4]	; (8003904 <RCC_ClearITPendingBit+0x8>)
 80038fe:	7018      	strb	r0, [r3, #0]
 8003900:	4770      	bx	lr
 8003902:	bf00      	nop
 8003904:	4002380e 	.word	0x4002380e

08003908 <RNG_DeInit>:
  * @brief  Deinitializes the RNG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void RNG_DeInit(void)
{
 8003908:	b508      	push	{r3, lr}
  /* Enable RNG reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);
 800390a:	2040      	movs	r0, #64	; 0x40
 800390c:	2101      	movs	r1, #1
 800390e:	f7ff ff41 	bl	8003794 <RCC_AHB2PeriphResetCmd>

  /* Release RNG from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
 8003912:	2040      	movs	r0, #64	; 0x40
 8003914:	2100      	movs	r1, #0
}
 8003916:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Enable RNG reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);

  /* Release RNG from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
 800391a:	f7ff bf3b 	b.w	8003794 <RCC_AHB2PeriphResetCmd>

0800391e <RNG_Cmd>:
  * @param  NewState: new state of the RNG peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_Cmd(FunctionalState NewState)
{
 800391e:	4b05      	ldr	r3, [pc, #20]	; (8003934 <RNG_Cmd+0x16>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the RNG */
    RNG->CR |= RNG_CR_RNGEN;
 8003920:	681a      	ldr	r2, [r3, #0]
void RNG_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003922:	b110      	cbz	r0, 800392a <RNG_Cmd+0xc>
  {
    /* Enable the RNG */
    RNG->CR |= RNG_CR_RNGEN;
 8003924:	f042 0204 	orr.w	r2, r2, #4
 8003928:	e001      	b.n	800392e <RNG_Cmd+0x10>
  }
  else
  {
    /* Disable the RNG */
    RNG->CR &= ~RNG_CR_RNGEN;
 800392a:	f022 0204 	bic.w	r2, r2, #4
 800392e:	601a      	str	r2, [r3, #0]
 8003930:	4770      	bx	lr
 8003932:	bf00      	nop
 8003934:	50060800 	.word	0x50060800

08003938 <RNG_GetRandomNumber>:
  * @retval 32-bit random number.
  */
uint32_t RNG_GetRandomNumber(void)
{
  /* Return the 32 bit random number from the DR register */
  return RNG->DR;
 8003938:	4b01      	ldr	r3, [pc, #4]	; (8003940 <RNG_GetRandomNumber+0x8>)
 800393a:	6898      	ldr	r0, [r3, #8]
}
 800393c:	4770      	bx	lr
 800393e:	bf00      	nop
 8003940:	50060800 	.word	0x50060800

08003944 <RNG_ITConfig>:
  * @param  NewState: new state of the RNG interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_ITConfig(FunctionalState NewState)
{
 8003944:	4b04      	ldr	r3, [pc, #16]	; (8003958 <RNG_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the RNG interrupt */
    RNG->CR |= RNG_CR_IE;
 8003946:	681a      	ldr	r2, [r3, #0]
void RNG_ITConfig(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003948:	b110      	cbz	r0, 8003950 <RNG_ITConfig+0xc>
  {
    /* Enable the RNG interrupt */
    RNG->CR |= RNG_CR_IE;
 800394a:	f042 0208 	orr.w	r2, r2, #8
 800394e:	e001      	b.n	8003954 <RNG_ITConfig+0x10>
  }
  else
  {
    /* Disable the RNG interrupt */
    RNG->CR &= ~RNG_CR_IE;
 8003950:	f022 0208 	bic.w	r2, r2, #8
 8003954:	601a      	str	r2, [r3, #0]
 8003956:	4770      	bx	lr
 8003958:	50060800 	.word	0x50060800

0800395c <RNG_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_FLAG(RNG_FLAG));

  /* Check the status of the specified RNG flag */
  if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
 800395c:	4b03      	ldr	r3, [pc, #12]	; (800396c <RNG_GetFlagStatus+0x10>)
 800395e:	685b      	ldr	r3, [r3, #4]
 8003960:	4218      	tst	r0, r3
    /* RNG_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the RNG_FLAG status */
  return  bitstatus;
}
 8003962:	bf0c      	ite	eq
 8003964:	2000      	moveq	r0, #0
 8003966:	2001      	movne	r0, #1
 8003968:	4770      	bx	lr
 800396a:	bf00      	nop
 800396c:	50060800 	.word	0x50060800

08003970 <RNG_ClearFlag>:
void RNG_ClearFlag(uint8_t RNG_FLAG)
{
  /* Check the parameters */
  assert_param(IS_RNG_CLEAR_FLAG(RNG_FLAG));
  /* Clear the selected RNG flags */
  RNG->SR = ~(uint32_t)(((uint32_t)RNG_FLAG) << 4);
 8003970:	4b02      	ldr	r3, [pc, #8]	; (800397c <RNG_ClearFlag+0xc>)
 8003972:	ea6f 1000 	mvn.w	r0, r0, lsl #4
 8003976:	6058      	str	r0, [r3, #4]
 8003978:	4770      	bx	lr
 800397a:	bf00      	nop
 800397c:	50060800 	.word	0x50060800

08003980 <RNG_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_IT(RNG_IT));

  /* Check the status of the specified RNG interrupt */
  if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
 8003980:	4b03      	ldr	r3, [pc, #12]	; (8003990 <RNG_GetITStatus+0x10>)
 8003982:	685b      	ldr	r3, [r3, #4]
 8003984:	4218      	tst	r0, r3
    /* RNG_IT is reset */
    bitstatus = RESET;
  }
  /* Return the RNG_IT status */
  return bitstatus;
}
 8003986:	bf0c      	ite	eq
 8003988:	2000      	moveq	r0, #0
 800398a:	2001      	movne	r0, #1
 800398c:	4770      	bx	lr
 800398e:	bf00      	nop
 8003990:	50060800 	.word	0x50060800

08003994 <RNG_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_RNG_IT(RNG_IT));

  /* Clear the selected RNG interrupt pending bit */
  RNG->SR = (uint8_t)~RNG_IT;
 8003994:	43c0      	mvns	r0, r0
 8003996:	4b02      	ldr	r3, [pc, #8]	; (80039a0 <RNG_ClearITPendingBit+0xc>)
 8003998:	b2c0      	uxtb	r0, r0
 800399a:	6058      	str	r0, [r3, #4]
 800399c:	4770      	bx	lr
 800399e:	bf00      	nop
 80039a0:	50060800 	.word	0x50060800

080039a4 <RTC_ByteToBcd2>:
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
 80039a4:	2300      	movs	r3, #0
  
  while (Value >= 10)
 80039a6:	e003      	b.n	80039b0 <RTC_ByteToBcd2+0xc>
  {
    bcdhigh++;
 80039a8:	3301      	adds	r3, #1
    Value -= 10;
 80039aa:	380a      	subs	r0, #10
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
 80039ac:	b2db      	uxtb	r3, r3
    Value -= 10;
 80039ae:	b2c0      	uxtb	r0, r0
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 80039b0:	2809      	cmp	r0, #9
 80039b2:	d8f9      	bhi.n	80039a8 <RTC_ByteToBcd2+0x4>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 80039b4:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 80039b8:	b2c0      	uxtb	r0, r0
 80039ba:	4770      	bx	lr

080039bc <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 80039bc:	0902      	lsrs	r2, r0, #4
  return (tmp + (Value & (uint8_t)0x0F));
 80039be:	f000 030f 	and.w	r3, r0, #15
 80039c2:	200a      	movs	r0, #10
 80039c4:	fb00 3002 	mla	r0, r0, r2, r3
}
 80039c8:	b2c0      	uxtb	r0, r0
 80039ca:	4770      	bx	lr

080039cc <RTC_StructInit>:
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 80039cc:	2100      	movs	r1, #0
 80039ce:	227f      	movs	r2, #127	; 0x7f
 80039d0:	23ff      	movs	r3, #255	; 0xff
 80039d2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 80039d6:	4770      	bx	lr

080039d8 <RTC_WriteProtectionCmd>:
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
 80039d8:	4b04      	ldr	r3, [pc, #16]	; (80039ec <RTC_WriteProtectionCmd+0x14>)
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 80039da:	b108      	cbz	r0, 80039e0 <RTC_WriteProtectionCmd+0x8>
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
 80039dc:	22ff      	movs	r2, #255	; 0xff
 80039de:	e002      	b.n	80039e6 <RTC_WriteProtectionCmd+0xe>
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
 80039e0:	22ca      	movs	r2, #202	; 0xca
 80039e2:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 80039e4:	2253      	movs	r2, #83	; 0x53
 80039e6:	625a      	str	r2, [r3, #36]	; 0x24
 80039e8:	4770      	bx	lr
 80039ea:	bf00      	nop
 80039ec:	40002800 	.word	0x40002800

080039f0 <RTC_EnterInitMode>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
 80039f0:	b082      	sub	sp, #8
  __IO uint32_t initcounter = 0x00;
 80039f2:	2300      	movs	r3, #0
 80039f4:	9301      	str	r3, [sp, #4]
  ErrorStatus status = ERROR;
  uint32_t initstatus = 0x00;
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80039f6:	4b0d      	ldr	r3, [pc, #52]	; (8003a2c <RTC_EnterInitMode+0x3c>)
 80039f8:	68da      	ldr	r2, [r3, #12]
 80039fa:	0650      	lsls	r0, r2, #25
 80039fc:	d413      	bmi.n	8003a26 <RTC_EnterInitMode+0x36>
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 80039fe:	f04f 32ff 	mov.w	r2, #4294967295
 8003a02:	60da      	str	r2, [r3, #12]
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 8003a04:	68da      	ldr	r2, [r3, #12]
      initcounter++;  
 8003a06:	9901      	ldr	r1, [sp, #4]
 8003a08:	3101      	adds	r1, #1
 8003a0a:	9101      	str	r1, [sp, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8003a0c:	9901      	ldr	r1, [sp, #4]
 8003a0e:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
 8003a12:	f002 0240 	and.w	r2, r2, #64	; 0x40
      initcounter++;  
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8003a16:	d001      	beq.n	8003a1c <RTC_EnterInitMode+0x2c>
 8003a18:	2a00      	cmp	r2, #0
 8003a1a:	d0f3      	beq.n	8003a04 <RTC_EnterInitMode+0x14>
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 8003a1c:	4b03      	ldr	r3, [pc, #12]	; (8003a2c <RTC_EnterInitMode+0x3c>)
 8003a1e:	68d8      	ldr	r0, [r3, #12]
    {
      status = SUCCESS;
 8003a20:	f3c0 1080 	ubfx	r0, r0, #6, #1
 8003a24:	e000      	b.n	8003a28 <RTC_EnterInitMode+0x38>
      status = ERROR;
    }        
  }
  else
  {
    status = SUCCESS;  
 8003a26:	2001      	movs	r0, #1
  } 
    
  return (status);  
}
 8003a28:	b002      	add	sp, #8
 8003a2a:	4770      	bx	lr
 8003a2c:	40002800 	.word	0x40002800

08003a30 <RTC_ExitInitMode>:
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8003a30:	4b02      	ldr	r3, [pc, #8]	; (8003a3c <RTC_ExitInitMode+0xc>)
 8003a32:	68da      	ldr	r2, [r3, #12]
 8003a34:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003a38:	60da      	str	r2, [r3, #12]
 8003a3a:	4770      	bx	lr
 8003a3c:	40002800 	.word	0x40002800

08003a40 <RTC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 8003a40:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003a42:	4c0f      	ldr	r4, [pc, #60]	; (8003a80 <RTC_Init+0x40>)
 8003a44:	23ca      	movs	r3, #202	; 0xca
 8003a46:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8003a48:	2353      	movs	r3, #83	; 0x53
 8003a4a:	6263      	str	r3, [r4, #36]	; 0x24
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
 8003a4c:	4605      	mov	r5, r0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8003a4e:	f7ff ffcf 	bl	80039f0 <RTC_EnterInitMode>
 8003a52:	b188      	cbz	r0, 8003a78 <RTC_Init+0x38>
    status = ERROR;
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 8003a54:	68a3      	ldr	r3, [r4, #8]
 8003a56:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003a5a:	60a3      	str	r3, [r4, #8]
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 8003a5c:	68a2      	ldr	r2, [r4, #8]
 8003a5e:	682b      	ldr	r3, [r5, #0]
 8003a60:	4313      	orrs	r3, r2
 8003a62:	60a3      	str	r3, [r4, #8]
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 8003a64:	68ab      	ldr	r3, [r5, #8]
 8003a66:	6123      	str	r3, [r4, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 8003a68:	6923      	ldr	r3, [r4, #16]
 8003a6a:	686a      	ldr	r2, [r5, #4]
 8003a6c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8003a70:	6123      	str	r3, [r4, #16]

    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8003a72:	f7ff ffdd 	bl	8003a30 <RTC_ExitInitMode>

    status = SUCCESS;    
 8003a76:	2001      	movs	r0, #1
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003a78:	4b01      	ldr	r3, [pc, #4]	; (8003a80 <RTC_Init+0x40>)
 8003a7a:	22ff      	movs	r2, #255	; 0xff
 8003a7c:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8003a7e:	bd38      	pop	{r3, r4, r5, pc}
 8003a80:	40002800 	.word	0x40002800

08003a84 <RTC_WaitForSynchro>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
 8003a84:	b082      	sub	sp, #8
  __IO uint32_t synchrocounter = 0;
 8003a86:	2300      	movs	r3, #0
 8003a88:	9301      	str	r3, [sp, #4]
  ErrorStatus status = ERROR;
  uint32_t synchrostatus = 0x00;

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003a8a:	4b0e      	ldr	r3, [pc, #56]	; (8003ac4 <RTC_WaitForSynchro+0x40>)
 8003a8c:	22ca      	movs	r2, #202	; 0xca
 8003a8e:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003a90:	2253      	movs	r2, #83	; 0x53
 8003a92:	625a      	str	r2, [r3, #36]	; 0x24
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8003a94:	68da      	ldr	r2, [r3, #12]
 8003a96:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8003a9a:	60da      	str	r2, [r3, #12]
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8003a9c:	68d9      	ldr	r1, [r3, #12]
    synchrocounter++;  
 8003a9e:	9a01      	ldr	r2, [sp, #4]
 8003aa0:	3201      	adds	r2, #1
 8003aa2:	9201      	str	r2, [sp, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8003aa4:	9a01      	ldr	r2, [sp, #4]
 8003aa6:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8003aaa:	f001 0120 	and.w	r1, r1, #32
 8003aae:	4a05      	ldr	r2, [pc, #20]	; (8003ac4 <RTC_WaitForSynchro+0x40>)
    synchrocounter++;  
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8003ab0:	d001      	beq.n	8003ab6 <RTC_WaitForSynchro+0x32>
 8003ab2:	2900      	cmp	r1, #0
 8003ab4:	d0f2      	beq.n	8003a9c <RTC_WaitForSynchro+0x18>
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 8003ab6:	68d0      	ldr	r0, [r2, #12]
  {
    status = ERROR;
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003ab8:	23ff      	movs	r3, #255	; 0xff
 8003aba:	6253      	str	r3, [r2, #36]	; 0x24
    
  return (status); 
}
 8003abc:	f3c0 1040 	ubfx	r0, r0, #5, #1
 8003ac0:	b002      	add	sp, #8
 8003ac2:	4770      	bx	lr
 8003ac4:	40002800 	.word	0x40002800

08003ac8 <RTC_DeInit>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
 8003ac8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __IO uint32_t wutcounter = 0x00;
  uint32_t wutwfstatus = 0x00;
  ErrorStatus status = ERROR;
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003aca:	4c1f      	ldr	r4, [pc, #124]	; (8003b48 <RTC_DeInit+0x80>)
 8003acc:	23ca      	movs	r3, #202	; 0xca
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
  __IO uint32_t wutcounter = 0x00;
 8003ace:	2500      	movs	r5, #0
 8003ad0:	9501      	str	r5, [sp, #4]
  uint32_t wutwfstatus = 0x00;
  ErrorStatus status = ERROR;
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003ad2:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8003ad4:	2353      	movs	r3, #83	; 0x53
 8003ad6:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8003ad8:	f7ff ff8a 	bl	80039f0 <RTC_EnterInitMode>
 8003adc:	b908      	cbnz	r0, 8003ae2 <RTC_DeInit+0x1a>
  {
    status = ERROR;
 8003ade:	2000      	movs	r0, #0
 8003ae0:	e02d      	b.n	8003b3e <RTC_DeInit+0x76>
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
    RTC->DR = (uint32_t)0x00002101;
 8003ae2:	f242 1301 	movw	r3, #8449	; 0x2101
    status = ERROR;
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
 8003ae6:	6025      	str	r5, [r4, #0]
    RTC->DR = (uint32_t)0x00002101;
 8003ae8:	6063      	str	r3, [r4, #4]
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
 8003aea:	68a3      	ldr	r3, [r4, #8]
 8003aec:	f003 0307 	and.w	r3, r3, #7
 8003af0:	60a3      	str	r3, [r4, #8]
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8003af2:	68e3      	ldr	r3, [r4, #12]
      wutcounter++;  
 8003af4:	9a01      	ldr	r2, [sp, #4]
 8003af6:	3201      	adds	r2, #1
 8003af8:	9201      	str	r2, [sp, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8003afa:	9a01      	ldr	r2, [sp, #4]
 8003afc:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    RTC->CR &= (uint32_t)0x00000007;
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8003b00:	f003 0304 	and.w	r3, r3, #4
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8003b04:	d001      	beq.n	8003b0a <RTC_DeInit+0x42>
 8003b06:	2b00      	cmp	r3, #0
 8003b08:	d0f3      	beq.n	8003af2 <RTC_DeInit+0x2a>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8003b0a:	4b0f      	ldr	r3, [pc, #60]	; (8003b48 <RTC_DeInit+0x80>)
 8003b0c:	68da      	ldr	r2, [r3, #12]
 8003b0e:	0752      	lsls	r2, r2, #29
 8003b10:	d5e5      	bpl.n	8003ade <RTC_DeInit+0x16>
      status = ERROR;
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
 8003b12:	689a      	ldr	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 8003b14:	f64f 71ff 	movw	r1, #65535	; 0xffff
      status = ERROR;
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
 8003b18:	2200      	movs	r2, #0
 8003b1a:	609a      	str	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 8003b1c:	6159      	str	r1, [r3, #20]
      RTC->PRER = (uint32_t)0x007F00FF;
 8003b1e:	490b      	ldr	r1, [pc, #44]	; (8003b4c <RTC_DeInit+0x84>)
 8003b20:	6119      	str	r1, [r3, #16]
      RTC->CALIBR = (uint32_t)0x00000000;
 8003b22:	619a      	str	r2, [r3, #24]
      RTC->ALRMAR = (uint32_t)0x00000000;        
 8003b24:	61da      	str	r2, [r3, #28]
      RTC->ALRMBR = (uint32_t)0x00000000;
 8003b26:	621a      	str	r2, [r3, #32]
      RTC->SHIFTR = (uint32_t)0x00000000;
 8003b28:	62da      	str	r2, [r3, #44]	; 0x2c
      RTC->CALR = (uint32_t)0x00000000;
 8003b2a:	63da      	str	r2, [r3, #60]	; 0x3c
      RTC->ALRMASSR = (uint32_t)0x00000000;
 8003b2c:	645a      	str	r2, [r3, #68]	; 0x44
      RTC->ALRMBSSR = (uint32_t)0x00000000;
 8003b2e:	649a      	str	r2, [r3, #72]	; 0x48
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
 8003b30:	60da      	str	r2, [r3, #12]
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
 8003b32:	641a      	str	r2, [r3, #64]	; 0x40
  
      if(RTC_WaitForSynchro() == ERROR)
 8003b34:	f7ff ffa6 	bl	8003a84 <RTC_WaitForSynchro>
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 8003b38:	3000      	adds	r0, #0
 8003b3a:	bf18      	it	ne
 8003b3c:	2001      	movne	r0, #1
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8003b3e:	4b02      	ldr	r3, [pc, #8]	; (8003b48 <RTC_DeInit+0x80>)
 8003b40:	22ff      	movs	r2, #255	; 0xff
 8003b42:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8003b44:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8003b46:	bf00      	nop
 8003b48:	40002800 	.word	0x40002800
 8003b4c:	007f00ff 	.word	0x007f00ff

08003b50 <RTC_RefClockCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
 8003b50:	b538      	push	{r3, r4, r5, lr}
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003b52:	4c0b      	ldr	r4, [pc, #44]	; (8003b80 <RTC_RefClockCmd+0x30>)
 8003b54:	23ca      	movs	r3, #202	; 0xca
 8003b56:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8003b58:	2353      	movs	r3, #83	; 0x53
 8003b5a:	6263      	str	r3, [r4, #36]	; 0x24
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
 8003b5c:	4605      	mov	r5, r0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8003b5e:	f7ff ff47 	bl	80039f0 <RTC_EnterInitMode>
 8003b62:	b150      	cbz	r0, 8003b7a <RTC_RefClockCmd+0x2a>
  else
  {  
    if (NewState != DISABLE)
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
 8003b64:	68a3      	ldr	r3, [r4, #8]
  {
    status = ERROR;
  } 
  else
  {  
    if (NewState != DISABLE)
 8003b66:	b115      	cbz	r5, 8003b6e <RTC_RefClockCmd+0x1e>
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
 8003b68:	f043 0310 	orr.w	r3, r3, #16
 8003b6c:	e001      	b.n	8003b72 <RTC_RefClockCmd+0x22>
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
 8003b6e:	f023 0310 	bic.w	r3, r3, #16
 8003b72:	60a3      	str	r3, [r4, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8003b74:	f7ff ff5c 	bl	8003a30 <RTC_ExitInitMode>
    
    status = SUCCESS;
 8003b78:	2001      	movs	r0, #1
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 8003b7a:	23ff      	movs	r3, #255	; 0xff
 8003b7c:	6263      	str	r3, [r4, #36]	; 0x24
  
  return status; 
}
 8003b7e:	bd38      	pop	{r3, r4, r5, pc}
 8003b80:	40002800 	.word	0x40002800

08003b84 <RTC_BypassShadowCmd>:
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003b84:	4b07      	ldr	r3, [pc, #28]	; (8003ba4 <RTC_BypassShadowCmd+0x20>)
 8003b86:	22ca      	movs	r2, #202	; 0xca
 8003b88:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003b8a:	2253      	movs	r2, #83	; 0x53
 8003b8c:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 8003b8e:	689a      	ldr	r2, [r3, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
 8003b90:	b110      	cbz	r0, 8003b98 <RTC_BypassShadowCmd+0x14>
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 8003b92:	f042 0220 	orr.w	r2, r2, #32
 8003b96:	e001      	b.n	8003b9c <RTC_BypassShadowCmd+0x18>
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 8003b98:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 8003b9c:	609a      	str	r2, [r3, #8]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8003b9e:	22ff      	movs	r2, #255	; 0xff
 8003ba0:	625a      	str	r2, [r3, #36]	; 0x24
 8003ba2:	4770      	bx	lr
 8003ba4:	40002800 	.word	0x40002800

08003ba8 <RTC_SetTime>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8003ba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003baa:	4b24      	ldr	r3, [pc, #144]	; (8003c3c <RTC_SetTime+0x94>)
 8003bac:	460c      	mov	r4, r1
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003bae:	689b      	ldr	r3, [r3, #8]
  ErrorStatus status = ERROR;
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
 8003bb0:	b920      	cbnz	r0, 8003bbc <RTC_SetTime+0x14>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003bb2:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8003bb6:	d12e      	bne.n	8003c16 <RTC_SetTime+0x6e>
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8003bb8:	70cb      	strb	r3, [r1, #3]
 8003bba:	e02c      	b.n	8003c16 <RTC_SetTime+0x6e>
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003bbc:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8003bc0:	d11e      	bne.n	8003c00 <RTC_SetTime+0x58>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
 8003bc2:	70cb      	strb	r3, [r1, #3]
 8003bc4:	e01c      	b.n	8003c00 <RTC_SetTime+0x58>
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003bc6:	4c1d      	ldr	r4, [pc, #116]	; (8003c3c <RTC_SetTime+0x94>)
 8003bc8:	23ca      	movs	r3, #202	; 0xca
 8003bca:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8003bcc:	2353      	movs	r3, #83	; 0x53
 8003bce:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8003bd0:	f7ff ff0e 	bl	80039f0 <RTC_EnterInitMode>
 8003bd4:	b180      	cbz	r0, 8003bf8 <RTC_SetTime+0x50>
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8003bd6:	f005 357f 	and.w	r5, r5, #2139062143	; 0x7f7f7f7f
 8003bda:	f025 45fe 	bic.w	r5, r5, #2130706432	; 0x7f000000
 8003bde:	6025      	str	r5, [r4, #0]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8003be0:	f7ff ff26 	bl	8003a30 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8003be4:	68a3      	ldr	r3, [r4, #8]
 8003be6:	0699      	lsls	r1, r3, #26
 8003be8:	d405      	bmi.n	8003bf6 <RTC_SetTime+0x4e>
    {
      if (RTC_WaitForSynchro() == ERROR)
 8003bea:	f7ff ff4b 	bl	8003a84 <RTC_WaitForSynchro>
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 8003bee:	3000      	adds	r0, #0
 8003bf0:	bf18      	it	ne
 8003bf2:	2001      	movne	r0, #1
 8003bf4:	e000      	b.n	8003bf8 <RTC_SetTime+0x50>
        status = SUCCESS;
      }
    }
    else
    {
      status = SUCCESS;
 8003bf6:	2001      	movs	r0, #1
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003bf8:	4b10      	ldr	r3, [pc, #64]	; (8003c3c <RTC_SetTime+0x94>)
 8003bfa:	22ff      	movs	r2, #255	; 0xff
 8003bfc:	625a      	str	r2, [r3, #36]	; 0x24
 8003bfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8003c00:	7865      	ldrb	r5, [r4, #1]
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c02:	7823      	ldrb	r3, [r4, #0]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8003c04:	022d      	lsls	r5, r5, #8
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c06:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8003c0a:	78a3      	ldrb	r3, [r4, #2]
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8003c0c:	431d      	orrs	r5, r3
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 8003c0e:	78e3      	ldrb	r3, [r4, #3]
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c10:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8003c14:	e7d7      	b.n	8003bc6 <RTC_SetTime+0x1e>
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c16:	7820      	ldrb	r0, [r4, #0]
 8003c18:	f7ff fec4 	bl	80039a4 <RTC_ByteToBcd2>
 8003c1c:	4607      	mov	r7, r0
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8003c1e:	7860      	ldrb	r0, [r4, #1]
 8003c20:	f7ff fec0 	bl	80039a4 <RTC_ByteToBcd2>
 8003c24:	4606      	mov	r6, r0
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8003c26:	78a0      	ldrb	r0, [r4, #2]
 8003c28:	f7ff febc 	bl	80039a4 <RTC_ByteToBcd2>
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 8003c2c:	78e5      	ldrb	r5, [r4, #3]
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c2e:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8003c32:	ea40 4507 	orr.w	r5, r0, r7, lsl #16
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8003c36:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8003c3a:	e7c4      	b.n	8003bc6 <RTC_SetTime+0x1e>
 8003c3c:	40002800 	.word	0x40002800

08003c40 <RTC_TimeStructInit>:
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8003c40:	2300      	movs	r3, #0
 8003c42:	70c3      	strb	r3, [r0, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8003c44:	7003      	strb	r3, [r0, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8003c46:	7043      	strb	r3, [r0, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8003c48:	7083      	strb	r3, [r0, #2]
 8003c4a:	4770      	bx	lr

08003c4c <RTC_GetTime>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8003c4c:	4b0f      	ldr	r3, [pc, #60]	; (8003c8c <RTC_GetTime+0x40>)
 8003c4e:	681b      	ldr	r3, [r3, #0]
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8003c50:	b570      	push	{r4, r5, r6, lr}

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8003c52:	f3c3 4205 	ubfx	r2, r3, #16, #6
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8003c56:	f3c3 2606 	ubfx	r6, r3, #8, #7
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8003c5a:	f003 057f 	and.w	r5, r3, #127	; 0x7f
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8003c5e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003c62:	0c1b      	lsrs	r3, r3, #16
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
 8003c64:	460c      	mov	r4, r1

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8003c66:	700a      	strb	r2, [r1, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8003c68:	704e      	strb	r6, [r1, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8003c6a:	708d      	strb	r5, [r1, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8003c6c:	70cb      	strb	r3, [r1, #3]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8003c6e:	b958      	cbnz	r0, 8003c88 <RTC_GetTime+0x3c>
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8003c70:	4610      	mov	r0, r2
 8003c72:	f7ff fea3 	bl	80039bc <RTC_Bcd2ToByte>
 8003c76:	7020      	strb	r0, [r4, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8003c78:	4630      	mov	r0, r6
 8003c7a:	f7ff fe9f 	bl	80039bc <RTC_Bcd2ToByte>
 8003c7e:	7060      	strb	r0, [r4, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 8003c80:	4628      	mov	r0, r5
 8003c82:	f7ff fe9b 	bl	80039bc <RTC_Bcd2ToByte>
 8003c86:	70a0      	strb	r0, [r4, #2]
 8003c88:	bd70      	pop	{r4, r5, r6, pc}
 8003c8a:	bf00      	nop
 8003c8c:	40002800 	.word	0x40002800

08003c90 <RTC_GetSubSecond>:
uint32_t RTC_GetSubSecond(void)
{
  uint32_t tmpreg = 0;
  
  /* Get subseconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
 8003c90:	4b01      	ldr	r3, [pc, #4]	; (8003c98 <RTC_GetSubSecond+0x8>)
 8003c92:	6a98      	ldr	r0, [r3, #40]	; 0x28
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
 8003c94:	685b      	ldr	r3, [r3, #4]
  
  return (tmpreg);
}
 8003c96:	4770      	bx	lr
 8003c98:	40002800 	.word	0x40002800

08003c9c <RTC_SetDate>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8003c9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c9e:	460c      	mov	r4, r1
 8003ca0:	784b      	ldrb	r3, [r1, #1]
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8003ca2:	2800      	cmp	r0, #0
 8003ca4:	d138      	bne.n	8003d18 <RTC_SetDate+0x7c>
 8003ca6:	f003 0210 	and.w	r2, r3, #16
 8003caa:	b2d2      	uxtb	r2, r2
 8003cac:	b30a      	cbz	r2, 8003cf2 <RTC_SetDate+0x56>
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8003cae:	f023 0310 	bic.w	r3, r3, #16
 8003cb2:	330a      	adds	r3, #10
 8003cb4:	704b      	strb	r3, [r1, #1]
 8003cb6:	e01c      	b.n	8003cf2 <RTC_SetDate+0x56>
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003cb8:	4c1c      	ldr	r4, [pc, #112]	; (8003d2c <RTC_SetDate+0x90>)
 8003cba:	23ca      	movs	r3, #202	; 0xca
 8003cbc:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8003cbe:	2353      	movs	r3, #83	; 0x53
 8003cc0:	6263      	str	r3, [r4, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8003cc2:	f7ff fe95 	bl	80039f0 <RTC_EnterInitMode>
 8003cc6:	b180      	cbz	r0, 8003cea <RTC_SetDate+0x4e>
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8003cc8:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8003ccc:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
 8003cd0:	6065      	str	r5, [r4, #4]

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
 8003cd2:	f7ff fead 	bl	8003a30 <RTC_ExitInitMode>

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8003cd6:	68a3      	ldr	r3, [r4, #8]
 8003cd8:	0698      	lsls	r0, r3, #26
 8003cda:	d405      	bmi.n	8003ce8 <RTC_SetDate+0x4c>
    {
      if (RTC_WaitForSynchro() == ERROR)
 8003cdc:	f7ff fed2 	bl	8003a84 <RTC_WaitForSynchro>
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
 8003ce0:	3000      	adds	r0, #0
 8003ce2:	bf18      	it	ne
 8003ce4:	2001      	movne	r0, #1
 8003ce6:	e000      	b.n	8003cea <RTC_SetDate+0x4e>
        status = SUCCESS;
      }
    }
    else
    {
      status = SUCCESS;
 8003ce8:	2001      	movs	r0, #1
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8003cea:	4b10      	ldr	r3, [pc, #64]	; (8003d2c <RTC_SetDate+0x90>)
 8003cec:	22ff      	movs	r2, #255	; 0xff
 8003cee:	625a      	str	r2, [r3, #36]	; 0x24
 8003cf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8003cf2:	78e0      	ldrb	r0, [r4, #3]
 8003cf4:	f7ff fe56 	bl	80039a4 <RTC_ByteToBcd2>
 8003cf8:	4607      	mov	r7, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8003cfa:	7860      	ldrb	r0, [r4, #1]
 8003cfc:	f7ff fe52 	bl	80039a4 <RTC_ByteToBcd2>
 8003d00:	4606      	mov	r6, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8003d02:	78a0      	ldrb	r0, [r4, #2]
 8003d04:	f7ff fe4e 	bl	80039a4 <RTC_ByteToBcd2>
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8003d08:	7825      	ldrb	r5, [r4, #0]
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8003d0a:	ea40 3045 	orr.w	r0, r0, r5, lsl #13
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8003d0e:	ea40 4507 	orr.w	r5, r0, r7, lsl #16
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8003d12:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8003d16:	e7cf      	b.n	8003cb8 <RTC_SetDate+0x1c>
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8003d18:	78cd      	ldrb	r5, [r1, #3]
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 8003d1a:	788a      	ldrb	r2, [r1, #2]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8003d1c:	021b      	lsls	r3, r3, #8
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8003d1e:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8003d22:	780b      	ldrb	r3, [r1, #0]

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8003d24:	4315      	orrs	r5, r2
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8003d26:	ea45 3543 	orr.w	r5, r5, r3, lsl #13
 8003d2a:	e7c5      	b.n	8003cb8 <RTC_SetDate+0x1c>
 8003d2c:	40002800 	.word	0x40002800

08003d30 <RTC_DateStructInit>:
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8003d30:	2301      	movs	r3, #1
 8003d32:	7003      	strb	r3, [r0, #0]
  RTC_DateStruct->RTC_Date = 1;
 8003d34:	7083      	strb	r3, [r0, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8003d36:	7043      	strb	r3, [r0, #1]
  RTC_DateStruct->RTC_Year = 0;
 8003d38:	2300      	movs	r3, #0
 8003d3a:	70c3      	strb	r3, [r0, #3]
 8003d3c:	4770      	bx	lr

08003d3e <RTC_GetDate>:

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 8003d3e:	4b0f      	ldr	r3, [pc, #60]	; (8003d7c <RTC_GetDate+0x3e>)
 8003d40:	685b      	ldr	r3, [r3, #4]
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8003d42:	b570      	push	{r4, r5, r6, lr}
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8003d44:	f3c3 4207 	ubfx	r2, r3, #16, #8
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8003d48:	f3c3 2604 	ubfx	r6, r3, #8, #5
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8003d4c:	f003 053f 	and.w	r5, r3, #63	; 0x3f
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8003d50:	f3c3 3342 	ubfx	r3, r3, #13, #3
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
 8003d54:	460c      	mov	r4, r1
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8003d56:	70ca      	strb	r2, [r1, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8003d58:	704e      	strb	r6, [r1, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8003d5a:	708d      	strb	r5, [r1, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8003d5c:	700b      	strb	r3, [r1, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8003d5e:	b958      	cbnz	r0, 8003d78 <RTC_GetDate+0x3a>
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 8003d60:	4610      	mov	r0, r2
 8003d62:	f7ff fe2b 	bl	80039bc <RTC_Bcd2ToByte>
 8003d66:	70e0      	strb	r0, [r4, #3]
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 8003d68:	4630      	mov	r0, r6
 8003d6a:	f7ff fe27 	bl	80039bc <RTC_Bcd2ToByte>
 8003d6e:	7060      	strb	r0, [r4, #1]
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8003d70:	4628      	mov	r0, r5
 8003d72:	f7ff fe23 	bl	80039bc <RTC_Bcd2ToByte>
 8003d76:	70a0      	strb	r0, [r4, #2]
 8003d78:	bd70      	pop	{r4, r5, r6, pc}
 8003d7a:	bf00      	nop
 8003d7c:	40002800 	.word	0x40002800

08003d80 <RTC_SetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8003d80:	4b27      	ldr	r3, [pc, #156]	; (8003e20 <RTC_SetAlarm+0xa0>)
 8003d82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003d86:	689b      	ldr	r3, [r3, #8]
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8003d88:	460d      	mov	r5, r1
 8003d8a:	4614      	mov	r4, r2
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
 8003d8c:	b920      	cbnz	r0, 8003d98 <RTC_SetAlarm+0x18>
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003d8e:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8003d92:	d126      	bne.n	8003de2 <RTC_SetAlarm+0x62>
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8003d94:	70d3      	strb	r3, [r2, #3]
 8003d96:	e024      	b.n	8003de2 <RTC_SetAlarm+0x62>
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003d98:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8003d9c:	d10f      	bne.n	8003dbe <RTC_SetAlarm+0x3e>
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8003d9e:	70d3      	strb	r3, [r2, #3]
 8003da0:	e00d      	b.n	8003dbe <RTC_SetAlarm+0x3e>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003da2:	4b1f      	ldr	r3, [pc, #124]	; (8003e20 <RTC_SetAlarm+0xa0>)
 8003da4:	22ca      	movs	r2, #202	; 0xca
 8003da6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003da8:	2253      	movs	r2, #83	; 0x53

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 8003daa:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
 8003dae:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 8003db0:	bf0c      	ite	eq
 8003db2:	61d8      	streq	r0, [r3, #28]
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 8003db4:	6218      	strne	r0, [r3, #32]
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 8003db6:	22ff      	movs	r2, #255	; 0xff
 8003db8:	625a      	str	r2, [r3, #36]	; 0x24
 8003dba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003dbe:	6862      	ldr	r2, [r4, #4]
 8003dc0:	68a3      	ldr	r3, [r4, #8]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8003dc2:	78a1      	ldrb	r1, [r4, #2]
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003dc4:	7820      	ldrb	r0, [r4, #0]
 8003dc6:	4313      	orrs	r3, r2
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8003dc8:	430b      	orrs	r3, r1
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8003dca:	ea43 4000 	orr.w	r0, r3, r0, lsl #16

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8003dce:	7863      	ldrb	r3, [r4, #1]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8003dd0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8003dd4:	78e3      	ldrb	r3, [r4, #3]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8003dd6:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8003dda:	7b23      	ldrb	r3, [r4, #12]
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003ddc:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 8003de0:	e7df      	b.n	8003da2 <RTC_SetAlarm+0x22>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003de2:	7820      	ldrb	r0, [r4, #0]
 8003de4:	f7ff fdde 	bl	80039a4 <RTC_ByteToBcd2>
 8003de8:	4607      	mov	r7, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8003dea:	7860      	ldrb	r0, [r4, #1]
 8003dec:	f7ff fdda 	bl	80039a4 <RTC_ByteToBcd2>
 8003df0:	4606      	mov	r6, r0
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8003df2:	78a0      	ldrb	r0, [r4, #2]
 8003df4:	f7ff fdd6 	bl	80039a4 <RTC_ByteToBcd2>
 8003df8:	4680      	mov	r8, r0
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8003dfa:	7b20      	ldrb	r0, [r4, #12]
 8003dfc:	f7ff fdd2 	bl	80039a4 <RTC_ByteToBcd2>
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003e00:	6862      	ldr	r2, [r4, #4]
 8003e02:	68a3      	ldr	r3, [r4, #8]
 8003e04:	4313      	orrs	r3, r2
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8003e06:	78e2      	ldrb	r2, [r4, #3]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8003e08:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 8003e0c:	ea43 0308 	orr.w	r3, r3, r8
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8003e10:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8003e14:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8003e18:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
 8003e1c:	e7c1      	b.n	8003da2 <RTC_SetAlarm+0x22>
 8003e1e:	bf00      	nop
 8003e20:	40002800 	.word	0x40002800

08003e24 <RTC_AlarmStructInit>:
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8003e24:	2300      	movs	r3, #0
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8003e26:	2201      	movs	r2, #1
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 8003e28:	70c3      	strb	r3, [r0, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 8003e2a:	7003      	strb	r3, [r0, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 8003e2c:	7043      	strb	r3, [r0, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 8003e2e:	7083      	strb	r3, [r0, #2]

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 8003e30:	6083      	str	r3, [r0, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 8003e32:	7302      	strb	r2, [r0, #12]

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 8003e34:	6043      	str	r3, [r0, #4]
 8003e36:	4770      	bx	lr

08003e38 <RTC_GetAlarm>:
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8003e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e3a:	4b17      	ldr	r3, [pc, #92]	; (8003e98 <RTC_GetAlarm+0x60>)
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 8003e3c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
 8003e40:	bf0c      	ite	eq
 8003e42:	69db      	ldreq	r3, [r3, #28]
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
 8003e44:	6a1b      	ldrne	r3, [r3, #32]
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
 8003e46:	4614      	mov	r4, r2
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8003e48:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
 8003e4c:	0c09      	lsrs	r1, r1, #16
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8003e4e:	f3c3 4205 	ubfx	r2, r3, #16, #6
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8003e52:	f3c3 2706 	ubfx	r7, r3, #8, #7
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8003e56:	f003 067f 	and.w	r6, r3, #127	; 0x7f
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8003e5a:	f3c3 6505 	ubfx	r5, r3, #24, #6
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8003e5e:	70e1      	strb	r1, [r4, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8003e60:	f003 4180 	and.w	r1, r3, #1073741824	; 0x40000000
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8003e64:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 8003e68:	7022      	strb	r2, [r4, #0]
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 8003e6a:	7067      	strb	r7, [r4, #1]
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 8003e6c:	70a6      	strb	r6, [r4, #2]
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8003e6e:	7325      	strb	r5, [r4, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 8003e70:	60a1      	str	r1, [r4, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8003e72:	6063      	str	r3, [r4, #4]

  if (RTC_Format == RTC_Format_BIN)
 8003e74:	b978      	cbnz	r0, 8003e96 <RTC_GetAlarm+0x5e>
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8003e76:	4610      	mov	r0, r2
 8003e78:	f7ff fda0 	bl	80039bc <RTC_Bcd2ToByte>
 8003e7c:	7020      	strb	r0, [r4, #0]
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8003e7e:	4638      	mov	r0, r7
 8003e80:	f7ff fd9c 	bl	80039bc <RTC_Bcd2ToByte>
 8003e84:	7060      	strb	r0, [r4, #1]
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8003e86:	4630      	mov	r0, r6
 8003e88:	f7ff fd98 	bl	80039bc <RTC_Bcd2ToByte>
 8003e8c:	70a0      	strb	r0, [r4, #2]
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8003e8e:	4628      	mov	r0, r5
 8003e90:	f7ff fd94 	bl	80039bc <RTC_Bcd2ToByte>
 8003e94:	7320      	strb	r0, [r4, #12]
 8003e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003e98:	40002800 	.word	0x40002800

08003e9c <RTC_AlarmCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
 8003e9c:	b082      	sub	sp, #8
  __IO uint32_t alarmcounter = 0x00;
 8003e9e:	2300      	movs	r3, #0
 8003ea0:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003ea2:	4b14      	ldr	r3, [pc, #80]	; (8003ef4 <RTC_AlarmCmd+0x58>)
 8003ea4:	22ca      	movs	r2, #202	; 0xca
 8003ea6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003ea8:	2253      	movs	r2, #83	; 0x53
 8003eaa:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8003eac:	689a      	ldr	r2, [r3, #8]
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Alarm state */
  if (NewState != DISABLE)
 8003eae:	b119      	cbz	r1, 8003eb8 <RTC_AlarmCmd+0x1c>
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
 8003eb0:	4310      	orrs	r0, r2
 8003eb2:	6098      	str	r0, [r3, #8]

    status = SUCCESS;    
 8003eb4:	2001      	movs	r0, #1
 8003eb6:	e017      	b.n	8003ee8 <RTC_AlarmCmd+0x4c>
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
 8003eb8:	ea22 0200 	bic.w	r2, r2, r0
 8003ebc:	609a      	str	r2, [r3, #8]
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8003ebe:	0a00      	lsrs	r0, r0, #8
 8003ec0:	68da      	ldr	r2, [r3, #12]
      alarmcounter++;  
 8003ec2:	9901      	ldr	r1, [sp, #4]
 8003ec4:	3101      	adds	r1, #1
 8003ec6:	9101      	str	r1, [sp, #4]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8003ec8:	9901      	ldr	r1, [sp, #4]
 8003eca:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    RTC->CR &= (uint32_t)~RTC_Alarm;
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8003ece:	ea00 0202 	and.w	r2, r0, r2
      alarmcounter++;  
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8003ed2:	d106      	bne.n	8003ee2 <RTC_AlarmCmd+0x46>
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 8003ed4:	4b07      	ldr	r3, [pc, #28]	; (8003ef4 <RTC_AlarmCmd+0x58>)
 8003ed6:	68db      	ldr	r3, [r3, #12]
 8003ed8:	4218      	tst	r0, r3
  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;

    status = SUCCESS;    
 8003eda:	bf0c      	ite	eq
 8003edc:	2000      	moveq	r0, #0
 8003ede:	2001      	movne	r0, #1
 8003ee0:	e002      	b.n	8003ee8 <RTC_AlarmCmd+0x4c>
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
      alarmcounter++;  
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8003ee2:	2a00      	cmp	r2, #0
 8003ee4:	d0ec      	beq.n	8003ec0 <RTC_AlarmCmd+0x24>
 8003ee6:	e7f5      	b.n	8003ed4 <RTC_AlarmCmd+0x38>
      status = SUCCESS;
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003ee8:	4b02      	ldr	r3, [pc, #8]	; (8003ef4 <RTC_AlarmCmd+0x58>)
 8003eea:	22ff      	movs	r2, #255	; 0xff
 8003eec:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8003eee:	b002      	add	sp, #8
 8003ef0:	4770      	bx	lr
 8003ef2:	bf00      	nop
 8003ef4:	40002800 	.word	0x40002800

08003ef8 <RTC_AlarmSubSecondConfig>:
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003ef8:	4b07      	ldr	r3, [pc, #28]	; (8003f18 <RTC_AlarmSubSecondConfig+0x20>)
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
 8003efa:	b510      	push	{r4, lr}
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003efc:	24ca      	movs	r4, #202	; 0xca
 8003efe:	625c      	str	r4, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 8003f00:	430a      	orrs	r2, r1
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
 8003f02:	2453      	movs	r4, #83	; 0x53
  
  /* Configure the Alarm A or Alarm B SubSecond registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
  
  if (RTC_Alarm == RTC_Alarm_A)
 8003f04:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
 8003f08:	625c      	str	r4, [r3, #36]	; 0x24
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
  
  if (RTC_Alarm == RTC_Alarm_A)
  {
    /* Configure the AlarmA SubSecond register */
    RTC->ALRMASSR = tmpreg;
 8003f0a:	bf0c      	ite	eq
 8003f0c:	645a      	streq	r2, [r3, #68]	; 0x44
  }
  else
  {
    /* Configure the Alarm B SubSecond register */
    RTC->ALRMBSSR = tmpreg;
 8003f0e:	649a      	strne	r2, [r3, #72]	; 0x48
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8003f10:	22ff      	movs	r2, #255	; 0xff
 8003f12:	625a      	str	r2, [r3, #36]	; 0x24
 8003f14:	bd10      	pop	{r4, pc}
 8003f16:	bf00      	nop
 8003f18:	40002800 	.word	0x40002800

08003f1c <RTC_GetAlarmSubSecond>:
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Subseconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
 8003f1c:	4b04      	ldr	r3, [pc, #16]	; (8003f30 <RTC_GetAlarmSubSecond+0x14>)
  uint32_t tmpreg = 0;
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
 8003f1e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 8003f22:	bf0c      	ite	eq
 8003f24:	6c58      	ldreq	r0, [r3, #68]	; 0x44
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 8003f26:	6c98      	ldrne	r0, [r3, #72]	; 0x48
 8003f28:	0440      	lsls	r0, r0, #17
 8003f2a:	0c40      	lsrs	r0, r0, #17
  } 
  
  return (tmpreg);
}
 8003f2c:	4770      	bx	lr
 8003f2e:	bf00      	nop
 8003f30:	40002800 	.word	0x40002800

08003f34 <RTC_WakeUpClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003f34:	4b07      	ldr	r3, [pc, #28]	; (8003f54 <RTC_WakeUpClockConfig+0x20>)
 8003f36:	22ca      	movs	r2, #202	; 0xca
 8003f38:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003f3a:	2253      	movs	r2, #83	; 0x53
 8003f3c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8003f3e:	689a      	ldr	r2, [r3, #8]
 8003f40:	f022 0207 	bic.w	r2, r2, #7
 8003f44:	609a      	str	r2, [r3, #8]

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8003f46:	689a      	ldr	r2, [r3, #8]
 8003f48:	4310      	orrs	r0, r2
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003f4a:	22ff      	movs	r2, #255	; 0xff

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8003f4c:	6098      	str	r0, [r3, #8]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003f4e:	625a      	str	r2, [r3, #36]	; 0x24
 8003f50:	4770      	bx	lr
 8003f52:	bf00      	nop
 8003f54:	40002800 	.word	0x40002800

08003f58 <RTC_SetWakeUpCounter>:
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003f58:	4b04      	ldr	r3, [pc, #16]	; (8003f6c <RTC_SetWakeUpCounter+0x14>)
 8003f5a:	22ca      	movs	r2, #202	; 0xca
 8003f5c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003f5e:	2253      	movs	r2, #83	; 0x53
 8003f60:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003f62:	22ff      	movs	r2, #255	; 0xff
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 8003f64:	6158      	str	r0, [r3, #20]
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003f66:	625a      	str	r2, [r3, #36]	; 0x24
 8003f68:	4770      	bx	lr
 8003f6a:	bf00      	nop
 8003f6c:	40002800 	.word	0x40002800

08003f70 <RTC_GetWakeUpCounter>:
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 8003f70:	4b01      	ldr	r3, [pc, #4]	; (8003f78 <RTC_GetWakeUpCounter+0x8>)
 8003f72:	6958      	ldr	r0, [r3, #20]
}
 8003f74:	b280      	uxth	r0, r0
 8003f76:	4770      	bx	lr
 8003f78:	40002800 	.word	0x40002800

08003f7c <RTC_WakeUpCmd>:
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
 8003f7c:	b082      	sub	sp, #8
  __IO uint32_t wutcounter = 0x00;
 8003f7e:	2300      	movs	r3, #0
 8003f80:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003f82:	4b12      	ldr	r3, [pc, #72]	; (8003fcc <RTC_WakeUpCmd+0x50>)
 8003f84:	22ca      	movs	r2, #202	; 0xca
 8003f86:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003f88:	2253      	movs	r2, #83	; 0x53
 8003f8a:	625a      	str	r2, [r3, #36]	; 0x24

  if (NewState != DISABLE)
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 8003f8c:	689a      	ldr	r2, [r3, #8]

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  if (NewState != DISABLE)
 8003f8e:	b120      	cbz	r0, 8003f9a <RTC_WakeUpCmd+0x1e>
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 8003f90:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8003f94:	609a      	str	r2, [r3, #8]
    status = SUCCESS;    
 8003f96:	2001      	movs	r0, #1
 8003f98:	e012      	b.n	8003fc0 <RTC_WakeUpCmd+0x44>
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 8003f9a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003f9e:	609a      	str	r2, [r3, #8]
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8003fa0:	68da      	ldr	r2, [r3, #12]
      wutcounter++;  
 8003fa2:	9901      	ldr	r1, [sp, #4]
 8003fa4:	3101      	adds	r1, #1
 8003fa6:	9101      	str	r1, [sp, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8003fa8:	9901      	ldr	r1, [sp, #4]
 8003faa:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8003fae:	f002 0204 	and.w	r2, r2, #4
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8003fb2:	d001      	beq.n	8003fb8 <RTC_WakeUpCmd+0x3c>
 8003fb4:	2a00      	cmp	r2, #0
 8003fb6:	d0f3      	beq.n	8003fa0 <RTC_WakeUpCmd+0x24>
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8003fb8:	4b04      	ldr	r3, [pc, #16]	; (8003fcc <RTC_WakeUpCmd+0x50>)
 8003fba:	68d8      	ldr	r0, [r3, #12]

  if (NewState != DISABLE)
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
    status = SUCCESS;    
 8003fbc:	f3c0 0080 	ubfx	r0, r0, #2, #1
      status = SUCCESS;
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003fc0:	4b02      	ldr	r3, [pc, #8]	; (8003fcc <RTC_WakeUpCmd+0x50>)
 8003fc2:	22ff      	movs	r2, #255	; 0xff
 8003fc4:	625a      	str	r2, [r3, #36]	; 0x24
  
  return status;
}
 8003fc6:	b002      	add	sp, #8
 8003fc8:	4770      	bx	lr
 8003fca:	bf00      	nop
 8003fcc:	40002800 	.word	0x40002800

08003fd0 <RTC_DayLightSavingConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8003fd0:	4b07      	ldr	r3, [pc, #28]	; (8003ff0 <RTC_DayLightSavingConfig+0x20>)
 8003fd2:	22ca      	movs	r2, #202	; 0xca
 8003fd4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8003fd6:	2253      	movs	r2, #83	; 0x53
 8003fd8:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 8003fda:	689a      	ldr	r2, [r3, #8]
 8003fdc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003fe0:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 8003fe2:	689a      	ldr	r2, [r3, #8]
 8003fe4:	4310      	orrs	r0, r2
 8003fe6:	4301      	orrs	r1, r0

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003fe8:	22ff      	movs	r2, #255	; 0xff

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 8003fea:	6099      	str	r1, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8003fec:	625a      	str	r2, [r3, #36]	; 0x24
 8003fee:	4770      	bx	lr
 8003ff0:	40002800 	.word	0x40002800

08003ff4 <RTC_GetStoreOperation>:
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
  return (RTC->CR & RTC_CR_BCK);
 8003ff4:	4b02      	ldr	r3, [pc, #8]	; (8004000 <RTC_GetStoreOperation+0xc>)
 8003ff6:	6898      	ldr	r0, [r3, #8]
}
 8003ff8:	f400 2080 	and.w	r0, r0, #262144	; 0x40000
 8003ffc:	4770      	bx	lr
 8003ffe:	bf00      	nop
 8004000:	40002800 	.word	0x40002800

08004004 <RTC_OutputConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8004004:	4b07      	ldr	r3, [pc, #28]	; (8004024 <RTC_OutputConfig+0x20>)
 8004006:	22ca      	movs	r2, #202	; 0xca
 8004008:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800400a:	2253      	movs	r2, #83	; 0x53
 800400c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 800400e:	689a      	ldr	r2, [r3, #8]
 8004010:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 8004014:	609a      	str	r2, [r3, #8]

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 8004016:	689a      	ldr	r2, [r3, #8]
 8004018:	4310      	orrs	r0, r2
 800401a:	4301      	orrs	r1, r0

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800401c:	22ff      	movs	r2, #255	; 0xff

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 800401e:	6099      	str	r1, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8004020:	625a      	str	r2, [r3, #36]	; 0x24
 8004022:	4770      	bx	lr
 8004024:	40002800 	.word	0x40002800

08004028 <RTC_CoarseCalibConfig>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
 8004028:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 800402a:	4c09      	ldr	r4, [pc, #36]	; (8004050 <RTC_CoarseCalibConfig+0x28>)
 800402c:	23ca      	movs	r3, #202	; 0xca
 800402e:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 8004030:	2353      	movs	r3, #83	; 0x53
 8004032:	6263      	str	r3, [r4, #36]	; 0x24
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
 8004034:	4605      	mov	r5, r0
 8004036:	460e      	mov	r6, r1
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8004038:	f7ff fcda 	bl	80039f0 <RTC_EnterInitMode>
 800403c:	b120      	cbz	r0, 8004048 <RTC_CoarseCalibConfig+0x20>
    status = ERROR;
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
 800403e:	4335      	orrs	r5, r6
 8004040:	61a5      	str	r5, [r4, #24]
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8004042:	f7ff fcf5 	bl	8003a30 <RTC_ExitInitMode>
    
    status = SUCCESS;
 8004046:	2001      	movs	r0, #1
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8004048:	23ff      	movs	r3, #255	; 0xff
 800404a:	6263      	str	r3, [r4, #36]	; 0x24
  
  return status;
}
 800404c:	bd70      	pop	{r4, r5, r6, pc}
 800404e:	bf00      	nop
 8004050:	40002800 	.word	0x40002800

08004054 <RTC_CoarseCalibCmd>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
 8004054:	b538      	push	{r3, r4, r5, lr}
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8004056:	4c0b      	ldr	r4, [pc, #44]	; (8004084 <RTC_CoarseCalibCmd+0x30>)
 8004058:	23ca      	movs	r3, #202	; 0xca
 800405a:	6263      	str	r3, [r4, #36]	; 0x24
  RTC->WPR = 0x53;
 800405c:	2353      	movs	r3, #83	; 0x53
 800405e:	6263      	str	r3, [r4, #36]	; 0x24
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
 8004060:	4605      	mov	r5, r0
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
 8004062:	f7ff fcc5 	bl	80039f0 <RTC_EnterInitMode>
 8004066:	b150      	cbz	r0, 800407e <RTC_CoarseCalibCmd+0x2a>
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 8004068:	68a3      	ldr	r3, [r4, #8]
  {
    status =  ERROR;
  }
  else
  {
    if (NewState != DISABLE)
 800406a:	b115      	cbz	r5, 8004072 <RTC_CoarseCalibCmd+0x1e>
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 800406c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004070:	e001      	b.n	8004076 <RTC_CoarseCalibCmd+0x22>
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
 8004072:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004076:	60a3      	str	r3, [r4, #8]
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
 8004078:	f7ff fcda 	bl	8003a30 <RTC_ExitInitMode>
    
    status = SUCCESS;
 800407c:	2001      	movs	r0, #1
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 800407e:	23ff      	movs	r3, #255	; 0xff
 8004080:	6263      	str	r3, [r4, #36]	; 0x24
  
  return status;
}
 8004082:	bd38      	pop	{r3, r4, r5, pc}
 8004084:	40002800 	.word	0x40002800

08004088 <RTC_CalibOutputCmd>:
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8004088:	4b07      	ldr	r3, [pc, #28]	; (80040a8 <RTC_CalibOutputCmd+0x20>)
 800408a:	22ca      	movs	r2, #202	; 0xca
 800408c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800408e:	2253      	movs	r2, #83	; 0x53
 8004090:	625a      	str	r2, [r3, #36]	; 0x24
  
  if (NewState != DISABLE)
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 8004092:	689a      	ldr	r2, [r3, #8]
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
 8004094:	b110      	cbz	r0, 800409c <RTC_CalibOutputCmd+0x14>
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
 8004096:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800409a:	e001      	b.n	80040a0 <RTC_CalibOutputCmd+0x18>
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 800409c:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80040a0:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 80040a2:	22ff      	movs	r2, #255	; 0xff
 80040a4:	625a      	str	r2, [r3, #36]	; 0x24
 80040a6:	4770      	bx	lr
 80040a8:	40002800 	.word	0x40002800

080040ac <RTC_CalibOutputConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80040ac:	4b07      	ldr	r3, [pc, #28]	; (80040cc <RTC_CalibOutputConfig+0x20>)
 80040ae:	22ca      	movs	r2, #202	; 0xca
 80040b0:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80040b2:	2253      	movs	r2, #83	; 0x53
 80040b4:	625a      	str	r2, [r3, #36]	; 0x24
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 80040b6:	689a      	ldr	r2, [r3, #8]
 80040b8:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80040bc:	609a      	str	r2, [r3, #8]

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 80040be:	689a      	ldr	r2, [r3, #8]
 80040c0:	4310      	orrs	r0, r2

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 80040c2:	22ff      	movs	r2, #255	; 0xff
  
  /*clear flags before config*/
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 80040c4:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 80040c6:	625a      	str	r2, [r3, #36]	; 0x24
 80040c8:	4770      	bx	lr
 80040ca:	bf00      	nop
 80040cc:	40002800 	.word	0x40002800

080040d0 <RTC_SmoothCalibConfig>:
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80040d0:	4b0e      	ldr	r3, [pc, #56]	; (800410c <RTC_SmoothCalibConfig+0x3c>)
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
 80040d2:	b530      	push	{r4, r5, lr}
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80040d4:	24ca      	movs	r4, #202	; 0xca
 80040d6:	625c      	str	r4, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80040d8:	2453      	movs	r4, #83	; 0x53
 80040da:	625c      	str	r4, [r3, #36]	; 0x24
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 80040dc:	68dc      	ldr	r4, [r3, #12]
 80040de:	03e4      	lsls	r4, r4, #15
 80040e0:	d506      	bpl.n	80040f0 <RTC_SmoothCalibConfig+0x20>
 80040e2:	4c0b      	ldr	r4, [pc, #44]	; (8004110 <RTC_SmoothCalibConfig+0x40>)
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 80040e4:	68dd      	ldr	r5, [r3, #12]
 80040e6:	f415 3f80 	tst.w	r5, #65536	; 0x10000
 80040ea:	d001      	beq.n	80040f0 <RTC_SmoothCalibConfig+0x20>
 80040ec:	3c01      	subs	r4, #1
 80040ee:	d1f9      	bne.n	80040e4 <RTC_SmoothCalibConfig+0x14>
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 80040f0:	4b06      	ldr	r3, [pc, #24]	; (800410c <RTC_SmoothCalibConfig+0x3c>)
 80040f2:	68dc      	ldr	r4, [r3, #12]
 80040f4:	f414 3f80 	tst.w	r4, #65536	; 0x10000
 80040f8:	d104      	bne.n	8004104 <RTC_SmoothCalibConfig+0x34>
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 80040fa:	4301      	orrs	r1, r0
 80040fc:	4311      	orrs	r1, r2
 80040fe:	63d9      	str	r1, [r3, #60]	; 0x3c

    status = SUCCESS;
 8004100:	2001      	movs	r0, #1
 8004102:	e000      	b.n	8004106 <RTC_SmoothCalibConfig+0x36>
  }
  else
  {
    status = ERROR;
 8004104:	2000      	movs	r0, #0
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8004106:	22ff      	movs	r2, #255	; 0xff
 8004108:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
}
 800410a:	bd30      	pop	{r4, r5, pc}
 800410c:	40002800 	.word	0x40002800
 8004110:	00020001 	.word	0x00020001

08004114 <RTC_TimeStampCmd>:
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8004114:	4b08      	ldr	r3, [pc, #32]	; (8004138 <RTC_TimeStampCmd+0x24>)
 8004116:	689a      	ldr	r2, [r3, #8]
 8004118:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800411c:	f022 0208 	bic.w	r2, r2, #8

  /* Get the new configuration */
  if (NewState != DISABLE)
 8004120:	b109      	cbz	r1, 8004126 <RTC_TimeStampCmd+0x12>
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 8004122:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 8004126:	4310      	orrs	r0, r2
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8004128:	22ca      	movs	r2, #202	; 0xca
 800412a:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800412c:	2253      	movs	r2, #83	; 0x53
 800412e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8004130:	22ff      	movs	r2, #255	; 0xff
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
 8004132:	6098      	str	r0, [r3, #8]

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8004134:	625a      	str	r2, [r3, #36]	; 0x24
 8004136:	4770      	bx	lr
 8004138:	40002800 	.word	0x40002800

0800413c <RTC_GetTimeStamp>:
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 800413c:	b538      	push	{r3, r4, r5, lr}
 800413e:	4615      	mov	r5, r2

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 8004140:	4a1a      	ldr	r2, [pc, #104]	; (80041ac <RTC_GetTimeStamp+0x70>)
 8004142:	6b13      	ldr	r3, [r2, #48]	; 0x30
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 8004144:	6b52      	ldr	r2, [r2, #52]	; 0x34
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
 8004146:	460c      	mov	r4, r1
  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8004148:	f3c3 4105 	ubfx	r1, r3, #16, #6
 800414c:	7021      	strb	r1, [r4, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 800414e:	f3c3 2106 	ubfx	r1, r3, #8, #7
 8004152:	7061      	strb	r1, [r4, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8004154:	f003 017f 	and.w	r1, r3, #127	; 0x7f
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 8004158:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800415c:	0c1b      	lsrs	r3, r3, #16
 800415e:	70e3      	strb	r3, [r4, #3]

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 8004160:	2300      	movs	r3, #0
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 8004162:	70a1      	strb	r1, [r4, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
 8004164:	70eb      	strb	r3, [r5, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8004166:	f3c2 2304 	ubfx	r3, r2, #8, #5
 800416a:	706b      	strb	r3, [r5, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 800416c:	f002 033f 	and.w	r3, r2, #63	; 0x3f
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8004170:	f3c2 3242 	ubfx	r2, r2, #13, #3
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8004174:	70ab      	strb	r3, [r5, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8004176:	702a      	strb	r2, [r5, #0]

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
 8004178:	b9b8      	cbnz	r0, 80041aa <RTC_GetTimeStamp+0x6e>
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800417a:	7820      	ldrb	r0, [r4, #0]
 800417c:	f7ff fc1e 	bl	80039bc <RTC_Bcd2ToByte>
 8004180:	7020      	strb	r0, [r4, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 8004182:	7860      	ldrb	r0, [r4, #1]
 8004184:	f7ff fc1a 	bl	80039bc <RTC_Bcd2ToByte>
 8004188:	7060      	strb	r0, [r4, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 800418a:	78a0      	ldrb	r0, [r4, #2]
 800418c:	f7ff fc16 	bl	80039bc <RTC_Bcd2ToByte>
 8004190:	70a0      	strb	r0, [r4, #2]

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 8004192:	7868      	ldrb	r0, [r5, #1]
 8004194:	f7ff fc12 	bl	80039bc <RTC_Bcd2ToByte>
 8004198:	7068      	strb	r0, [r5, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 800419a:	78a8      	ldrb	r0, [r5, #2]
 800419c:	f7ff fc0e 	bl	80039bc <RTC_Bcd2ToByte>
 80041a0:	70a8      	strb	r0, [r5, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 80041a2:	7828      	ldrb	r0, [r5, #0]
 80041a4:	f7ff fc0a 	bl	80039bc <RTC_Bcd2ToByte>
 80041a8:	7028      	strb	r0, [r5, #0]
 80041aa:	bd38      	pop	{r3, r4, r5, pc}
 80041ac:	40002800 	.word	0x40002800

080041b0 <RTC_GetTimeStampSubSecond>:
  * @retval RTC current timestamp Subseconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
  /* Get timestamp subseconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
 80041b0:	4b01      	ldr	r3, [pc, #4]	; (80041b8 <RTC_GetTimeStampSubSecond+0x8>)
 80041b2:	6b98      	ldr	r0, [r3, #56]	; 0x38
}
 80041b4:	4770      	bx	lr
 80041b6:	bf00      	nop
 80041b8:	40002800 	.word	0x40002800

080041bc <RTC_TamperTriggerConfig>:
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
 80041bc:	4b04      	ldr	r3, [pc, #16]	; (80041d0 <RTC_TamperTriggerConfig+0x14>)
 80041be:	0040      	lsls	r0, r0, #1
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 80041c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 80041c2:	b911      	cbnz	r1, 80041ca <RTC_TamperTriggerConfig+0xe>
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 80041c4:	ea22 0000 	bic.w	r0, r2, r0
 80041c8:	e000      	b.n	80041cc <RTC_TamperTriggerConfig+0x10>
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 80041ca:	4310      	orrs	r0, r2
 80041cc:	6418      	str	r0, [r3, #64]	; 0x40
 80041ce:	4770      	bx	lr
 80041d0:	40002800 	.word	0x40002800

080041d4 <RTC_TamperCmd>:
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
 80041d4:	4b04      	ldr	r3, [pc, #16]	; (80041e8 <RTC_TamperCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 80041d6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80041d8:	b109      	cbz	r1, 80041de <RTC_TamperCmd+0xa>
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 80041da:	4310      	orrs	r0, r2
 80041dc:	e001      	b.n	80041e2 <RTC_TamperCmd+0xe>
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 80041de:	ea22 0000 	bic.w	r0, r2, r0
 80041e2:	6418      	str	r0, [r3, #64]	; 0x40
 80041e4:	4770      	bx	lr
 80041e6:	bf00      	nop
 80041e8:	40002800 	.word	0x40002800

080041ec <RTC_TamperFilterConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 80041ec:	4b04      	ldr	r3, [pc, #16]	; (8004200 <RTC_TamperFilterConfig+0x14>)
 80041ee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80041f0:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 80041f4:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 80041f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80041f8:	4310      	orrs	r0, r2
 80041fa:	6418      	str	r0, [r3, #64]	; 0x40
 80041fc:	4770      	bx	lr
 80041fe:	bf00      	nop
 8004200:	40002800 	.word	0x40002800

08004204 <RTC_TamperSamplingFreqConfig>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 8004204:	4b04      	ldr	r3, [pc, #16]	; (8004218 <RTC_TamperSamplingFreqConfig+0x14>)
 8004206:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004208:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800420c:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 800420e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004210:	4310      	orrs	r0, r2
 8004212:	6418      	str	r0, [r3, #64]	; 0x40
 8004214:	4770      	bx	lr
 8004216:	bf00      	nop
 8004218:	40002800 	.word	0x40002800

0800421c <RTC_TamperPinsPrechargeDuration>:
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 800421c:	4b04      	ldr	r3, [pc, #16]	; (8004230 <RTC_TamperPinsPrechargeDuration+0x14>)
 800421e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004220:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 8004224:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 8004226:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004228:	4310      	orrs	r0, r2
 800422a:	6418      	str	r0, [r3, #64]	; 0x40
 800422c:	4770      	bx	lr
 800422e:	bf00      	nop
 8004230:	40002800 	.word	0x40002800

08004234 <RTC_TimeStampOnTamperDetectionCmd>:
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
 8004234:	4b04      	ldr	r3, [pc, #16]	; (8004248 <RTC_TimeStampOnTamperDetectionCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 8004236:	6c1a      	ldr	r2, [r3, #64]	; 0x40
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
 8004238:	b110      	cbz	r0, 8004240 <RTC_TimeStampOnTamperDetectionCmd+0xc>
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 800423a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800423e:	e001      	b.n	8004244 <RTC_TimeStampOnTamperDetectionCmd+0x10>
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 8004240:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8004244:	641a      	str	r2, [r3, #64]	; 0x40
 8004246:	4770      	bx	lr
 8004248:	40002800 	.word	0x40002800

0800424c <RTC_TamperPullUpCmd>:
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
 800424c:	4b04      	ldr	r3, [pc, #16]	; (8004260 <RTC_TamperPullUpCmd+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 800424e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
 8004250:	b110      	cbz	r0, 8004258 <RTC_TamperPullUpCmd+0xc>
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 8004252:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004256:	e001      	b.n	800425c <RTC_TamperPullUpCmd+0x10>
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 8004258:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800425c:	641a      	str	r2, [r3, #64]	; 0x40
 800425e:	4770      	bx	lr
 8004260:	40002800 	.word	0x40002800

08004264 <RTC_WriteBackupRegister>:
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
 8004264:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8004266:	2300      	movs	r3, #0
 8004268:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 800426a:	4b05      	ldr	r3, [pc, #20]	; (8004280 <RTC_WriteBackupRegister+0x1c>)
 800426c:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 800426e:	9b01      	ldr	r3, [sp, #4]
 8004270:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8004274:	9001      	str	r0, [sp, #4]

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8004276:	9b01      	ldr	r3, [sp, #4]
 8004278:	6019      	str	r1, [r3, #0]
}
 800427a:	b002      	add	sp, #8
 800427c:	4770      	bx	lr
 800427e:	bf00      	nop
 8004280:	40002850 	.word	0x40002850

08004284 <RTC_ReadBackupRegister>:
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
 8004284:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8004286:	2300      	movs	r3, #0
 8004288:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
 800428a:	4b05      	ldr	r3, [pc, #20]	; (80042a0 <RTC_ReadBackupRegister+0x1c>)
 800428c:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 800428e:	9b01      	ldr	r3, [sp, #4]
 8004290:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8004294:	9001      	str	r0, [sp, #4]
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8004296:	9b01      	ldr	r3, [sp, #4]
 8004298:	6818      	ldr	r0, [r3, #0]
}
 800429a:	b002      	add	sp, #8
 800429c:	4770      	bx	lr
 800429e:	bf00      	nop
 80042a0:	40002850 	.word	0x40002850

080042a4 <RTC_TamperPinSelection>:
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
 80042a4:	4b04      	ldr	r3, [pc, #16]	; (80042b8 <RTC_TamperPinSelection+0x14>)
 80042a6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80042ac:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
 80042ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042b0:	4310      	orrs	r0, r2
 80042b2:	6418      	str	r0, [r3, #64]	; 0x40
 80042b4:	4770      	bx	lr
 80042b6:	bf00      	nop
 80042b8:	40002800 	.word	0x40002800

080042bc <RTC_TimeStampPinSelection>:
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
 80042bc:	4b04      	ldr	r3, [pc, #16]	; (80042d0 <RTC_TimeStampPinSelection+0x14>)
 80042be:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042c0:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80042c4:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
 80042c6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042c8:	4310      	orrs	r0, r2
 80042ca:	6418      	str	r0, [r3, #64]	; 0x40
 80042cc:	4770      	bx	lr
 80042ce:	bf00      	nop
 80042d0:	40002800 	.word	0x40002800

080042d4 <RTC_OutputTypeConfig>:
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 80042d4:	4b04      	ldr	r3, [pc, #16]	; (80042e8 <RTC_OutputTypeConfig+0x14>)
 80042d6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042d8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80042dc:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 80042de:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80042e0:	4310      	orrs	r0, r2
 80042e2:	6418      	str	r0, [r3, #64]	; 0x40
 80042e4:	4770      	bx	lr
 80042e6:	bf00      	nop
 80042e8:	40002800 	.word	0x40002800

080042ec <RTC_SynchroShiftConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80042ec:	4b14      	ldr	r3, [pc, #80]	; (8004340 <RTC_SynchroShiftConfig+0x54>)
 80042ee:	22ca      	movs	r2, #202	; 0xca
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
 80042f0:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 80042f2:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80042f4:	2253      	movs	r2, #83	; 0x53
 80042f6:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 80042f8:	68da      	ldr	r2, [r3, #12]
 80042fa:	0712      	lsls	r2, r2, #28
 80042fc:	d507      	bpl.n	800430e <RTC_SynchroShiftConfig+0x22>
 80042fe:	f241 0201 	movw	r2, #4097	; 0x1001
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 8004302:	68dc      	ldr	r4, [r3, #12]
 8004304:	f014 0f08 	tst.w	r4, #8
 8004308:	d001      	beq.n	800430e <RTC_SynchroShiftConfig+0x22>
 800430a:	3a01      	subs	r2, #1
 800430c:	d1f9      	bne.n	8004302 <RTC_SynchroShiftConfig+0x16>
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 800430e:	4b0c      	ldr	r3, [pc, #48]	; (8004340 <RTC_SynchroShiftConfig+0x54>)
 8004310:	68da      	ldr	r2, [r3, #12]
 8004312:	f012 0208 	ands.w	r2, r2, #8
 8004316:	d10b      	bne.n	8004330 <RTC_SynchroShiftConfig+0x44>
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 8004318:	689c      	ldr	r4, [r3, #8]
 800431a:	f014 0f10 	tst.w	r4, #16
 800431e:	d109      	bne.n	8004334 <RTC_SynchroShiftConfig+0x48>
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 8004320:	4308      	orrs	r0, r1
 8004322:	62d8      	str	r0, [r3, #44]	; 0x2c
    
      if(RTC_WaitForSynchro() == ERROR)
 8004324:	f7ff fbae 	bl	8003a84 <RTC_WaitForSynchro>
        status = SUCCESS;
      }
    }
    else
    {
      status = ERROR;
 8004328:	3000      	adds	r0, #0
 800432a:	bf18      	it	ne
 800432c:	2001      	movne	r0, #1
 800432e:	e002      	b.n	8004336 <RTC_SynchroShiftConfig+0x4a>
    }
  }
  else
  {
    status = ERROR;
 8004330:	2000      	movs	r0, #0
 8004332:	e000      	b.n	8004336 <RTC_SynchroShiftConfig+0x4a>
 8004334:	4610      	mov	r0, r2
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
 8004336:	4b02      	ldr	r3, [pc, #8]	; (8004340 <RTC_SynchroShiftConfig+0x54>)
 8004338:	22ff      	movs	r2, #255	; 0xff
 800433a:	625a      	str	r2, [r3, #36]	; 0x24
  
  return (ErrorStatus)(status);
}
 800433c:	bd10      	pop	{r4, pc}
 800433e:	bf00      	nop
 8004340:	40002800 	.word	0x40002800

08004344 <RTC_ITConfig>:
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 8004344:	4b0e      	ldr	r3, [pc, #56]	; (8004380 <RTC_ITConfig+0x3c>)
 8004346:	22ca      	movs	r2, #202	; 0xca
 8004348:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800434a:	2253      	movs	r2, #83	; 0x53
 800434c:	625a      	str	r2, [r3, #36]	; 0x24
 800434e:	f020 0204 	bic.w	r2, r0, #4

  if (NewState != DISABLE)
 8004352:	b139      	cbz	r1, 8004364 <RTC_ITConfig+0x20>
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 8004354:	6899      	ldr	r1, [r3, #8]
 8004356:	430a      	orrs	r2, r1
 8004358:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 800435a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800435c:	f000 0004 	and.w	r0, r0, #4
 8004360:	4310      	orrs	r0, r2
 8004362:	e008      	b.n	8004376 <RTC_ITConfig+0x32>
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 8004364:	6899      	ldr	r1, [r3, #8]
 8004366:	ea21 0202 	bic.w	r2, r1, r2
 800436a:	609a      	str	r2, [r3, #8]
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 800436c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800436e:	f000 0004 	and.w	r0, r0, #4
 8004372:	ea22 0000 	bic.w	r0, r2, r0
 8004376:	6418      	str	r0, [r3, #64]	; 0x40
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 8004378:	4b01      	ldr	r3, [pc, #4]	; (8004380 <RTC_ITConfig+0x3c>)
 800437a:	22ff      	movs	r2, #255	; 0xff
 800437c:	625a      	str	r2, [r3, #36]	; 0x24
 800437e:	4770      	bx	lr
 8004380:	40002800 	.word	0x40002800

08004384 <RTC_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 8004384:	4b04      	ldr	r3, [pc, #16]	; (8004398 <RTC_GetFlagStatus+0x14>)
 8004386:	68da      	ldr	r2, [r3, #12]
 8004388:	4b04      	ldr	r3, [pc, #16]	; (800439c <RTC_GetFlagStatus+0x18>)
 800438a:	4013      	ands	r3, r2
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 800438c:	4203      	tst	r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800438e:	bf0c      	ite	eq
 8004390:	2000      	moveq	r0, #0
 8004392:	2001      	movne	r0, #1
 8004394:	4770      	bx	lr
 8004396:	bf00      	nop
 8004398:	40002800 	.word	0x40002800
 800439c:	00013f7f 	.word	0x00013f7f

080043a0 <RTC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 80043a0:	4b05      	ldr	r3, [pc, #20]	; (80043b8 <RTC_ClearFlag+0x18>)
 80043a2:	68da      	ldr	r2, [r3, #12]
 80043a4:	b280      	uxth	r0, r0
 80043a6:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80043aa:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80043ae:	ea62 0200 	orn	r2, r2, r0
 80043b2:	60da      	str	r2, [r3, #12]
 80043b4:	4770      	bx	lr
 80043b6:	bf00      	nop
 80043b8:	40002800 	.word	0x40002800

080043bc <RTC_GetITStatus>:
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80043bc:	4b0a      	ldr	r3, [pc, #40]	; (80043e8 <RTC_GetITStatus+0x2c>)
 80043be:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
 80043c0:	b510      	push	{r4, lr}
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 80043c2:	689c      	ldr	r4, [r3, #8]
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 80043c4:	68d9      	ldr	r1, [r3, #12]
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 80043c6:	f002 0204 	and.w	r2, r2, #4
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 80043ca:	ea02 32d0 	and.w	r2, r2, r0, lsr #15
 80043ce:	ea00 0304 	and.w	r3, r0, r4
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 80043d2:	4313      	orrs	r3, r2
 80043d4:	d006      	beq.n	80043e4 <RTC_GetITStatus+0x28>
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 80043d6:	b28b      	uxth	r3, r1
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 80043d8:	ea13 1310 	ands.w	r3, r3, r0, lsr #4
  {
    bitstatus = SET;
 80043dc:	bf0c      	ite	eq
 80043de:	2000      	moveq	r0, #0
 80043e0:	2001      	movne	r0, #1
 80043e2:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 80043e4:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 80043e6:	bd10      	pop	{r4, pc}
 80043e8:	40002800 	.word	0x40002800

080043ec <RTC_ClearITPendingBit>:

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 80043ec:	4b05      	ldr	r3, [pc, #20]	; (8004404 <RTC_ClearITPendingBit+0x18>)
 80043ee:	68da      	ldr	r2, [r3, #12]
 80043f0:	f3c0 100f 	ubfx	r0, r0, #4, #16
 80043f4:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80043f8:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80043fc:	ea62 0200 	orn	r2, r2, r0
 8004400:	60da      	str	r2, [r3, #12]
 8004402:	4770      	bx	lr
 8004404:	40002800 	.word	0x40002800

08004408 <SDIO_DeInit>:
  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void SDIO_DeInit(void)
{
 8004408:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
 800440a:	2101      	movs	r1, #1
 800440c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004410:	f7ff f9e4 	bl	80037dc <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
 8004414:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004418:	2100      	movs	r1, #0
}
 800441a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void SDIO_DeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
 800441e:	f7ff b9dd 	b.w	80037dc <RCC_APB2PeriphResetCmd>

08004422 <SDIO_Init>:
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8004422:	6881      	ldr	r1, [r0, #8]
  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
 8004424:	4a09      	ldr	r2, [pc, #36]	; (800444c <SDIO_Init+0x2a>)
  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
  *         that contains the configuration information for the SDIO peripheral.
  * @retval None
  */
void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
{
 8004426:	b510      	push	{r4, lr}
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8004428:	6844      	ldr	r4, [r0, #4]
  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
 800442a:	6853      	ldr	r3, [r2, #4]
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 800442c:	430c      	orrs	r4, r1
 800442e:	68c1      	ldr	r1, [r0, #12]
 8004430:	430c      	orrs	r4, r1
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8004432:	6801      	ldr	r1, [r0, #0]
 8004434:	430c      	orrs	r4, r1
 8004436:	6901      	ldr	r1, [r0, #16]
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8004438:	7d00      	ldrb	r0, [r0, #20]
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
  
  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
  tmpreg &= CLKCR_CLEAR_MASK;
 800443a:	f423 43fd 	bic.w	r3, r3, #32384	; 0x7e80
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 800443e:	4321      	orrs	r1, r4
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
  
  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
  tmpreg &= CLKCR_CLEAR_MASK;
 8004440:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
 8004444:	430b      	orrs	r3, r1
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8004446:	4303      	orrs	r3, r0
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
  
  /* Write to SDIO CLKCR */
  SDIO->CLKCR = tmpreg;
 8004448:	6053      	str	r3, [r2, #4]
 800444a:	bd10      	pop	{r4, pc}
 800444c:	40012c00 	.word	0x40012c00

08004450 <SDIO_StructInit>:
  * @retval None
  */
void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
{
  /* SDIO_InitStruct members default value */
  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
 8004450:	2300      	movs	r3, #0
 8004452:	7503      	strb	r3, [r0, #20]
  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
 8004454:	6003      	str	r3, [r0, #0]
  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
 8004456:	6043      	str	r3, [r0, #4]
  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
 8004458:	6083      	str	r3, [r0, #8]
  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
 800445a:	60c3      	str	r3, [r0, #12]
  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
 800445c:	6103      	str	r3, [r0, #16]
 800445e:	4770      	bx	lr

08004460 <SDIO_ClockCmd>:
void SDIO_ClockCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
 8004460:	4b01      	ldr	r3, [pc, #4]	; (8004468 <SDIO_ClockCmd+0x8>)
 8004462:	6018      	str	r0, [r3, #0]
 8004464:	4770      	bx	lr
 8004466:	bf00      	nop
 8004468:	422580a0 	.word	0x422580a0

0800446c <SDIO_SetPowerState>:
void SDIO_SetPowerState(uint32_t SDIO_PowerState)
{
  /* Check the parameters */
  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
  
  SDIO->POWER = SDIO_PowerState;
 800446c:	4b01      	ldr	r3, [pc, #4]	; (8004474 <SDIO_SetPowerState+0x8>)
 800446e:	6018      	str	r0, [r3, #0]
 8004470:	4770      	bx	lr
 8004472:	bf00      	nop
 8004474:	40012c00 	.word	0x40012c00

08004478 <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(void)
{
  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
 8004478:	4b02      	ldr	r3, [pc, #8]	; (8004484 <SDIO_GetPowerState+0xc>)
 800447a:	6818      	ldr	r0, [r3, #0]
}
 800447c:	f000 0003 	and.w	r0, r0, #3
 8004480:	4770      	bx	lr
 8004482:	bf00      	nop
 8004484:	40012c00 	.word	0x40012c00

08004488 <SDIO_SendCommand>:
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
  
/*---------------------------- SDIO ARG Configuration ------------------------*/
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
 8004488:	6802      	ldr	r2, [r0, #0]
 800448a:	4b09      	ldr	r3, [pc, #36]	; (80044b0 <SDIO_SendCommand+0x28>)
  *         structure that contains the configuration information for the SDIO 
  *         command.
  * @retval None
  */
void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 800448c:	b510      	push	{r4, lr}
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
  
/*---------------------------- SDIO ARG Configuration ------------------------*/
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
 800448e:	609a      	str	r2, [r3, #8]
  tmpreg &= CMD_CLEAR_MASK;
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 8004490:	6841      	ldr	r1, [r0, #4]
 8004492:	6884      	ldr	r4, [r0, #8]
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
 8004494:	68da      	ldr	r2, [r3, #12]
  tmpreg &= CMD_CLEAR_MASK;
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 8004496:	430c      	orrs	r4, r1
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
 8004498:	68c1      	ldr	r1, [r0, #12]
 800449a:	6900      	ldr	r0, [r0, #16]
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
  tmpreg &= CMD_CLEAR_MASK;
 800449c:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
 80044a0:	4321      	orrs	r1, r4
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
  tmpreg &= CMD_CLEAR_MASK;
 80044a2:	f022 0207 	bic.w	r2, r2, #7
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
 80044a6:	4301      	orrs	r1, r0
  tmpreg &= CMD_CLEAR_MASK;
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 80044a8:	430a      	orrs	r2, r1
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
  
  /* Write to SDIO CMD */
  SDIO->CMD = tmpreg;
 80044aa:	60da      	str	r2, [r3, #12]
 80044ac:	bd10      	pop	{r4, pc}
 80044ae:	bf00      	nop
 80044b0:	40012c00 	.word	0x40012c00

080044b4 <SDIO_CmdStructInit>:
  * @retval None
  */
void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
{
  /* SDIO_CmdInitStruct members default value */
  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
 80044b4:	2300      	movs	r3, #0
 80044b6:	6003      	str	r3, [r0, #0]
  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
 80044b8:	6043      	str	r3, [r0, #4]
  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
 80044ba:	6083      	str	r3, [r0, #8]
  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
 80044bc:	60c3      	str	r3, [r0, #12]
  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
 80044be:	6103      	str	r3, [r0, #16]
 80044c0:	4770      	bx	lr

080044c2 <SDIO_GetCommandResponse>:
  * @param  None
  * @retval Returns the command index of the last command response received.
  */
uint8_t SDIO_GetCommandResponse(void)
{
  return (uint8_t)(SDIO->RESPCMD);
 80044c2:	4b02      	ldr	r3, [pc, #8]	; (80044cc <SDIO_GetCommandResponse+0xa>)
 80044c4:	6918      	ldr	r0, [r3, #16]
}
 80044c6:	b2c0      	uxtb	r0, r0
 80044c8:	4770      	bx	lr
 80044ca:	bf00      	nop
 80044cc:	40012c00 	.word	0x40012c00

080044d0 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4
  * @retval The Corresponding response register value.
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 80044d0:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80044d2:	2300      	movs	r3, #0
 80044d4:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 80044d6:	4b03      	ldr	r3, [pc, #12]	; (80044e4 <SDIO_GetResponse+0x14>)
 80044d8:	18c3      	adds	r3, r0, r3
 80044da:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp); 
 80044dc:	9b01      	ldr	r3, [sp, #4]
 80044de:	6818      	ldr	r0, [r3, #0]
}
 80044e0:	b002      	add	sp, #8
 80044e2:	4770      	bx	lr
 80044e4:	40012c14 	.word	0x40012c14

080044e8 <SDIO_DataConfig>:
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));

/*---------------------------- SDIO DTIMER Configuration ---------------------*/
  /* Set the SDIO Data TimeOut value */
  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
 80044e8:	6802      	ldr	r2, [r0, #0]
 80044ea:	4b09      	ldr	r3, [pc, #36]	; (8004510 <SDIO_DataConfig+0x28>)
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval None
  */
void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 80044ec:	b510      	push	{r4, lr}
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));

/*---------------------------- SDIO DTIMER Configuration ---------------------*/
  /* Set the SDIO Data TimeOut value */
  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
 80044ee:	625a      	str	r2, [r3, #36]	; 0x24

/*---------------------------- SDIO DLEN Configuration -----------------------*/
  /* Set the SDIO DataLength value */
  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
 80044f0:	6842      	ldr	r2, [r0, #4]
 80044f2:	629a      	str	r2, [r3, #40]	; 0x28
  tmpreg &= DCTRL_CLEAR_MASK;
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 80044f4:	68c2      	ldr	r2, [r0, #12]
 80044f6:	6881      	ldr	r1, [r0, #8]
  /* Set the SDIO DataLength value */
  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;

/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
  /* Get the SDIO DCTRL value */
  tmpreg = SDIO->DCTRL;
 80044f8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
  tmpreg &= DCTRL_CLEAR_MASK;
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 80044fa:	4311      	orrs	r1, r2
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
 80044fc:	6902      	ldr	r2, [r0, #16]
 80044fe:	6940      	ldr	r0, [r0, #20]
 8004500:	430a      	orrs	r2, r1

/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
  /* Get the SDIO DCTRL value */
  tmpreg = SDIO->DCTRL;
  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
  tmpreg &= DCTRL_CLEAR_MASK;
 8004502:	f024 04f7 	bic.w	r4, r4, #247	; 0xf7
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
 8004506:	4302      	orrs	r2, r0
  tmpreg &= DCTRL_CLEAR_MASK;
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 8004508:	4322      	orrs	r2, r4
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;

  /* Write to SDIO DCTRL */
  SDIO->DCTRL = tmpreg;
 800450a:	62da      	str	r2, [r3, #44]	; 0x2c
 800450c:	bd10      	pop	{r4, pc}
 800450e:	bf00      	nop
 8004510:	40012c00 	.word	0x40012c00

08004514 <SDIO_DataStructInit>:
  * @retval None
  */
void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
  /* SDIO_DataInitStruct members default value */
  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
 8004514:	f04f 33ff 	mov.w	r3, #4294967295
 8004518:	6003      	str	r3, [r0, #0]
  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
 800451a:	2300      	movs	r3, #0
 800451c:	6043      	str	r3, [r0, #4]
  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
 800451e:	6083      	str	r3, [r0, #8]
  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
 8004520:	60c3      	str	r3, [r0, #12]
  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
 8004522:	6103      	str	r3, [r0, #16]
  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
 8004524:	6143      	str	r3, [r0, #20]
 8004526:	4770      	bx	lr

08004528 <SDIO_GetDataCounter>:
  * @param  None
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDIO_GetDataCounter(void)
{ 
  return SDIO->DCOUNT;
 8004528:	4b01      	ldr	r3, [pc, #4]	; (8004530 <SDIO_GetDataCounter+0x8>)
 800452a:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
 800452c:	4770      	bx	lr
 800452e:	bf00      	nop
 8004530:	40012c00 	.word	0x40012c00

08004534 <SDIO_ReadData>:
  * @param  None
  * @retval Data received
  */
uint32_t SDIO_ReadData(void)
{ 
  return SDIO->FIFO;
 8004534:	4b01      	ldr	r3, [pc, #4]	; (800453c <SDIO_ReadData+0x8>)
 8004536:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
}
 800453a:	4770      	bx	lr
 800453c:	40012c00 	.word	0x40012c00

08004540 <SDIO_WriteData>:
  * @param  Data: 32-bit data word to write.
  * @retval None
  */
void SDIO_WriteData(uint32_t Data)
{ 
  SDIO->FIFO = Data;
 8004540:	4b01      	ldr	r3, [pc, #4]	; (8004548 <SDIO_WriteData+0x8>)
 8004542:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
 8004546:	4770      	bx	lr
 8004548:	40012c00 	.word	0x40012c00

0800454c <SDIO_GetFIFOCount>:
  * @param  None
  * @retval Remaining number of words.
  */
uint32_t SDIO_GetFIFOCount(void)
{ 
  return SDIO->FIFOCNT;
 800454c:	4b01      	ldr	r3, [pc, #4]	; (8004554 <SDIO_GetFIFOCount+0x8>)
 800454e:	6c98      	ldr	r0, [r3, #72]	; 0x48
}
 8004550:	4770      	bx	lr
 8004552:	bf00      	nop
 8004554:	40012c00 	.word	0x40012c00

08004558 <SDIO_StartSDIOReadWait>:
void SDIO_StartSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
 8004558:	4b01      	ldr	r3, [pc, #4]	; (8004560 <SDIO_StartSDIOReadWait+0x8>)
 800455a:	6018      	str	r0, [r3, #0]
 800455c:	4770      	bx	lr
 800455e:	bf00      	nop
 8004560:	422585a0 	.word	0x422585a0

08004564 <SDIO_StopSDIOReadWait>:
void SDIO_StopSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
 8004564:	4b01      	ldr	r3, [pc, #4]	; (800456c <SDIO_StopSDIOReadWait+0x8>)
 8004566:	6018      	str	r0, [r3, #0]
 8004568:	4770      	bx	lr
 800456a:	bf00      	nop
 800456c:	422585a4 	.word	0x422585a4

08004570 <SDIO_SetSDIOReadWaitMode>:
void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
{
  /* Check the parameters */
  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
  
  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
 8004570:	4b01      	ldr	r3, [pc, #4]	; (8004578 <SDIO_SetSDIOReadWaitMode+0x8>)
 8004572:	6018      	str	r0, [r3, #0]
 8004574:	4770      	bx	lr
 8004576:	bf00      	nop
 8004578:	422585a8 	.word	0x422585a8

0800457c <SDIO_SetSDIOOperation>:
void SDIO_SetSDIOOperation(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
 800457c:	4b01      	ldr	r3, [pc, #4]	; (8004584 <SDIO_SetSDIOOperation+0x8>)
 800457e:	6018      	str	r0, [r3, #0]
 8004580:	4770      	bx	lr
 8004582:	bf00      	nop
 8004584:	422585ac 	.word	0x422585ac

08004588 <SDIO_SendSDIOSuspendCmd>:
void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
 8004588:	4b01      	ldr	r3, [pc, #4]	; (8004590 <SDIO_SendSDIOSuspendCmd+0x8>)
 800458a:	6018      	str	r0, [r3, #0]
 800458c:	4770      	bx	lr
 800458e:	bf00      	nop
 8004590:	422581ac 	.word	0x422581ac

08004594 <SDIO_CommandCompletionCmd>:
void SDIO_CommandCompletionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
 8004594:	4b01      	ldr	r3, [pc, #4]	; (800459c <SDIO_CommandCompletionCmd+0x8>)
 8004596:	6018      	str	r0, [r3, #0]
 8004598:	4770      	bx	lr
 800459a:	bf00      	nop
 800459c:	422581b0 	.word	0x422581b0

080045a0 <SDIO_CEATAITCmd>:
void SDIO_CEATAITCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
 80045a0:	f000 0001 	and.w	r0, r0, #1
 80045a4:	4b02      	ldr	r3, [pc, #8]	; (80045b0 <SDIO_CEATAITCmd+0x10>)
 80045a6:	f080 0001 	eor.w	r0, r0, #1
 80045aa:	6018      	str	r0, [r3, #0]
 80045ac:	4770      	bx	lr
 80045ae:	bf00      	nop
 80045b0:	422581b4 	.word	0x422581b4

080045b4 <SDIO_SendCEATACmd>:
void SDIO_SendCEATACmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
 80045b4:	4b01      	ldr	r3, [pc, #4]	; (80045bc <SDIO_SendCEATACmd+0x8>)
 80045b6:	6018      	str	r0, [r3, #0]
 80045b8:	4770      	bx	lr
 80045ba:	bf00      	nop
 80045bc:	422581b8 	.word	0x422581b8

080045c0 <SDIO_DMACmd>:
void SDIO_DMACmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
 80045c0:	4b01      	ldr	r3, [pc, #4]	; (80045c8 <SDIO_DMACmd+0x8>)
 80045c2:	6018      	str	r0, [r3, #0]
 80045c4:	4770      	bx	lr
 80045c6:	bf00      	nop
 80045c8:	4225858c 	.word	0x4225858c

080045cc <SDIO_ITConfig>:
  * @param  NewState: new state of the specified SDIO interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None 
  */
void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
{
 80045cc:	4b04      	ldr	r3, [pc, #16]	; (80045e0 <SDIO_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the SDIO interrupts */
    SDIO->MASK |= SDIO_IT;
 80045ce:	6bda      	ldr	r2, [r3, #60]	; 0x3c
{
  /* Check the parameters */
  assert_param(IS_SDIO_IT(SDIO_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80045d0:	b109      	cbz	r1, 80045d6 <SDIO_ITConfig+0xa>
  {
    /* Enable the SDIO interrupts */
    SDIO->MASK |= SDIO_IT;
 80045d2:	4310      	orrs	r0, r2
 80045d4:	e001      	b.n	80045da <SDIO_ITConfig+0xe>
  }
  else
  {
    /* Disable the SDIO interrupts */
    SDIO->MASK &= ~SDIO_IT;
 80045d6:	ea22 0000 	bic.w	r0, r2, r0
 80045da:	63d8      	str	r0, [r3, #60]	; 0x3c
 80045dc:	4770      	bx	lr
 80045de:	bf00      	nop
 80045e0:	40012c00 	.word	0x40012c00

080045e4 <SDIO_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
  
  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
 80045e4:	4b03      	ldr	r3, [pc, #12]	; (80045f4 <SDIO_GetFlagStatus+0x10>)
 80045e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80045e8:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80045ea:	bf0c      	ite	eq
 80045ec:	2000      	moveq	r0, #0
 80045ee:	2001      	movne	r0, #1
 80045f0:	4770      	bx	lr
 80045f2:	bf00      	nop
 80045f4:	40012c00 	.word	0x40012c00

080045f8 <SDIO_ClearFlag>:
void SDIO_ClearFlag(uint32_t SDIO_FLAG)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
   
  SDIO->ICR = SDIO_FLAG;
 80045f8:	4b01      	ldr	r3, [pc, #4]	; (8004600 <SDIO_ClearFlag+0x8>)
 80045fa:	6398      	str	r0, [r3, #56]	; 0x38
 80045fc:	4770      	bx	lr
 80045fe:	bf00      	nop
 8004600:	40012c00 	.word	0x40012c00

08004604 <SDIO_GetITStatus>:
{ 
  ITStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_GET_IT(SDIO_IT));
  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
 8004604:	4b03      	ldr	r3, [pc, #12]	; (8004614 <SDIO_GetITStatus+0x10>)
 8004606:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004608:	4218      	tst	r0, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800460a:	bf0c      	ite	eq
 800460c:	2000      	moveq	r0, #0
 800460e:	2001      	movne	r0, #1
 8004610:	4770      	bx	lr
 8004612:	bf00      	nop
 8004614:	40012c00 	.word	0x40012c00

08004618 <SDIO_ClearITPendingBit>:
void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
   
  SDIO->ICR = SDIO_IT;
 8004618:	4b01      	ldr	r3, [pc, #4]	; (8004620 <SDIO_ClearITPendingBit+0x8>)
 800461a:	6398      	str	r0, [r3, #56]	; 0x38
 800461c:	4770      	bx	lr
 800461e:	bf00      	nop
 8004620:	40012c00 	.word	0x40012c00

08004624 <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 8004624:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 8004626:	4b15      	ldr	r3, [pc, #84]	; (800467c <SPI_I2S_DeInit+0x58>)
 8004628:	4298      	cmp	r0, r3
 800462a:	d10b      	bne.n	8004644 <SPI_I2S_DeInit+0x20>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 800462c:	2101      	movs	r1, #1
 800462e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8004632:	f7ff f8d3 	bl	80037dc <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004636:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800463a:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 800463c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004640:	f7ff b8cc 	b.w	80037dc <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
 8004644:	4b0e      	ldr	r3, [pc, #56]	; (8004680 <SPI_I2S_DeInit+0x5c>)
 8004646:	4298      	cmp	r0, r3
 8004648:	d107      	bne.n	800465a <SPI_I2S_DeInit+0x36>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 800464a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800464e:	2101      	movs	r1, #1
 8004650:	f7ff f8b8 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8004654:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004658:	e009      	b.n	800466e <SPI_I2S_DeInit+0x4a>
    }
  else
  {
    if (SPIx == SPI3)
 800465a:	4b0a      	ldr	r3, [pc, #40]	; (8004684 <SPI_I2S_DeInit+0x60>)
 800465c:	4298      	cmp	r0, r3
 800465e:	d10b      	bne.n	8004678 <SPI_I2S_DeInit+0x54>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8004660:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004664:	2101      	movs	r1, #1
 8004666:	f7ff f8ad 	bl	80037c4 <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 800466a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800466e:	2100      	movs	r1, #0
    }
  }
}
 8004670:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI3)
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8004674:	f7ff b8a6 	b.w	80037c4 <RCC_APB1PeriphResetCmd>
 8004678:	bd08      	pop	{r3, pc}
 800467a:	bf00      	nop
 800467c:	40013000 	.word	0x40013000
 8004680:	40003800 	.word	0x40003800
 8004684:	40003c00 	.word	0x40003c00

08004688 <SPI_Init>:
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8004688:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 800468a:	8802      	ldrh	r2, [r0, #0]
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 800468c:	b510      	push	{r4, lr}
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 800468e:	884c      	ldrh	r4, [r1, #2]
 8004690:	4323      	orrs	r3, r4
 8004692:	888c      	ldrh	r4, [r1, #4]
 8004694:	4323      	orrs	r3, r4
 8004696:	88cc      	ldrh	r4, [r1, #6]
 8004698:	4323      	orrs	r3, r4
 800469a:	890c      	ldrh	r4, [r1, #8]
 800469c:	4323      	orrs	r3, r4
 800469e:	894c      	ldrh	r4, [r1, #10]
 80046a0:	4323      	orrs	r3, r4
 80046a2:	898c      	ldrh	r4, [r1, #12]
 80046a4:	4323      	orrs	r3, r4
 80046a6:	89cc      	ldrh	r4, [r1, #14]

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 80046a8:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80046ac:	4323      	orrs	r3, r4
 80046ae:	4313      	orrs	r3, r2
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 80046b0:	8003      	strh	r3, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 80046b2:	8b83      	ldrh	r3, [r0, #28]
 80046b4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80046b8:	041b      	lsls	r3, r3, #16
 80046ba:	0c1b      	lsrs	r3, r3, #16
 80046bc:	8383      	strh	r3, [r0, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 80046be:	8a0b      	ldrh	r3, [r1, #16]
 80046c0:	8203      	strh	r3, [r0, #16]
 80046c2:	bd10      	pop	{r4, pc}

080046c4 <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80046c4:	8b83      	ldrh	r3, [r0, #28]
 80046c6:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 80046ca:	f023 030f 	bic.w	r3, r3, #15
 80046ce:	041b      	lsls	r3, r3, #16
 80046d0:	0c1b      	lsrs	r3, r3, #16
 80046d2:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 80046d4:	2302      	movs	r3, #2
 80046d6:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80046d8:	688b      	ldr	r3, [r1, #8]
 80046da:	2b02      	cmp	r3, #2
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80046dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 80046de:	8b85      	ldrh	r5, [r0, #28]
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80046e0:	d038      	beq.n	8004754 <I2S_Init+0x90>
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 80046e2:	4a29      	ldr	r2, [pc, #164]	; (8004788 <I2S_Init+0xc4>)
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 80046e4:	888e      	ldrh	r6, [r1, #4]
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 80046e6:	6894      	ldr	r4, [r2, #8]
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 80046e8:	2e00      	cmp	r6, #0
 80046ea:	bf14      	ite	ne
 80046ec:	2602      	movne	r6, #2
 80046ee:	2601      	moveq	r6, #1
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 80046f0:	0224      	lsls	r4, r4, #8
 80046f2:	d503      	bpl.n	80046fc <I2S_Init+0x38>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 80046f4:	6894      	ldr	r4, [r2, #8]
 80046f6:	f424 0400 	bic.w	r4, r4, #8388608	; 0x800000
 80046fa:	6094      	str	r4, [r2, #8]
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 80046fc:	f8d2 4084 	ldr.w	r4, [r2, #132]	; 0x84
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8004700:	f8d2 7084 	ldr.w	r7, [r2, #132]	; 0x84
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 8004704:	6852      	ldr	r2, [r2, #4]
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8004706:	f8df c084 	ldr.w	ip, [pc, #132]	; 800478c <I2S_Init+0xc8>
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 800470a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 800470e:	fbbc f2f2 	udiv	r2, ip, r2
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8004712:	f3c4 1488 	ubfx	r4, r4, #6, #9
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8004716:	4354      	muls	r4, r2
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8004718:	f3c7 7202 	ubfx	r2, r7, #28, #3
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
    
    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 800471c:	fbb4 f4f2 	udiv	r4, r4, r2
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8004720:	88ca      	ldrh	r2, [r1, #6]
 8004722:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8004726:	f04f 020a 	mov.w	r2, #10
 800472a:	d101      	bne.n	8004730 <I2S_Init+0x6c>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 800472c:	0a24      	lsrs	r4, r4, #8
 800472e:	e002      	b.n	8004736 <I2S_Init+0x72>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004730:	0176      	lsls	r6, r6, #5
 8004732:	fbb4 f4f6 	udiv	r4, r4, r6
 8004736:	4362      	muls	r2, r4
 8004738:	fbb2 f3f3 	udiv	r3, r2, r3
 800473c:	3305      	adds	r3, #5
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 800473e:	220a      	movs	r2, #10
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004740:	b29b      	uxth	r3, r3
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 8004742:	fbb3 f3f2 	udiv	r3, r3, r2
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004746:	f003 0201 	and.w	r2, r3, #1
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 800474a:	0212      	lsls	r2, r2, #8
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 800474c:	f3c3 034f 	ubfx	r3, r3, #1, #16
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004750:	b292      	uxth	r2, r2
 8004752:	e000      	b.n	8004756 <I2S_Init+0x92>
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
 8004754:	2200      	movs	r2, #0
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8004756:	1e9c      	subs	r4, r3, #2
 8004758:	b2a4      	uxth	r4, r4
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 800475a:	2cfe      	cmp	r4, #254	; 0xfe
 800475c:	bf28      	it	cs
 800475e:	2200      	movcs	r2, #0
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004760:	88cc      	ldrh	r4, [r1, #6]
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004762:	bf28      	it	cs
 8004764:	2302      	movcs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004766:	4313      	orrs	r3, r2
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004768:	880a      	ldrh	r2, [r1, #0]
    i2sdiv = 2;
    i2sodd = 0;
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 800476a:	4323      	orrs	r3, r4
 800476c:	8403      	strh	r3, [r0, #32]
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800476e:	ea45 0302 	orr.w	r3, r5, r2

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8004772:	884a      	ldrh	r2, [r1, #2]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004774:	f443 6300 	orr.w	r3, r3, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8004778:	4313      	orrs	r3, r2
 800477a:	888a      	ldrh	r2, [r1, #4]
 800477c:	4313      	orrs	r3, r2
 800477e:	898a      	ldrh	r2, [r1, #12]
 8004780:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 8004782:	8383      	strh	r3, [r0, #28]
 8004784:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004786:	bf00      	nop
 8004788:	40023800 	.word	0x40023800
 800478c:	007a1200 	.word	0x007a1200

08004790 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8004790:	2300      	movs	r3, #0
 8004792:	8003      	strh	r3, [r0, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8004794:	8043      	strh	r3, [r0, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8004796:	8083      	strh	r3, [r0, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8004798:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 800479a:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 800479c:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 800479e:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 80047a0:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 80047a2:	2307      	movs	r3, #7
 80047a4:	8203      	strh	r3, [r0, #16]
 80047a6:	4770      	bx	lr

080047a8 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 80047a8:	2300      	movs	r3, #0
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 80047aa:	2202      	movs	r2, #2
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 80047ac:	8003      	strh	r3, [r0, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 80047ae:	8043      	strh	r3, [r0, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 80047b0:	8083      	strh	r3, [r0, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 80047b2:	80c3      	strh	r3, [r0, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 80047b4:	6082      	str	r2, [r0, #8]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 80047b6:	8183      	strh	r3, [r0, #12]
 80047b8:	4770      	bx	lr

080047ba <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80047ba:	8803      	ldrh	r3, [r0, #0]
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80047bc:	b119      	cbz	r1, 80047c6 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80047be:	b29b      	uxth	r3, r3
 80047c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80047c4:	e003      	b.n	80047ce <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 80047c6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80047ca:	041b      	lsls	r3, r3, #16
 80047cc:	0c1b      	lsrs	r3, r3, #16
 80047ce:	8003      	strh	r3, [r0, #0]
 80047d0:	4770      	bx	lr

080047d2 <I2S_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80047d2:	8b83      	ldrh	r3, [r0, #28]
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80047d4:	b119      	cbz	r1, 80047de <I2S_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80047d6:	b29b      	uxth	r3, r3
 80047d8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80047dc:	e003      	b.n	80047e6 <I2S_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 80047de:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80047e2:	041b      	lsls	r3, r3, #16
 80047e4:	0c1b      	lsrs	r3, r3, #16
 80047e6:	8383      	strh	r3, [r0, #28]
 80047e8:	4770      	bx	lr

080047ea <SPI_DataSizeConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 80047ea:	8803      	ldrh	r3, [r0, #0]
 80047ec:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80047f0:	041b      	lsls	r3, r3, #16
 80047f2:	0c1b      	lsrs	r3, r3, #16
 80047f4:	8003      	strh	r3, [r0, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 80047f6:	8803      	ldrh	r3, [r0, #0]
 80047f8:	b29b      	uxth	r3, r3
 80047fa:	4319      	orrs	r1, r3
 80047fc:	8001      	strh	r1, [r0, #0]
 80047fe:	4770      	bx	lr

08004800 <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004800:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004804:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004806:	d103      	bne.n	8004810 <SPI_BiDirectionalLineConfig+0x10>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004808:	b29b      	uxth	r3, r3
 800480a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800480e:	e003      	b.n	8004818 <SPI_BiDirectionalLineConfig+0x18>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 8004810:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004814:	041b      	lsls	r3, r3, #16
 8004816:	0c1b      	lsrs	r3, r3, #16
 8004818:	8003      	strh	r3, [r0, #0]
 800481a:	4770      	bx	lr

0800481c <SPI_NSSInternalSoftwareConfig>:
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 800481c:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8004820:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004822:	8803      	ldrh	r3, [r0, #0]
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004824:	d003      	beq.n	800482e <SPI_NSSInternalSoftwareConfig+0x12>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004826:	b29b      	uxth	r3, r3
 8004828:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800482c:	e003      	b.n	8004836 <SPI_NSSInternalSoftwareConfig+0x1a>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 800482e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004832:	041b      	lsls	r3, r3, #16
 8004834:	0c1b      	lsrs	r3, r3, #16
 8004836:	8003      	strh	r3, [r0, #0]
 8004838:	4770      	bx	lr

0800483a <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 800483a:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800483c:	b119      	cbz	r1, 8004846 <SPI_SSOutputCmd+0xc>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 800483e:	b29b      	uxth	r3, r3
 8004840:	f043 0304 	orr.w	r3, r3, #4
 8004844:	e003      	b.n	800484e <SPI_SSOutputCmd+0x14>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 8004846:	f023 0304 	bic.w	r3, r3, #4
 800484a:	041b      	lsls	r3, r3, #16
 800484c:	0c1b      	lsrs	r3, r3, #16
 800484e:	8083      	strh	r3, [r0, #4]
 8004850:	4770      	bx	lr

08004852 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8004852:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004854:	b119      	cbz	r1, 800485e <SPI_TIModeCmd+0xc>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8004856:	b29b      	uxth	r3, r3
 8004858:	f043 0310 	orr.w	r3, r3, #16
 800485c:	e003      	b.n	8004866 <SPI_TIModeCmd+0x14>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 800485e:	f023 0310 	bic.w	r3, r3, #16
 8004862:	041b      	lsls	r3, r3, #16
 8004864:	0c1b      	lsrs	r3, r3, #16
 8004866:	8083      	strh	r3, [r0, #4]
 8004868:	4770      	bx	lr

0800486a <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800486a:	8b83      	ldrh	r3, [r0, #28]
 800486c:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8004870:	f023 030f 	bic.w	r3, r3, #15
 8004874:	041b      	lsls	r3, r3, #16
 8004876:	0c1b      	lsrs	r3, r3, #16
 8004878:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 800487a:	2302      	movs	r3, #2
 800487c:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800487e:	880b      	ldrh	r3, [r1, #0]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8004880:	8b82      	ldrh	r2, [r0, #28]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004882:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 8004886:	b510      	push	{r4, lr}
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004888:	d102      	bne.n	8004890 <I2S_FullDuplexConfig+0x26>
  {
    tmp = I2S_Mode_SlaveRx;
 800488a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800488e:	e002      	b.n	8004896 <I2S_FullDuplexConfig+0x2c>
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004890:	2b00      	cmp	r3, #0
 8004892:	d0fa      	beq.n	800488a <I2S_FullDuplexConfig+0x20>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
 8004894:	2300      	movs	r3, #0
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004896:	884c      	ldrh	r4, [r1, #2]
 8004898:	4322      	orrs	r2, r4
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 800489a:	888c      	ldrh	r4, [r1, #4]
 800489c:	8989      	ldrh	r1, [r1, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800489e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 80048a2:	4322      	orrs	r2, r4
 80048a4:	430a      	orrs	r2, r1
 80048a6:	b292      	uxth	r2, r2
 80048a8:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 80048aa:	8383      	strh	r3, [r0, #28]
 80048ac:	bd10      	pop	{r4, pc}

080048ae <SPI_I2S_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 80048ae:	8980      	ldrh	r0, [r0, #12]
}
 80048b0:	b280      	uxth	r0, r0
 80048b2:	4770      	bx	lr

080048b4 <SPI_I2S_SendData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 80048b4:	8181      	strh	r1, [r0, #12]
 80048b6:	4770      	bx	lr

080048b8 <SPI_CalculateCRC>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 80048b8:	8803      	ldrh	r3, [r0, #0]
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80048ba:	b119      	cbz	r1, 80048c4 <SPI_CalculateCRC+0xc>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 80048bc:	b29b      	uxth	r3, r3
 80048be:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80048c2:	e003      	b.n	80048cc <SPI_CalculateCRC+0x14>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 80048c4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80048c8:	041b      	lsls	r3, r3, #16
 80048ca:	0c1b      	lsrs	r3, r3, #16
 80048cc:	8003      	strh	r3, [r0, #0]
 80048ce:	4770      	bx	lr

080048d0 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 80048d0:	8803      	ldrh	r3, [r0, #0]
 80048d2:	b29b      	uxth	r3, r3
 80048d4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80048d8:	8003      	strh	r3, [r0, #0]
 80048da:	4770      	bx	lr

080048dc <SPI_GetCRC>:
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 80048dc:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 80048de:	bf14      	ite	ne
 80048e0:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 80048e2:	8a80      	ldrheq	r0, [r0, #20]
 80048e4:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 80048e6:	4770      	bx	lr

080048e8 <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 80048e8:	8a00      	ldrh	r0, [r0, #16]
}
 80048ea:	b280      	uxth	r0, r0
 80048ec:	4770      	bx	lr

080048ee <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80048ee:	8883      	ldrh	r3, [r0, #4]
 80048f0:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 80048f2:	b10a      	cbz	r2, 80048f8 <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80048f4:	4319      	orrs	r1, r3
 80048f6:	e001      	b.n	80048fc <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 80048f8:	ea23 0101 	bic.w	r1, r3, r1
 80048fc:	8081      	strh	r1, [r0, #4]
 80048fe:	4770      	bx	lr

08004900 <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8004900:	0909      	lsrs	r1, r1, #4
 8004902:	2301      	movs	r3, #1
 8004904:	fa03 f301 	lsl.w	r3, r3, r1
 8004908:	b29b      	uxth	r3, r3

  if (NewState != DISABLE)
 800490a:	b11a      	cbz	r2, 8004914 <SPI_I2S_ITConfig+0x14>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 800490c:	8882      	ldrh	r2, [r0, #4]
 800490e:	b292      	uxth	r2, r2
 8004910:	4313      	orrs	r3, r2
 8004912:	e003      	b.n	800491c <SPI_I2S_ITConfig+0x1c>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8004914:	8882      	ldrh	r2, [r0, #4]
 8004916:	b292      	uxth	r2, r2
 8004918:	ea22 0303 	bic.w	r3, r2, r3
 800491c:	8083      	strh	r3, [r0, #4]
 800491e:	4770      	bx	lr

08004920 <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8004920:	8903      	ldrh	r3, [r0, #8]
 8004922:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 8004924:	bf0c      	ite	eq
 8004926:	2000      	moveq	r0, #0
 8004928:	2001      	movne	r0, #1
 800492a:	4770      	bx	lr

0800492c <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 800492c:	43c9      	mvns	r1, r1
 800492e:	8101      	strh	r1, [r0, #8]
 8004930:	4770      	bx	lr

08004932 <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8004932:	b510      	push	{r4, lr}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8004934:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004936:	8900      	ldrh	r0, [r0, #8]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8004938:	2301      	movs	r3, #1
 800493a:	f001 020f 	and.w	r2, r1, #15

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800493e:	b280      	uxth	r0, r0
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8004940:	fa03 f202 	lsl.w	r2, r3, r2

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004944:	4010      	ands	r0, r2

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8004946:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004948:	d006      	beq.n	8004958 <SPI_I2S_GetITStatus+0x26>

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 800494a:	0909      	lsrs	r1, r1, #4
 800494c:	fa03 f301 	lsl.w	r3, r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8004950:	421c      	tst	r4, r3
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 8004952:	bf0c      	ite	eq
 8004954:	2000      	moveq	r0, #0
 8004956:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8004958:	bd10      	pop	{r4, pc}

0800495a <SPI_I2S_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 800495a:	f001 010f 	and.w	r1, r1, #15
 800495e:	2301      	movs	r3, #1
 8004960:	fa03 f301 	lsl.w	r3, r3, r1

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 8004964:	43db      	mvns	r3, r3
 8004966:	8103      	strh	r3, [r0, #8]
 8004968:	4770      	bx	lr
 800496a:	bf00      	nop

0800496c <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 800496c:	b508      	push	{r3, lr}
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800496e:	2101      	movs	r1, #1
 8004970:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004974:	f7fe ff32 	bl	80037dc <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8004978:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800497c:	2100      	movs	r1, #0
}
 800497e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void SYSCFG_DeInit(void)
{
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8004982:	f7fe bf2b 	b.w	80037dc <RCC_APB2PeriphResetCmd>

08004986 <SYSCFG_MemoryRemapConfig>:
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8004986:	4b01      	ldr	r3, [pc, #4]	; (800498c <SYSCFG_MemoryRemapConfig+0x6>)
 8004988:	6018      	str	r0, [r3, #0]
 800498a:	4770      	bx	lr
 800498c:	40013800 	.word	0x40013800

08004990 <SYSCFG_EXTILineConfig>:

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8004990:	f001 0203 	and.w	r2, r1, #3
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8004994:	0889      	lsrs	r1, r1, #2
 8004996:	4b0a      	ldr	r3, [pc, #40]	; (80049c0 <SYSCFG_EXTILineConfig+0x30>)
 8004998:	3102      	adds	r1, #2
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 800499a:	b530      	push	{r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 800499c:	0092      	lsls	r2, r2, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 800499e:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80049a2:	240f      	movs	r4, #15
 80049a4:	fa04 f402 	lsl.w	r4, r4, r2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80049a8:	ea25 0404 	bic.w	r4, r5, r4
 80049ac:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 80049b0:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 80049b4:	fa00 f002 	lsl.w	r0, r0, r2
 80049b8:	4304      	orrs	r4, r0
 80049ba:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
 80049be:	bd30      	pop	{r4, r5, pc}
 80049c0:	40013800 	.word	0x40013800

080049c4 <SYSCFG_ETH_MediaInterfaceConfig>:
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 80049c4:	4b01      	ldr	r3, [pc, #4]	; (80049cc <SYSCFG_ETH_MediaInterfaceConfig+0x8>)
 80049c6:	6018      	str	r0, [r3, #0]
 80049c8:	4770      	bx	lr
 80049ca:	bf00      	nop
 80049cc:	422700dc 	.word	0x422700dc

080049d0 <SYSCFG_CompensationCellCmd>:
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 80049d0:	4b01      	ldr	r3, [pc, #4]	; (80049d8 <SYSCFG_CompensationCellCmd+0x8>)
 80049d2:	6018      	str	r0, [r3, #0]
 80049d4:	4770      	bx	lr
 80049d6:	bf00      	nop
 80049d8:	42270400 	.word	0x42270400

080049dc <SYSCFG_GetCompensationCellStatus>:
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 80049dc:	4b02      	ldr	r3, [pc, #8]	; (80049e8 <SYSCFG_GetCompensationCellStatus+0xc>)
 80049de:	6a18      	ldr	r0, [r3, #32]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80049e0:	f3c0 2000 	ubfx	r0, r0, #8, #1
 80049e4:	4770      	bx	lr
 80049e6:	bf00      	nop
 80049e8:	40013800 	.word	0x40013800

080049ec <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 80049ec:	b530      	push	{r4, r5, lr}
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 80049ee:	8c04      	ldrh	r4, [r0, #32]
 80049f0:	f024 0401 	bic.w	r4, r4, #1
 80049f4:	0424      	lsls	r4, r4, #16
 80049f6:	0c24      	lsrs	r4, r4, #16
 80049f8:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 80049fa:	8b05      	ldrh	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 80049fc:	8c04      	ldrh	r4, [r0, #32]
{
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;
 80049fe:	b2ad      	uxth	r5, r5
  tmpccer = TIMx->CCER;
 8004a00:	b2a4      	uxth	r4, r4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8004a02:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004a06:	f024 040a 	bic.w	r4, r4, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8004a0a:	432a      	orrs	r2, r5

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8004a0c:	f044 0401 	orr.w	r4, r4, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8004a10:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8004a14:	4321      	orrs	r1, r4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004a16:	8303      	strh	r3, [r0, #24]
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8004a18:	461d      	mov	r5, r3
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
  TIMx->CCER = tmpccer;
 8004a1a:	8401      	strh	r1, [r0, #32]
 8004a1c:	bd30      	pop	{r4, r5, pc}

08004a1e <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8004a1e:	b530      	push	{r4, r5, lr}
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8004a20:	8c04      	ldrh	r4, [r0, #32]
 8004a22:	f024 0410 	bic.w	r4, r4, #16
 8004a26:	0424      	lsls	r4, r4, #16
 8004a28:	0c24      	lsrs	r4, r4, #16
 8004a2a:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004a2c:	8b04      	ldrh	r4, [r0, #24]
  tmpccer = TIMx->CCER;
 8004a2e:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8004a30:	f424 7440 	bic.w	r4, r4, #768	; 0x300
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8004a34:	b2ad      	uxth	r5, r5
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8004a36:	0524      	lsls	r4, r4, #20
 8004a38:	0d24      	lsrs	r4, r4, #20
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004a3a:	f025 05a0 	bic.w	r5, r5, #160	; 0xa0
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004a3e:	f045 0510 	orr.w	r5, r5, #16
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8004a42:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004a46:	ea45 1101 	orr.w	r1, r5, r1, lsl #4
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8004a4a:	ea42 3303 	orr.w	r3, r2, r3, lsl #12
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004a4e:	8303      	strh	r3, [r0, #24]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004a50:	460d      	mov	r5, r1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
  TIMx->CCER = tmpccer;
 8004a52:	8401      	strh	r1, [r0, #32]
 8004a54:	bd30      	pop	{r4, r5, pc}

08004a56 <TIM_DeInit>:
  * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 8004a56:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 8004a58:	4b47      	ldr	r3, [pc, #284]	; (8004b78 <TIM_DeInit+0x122>)
 8004a5a:	4298      	cmp	r0, r3
 8004a5c:	d105      	bne.n	8004a6a <TIM_DeInit+0x14>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8004a5e:	2001      	movs	r0, #1
 8004a60:	4601      	mov	r1, r0
 8004a62:	f7fe febb 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8004a66:	2001      	movs	r0, #1
 8004a68:	e03d      	b.n	8004ae6 <TIM_DeInit+0x90>
  } 
  else if (TIMx == TIM2) 
 8004a6a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004a6e:	d105      	bne.n	8004a7c <TIM_DeInit+0x26>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8004a70:	2001      	movs	r0, #1
 8004a72:	4601      	mov	r1, r0
 8004a74:	f7fe fea6 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8004a78:	2001      	movs	r0, #1
 8004a7a:	e076      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM3)
 8004a7c:	4b3f      	ldr	r3, [pc, #252]	; (8004b7c <TIM_DeInit+0x126>)
 8004a7e:	4298      	cmp	r0, r3
 8004a80:	d105      	bne.n	8004a8e <TIM_DeInit+0x38>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8004a82:	2002      	movs	r0, #2
 8004a84:	2101      	movs	r1, #1
 8004a86:	f7fe fe9d 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004a8a:	2002      	movs	r0, #2
 8004a8c:	e06d      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM4)
 8004a8e:	4b3c      	ldr	r3, [pc, #240]	; (8004b80 <TIM_DeInit+0x12a>)
 8004a90:	4298      	cmp	r0, r3
 8004a92:	d105      	bne.n	8004aa0 <TIM_DeInit+0x4a>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8004a94:	2004      	movs	r0, #4
 8004a96:	2101      	movs	r1, #1
 8004a98:	f7fe fe94 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8004a9c:	2004      	movs	r0, #4
 8004a9e:	e064      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM5)
 8004aa0:	4b38      	ldr	r3, [pc, #224]	; (8004b84 <TIM_DeInit+0x12e>)
 8004aa2:	4298      	cmp	r0, r3
 8004aa4:	d105      	bne.n	8004ab2 <TIM_DeInit+0x5c>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 8004aa6:	2008      	movs	r0, #8
 8004aa8:	2101      	movs	r1, #1
 8004aaa:	f7fe fe8b 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 8004aae:	2008      	movs	r0, #8
 8004ab0:	e05b      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM6)  
 8004ab2:	4b35      	ldr	r3, [pc, #212]	; (8004b88 <TIM_DeInit+0x132>)
 8004ab4:	4298      	cmp	r0, r3
 8004ab6:	d105      	bne.n	8004ac4 <TIM_DeInit+0x6e>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8004ab8:	2010      	movs	r0, #16
 8004aba:	2101      	movs	r1, #1
 8004abc:	f7fe fe82 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8004ac0:	2010      	movs	r0, #16
 8004ac2:	e052      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM7)
 8004ac4:	4b31      	ldr	r3, [pc, #196]	; (8004b8c <TIM_DeInit+0x136>)
 8004ac6:	4298      	cmp	r0, r3
 8004ac8:	d105      	bne.n	8004ad6 <TIM_DeInit+0x80>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8004aca:	2020      	movs	r0, #32
 8004acc:	2101      	movs	r1, #1
 8004ace:	f7fe fe79 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8004ad2:	2020      	movs	r0, #32
 8004ad4:	e049      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM8)
 8004ad6:	4b2e      	ldr	r3, [pc, #184]	; (8004b90 <TIM_DeInit+0x13a>)
 8004ad8:	4298      	cmp	r0, r3
 8004ada:	d109      	bne.n	8004af0 <TIM_DeInit+0x9a>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 8004adc:	2002      	movs	r0, #2
 8004ade:	2101      	movs	r1, #1
 8004ae0:	f7fe fe7c 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8004ae4:	2002      	movs	r0, #2
 8004ae6:	2100      	movs	r1, #0
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    }   
  }
}
 8004ae8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
  }  
  else if (TIMx == TIM8)
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8004aec:	f7fe be76 	b.w	80037dc <RCC_APB2PeriphResetCmd>
  }  
  else if (TIMx == TIM9)
 8004af0:	4b28      	ldr	r3, [pc, #160]	; (8004b94 <TIM_DeInit+0x13e>)
 8004af2:	4298      	cmp	r0, r3
 8004af4:	d107      	bne.n	8004b06 <TIM_DeInit+0xb0>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 8004af6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004afa:	2101      	movs	r1, #1
 8004afc:	f7fe fe6e 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 8004b00:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004b04:	e7ef      	b.n	8004ae6 <TIM_DeInit+0x90>
   }  
  else if (TIMx == TIM10)
 8004b06:	4b24      	ldr	r3, [pc, #144]	; (8004b98 <TIM_DeInit+0x142>)
 8004b08:	4298      	cmp	r0, r3
 8004b0a:	d107      	bne.n	8004b1c <TIM_DeInit+0xc6>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 8004b0c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004b10:	2101      	movs	r1, #1
 8004b12:	f7fe fe63 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 8004b16:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004b1a:	e7e4      	b.n	8004ae6 <TIM_DeInit+0x90>
  }  
  else if (TIMx == TIM11) 
 8004b1c:	4b1f      	ldr	r3, [pc, #124]	; (8004b9c <TIM_DeInit+0x146>)
 8004b1e:	4298      	cmp	r0, r3
 8004b20:	d107      	bne.n	8004b32 <TIM_DeInit+0xdc>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 8004b22:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004b26:	2101      	movs	r1, #1
 8004b28:	f7fe fe58 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8004b2c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004b30:	e7d9      	b.n	8004ae6 <TIM_DeInit+0x90>
  }  
  else if (TIMx == TIM12)
 8004b32:	4b1b      	ldr	r3, [pc, #108]	; (8004ba0 <TIM_DeInit+0x14a>)
 8004b34:	4298      	cmp	r0, r3
 8004b36:	d105      	bne.n	8004b44 <TIM_DeInit+0xee>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 8004b38:	2040      	movs	r0, #64	; 0x40
 8004b3a:	2101      	movs	r1, #1
 8004b3c:	f7fe fe42 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 8004b40:	2040      	movs	r0, #64	; 0x40
 8004b42:	e012      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else if (TIMx == TIM13) 
 8004b44:	4b17      	ldr	r3, [pc, #92]	; (8004ba4 <TIM_DeInit+0x14e>)
 8004b46:	4298      	cmp	r0, r3
 8004b48:	d105      	bne.n	8004b56 <TIM_DeInit+0x100>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 8004b4a:	2080      	movs	r0, #128	; 0x80
 8004b4c:	2101      	movs	r1, #1
 8004b4e:	f7fe fe39 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 8004b52:	2080      	movs	r0, #128	; 0x80
 8004b54:	e009      	b.n	8004b6a <TIM_DeInit+0x114>
  }  
  else
  { 
    if (TIMx == TIM14) 
 8004b56:	4b14      	ldr	r3, [pc, #80]	; (8004ba8 <TIM_DeInit+0x152>)
 8004b58:	4298      	cmp	r0, r3
 8004b5a:	d10b      	bne.n	8004b74 <TIM_DeInit+0x11e>
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 8004b5c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004b60:	2101      	movs	r1, #1
 8004b62:	f7fe fe2f 	bl	80037c4 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 8004b66:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004b6a:	2100      	movs	r1, #0
    }   
  }
}
 8004b6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  { 
    if (TIMx == TIM14) 
    {     
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 8004b70:	f7fe be28 	b.w	80037c4 <RCC_APB1PeriphResetCmd>
 8004b74:	bd08      	pop	{r3, pc}
 8004b76:	bf00      	nop
 8004b78:	40010000 	.word	0x40010000
 8004b7c:	40000400 	.word	0x40000400
 8004b80:	40000800 	.word	0x40000800
 8004b84:	40000c00 	.word	0x40000c00
 8004b88:	40001000 	.word	0x40001000
 8004b8c:	40001400 	.word	0x40001400
 8004b90:	40010400 	.word	0x40010400
 8004b94:	40014000 	.word	0x40014000
 8004b98:	40014400 	.word	0x40014400
 8004b9c:	40014800 	.word	0x40014800
 8004ba0:	40001800 	.word	0x40001800
 8004ba4:	40001c00 	.word	0x40001c00
 8004ba8:	40002000 	.word	0x40002000

08004bac <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8004bac:	4a1c      	ldr	r2, [pc, #112]	; (8004c20 <TIM_TimeBaseInit+0x74>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004bae:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8004bb0:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004bb2:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8004bb4:	d012      	beq.n	8004bdc <TIM_TimeBaseInit+0x30>
 8004bb6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004bba:	4290      	cmp	r0, r2
 8004bbc:	d00e      	beq.n	8004bdc <TIM_TimeBaseInit+0x30>
 8004bbe:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004bc2:	d00b      	beq.n	8004bdc <TIM_TimeBaseInit+0x30>
     (TIMx == TIM2) || (TIMx == TIM3)||
 8004bc4:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 8004bc8:	4290      	cmp	r0, r2
 8004bca:	d007      	beq.n	8004bdc <TIM_TimeBaseInit+0x30>
 8004bcc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004bd0:	4290      	cmp	r0, r2
 8004bd2:	d003      	beq.n	8004bdc <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8004bd4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004bd8:	4290      	cmp	r0, r2
 8004bda:	d103      	bne.n	8004be4 <TIM_TimeBaseInit+0x38>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004bdc:	884a      	ldrh	r2, [r1, #2]
  if((TIMx == TIM1) || (TIMx == TIM8)||
     (TIMx == TIM2) || (TIMx == TIM3)||
     (TIMx == TIM4) || (TIMx == TIM5)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8004bde:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004be2:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8004be4:	4a0f      	ldr	r2, [pc, #60]	; (8004c24 <TIM_TimeBaseInit+0x78>)
 8004be6:	4290      	cmp	r0, r2
 8004be8:	d008      	beq.n	8004bfc <TIM_TimeBaseInit+0x50>
 8004bea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004bee:	4290      	cmp	r0, r2
 8004bf0:	d004      	beq.n	8004bfc <TIM_TimeBaseInit+0x50>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8004bf2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004bf6:	890a      	ldrh	r2, [r1, #8]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8004bf8:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004bfa:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8004bfc:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8004bfe:	684b      	ldr	r3, [r1, #4]
 8004c00:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8004c02:	880b      	ldrh	r3, [r1, #0]
 8004c04:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 8004c06:	4b06      	ldr	r3, [pc, #24]	; (8004c20 <TIM_TimeBaseInit+0x74>)
 8004c08:	4298      	cmp	r0, r3
 8004c0a:	d003      	beq.n	8004c14 <TIM_TimeBaseInit+0x68>
 8004c0c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004c10:	4298      	cmp	r0, r3
 8004c12:	d101      	bne.n	8004c18 <TIM_TimeBaseInit+0x6c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8004c14:	7a8b      	ldrb	r3, [r1, #10]
 8004c16:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8004c18:	2301      	movs	r3, #1
 8004c1a:	8283      	strh	r3, [r0, #20]
 8004c1c:	4770      	bx	lr
 8004c1e:	bf00      	nop
 8004c20:	40010000 	.word	0x40010000
 8004c24:	40001000 	.word	0x40001000

08004c28 <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 8004c28:	f04f 33ff 	mov.w	r3, #4294967295
 8004c2c:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8004c2e:	2300      	movs	r3, #0
 8004c30:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8004c32:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8004c34:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 8004c36:	7283      	strb	r3, [r0, #10]
 8004c38:	4770      	bx	lr

08004c3a <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 8004c3a:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 8004c3c:	8282      	strh	r2, [r0, #20]
 8004c3e:	4770      	bx	lr

08004c40 <TIM_CounterModeConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 8004c40:	8803      	ldrh	r3, [r0, #0]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004c42:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004c46:	041b      	lsls	r3, r3, #16
 8004c48:	0c1b      	lsrs	r3, r3, #16

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 8004c4a:	4319      	orrs	r1, r3

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 8004c4c:	8001      	strh	r1, [r0, #0]
 8004c4e:	4770      	bx	lr

08004c50 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8004c50:	6241      	str	r1, [r0, #36]	; 0x24
 8004c52:	4770      	bx	lr

08004c54 <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 8004c54:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004c56:	4770      	bx	lr

08004c58 <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 8004c58:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 8004c5a:	4770      	bx	lr

08004c5c <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 8004c5c:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 8004c5e:	b280      	uxth	r0, r0
 8004c60:	4770      	bx	lr

08004c62 <TIM_UpdateDisableConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8004c62:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c64:	b119      	cbz	r1, 8004c6e <TIM_UpdateDisableConfig+0xc>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8004c66:	b29b      	uxth	r3, r3
 8004c68:	f043 0302 	orr.w	r3, r3, #2
 8004c6c:	e003      	b.n	8004c76 <TIM_UpdateDisableConfig+0x14>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 8004c6e:	f023 0302 	bic.w	r3, r3, #2
 8004c72:	041b      	lsls	r3, r3, #16
 8004c74:	0c1b      	lsrs	r3, r3, #16
 8004c76:	8003      	strh	r3, [r0, #0]
 8004c78:	4770      	bx	lr

08004c7a <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004c7a:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 8004c7c:	b119      	cbz	r1, 8004c86 <TIM_UpdateRequestConfig+0xc>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004c7e:	b29b      	uxth	r3, r3
 8004c80:	f043 0304 	orr.w	r3, r3, #4
 8004c84:	e003      	b.n	8004c8e <TIM_UpdateRequestConfig+0x14>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 8004c86:	f023 0304 	bic.w	r3, r3, #4
 8004c8a:	041b      	lsls	r3, r3, #16
 8004c8c:	0c1b      	lsrs	r3, r3, #16
 8004c8e:	8003      	strh	r3, [r0, #0]
 8004c90:	4770      	bx	lr

08004c92 <TIM_ARRPreloadConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004c92:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c94:	b119      	cbz	r1, 8004c9e <TIM_ARRPreloadConfig+0xc>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004c96:	b29b      	uxth	r3, r3
 8004c98:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004c9c:	e003      	b.n	8004ca6 <TIM_ARRPreloadConfig+0x14>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 8004c9e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004ca2:	041b      	lsls	r3, r3, #16
 8004ca4:	0c1b      	lsrs	r3, r3, #16
 8004ca6:	8003      	strh	r3, [r0, #0]
 8004ca8:	4770      	bx	lr

08004caa <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 8004caa:	8803      	ldrh	r3, [r0, #0]
 8004cac:	f023 0308 	bic.w	r3, r3, #8
 8004cb0:	041b      	lsls	r3, r3, #16
 8004cb2:	0c1b      	lsrs	r3, r3, #16
 8004cb4:	8003      	strh	r3, [r0, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 8004cb6:	8803      	ldrh	r3, [r0, #0]
 8004cb8:	b29b      	uxth	r3, r3
 8004cba:	4319      	orrs	r1, r3
 8004cbc:	8001      	strh	r1, [r0, #0]
 8004cbe:	4770      	bx	lr

08004cc0 <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 8004cc0:	8803      	ldrh	r3, [r0, #0]
 8004cc2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004cc6:	041b      	lsls	r3, r3, #16
 8004cc8:	0c1b      	lsrs	r3, r3, #16
 8004cca:	8003      	strh	r3, [r0, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8004ccc:	8803      	ldrh	r3, [r0, #0]
 8004cce:	b29b      	uxth	r3, r3
 8004cd0:	4319      	orrs	r1, r3
 8004cd2:	8001      	strh	r1, [r0, #0]
 8004cd4:	4770      	bx	lr

08004cd6 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004cd6:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004cd8:	b119      	cbz	r1, 8004ce2 <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004cda:	b29b      	uxth	r3, r3
 8004cdc:	f043 0301 	orr.w	r3, r3, #1
 8004ce0:	e003      	b.n	8004cea <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8004ce2:	f023 0301 	bic.w	r3, r3, #1
 8004ce6:	041b      	lsls	r3, r3, #16
 8004ce8:	0c1b      	lsrs	r3, r3, #16
 8004cea:	8003      	strh	r3, [r0, #0]
 8004cec:	4770      	bx	lr

08004cee <TIM_OC1Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8004cee:	8c03      	ldrh	r3, [r0, #32]
 8004cf0:	f023 0301 	bic.w	r3, r3, #1
 8004cf4:	041b      	lsls	r3, r3, #16
 8004cf6:	0c1b      	lsrs	r3, r3, #16
 8004cf8:	8403      	strh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004cfa:	b570      	push	{r4, r5, r6, lr}

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004cfc:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004cfe:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004d00:	8b02      	ldrh	r2, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004d02:	880d      	ldrh	r5, [r1, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004d04:	884e      	ldrh	r6, [r1, #2]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 8004d06:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8004d0a:	0412      	lsls	r2, r2, #16
 8004d0c:	0c12      	lsrs	r2, r2, #16
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004d0e:	432a      	orrs	r2, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004d10:	898d      	ldrh	r5, [r1, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8004d12:	f023 0302 	bic.w	r3, r3, #2
 8004d16:	041b      	lsls	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004d18:	4335      	orrs	r5, r6
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8004d1a:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004d1c:	b2ad      	uxth	r5, r5
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8004d1e:	432b      	orrs	r3, r5
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004d20:	4d0e      	ldr	r5, [pc, #56]	; (8004d5c <TIM_OC1Init+0x6e>)
 8004d22:	42a8      	cmp	r0, r5
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004d24:	b2a4      	uxth	r4, r4
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004d26:	d003      	beq.n	8004d30 <TIM_OC1Init+0x42>
 8004d28:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004d2c:	42a8      	cmp	r0, r5
 8004d2e:	d10e      	bne.n	8004d4e <TIM_OC1Init+0x60>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004d30:	89cd      	ldrh	r5, [r1, #14]
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004d32:	8a4e      	ldrh	r6, [r1, #18]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8004d34:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004d38:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004d3a:	888d      	ldrh	r5, [r1, #4]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 8004d3c:	f023 0304 	bic.w	r3, r3, #4
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004d40:	432b      	orrs	r3, r5
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004d42:	8a0d      	ldrh	r5, [r1, #16]
 8004d44:	4335      	orrs	r5, r6
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 8004d46:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004d4a:	b2ad      	uxth	r5, r5
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8004d4c:	432c      	orrs	r4, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004d4e:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004d50:	8302      	strh	r2, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004d52:	688a      	ldr	r2, [r1, #8]
 8004d54:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004d56:	8403      	strh	r3, [r0, #32]
 8004d58:	bd70      	pop	{r4, r5, r6, pc}
 8004d5a:	bf00      	nop
 8004d5c:	40010000 	.word	0x40010000

08004d60 <TIM_OC2Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8004d60:	8c03      	ldrh	r3, [r0, #32]
 8004d62:	f023 0310 	bic.w	r3, r3, #16
 8004d66:	041b      	lsls	r3, r3, #16
 8004d68:	0c1b      	lsrs	r3, r3, #16
 8004d6a:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8004d6c:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004d6e:	8882      	ldrh	r2, [r0, #4]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004d70:	b530      	push	{r4, r5, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004d72:	8b04      	ldrh	r4, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004d74:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 8004d76:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
 8004d7a:	0424      	lsls	r4, r4, #16
 8004d7c:	0c24      	lsrs	r4, r4, #16
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 8004d7e:	f023 0320 	bic.w	r3, r3, #32
 8004d82:	041b      	lsls	r3, r3, #16
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004d84:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004d88:	898d      	ldrh	r5, [r1, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 8004d8a:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004d8c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8004d90:	884d      	ldrh	r5, [r1, #2]
 8004d92:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004d96:	4d12      	ldr	r5, [pc, #72]	; (8004de0 <TIM_OC2Init+0x80>)
 8004d98:	42a8      	cmp	r0, r5
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004d9a:	b292      	uxth	r2, r2
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8004d9c:	b29b      	uxth	r3, r3
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004d9e:	d003      	beq.n	8004da8 <TIM_OC2Init+0x48>
 8004da0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004da4:	42a8      	cmp	r0, r5
 8004da6:	d115      	bne.n	8004dd4 <TIM_OC2Init+0x74>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004da8:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8004daa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004dae:	b29b      	uxth	r3, r3
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004db0:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 8004db4:	f64f 75bf 	movw	r5, #65471	; 0xffbf
 8004db8:	401d      	ands	r5, r3
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8004dba:	888b      	ldrh	r3, [r1, #4]
 8004dbc:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004dc0:	8a0d      	ldrh	r5, [r1, #16]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 8004dc2:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004dc6:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004dca:	8a4d      	ldrh	r5, [r1, #18]
 8004dcc:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8004dd0:	b29b      	uxth	r3, r3
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004dd2:	b292      	uxth	r2, r2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004dd4:	8082      	strh	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004dd6:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004dd8:	8304      	strh	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004dda:	6382      	str	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004ddc:	8403      	strh	r3, [r0, #32]
 8004dde:	bd30      	pop	{r4, r5, pc}
 8004de0:	40010000 	.word	0x40010000

08004de4 <TIM_OC3Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8004de4:	8c03      	ldrh	r3, [r0, #32]
 8004de6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004dea:	041b      	lsls	r3, r3, #16
 8004dec:	0c1b      	lsrs	r3, r3, #16
 8004dee:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004df0:	8c03      	ldrh	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004df2:	8882      	ldrh	r2, [r0, #4]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004df4:	b530      	push	{r4, r5, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004df6:	8b84      	ldrh	r4, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004df8:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 8004dfa:	f024 0473 	bic.w	r4, r4, #115	; 0x73
 8004dfe:	0424      	lsls	r4, r4, #16
 8004e00:	0c24      	lsrs	r4, r4, #16
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8004e02:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004e06:	041b      	lsls	r3, r3, #16
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004e08:	432c      	orrs	r4, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004e0a:	898d      	ldrh	r5, [r1, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8004e0c:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004e0e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8004e12:	884d      	ldrh	r5, [r1, #2]
 8004e14:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004e18:	4d12      	ldr	r5, [pc, #72]	; (8004e64 <TIM_OC3Init+0x80>)
 8004e1a:	42a8      	cmp	r0, r5
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004e1c:	b292      	uxth	r2, r2
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8004e1e:	b29b      	uxth	r3, r3
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004e20:	d003      	beq.n	8004e2a <TIM_OC3Init+0x46>
 8004e22:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004e26:	42a8      	cmp	r0, r5
 8004e28:	d115      	bne.n	8004e56 <TIM_OC3Init+0x72>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004e2a:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8004e2c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004e30:	b29b      	uxth	r3, r3
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004e32:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 8004e36:	f64f 35ff 	movw	r5, #64511	; 0xfbff
 8004e3a:	401d      	ands	r5, r3
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 8004e3c:	888b      	ldrh	r3, [r1, #4]
 8004e3e:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004e42:	8a0d      	ldrh	r5, [r1, #16]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 8004e44:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004e48:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004e4c:	8a4d      	ldrh	r5, [r1, #18]
 8004e4e:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 8004e52:	b29b      	uxth	r3, r3
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004e54:	b292      	uxth	r2, r2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004e56:	8082      	strh	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004e58:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004e5a:	8384      	strh	r4, [r0, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004e5c:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004e5e:	8403      	strh	r3, [r0, #32]
 8004e60:	bd30      	pop	{r4, r5, pc}
 8004e62:	bf00      	nop
 8004e64:	40010000 	.word	0x40010000

08004e68 <TIM_OC4Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 8004e68:	8c03      	ldrh	r3, [r0, #32]
 8004e6a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004e6e:	041b      	lsls	r3, r3, #16
 8004e70:	0c1b      	lsrs	r3, r3, #16
 8004e72:	8403      	strh	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004e74:	8c03      	ldrh	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004e76:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004e78:	8884      	ldrh	r4, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004e7a:	8b82      	ldrh	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004e7c:	880d      	ldrh	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 8004e7e:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 8004e82:	0412      	lsls	r2, r2, #16
 8004e84:	0c12      	lsrs	r2, r2, #16
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 8004e86:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8004e8a:	041b      	lsls	r3, r3, #16
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004e8c:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004e90:	898d      	ldrh	r5, [r1, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 8004e92:	0c1b      	lsrs	r3, r3, #16
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004e94:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8004e98:	884d      	ldrh	r5, [r1, #2]
 8004e9a:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004e9e:	4d0a      	ldr	r5, [pc, #40]	; (8004ec8 <TIM_OC4Init+0x60>)
 8004ea0:	42a8      	cmp	r0, r5
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004ea2:	b2a4      	uxth	r4, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004ea4:	d003      	beq.n	8004eae <TIM_OC4Init+0x46>
 8004ea6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004eaa:	42a8      	cmp	r0, r5
 8004eac:	d105      	bne.n	8004eba <TIM_OC4Init+0x52>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004eae:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 8004eb0:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004eb4:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8004eb8:	b2a4      	uxth	r4, r4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004eba:	8084      	strh	r4, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8004ebc:	8382      	strh	r2, [r0, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004ebe:	688a      	ldr	r2, [r1, #8]
 8004ec0:	6402      	str	r2, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004ec2:	8403      	strh	r3, [r0, #32]
 8004ec4:	bd30      	pop	{r4, r5, pc}
 8004ec6:	bf00      	nop
 8004ec8:	40010000 	.word	0x40010000

08004ecc <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8004ecc:	2300      	movs	r3, #0
 8004ece:	8003      	strh	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8004ed0:	8043      	strh	r3, [r0, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 8004ed2:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 8004ed4:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 8004ed6:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8004ed8:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8004eda:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8004edc:	8243      	strh	r3, [r0, #18]
 8004ede:	4770      	bx	lr

08004ee0 <TIM_SelectOCxM>:
  *            @arg TIM_ForcedAction_Active
  *            @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
 8004ee0:	b530      	push	{r4, r5, lr}
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004ee2:	8c05      	ldrh	r5, [r0, #32]
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8004ee4:	2401      	movs	r4, #1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004ee6:	b2ad      	uxth	r5, r5
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8004ee8:	fa04 f401 	lsl.w	r4, r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004eec:	ea25 0404 	bic.w	r4, r5, r4
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 8004ef0:	f100 0318 	add.w	r3, r0, #24

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004ef4:	8404      	strh	r4, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8004ef6:	b109      	cbz	r1, 8004efc <TIM_SelectOCxM+0x1c>
 8004ef8:	2908      	cmp	r1, #8
 8004efa:	d107      	bne.n	8004f0c <TIM_SelectOCxM+0x2c>
  {
    tmp += (TIM_Channel>>1);
 8004efc:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8004efe:	f64f 708f 	movw	r0, #65423	; 0xff8f
 8004f02:	58cc      	ldr	r4, [r1, r3]
 8004f04:	4020      	ands	r0, r4
 8004f06:	50c8      	str	r0, [r1, r3]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8004f08:	58c8      	ldr	r0, [r1, r3]
 8004f0a:	e00a      	b.n	8004f22 <TIM_SelectOCxM+0x42>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 8004f0c:	3904      	subs	r1, #4
 8004f0e:	f3c1 014e 	ubfx	r1, r1, #1, #15

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004f12:	f648 70ff 	movw	r0, #36863	; 0x8fff
 8004f16:	58cc      	ldr	r4, [r1, r3]
 8004f18:	4020      	ands	r0, r4
 8004f1a:	50c8      	str	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004f1c:	0212      	lsls	r2, r2, #8
 8004f1e:	58c8      	ldr	r0, [r1, r3]
 8004f20:	b292      	uxth	r2, r2
 8004f22:	4302      	orrs	r2, r0
 8004f24:	50ca      	str	r2, [r1, r3]
 8004f26:	bd30      	pop	{r4, r5, pc}

08004f28 <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8004f28:	6341      	str	r1, [r0, #52]	; 0x34
 8004f2a:	4770      	bx	lr

08004f2c <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8004f2c:	6381      	str	r1, [r0, #56]	; 0x38
 8004f2e:	4770      	bx	lr

08004f30 <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8004f30:	63c1      	str	r1, [r0, #60]	; 0x3c
 8004f32:	4770      	bx	lr

08004f34 <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8004f34:	6401      	str	r1, [r0, #64]	; 0x40
 8004f36:	4770      	bx	lr

08004f38 <TIM_ForcedOC1Config>:
  uint16_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004f38:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 8004f3a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004f3e:	041b      	lsls	r3, r3, #16
 8004f40:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8004f42:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004f44:	8301      	strh	r1, [r0, #24]
 8004f46:	4770      	bx	lr

08004f48 <TIM_ForcedOC2Config>:
  uint16_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004f48:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 8004f4a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8004f4e:	041b      	lsls	r3, r3, #16
 8004f50:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 8004f52:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004f56:	8301      	strh	r1, [r0, #24]
 8004f58:	4770      	bx	lr

08004f5a <TIM_ForcedOC3Config>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 8004f5a:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 8004f5c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004f60:	041b      	lsls	r3, r3, #16
 8004f62:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8004f64:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004f66:	8381      	strh	r1, [r0, #28]
 8004f68:	4770      	bx	lr

08004f6a <TIM_ForcedOC4Config>:
  uint16_t tmpccmr2 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 8004f6a:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 8004f6c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8004f70:	041b      	lsls	r3, r3, #16
 8004f72:	0c1b      	lsrs	r3, r3, #16

  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 8004f74:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004f78:	8381      	strh	r1, [r0, #28]
 8004f7a:	4770      	bx	lr

08004f7c <TIM_OC1PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004f7c:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 8004f7e:	f023 0308 	bic.w	r3, r3, #8
 8004f82:	041b      	lsls	r3, r3, #16
 8004f84:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8004f86:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004f88:	8301      	strh	r1, [r0, #24]
 8004f8a:	4770      	bx	lr

08004f8c <TIM_OC2PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004f8c:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 8004f8e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004f92:	041b      	lsls	r3, r3, #16
 8004f94:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 8004f96:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004f9a:	8301      	strh	r1, [r0, #24]
 8004f9c:	4770      	bx	lr

08004f9e <TIM_OC3PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004f9e:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 8004fa0:	f023 0308 	bic.w	r3, r3, #8
 8004fa4:	041b      	lsls	r3, r3, #16
 8004fa6:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 8004fa8:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004faa:	8381      	strh	r1, [r0, #28]
 8004fac:	4770      	bx	lr

08004fae <TIM_OC4PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004fae:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 8004fb0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004fb4:	041b      	lsls	r3, r3, #16
 8004fb6:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 8004fb8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004fbc:	8381      	strh	r1, [r0, #28]
 8004fbe:	4770      	bx	lr

08004fc0 <TIM_OC1FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004fc0:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 8004fc2:	f023 0304 	bic.w	r3, r3, #4
 8004fc6:	041b      	lsls	r3, r3, #16
 8004fc8:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8004fca:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004fcc:	8301      	strh	r1, [r0, #24]
 8004fce:	4770      	bx	lr

08004fd0 <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004fd0:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 8004fd2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004fd6:	041b      	lsls	r3, r3, #16
 8004fd8:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 8004fda:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004fde:	8301      	strh	r1, [r0, #24]
 8004fe0:	4770      	bx	lr

08004fe2 <TIM_OC3FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004fe2:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 8004fe4:	f023 0304 	bic.w	r3, r3, #4
 8004fe8:	041b      	lsls	r3, r3, #16
 8004fea:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8004fec:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8004fee:	8381      	strh	r1, [r0, #28]
 8004ff0:	4770      	bx	lr

08004ff2 <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004ff2:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 8004ff4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004ff8:	041b      	lsls	r3, r3, #16
 8004ffa:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 8004ffc:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8005000:	8381      	strh	r1, [r0, #28]
 8005002:	4770      	bx	lr

08005004 <TIM_ClearOC1Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8005004:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 8005006:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800500a:	041b      	lsls	r3, r3, #16
 800500c:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 800500e:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8005010:	8301      	strh	r1, [r0, #24]
 8005012:	4770      	bx	lr

08005014 <TIM_ClearOC2Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8005014:	8b03      	ldrh	r3, [r0, #24]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 8005016:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 8005018:	045b      	lsls	r3, r3, #17

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 800501a:	ea41 4353 	orr.w	r3, r1, r3, lsr #17

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800501e:	8303      	strh	r3, [r0, #24]
 8005020:	4770      	bx	lr

08005022 <TIM_ClearOC3Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8005022:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 8005024:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005028:	041b      	lsls	r3, r3, #16
 800502a:	0c1b      	lsrs	r3, r3, #16

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 800502c:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800502e:	8381      	strh	r1, [r0, #28]
 8005030:	4770      	bx	lr

08005032 <TIM_ClearOC4Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8005032:	8b83      	ldrh	r3, [r0, #28]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8005034:	0209      	lsls	r1, r1, #8
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 8005036:	045b      	lsls	r3, r3, #17

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8005038:	ea41 4353 	orr.w	r3, r1, r3, lsr #17

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 800503c:	8383      	strh	r3, [r0, #28]
 800503e:	4770      	bx	lr

08005040 <TIM_OC1PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8005040:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 8005042:	f023 0302 	bic.w	r3, r3, #2
 8005046:	041b      	lsls	r3, r3, #16
 8005048:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCPolarity;
 800504a:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800504c:	8401      	strh	r1, [r0, #32]
 800504e:	4770      	bx	lr

08005050 <TIM_OC1NPolarityConfig>:
  uint16_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8005050:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8005052:	f023 0308 	bic.w	r3, r3, #8
 8005056:	041b      	lsls	r3, r3, #16
 8005058:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= TIM_OCNPolarity;
 800505a:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800505c:	8401      	strh	r1, [r0, #32]
 800505e:	4770      	bx	lr

08005060 <TIM_OC2PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8005060:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 8005062:	f023 0320 	bic.w	r3, r3, #32
 8005066:	041b      	lsls	r3, r3, #16
 8005068:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 800506a:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 800506e:	8401      	strh	r1, [r0, #32]
 8005070:	4770      	bx	lr

08005072 <TIM_OC2NPolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8005072:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8005074:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005078:	041b      	lsls	r3, r3, #16
 800507a:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 800507c:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005080:	8401      	strh	r1, [r0, #32]
 8005082:	4770      	bx	lr

08005084 <TIM_OC3PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8005084:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8005086:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800508a:	041b      	lsls	r3, r3, #16
 800508c:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 800508e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8005092:	8401      	strh	r1, [r0, #32]
 8005094:	4770      	bx	lr

08005096 <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 8005096:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8005098:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800509c:	041b      	lsls	r3, r3, #16
 800509e:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 80050a0:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80050a4:	8401      	strh	r1, [r0, #32]
 80050a6:	4770      	bx	lr

080050a8 <TIM_OC4PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 80050a8:	8c03      	ldrh	r3, [r0, #32]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 80050aa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80050ae:	041b      	lsls	r3, r3, #16
 80050b0:	0c1b      	lsrs	r3, r3, #16
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 80050b2:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 80050b6:	8401      	strh	r1, [r0, #32]
 80050b8:	4770      	bx	lr

080050ba <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 80050ba:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 80050bc:	8c04      	ldrh	r4, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 80050be:	2301      	movs	r3, #1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 80050c0:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_SET << TIM_Channel;
 80050c2:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
 80050c6:	ea24 0303 	bic.w	r3, r4, r3
 80050ca:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 80050cc:	8c03      	ldrh	r3, [r0, #32]
 80050ce:	fa02 f201 	lsl.w	r2, r2, r1
 80050d2:	4313      	orrs	r3, r2
 80050d4:	8403      	strh	r3, [r0, #32]
 80050d6:	bd10      	pop	{r4, pc}

080050d8 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 80050d8:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 80050da:	8c04      	ldrh	r4, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 80050dc:	2304      	movs	r3, #4

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 80050de:	b2a4      	uxth	r4, r4
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_SET << TIM_Channel;
 80050e0:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
 80050e4:	ea24 0303 	bic.w	r3, r4, r3
 80050e8:	8403      	strh	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 80050ea:	8c03      	ldrh	r3, [r0, #32]
 80050ec:	fa02 f201 	lsl.w	r2, r2, r1
 80050f0:	4313      	orrs	r3, r2
 80050f2:	8403      	strh	r3, [r0, #32]
 80050f4:	bd10      	pop	{r4, pc}

080050f6 <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 80050f6:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 80050f8:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 80050fa:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 80050fc:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 80050fe:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8005100:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 8005102:	8103      	strh	r3, [r0, #8]
 8005104:	4770      	bx	lr

08005106 <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 8005106:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8005108:	4770      	bx	lr

0800510a <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 800510a:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 800510c:	4770      	bx	lr

0800510e <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 800510e:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 8005110:	4770      	bx	lr

08005112 <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8005112:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8005114:	4770      	bx	lr

08005116 <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8005116:	8b03      	ldrh	r3, [r0, #24]
 8005118:	f023 030c 	bic.w	r3, r3, #12
 800511c:	041b      	lsls	r3, r3, #16
 800511e:	0c1b      	lsrs	r3, r3, #16
 8005120:	8303      	strh	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8005122:	8b03      	ldrh	r3, [r0, #24]
 8005124:	b29b      	uxth	r3, r3
 8005126:	4319      	orrs	r1, r3
 8005128:	8301      	strh	r1, [r0, #24]
 800512a:	4770      	bx	lr

0800512c <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 800512c:	8b03      	ldrh	r3, [r0, #24]
 800512e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8005132:	041b      	lsls	r3, r3, #16
 8005134:	0c1b      	lsrs	r3, r3, #16
 8005136:	8303      	strh	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8005138:	8b03      	ldrh	r3, [r0, #24]
 800513a:	b29b      	uxth	r3, r3
 800513c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005140:	8301      	strh	r1, [r0, #24]
 8005142:	4770      	bx	lr

08005144 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005146:	460c      	mov	r4, r1

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8005148:	8849      	ldrh	r1, [r1, #2]
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 800514a:	88a2      	ldrh	r2, [r4, #4]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800514c:	f8b4 e000 	ldrh.w	lr, [r4]
 8005150:	8923      	ldrh	r3, [r4, #8]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005152:	4605      	mov	r5, r0
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8005154:	2900      	cmp	r1, #0
 8005156:	bf0c      	ite	eq
 8005158:	2702      	moveq	r7, #2
 800515a:	2700      	movne	r7, #0
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 800515c:	2a01      	cmp	r2, #1
 800515e:	bf14      	ite	ne
 8005160:	2601      	movne	r6, #1
 8005162:	2602      	moveq	r6, #2
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005164:	f1be 0f00 	cmp.w	lr, #0
 8005168:	d111      	bne.n	800518e <TIM_PWMIConfig+0x4a>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800516a:	f7ff fc3f 	bl	80049ec <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800516e:	4628      	mov	r0, r5
 8005170:	88e1      	ldrh	r1, [r4, #6]
 8005172:	f7ff ffd0 	bl	8005116 <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8005176:	4628      	mov	r0, r5
 8005178:	4639      	mov	r1, r7
 800517a:	4632      	mov	r2, r6
 800517c:	8923      	ldrh	r3, [r4, #8]
 800517e:	f7ff fc4e 	bl	8004a1e <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005182:	88e1      	ldrh	r1, [r4, #6]
 8005184:	4628      	mov	r0, r5
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005186:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800518a:	f7ff bfcf 	b.w	800512c <TIM_SetIC2Prescaler>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 800518e:	f7ff fc46 	bl	8004a1e <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005192:	4628      	mov	r0, r5
 8005194:	88e1      	ldrh	r1, [r4, #6]
 8005196:	f7ff ffc9 	bl	800512c <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 800519a:	4628      	mov	r0, r5
 800519c:	4639      	mov	r1, r7
 800519e:	4632      	mov	r2, r6
 80051a0:	8923      	ldrh	r3, [r4, #8]
 80051a2:	f7ff fc23 	bl	80049ec <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80051a6:	88e1      	ldrh	r1, [r4, #6]
 80051a8:	4628      	mov	r0, r5
  }
}
 80051aa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80051ae:	f7ff bfb2 	b.w	8005116 <TIM_SetIC1Prescaler>

080051b2 <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 80051b2:	8b83      	ldrh	r3, [r0, #28]
 80051b4:	f023 030c 	bic.w	r3, r3, #12
 80051b8:	041b      	lsls	r3, r3, #16
 80051ba:	0c1b      	lsrs	r3, r3, #16
 80051bc:	8383      	strh	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 80051be:	8b83      	ldrh	r3, [r0, #28]
 80051c0:	b29b      	uxth	r3, r3
 80051c2:	4319      	orrs	r1, r3
 80051c4:	8381      	strh	r1, [r0, #28]
 80051c6:	4770      	bx	lr

080051c8 <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 80051c8:	8b83      	ldrh	r3, [r0, #28]
 80051ca:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80051ce:	041b      	lsls	r3, r3, #16
 80051d0:	0c1b      	lsrs	r3, r3, #16
 80051d2:	8383      	strh	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 80051d4:	8b83      	ldrh	r3, [r0, #28]
 80051d6:	b29b      	uxth	r3, r3
 80051d8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80051dc:	8381      	strh	r1, [r0, #28]
 80051de:	4770      	bx	lr

080051e0 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80051e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80051e2:	460d      	mov	r5, r1
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80051e4:	880b      	ldrh	r3, [r1, #0]
 80051e6:	88aa      	ldrh	r2, [r5, #4]
 80051e8:	8849      	ldrh	r1, [r1, #2]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80051ea:	4604      	mov	r4, r0
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80051ec:	b943      	cbnz	r3, 8005200 <TIM_ICInit+0x20>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 80051ee:	892b      	ldrh	r3, [r5, #8]
 80051f0:	f7ff fbfc 	bl	80049ec <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80051f4:	88e9      	ldrh	r1, [r5, #6]
 80051f6:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80051f8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80051fc:	f7ff bf8b 	b.w	8005116 <TIM_SetIC1Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8005200:	2b04      	cmp	r3, #4
 8005202:	d108      	bne.n	8005216 <TIM_ICInit+0x36>
  {
    /* TI2 Configuration */
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8005204:	892b      	ldrh	r3, [r5, #8]
 8005206:	f7ff fc0a 	bl	8004a1e <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800520a:	88e9      	ldrh	r1, [r5, #6]
 800520c:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 800520e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005212:	f7ff bf8b 	b.w	800512c <TIM_SetIC2Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8005216:	2b08      	cmp	r3, #8
 8005218:	f8b5 c008 	ldrh.w	ip, [r5, #8]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 800521c:	8c07      	ldrh	r7, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800521e:	d11e      	bne.n	800525e <TIM_ICInit+0x7e>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8005220:	f427 7780 	bic.w	r7, r7, #256	; 0x100
 8005224:	043f      	lsls	r7, r7, #16
 8005226:	0c3f      	lsrs	r7, r7, #16
 8005228:	8407      	strh	r7, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 800522a:	8b86      	ldrh	r6, [r0, #28]
  tmpccer = TIMx->CCER;
 800522c:	8c03      	ldrh	r3, [r0, #32]
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  tmpccmr2 = TIMx->CCMR2;
 800522e:	b2b6      	uxth	r6, r6
  tmpccer = TIMx->CCER;
 8005230:	b29b      	uxth	r3, r3
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 8005232:	f026 06f3 	bic.w	r6, r6, #243	; 0xf3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8005236:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800523a:	ea46 1c0c 	orr.w	ip, r6, ip, lsl #4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800523e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005242:	fa1f fc8c 	uxth.w	ip, ip

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 8005246:	b289      	uxth	r1, r1
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005248:	ea4c 0202 	orr.w	r2, ip, r2

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800524c:	f441 7180 	orr.w	r1, r1, #256	; 0x100

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005250:	8382      	strh	r2, [r0, #28]
  TIMx->CCER = tmpccer;
 8005252:	8401      	strh	r1, [r0, #32]
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005254:	88e9      	ldrh	r1, [r5, #6]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005256:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800525a:	f7ff bfaa 	b.w	80051b2 <TIM_SetIC3Prescaler>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800525e:	f427 5780 	bic.w	r7, r7, #4096	; 0x1000
 8005262:	043f      	lsls	r7, r7, #16
 8005264:	0c3f      	lsrs	r7, r7, #16
 8005266:	8407      	strh	r7, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8005268:	8b86      	ldrh	r6, [r0, #28]
  tmpccer = TIMx->CCER;
 800526a:	8c03      	ldrh	r3, [r0, #32]
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 800526c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005270:	045b      	lsls	r3, r3, #17
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8005272:	f426 7640 	bic.w	r6, r6, #768	; 0x300
 8005276:	0536      	lsls	r6, r6, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8005278:	0c5b      	lsrs	r3, r3, #17
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800527a:	0d36      	lsrs	r6, r6, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 800527c:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8005280:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005284:	b29b      	uxth	r3, r3
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005286:	88e9      	ldrh	r1, [r5, #6]
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 8005288:	ea46 3c0c 	orr.w	ip, r6, ip, lsl #12

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 800528c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005290:	f8a0 c01c 	strh.w	ip, [r0, #28]
  TIMx->CCER = tmpccer ;
 8005294:	8403      	strh	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005296:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800529a:	f7ff bf95 	b.w	80051c8 <TIM_SetIC4Prescaler>

0800529e <TIM_BDTRConfig>:
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800529e:	884a      	ldrh	r2, [r1, #2]
 80052a0:	880b      	ldrh	r3, [r1, #0]
 80052a2:	4313      	orrs	r3, r2
 80052a4:	888a      	ldrh	r2, [r1, #4]
 80052a6:	4313      	orrs	r3, r2
 80052a8:	88ca      	ldrh	r2, [r1, #6]
 80052aa:	4313      	orrs	r3, r2
 80052ac:	890a      	ldrh	r2, [r1, #8]
 80052ae:	4313      	orrs	r3, r2
 80052b0:	894a      	ldrh	r2, [r1, #10]
 80052b2:	4313      	orrs	r3, r2
 80052b4:	898a      	ldrh	r2, [r1, #12]
 80052b6:	4313      	orrs	r3, r2
 80052b8:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80052bc:	4770      	bx	lr

080052be <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 80052be:	2300      	movs	r3, #0
 80052c0:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 80052c2:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 80052c4:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 80052c6:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 80052c8:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 80052ca:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 80052cc:	8183      	strh	r3, [r0, #12]
 80052ce:	4770      	bx	lr

080052d0 <TIM_CtrlPWMOutputs>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80052d0:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80052d4:	b121      	cbz	r1, 80052e0 <TIM_CtrlPWMOutputs+0x10>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80052d6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80052da:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80052de:	e001      	b.n	80052e4 <TIM_CtrlPWMOutputs+0x14>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 80052e0:	045b      	lsls	r3, r3, #17
 80052e2:	0c5b      	lsrs	r3, r3, #17
 80052e4:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80052e8:	4770      	bx	lr

080052ea <TIM_SelectCOM>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 80052ea:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80052ec:	b119      	cbz	r1, 80052f6 <TIM_SelectCOM+0xc>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 80052ee:	b29b      	uxth	r3, r3
 80052f0:	f043 0304 	orr.w	r3, r3, #4
 80052f4:	e003      	b.n	80052fe <TIM_SelectCOM+0x14>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 80052f6:	f023 0304 	bic.w	r3, r3, #4
 80052fa:	041b      	lsls	r3, r3, #16
 80052fc:	0c1b      	lsrs	r3, r3, #16
 80052fe:	8083      	strh	r3, [r0, #4]
 8005300:	4770      	bx	lr

08005302 <TIM_CCPreloadControl>:
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8005302:	8883      	ldrh	r3, [r0, #4]
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005304:	b119      	cbz	r1, 800530e <TIM_CCPreloadControl+0xc>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8005306:	b29b      	uxth	r3, r3
 8005308:	f043 0301 	orr.w	r3, r3, #1
 800530c:	e003      	b.n	8005316 <TIM_CCPreloadControl+0x14>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 800530e:	f023 0301 	bic.w	r3, r3, #1
 8005312:	041b      	lsls	r3, r3, #16
 8005314:	0c1b      	lsrs	r3, r3, #16
 8005316:	8083      	strh	r3, [r0, #4]
 8005318:	4770      	bx	lr

0800531a <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 800531a:	8983      	ldrh	r3, [r0, #12]
 800531c:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800531e:	b10a      	cbz	r2, 8005324 <TIM_ITConfig+0xa>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8005320:	4319      	orrs	r1, r3
 8005322:	e001      	b.n	8005328 <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8005324:	ea23 0101 	bic.w	r1, r3, r1
 8005328:	8181      	strh	r1, [r0, #12]
 800532a:	4770      	bx	lr

0800532c <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 800532c:	8281      	strh	r1, [r0, #20]
 800532e:	4770      	bx	lr

08005330 <TIM_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 8005330:	8a03      	ldrh	r3, [r0, #16]
 8005332:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005334:	bf0c      	ite	eq
 8005336:	2000      	moveq	r0, #0
 8005338:	2001      	movne	r0, #1
 800533a:	4770      	bx	lr

0800533c <TIM_ClearFlag>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 800533c:	43c9      	mvns	r1, r1
 800533e:	8201      	strh	r1, [r0, #16]
 8005340:	4770      	bx	lr

08005342 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8005342:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8005344:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8005346:	ea11 0003 	ands.w	r0, r1, r3
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
 800534a:	b292      	uxth	r2, r2
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800534c:	d003      	beq.n	8005356 <TIM_GetITStatus+0x14>
 800534e:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8005350:	bf0c      	ite	eq
 8005352:	2000      	moveq	r0, #0
 8005354:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005356:	4770      	bx	lr

08005358 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8005358:	43c9      	mvns	r1, r1
 800535a:	8201      	strh	r1, [r0, #16]
 800535c:	4770      	bx	lr

0800535e <TIM_DMAConfig>:
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 800535e:	430a      	orrs	r2, r1
 8005360:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 8005364:	4770      	bx	lr

08005366 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8005366:	8983      	ldrh	r3, [r0, #12]
 8005368:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800536a:	b10a      	cbz	r2, 8005370 <TIM_DMACmd+0xa>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 800536c:	4319      	orrs	r1, r3
 800536e:	e001      	b.n	8005374 <TIM_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 8005370:	ea23 0101 	bic.w	r1, r3, r1
 8005374:	8181      	strh	r1, [r0, #12]
 8005376:	4770      	bx	lr

08005378 <TIM_SelectCCDMA>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8005378:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800537a:	b119      	cbz	r1, 8005384 <TIM_SelectCCDMA+0xc>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 800537c:	b29b      	uxth	r3, r3
 800537e:	f043 0308 	orr.w	r3, r3, #8
 8005382:	e003      	b.n	800538c <TIM_SelectCCDMA+0x14>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8005384:	f023 0308 	bic.w	r3, r3, #8
 8005388:	041b      	lsls	r3, r3, #16
 800538a:	0c1b      	lsrs	r3, r3, #16
 800538c:	8083      	strh	r3, [r0, #4]
 800538e:	4770      	bx	lr

08005390 <TIM_InternalClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 8005390:	8903      	ldrh	r3, [r0, #8]
 8005392:	f023 0307 	bic.w	r3, r3, #7
 8005396:	041b      	lsls	r3, r3, #16
 8005398:	0c1b      	lsrs	r3, r3, #16
 800539a:	8103      	strh	r3, [r0, #8]
 800539c:	4770      	bx	lr

0800539e <TIM_ITRxExternalClockConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800539e:	8903      	ldrh	r3, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80053a0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80053a4:	041b      	lsls	r3, r3, #16
 80053a6:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 80053a8:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80053aa:	8101      	strh	r1, [r0, #8]

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80053ac:	8903      	ldrh	r3, [r0, #8]
 80053ae:	b29b      	uxth	r3, r3
 80053b0:	f043 0307 	orr.w	r3, r3, #7
 80053b4:	8103      	strh	r3, [r0, #8]
 80053b6:	4770      	bx	lr

080053b8 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 80053b8:	b538      	push	{r3, r4, r5, lr}
 80053ba:	460d      	mov	r5, r1
 80053bc:	4611      	mov	r1, r2
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80053be:	2201      	movs	r2, #1
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80053c0:	2d60      	cmp	r5, #96	; 0x60
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 80053c2:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80053c4:	d102      	bne.n	80053cc <TIM_TIxExternalClockConfig+0x14>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80053c6:	f7ff fb2a 	bl	8004a1e <TI2_Config>
 80053ca:	e001      	b.n	80053d0 <TIM_TIxExternalClockConfig+0x18>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80053cc:	f7ff fb0e 	bl	80049ec <TI1_Config>
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80053d0:	8923      	ldrh	r3, [r4, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80053d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80053d6:	041b      	lsls	r3, r3, #16
 80053d8:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 80053da:	432b      	orrs	r3, r5

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80053dc:	8123      	strh	r3, [r4, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80053de:	8923      	ldrh	r3, [r4, #8]
 80053e0:	b29b      	uxth	r3, r3
 80053e2:	f043 0307 	orr.w	r3, r3, #7
 80053e6:	8123      	strh	r3, [r4, #8]
 80053e8:	bd38      	pop	{r3, r4, r5, pc}

080053ea <TIM_SelectInputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80053ea:	8903      	ldrh	r3, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80053ec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80053f0:	041b      	lsls	r3, r3, #16
 80053f2:	0c1b      	lsrs	r3, r3, #16

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
 80053f4:	4319      	orrs	r1, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80053f6:	8101      	strh	r1, [r0, #8]
 80053f8:	4770      	bx	lr

080053fa <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 80053fa:	8883      	ldrh	r3, [r0, #4]
 80053fc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005400:	041b      	lsls	r3, r3, #16
 8005402:	0c1b      	lsrs	r3, r3, #16
 8005404:	8083      	strh	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 8005406:	8883      	ldrh	r3, [r0, #4]
 8005408:	b29b      	uxth	r3, r3
 800540a:	4319      	orrs	r1, r3
 800540c:	8081      	strh	r1, [r0, #4]
 800540e:	4770      	bx	lr

08005410 <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 8005410:	8903      	ldrh	r3, [r0, #8]
 8005412:	f023 0307 	bic.w	r3, r3, #7
 8005416:	041b      	lsls	r3, r3, #16
 8005418:	0c1b      	lsrs	r3, r3, #16
 800541a:	8103      	strh	r3, [r0, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
 800541c:	8903      	ldrh	r3, [r0, #8]
 800541e:	b29b      	uxth	r3, r3
 8005420:	4319      	orrs	r1, r3
 8005422:	8101      	strh	r1, [r0, #8]
 8005424:	4770      	bx	lr

08005426 <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 8005426:	8903      	ldrh	r3, [r0, #8]
 8005428:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800542c:	041b      	lsls	r3, r3, #16
 800542e:	0c1b      	lsrs	r3, r3, #16
 8005430:	8103      	strh	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 8005432:	8903      	ldrh	r3, [r0, #8]
 8005434:	b29b      	uxth	r3, r3
 8005436:	4319      	orrs	r1, r3
 8005438:	8101      	strh	r1, [r0, #8]
 800543a:	4770      	bx	lr

0800543c <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 800543c:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 800543e:	8904      	ldrh	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8005440:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8005442:	4321      	orrs	r1, r4
 8005444:	430a      	orrs	r2, r1
 8005446:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 800544a:	461c      	mov	r4, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800544c:	8103      	strh	r3, [r0, #8]
 800544e:	bd10      	pop	{r4, pc}

08005450 <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005450:	b510      	push	{r4, lr}
 8005452:	4604      	mov	r4, r0
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8005454:	f7ff fff2 	bl	800543c <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8005458:	8923      	ldrh	r3, [r4, #8]
 800545a:	b29b      	uxth	r3, r3
 800545c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005460:	8123      	strh	r3, [r4, #8]
 8005462:	bd10      	pop	{r4, pc}

08005464 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005464:	b510      	push	{r4, lr}
 8005466:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8005468:	f7ff ffe8 	bl	800543c <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800546c:	8923      	ldrh	r3, [r4, #8]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 800546e:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 8005472:	041b      	lsls	r3, r3, #16
 8005474:	0c1b      	lsrs	r3, r3, #16
  tmpsmcr |= TIM_TS_ETRF;
 8005476:	f043 0377 	orr.w	r3, r3, #119	; 0x77

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800547a:	8123      	strh	r3, [r4, #8]
 800547c:	bd10      	pop	{r4, pc}

0800547e <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 800547e:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005480:	8905      	ldrh	r5, [r0, #8]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005482:	8b04      	ldrh	r4, [r0, #24]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005484:	8c06      	ldrh	r6, [r0, #32]
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8005486:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 800548a:	f024 0403 	bic.w	r4, r4, #3

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800548e:	b2b6      	uxth	r6, r6

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8005490:	f025 0507 	bic.w	r5, r5, #7
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8005494:	0424      	lsls	r4, r4, #16
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 8005496:	f026 0622 	bic.w	r6, r6, #34	; 0x22

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800549a:	042d      	lsls	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 800549c:	0c24      	lsrs	r4, r4, #16
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 800549e:	4332      	orrs	r2, r6

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 80054a0:	0c2d      	lsrs	r5, r5, #16
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 80054a2:	f444 7480 	orr.w	r4, r4, #256	; 0x100

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80054a6:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;
 80054aa:	4329      	orrs	r1, r5

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 80054ac:	f044 0401 	orr.w	r4, r4, #1
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80054b0:	8101      	strh	r1, [r0, #8]
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80054b2:	461e      	mov	r6, r3

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 80054b4:	8304      	strh	r4, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80054b6:	8403      	strh	r3, [r0, #32]
 80054b8:	bd70      	pop	{r4, r5, r6, pc}

080054ba <TIM_SelectHallSensor>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 80054ba:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054bc:	b119      	cbz	r1, 80054c6 <TIM_SelectHallSensor+0xc>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 80054be:	b29b      	uxth	r3, r3
 80054c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80054c4:	e003      	b.n	80054ce <TIM_SelectHallSensor+0x14>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 80054c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80054ca:	041b      	lsls	r3, r3, #16
 80054cc:	0c1b      	lsrs	r3, r3, #16
 80054ce:	8083      	strh	r3, [r0, #4]
 80054d0:	4770      	bx	lr

080054d2 <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 80054d2:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 80054d6:	4770      	bx	lr

080054d8 <USART_DeInit>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 80054d8:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 80054da:	4b23      	ldr	r3, [pc, #140]	; (8005568 <USART_DeInit+0x90>)
 80054dc:	4298      	cmp	r0, r3
 80054de:	d105      	bne.n	80054ec <USART_DeInit+0x14>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80054e0:	2010      	movs	r0, #16
 80054e2:	2101      	movs	r1, #1
 80054e4:	f7fe f97a 	bl	80037dc <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80054e8:	2010      	movs	r0, #16
 80054ea:	e037      	b.n	800555c <USART_DeInit+0x84>
  }
  else if (USARTx == USART2)
 80054ec:	4b1f      	ldr	r3, [pc, #124]	; (800556c <USART_DeInit+0x94>)
 80054ee:	4298      	cmp	r0, r3
 80054f0:	d107      	bne.n	8005502 <USART_DeInit+0x2a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80054f2:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80054f6:	2101      	movs	r1, #1
 80054f8:	f7fe f964 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80054fc:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8005500:	e009      	b.n	8005516 <USART_DeInit+0x3e>
  }
  else if (USARTx == USART3)
 8005502:	4b1b      	ldr	r3, [pc, #108]	; (8005570 <USART_DeInit+0x98>)
 8005504:	4298      	cmp	r0, r3
 8005506:	d10b      	bne.n	8005520 <USART_DeInit+0x48>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 8005508:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800550c:	2101      	movs	r1, #1
 800550e:	f7fe f959 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 8005512:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8005516:	2100      	movs	r1, #0
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 8005518:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 800551c:	f7fe b952 	b.w	80037c4 <RCC_APB1PeriphResetCmd>
  }    
  else if (USARTx == UART4)
 8005520:	4b14      	ldr	r3, [pc, #80]	; (8005574 <USART_DeInit+0x9c>)
 8005522:	4298      	cmp	r0, r3
 8005524:	d107      	bne.n	8005536 <USART_DeInit+0x5e>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8005526:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800552a:	2101      	movs	r1, #1
 800552c:	f7fe f94a 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8005530:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005534:	e7ef      	b.n	8005516 <USART_DeInit+0x3e>
  }
  else if (USARTx == UART5)
 8005536:	4b10      	ldr	r3, [pc, #64]	; (8005578 <USART_DeInit+0xa0>)
 8005538:	4298      	cmp	r0, r3
 800553a:	d107      	bne.n	800554c <USART_DeInit+0x74>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 800553c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005540:	2101      	movs	r1, #1
 8005542:	f7fe f93f 	bl	80037c4 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8005546:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800554a:	e7e4      	b.n	8005516 <USART_DeInit+0x3e>
  }     
  else
  {
    if (USARTx == USART6)
 800554c:	4b0b      	ldr	r3, [pc, #44]	; (800557c <USART_DeInit+0xa4>)
 800554e:	4298      	cmp	r0, r3
 8005550:	d109      	bne.n	8005566 <USART_DeInit+0x8e>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 8005552:	2020      	movs	r0, #32
 8005554:	2101      	movs	r1, #1
 8005556:	f7fe f941 	bl	80037dc <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 800555a:	2020      	movs	r0, #32
 800555c:	2100      	movs	r1, #0
    }
  }
}
 800555e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (USARTx == USART6)
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 8005562:	f7fe b93b 	b.w	80037dc <RCC_APB2PeriphResetCmd>
 8005566:	bd08      	pop	{r3, pc}
 8005568:	40011000 	.word	0x40011000
 800556c:	40004400 	.word	0x40004400
 8005570:	40004800 	.word	0x40004800
 8005574:	40004c00 	.word	0x40004c00
 8005578:	40005000 	.word	0x40005000
 800557c:	40011400 	.word	0x40011400

08005580 <USART_Init>:
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005580:	8a03      	ldrh	r3, [r0, #16]
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005582:	88ca      	ldrh	r2, [r1, #6]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005584:	b29b      	uxth	r3, r3

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8005586:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800558a:	b530      	push	{r4, r5, lr}
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800558c:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800558e:	460d      	mov	r5, r1
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8005590:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8005592:	8983      	ldrh	r3, [r0, #12]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005594:	8909      	ldrh	r1, [r1, #8]
 8005596:	88aa      	ldrh	r2, [r5, #4]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8005598:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800559c:	430a      	orrs	r2, r1
 800559e:	8969      	ldrh	r1, [r5, #10]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 80055a0:	f023 030c 	bic.w	r3, r3, #12
 80055a4:	041b      	lsls	r3, r3, #16

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80055a6:	430a      	orrs	r2, r1

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 80055a8:	0c1b      	lsrs	r3, r3, #16

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80055aa:	b292      	uxth	r2, r2
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80055ac:	4313      	orrs	r3, r2
 80055ae:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80055b0:	8a83      	ldrh	r3, [r0, #20]
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80055b2:	89aa      	ldrh	r2, [r5, #12]

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80055b4:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80055b6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 80055ba:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80055bc:	b085      	sub	sp, #20
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 80055be:	8283      	strh	r3, [r0, #20]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80055c0:	4604      	mov	r4, r0
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 80055c2:	4668      	mov	r0, sp
 80055c4:	f7fe f82e 	bl	8003624 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 80055c8:	4b19      	ldr	r3, [pc, #100]	; (8005630 <USART_Init+0xb0>)
 80055ca:	429c      	cmp	r4, r3
 80055cc:	d003      	beq.n	80055d6 <USART_Init+0x56>
 80055ce:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80055d2:	429c      	cmp	r4, r3
 80055d4:	d101      	bne.n	80055da <USART_Init+0x5a>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 80055d6:	9b03      	ldr	r3, [sp, #12]
 80055d8:	e000      	b.n	80055dc <USART_Init+0x5c>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 80055da:	9b02      	ldr	r3, [sp, #8]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80055dc:	89a2      	ldrh	r2, [r4, #12]
 80055de:	b212      	sxth	r2, r2
 80055e0:	2a00      	cmp	r2, #0
 80055e2:	f04f 0119 	mov.w	r1, #25
 80055e6:	682a      	ldr	r2, [r5, #0]
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 80055e8:	fb01 f103 	mul.w	r1, r1, r3
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80055ec:	da01      	bge.n	80055f2 <USART_Init+0x72>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 80055ee:	0052      	lsls	r2, r2, #1
 80055f0:	e000      	b.n	80055f4 <USART_Init+0x74>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 80055f2:	0092      	lsls	r2, r2, #2
  }
  tmpreg = (integerdivider / 100) << 4;
 80055f4:	2364      	movs	r3, #100	; 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 80055f6:	fbb1 f1f2 	udiv	r1, r1, r2
  }
  tmpreg = (integerdivider / 100) << 4;
 80055fa:	fbb1 f2f3 	udiv	r2, r1, r3
 80055fe:	0112      	lsls	r2, r2, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8005600:	0910      	lsrs	r0, r2, #4
 8005602:	fb03 1110 	mls	r1, r3, r0, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8005606:	89a0      	ldrh	r0, [r4, #12]
 8005608:	b200      	sxth	r0, r0
 800560a:	2800      	cmp	r0, #0
 800560c:	da06      	bge.n	800561c <USART_Init+0x9c>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 800560e:	00c9      	lsls	r1, r1, #3
 8005610:	3132      	adds	r1, #50	; 0x32
 8005612:	fbb1 f3f3 	udiv	r3, r1, r3
 8005616:	f003 0307 	and.w	r3, r3, #7
 800561a:	e005      	b.n	8005628 <USART_Init+0xa8>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 800561c:	0109      	lsls	r1, r1, #4
 800561e:	3132      	adds	r1, #50	; 0x32
 8005620:	fbb1 f3f3 	udiv	r3, r1, r3
 8005624:	f003 030f 	and.w	r3, r3, #15
 8005628:	431a      	orrs	r2, r3
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 800562a:	8122      	strh	r2, [r4, #8]
}
 800562c:	b005      	add	sp, #20
 800562e:	bd30      	pop	{r4, r5, pc}
 8005630:	40011000 	.word	0x40011000

08005634 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8005634:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8005638:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800563a:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 800563c:	2300      	movs	r3, #0
 800563e:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 8005640:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 8005642:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005644:	8142      	strh	r2, [r0, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8005646:	8183      	strh	r3, [r0, #12]
 8005648:	4770      	bx	lr

0800564a <USART_ClockInit>:
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 800564a:	880b      	ldrh	r3, [r1, #0]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800564c:	8a02      	ldrh	r2, [r0, #16]
  *         contains the configuration information for the specified  USART peripheral.
  * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 800564e:	b510      	push	{r4, lr}
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005650:	884c      	ldrh	r4, [r1, #2]
 8005652:	4323      	orrs	r3, r4
 8005654:	888c      	ldrh	r4, [r1, #4]
 8005656:	88c9      	ldrh	r1, [r1, #6]
 8005658:	4323      	orrs	r3, r4
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800565a:	b292      	uxth	r2, r2
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 800565c:	430b      	orrs	r3, r1
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 800565e:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8005662:	b29b      	uxth	r3, r3
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8005664:	4313      	orrs	r3, r2
 8005666:	8203      	strh	r3, [r0, #16]
 8005668:	bd10      	pop	{r4, pc}

0800566a <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 800566a:	2300      	movs	r3, #0
 800566c:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 800566e:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8005670:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8005672:	80c3      	strh	r3, [r0, #6]
 8005674:	4770      	bx	lr

08005676 <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8005676:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005678:	b119      	cbz	r1, 8005682 <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 800567a:	b29b      	uxth	r3, r3
 800567c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005680:	e003      	b.n	800568a <USART_Cmd+0x14>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8005682:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005686:	041b      	lsls	r3, r3, #16
 8005688:	0c1b      	lsrs	r3, r3, #16
 800568a:	8183      	strh	r3, [r0, #12]
 800568c:	4770      	bx	lr

0800568e <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 800568e:	8b03      	ldrh	r3, [r0, #24]
 8005690:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005694:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8005696:	8b03      	ldrh	r3, [r0, #24]
 8005698:	b29b      	uxth	r3, r3
 800569a:	4319      	orrs	r1, r3
 800569c:	8301      	strh	r1, [r0, #24]
 800569e:	4770      	bx	lr

080056a0 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 80056a0:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80056a2:	b121      	cbz	r1, 80056ae <USART_OverSampling8Cmd+0xe>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 80056a4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80056a8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80056ac:	e001      	b.n	80056b2 <USART_OverSampling8Cmd+0x12>
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 80056ae:	045b      	lsls	r3, r3, #17
 80056b0:	0c5b      	lsrs	r3, r3, #17
 80056b2:	8183      	strh	r3, [r0, #12]
 80056b4:	4770      	bx	lr

080056b6 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80056b6:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80056b8:	b119      	cbz	r1, 80056c2 <USART_OneBitMethodCmd+0xc>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80056ba:	b29b      	uxth	r3, r3
 80056bc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80056c0:	e003      	b.n	80056ca <USART_OneBitMethodCmd+0x14>
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 80056c2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80056c6:	041b      	lsls	r3, r3, #16
 80056c8:	0c1b      	lsrs	r3, r3, #16
 80056ca:	8283      	strh	r3, [r0, #20]
 80056cc:	4770      	bx	lr

080056ce <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 80056ce:	05c9      	lsls	r1, r1, #23
 80056d0:	0dc9      	lsrs	r1, r1, #23
 80056d2:	8081      	strh	r1, [r0, #4]
 80056d4:	4770      	bx	lr

080056d6 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 80056d6:	8880      	ldrh	r0, [r0, #4]
 80056d8:	05c0      	lsls	r0, r0, #23
}
 80056da:	0dc0      	lsrs	r0, r0, #23
 80056dc:	4770      	bx	lr

080056de <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 80056de:	8a03      	ldrh	r3, [r0, #16]
 80056e0:	f023 030f 	bic.w	r3, r3, #15
 80056e4:	041b      	lsls	r3, r3, #16
 80056e6:	0c1b      	lsrs	r3, r3, #16
 80056e8:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 80056ea:	8a03      	ldrh	r3, [r0, #16]
 80056ec:	b29b      	uxth	r3, r3
 80056ee:	4319      	orrs	r1, r3
 80056f0:	8201      	strh	r1, [r0, #16]
 80056f2:	4770      	bx	lr

080056f4 <USART_ReceiverWakeUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_RWU;
 80056f4:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 80056f6:	b119      	cbz	r1, 8005700 <USART_ReceiverWakeUpCmd+0xc>
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_RWU;
 80056f8:	b29b      	uxth	r3, r3
 80056fa:	f043 0302 	orr.w	r3, r3, #2
 80056fe:	e003      	b.n	8005708 <USART_ReceiverWakeUpCmd+0x14>
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 8005700:	f023 0302 	bic.w	r3, r3, #2
 8005704:	041b      	lsls	r3, r3, #16
 8005706:	0c1b      	lsrs	r3, r3, #16
 8005708:	8183      	strh	r3, [r0, #12]
 800570a:	4770      	bx	lr

0800570c <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 800570c:	8983      	ldrh	r3, [r0, #12]
 800570e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005712:	041b      	lsls	r3, r3, #16
 8005714:	0c1b      	lsrs	r3, r3, #16
 8005716:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 8005718:	8983      	ldrh	r3, [r0, #12]
 800571a:	b29b      	uxth	r3, r3
 800571c:	4319      	orrs	r1, r3
 800571e:	8181      	strh	r1, [r0, #12]
 8005720:	4770      	bx	lr

08005722 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 8005722:	8a03      	ldrh	r3, [r0, #16]
 8005724:	f023 0320 	bic.w	r3, r3, #32
 8005728:	041b      	lsls	r3, r3, #16
 800572a:	0c1b      	lsrs	r3, r3, #16
 800572c:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 800572e:	8a03      	ldrh	r3, [r0, #16]
 8005730:	b29b      	uxth	r3, r3
 8005732:	4319      	orrs	r1, r3
 8005734:	8201      	strh	r1, [r0, #16]
 8005736:	4770      	bx	lr

08005738 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 8005738:	8a03      	ldrh	r3, [r0, #16]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800573a:	b119      	cbz	r1, 8005744 <USART_LINCmd+0xc>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 800573c:	b29b      	uxth	r3, r3
 800573e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005742:	e003      	b.n	800574c <USART_LINCmd+0x14>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 8005744:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005748:	041b      	lsls	r3, r3, #16
 800574a:	0c1b      	lsrs	r3, r3, #16
 800574c:	8203      	strh	r3, [r0, #16]
 800574e:	4770      	bx	lr

08005750 <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= USART_CR1_SBK;
 8005750:	8983      	ldrh	r3, [r0, #12]
 8005752:	b29b      	uxth	r3, r3
 8005754:	f043 0301 	orr.w	r3, r3, #1
 8005758:	8183      	strh	r3, [r0, #12]
 800575a:	4770      	bx	lr

0800575c <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 800575c:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800575e:	b119      	cbz	r1, 8005768 <USART_HalfDuplexCmd+0xc>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 8005760:	b29b      	uxth	r3, r3
 8005762:	f043 0308 	orr.w	r3, r3, #8
 8005766:	e003      	b.n	8005770 <USART_HalfDuplexCmd+0x14>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 8005768:	f023 0308 	bic.w	r3, r3, #8
 800576c:	041b      	lsls	r3, r3, #16
 800576e:	0c1b      	lsrs	r3, r3, #16
 8005770:	8283      	strh	r3, [r0, #20]
 8005772:	4770      	bx	lr

08005774 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 8005774:	8b03      	ldrh	r3, [r0, #24]
 8005776:	b2db      	uxtb	r3, r3
 8005778:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 800577a:	8b03      	ldrh	r3, [r0, #24]
 800577c:	b29b      	uxth	r3, r3
 800577e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005782:	8301      	strh	r1, [r0, #24]
 8005784:	4770      	bx	lr

08005786 <USART_SmartCardCmd>:
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8005786:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005788:	b119      	cbz	r1, 8005792 <USART_SmartCardCmd+0xc>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 800578a:	b29b      	uxth	r3, r3
 800578c:	f043 0320 	orr.w	r3, r3, #32
 8005790:	e003      	b.n	800579a <USART_SmartCardCmd+0x14>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 8005792:	f023 0320 	bic.w	r3, r3, #32
 8005796:	041b      	lsls	r3, r3, #16
 8005798:	0c1b      	lsrs	r3, r3, #16
 800579a:	8283      	strh	r3, [r0, #20]
 800579c:	4770      	bx	lr

0800579e <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 800579e:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80057a0:	b119      	cbz	r1, 80057aa <USART_SmartCardNACKCmd+0xc>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 80057a2:	b29b      	uxth	r3, r3
 80057a4:	f043 0310 	orr.w	r3, r3, #16
 80057a8:	e003      	b.n	80057b2 <USART_SmartCardNACKCmd+0x14>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 80057aa:	f023 0310 	bic.w	r3, r3, #16
 80057ae:	041b      	lsls	r3, r3, #16
 80057b0:	0c1b      	lsrs	r3, r3, #16
 80057b2:	8283      	strh	r3, [r0, #20]
 80057b4:	4770      	bx	lr

080057b6 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 80057b6:	8a83      	ldrh	r3, [r0, #20]
 80057b8:	f023 0304 	bic.w	r3, r3, #4
 80057bc:	041b      	lsls	r3, r3, #16
 80057be:	0c1b      	lsrs	r3, r3, #16
 80057c0:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 80057c2:	8a83      	ldrh	r3, [r0, #20]
 80057c4:	b29b      	uxth	r3, r3
 80057c6:	4319      	orrs	r1, r3
 80057c8:	8281      	strh	r1, [r0, #20]
 80057ca:	4770      	bx	lr

080057cc <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 80057cc:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 80057ce:	b119      	cbz	r1, 80057d8 <USART_IrDACmd+0xc>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 80057d0:	b29b      	uxth	r3, r3
 80057d2:	f043 0302 	orr.w	r3, r3, #2
 80057d6:	e003      	b.n	80057e0 <USART_IrDACmd+0x14>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 80057d8:	f023 0302 	bic.w	r3, r3, #2
 80057dc:	041b      	lsls	r3, r3, #16
 80057de:	0c1b      	lsrs	r3, r3, #16
 80057e0:	8283      	strh	r3, [r0, #20]
 80057e2:	4770      	bx	lr

080057e4 <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80057e4:	8a83      	ldrh	r3, [r0, #20]
 80057e6:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80057e8:	b10a      	cbz	r2, 80057ee <USART_DMACmd+0xa>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80057ea:	4319      	orrs	r1, r3
 80057ec:	e001      	b.n	80057f2 <USART_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 80057ee:	ea23 0101 	bic.w	r1, r3, r1
 80057f2:	8281      	strh	r1, [r0, #20]
 80057f4:	4770      	bx	lr

080057f6 <USART_ITConfig>:
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80057f6:	f3c1 1342 	ubfx	r3, r1, #5, #3
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 80057fa:	b510      	push	{r4, lr}
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80057fc:	2401      	movs	r4, #1
 80057fe:	f001 011f 	and.w	r1, r1, #31
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8005802:	42a3      	cmp	r3, r4
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 8005804:	fa04 f101 	lsl.w	r1, r4, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8005808:	d101      	bne.n	800580e <USART_ITConfig+0x18>
  {
    usartxbase += 0x0C;
 800580a:	300c      	adds	r0, #12
 800580c:	e004      	b.n	8005818 <USART_ITConfig+0x22>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 800580e:	2b02      	cmp	r3, #2
 8005810:	d101      	bne.n	8005816 <USART_ITConfig+0x20>
  {
    usartxbase += 0x10;
 8005812:	3010      	adds	r0, #16
 8005814:	e000      	b.n	8005818 <USART_ITConfig+0x22>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8005816:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8005818:	6803      	ldr	r3, [r0, #0]
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
 800581a:	b10a      	cbz	r2, 8005820 <USART_ITConfig+0x2a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800581c:	4319      	orrs	r1, r3
 800581e:	e001      	b.n	8005824 <USART_ITConfig+0x2e>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8005820:	ea23 0101 	bic.w	r1, r3, r1
 8005824:	6001      	str	r1, [r0, #0]
 8005826:	bd10      	pop	{r4, pc}

08005828 <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8005828:	8803      	ldrh	r3, [r0, #0]
 800582a:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800582c:	bf0c      	ite	eq
 800582e:	2000      	moveq	r0, #0
 8005830:	2001      	movne	r0, #1
 8005832:	4770      	bx	lr

08005834 <USART_ClearFlag>:
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
       
  USARTx->SR = (uint16_t)~USART_FLAG;
 8005834:	43c9      	mvns	r1, r1
 8005836:	8001      	strh	r1, [r0, #0]
 8005838:	4770      	bx	lr

0800583a <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 800583a:	b510      	push	{r4, lr}
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 800583c:	f3c1 1442 	ubfx	r4, r1, #5, #3
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8005840:	2201      	movs	r2, #1
 8005842:	f001 031f 	and.w	r3, r1, #31
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8005846:	2c01      	cmp	r4, #1
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8005848:	fa02 f203 	lsl.w	r2, r2, r3
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 800584c:	d101      	bne.n	8005852 <USART_GetITStatus+0x18>
  {
    itmask &= USARTx->CR1;
 800584e:	8983      	ldrh	r3, [r0, #12]
 8005850:	e003      	b.n	800585a <USART_GetITStatus+0x20>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8005852:	2c02      	cmp	r4, #2
  {
    itmask &= USARTx->CR2;
 8005854:	bf0c      	ite	eq
 8005856:	8a03      	ldrheq	r3, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8005858:	8a83      	ldrhne	r3, [r0, #20]
 800585a:	b29b      	uxth	r3, r3
 800585c:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
 800585e:	8802      	ldrh	r2, [r0, #0]
 8005860:	b292      	uxth	r2, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005862:	b143      	cbz	r3, 8005876 <USART_GetITStatus+0x3c>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
 8005864:	2301      	movs	r3, #1
 8005866:	0a09      	lsrs	r1, r1, #8
 8005868:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 800586c:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 800586e:	bf0c      	ite	eq
 8005870:	2000      	moveq	r0, #0
 8005872:	2001      	movne	r0, #1
 8005874:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 8005876:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8005878:	bd10      	pop	{r4, pc}

0800587a <USART_ClearITPendingBit>:
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 800587a:	0a09      	lsrs	r1, r1, #8
 800587c:	2301      	movs	r3, #1
 800587e:	fa03 f301 	lsl.w	r3, r3, r1
  USARTx->SR = (uint16_t)~itmask;
 8005882:	43db      	mvns	r3, r3
 8005884:	8003      	strh	r3, [r0, #0]
 8005886:	4770      	bx	lr

08005888 <WWDG_DeInit>:
  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
 8005888:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
 800588a:	2101      	movs	r1, #1
 800588c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005890:	f7fd ff98 	bl	80037c4 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 8005894:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005898:	2100      	movs	r1, #0
}
 800589a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void WWDG_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 800589e:	f7fd bf91 	b.w	80037c4 <RCC_APB1PeriphResetCmd>

080058a2 <WWDG_SetPrescaler>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
  /* Clear WDGTB[1:0] bits */
  tmpreg = WWDG->CFR & CFR_WDGTB_MASK;
 80058a2:	4b03      	ldr	r3, [pc, #12]	; (80058b0 <WWDG_SetPrescaler+0xe>)
 80058a4:	685a      	ldr	r2, [r3, #4]
 80058a6:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
  tmpreg |= WWDG_Prescaler;
 80058aa:	4310      	orrs	r0, r2
  /* Store the new value */
  WWDG->CFR = tmpreg;
 80058ac:	6058      	str	r0, [r3, #4]
 80058ae:	4770      	bx	lr
 80058b0:	40002c00 	.word	0x40002c00

080058b4 <WWDG_SetWindowValue>:
  * @param  WindowValue: specifies the window value to be compared to the downcounter.
  *   This parameter value must be lower than 0x80.
  * @retval None
  */
void WWDG_SetWindowValue(uint8_t WindowValue)
{
 80058b4:	b082      	sub	sp, #8
  __IO uint32_t tmpreg = 0;
 80058b6:	2300      	movs	r3, #0
 80058b8:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_MASK;
 80058ba:	4b07      	ldr	r3, [pc, #28]	; (80058d8 <WWDG_SetWindowValue+0x24>)
 80058bc:	685a      	ldr	r2, [r3, #4]
 80058be:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 80058c2:	9201      	str	r2, [sp, #4]

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_MASK;
 80058c4:	9a01      	ldr	r2, [sp, #4]
 80058c6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80058ca:	4302      	orrs	r2, r0
 80058cc:	9201      	str	r2, [sp, #4]

  /* Store the new value */
  WWDG->CFR = tmpreg;
 80058ce:	9a01      	ldr	r2, [sp, #4]
 80058d0:	605a      	str	r2, [r3, #4]
}
 80058d2:	b002      	add	sp, #8
 80058d4:	4770      	bx	lr
 80058d6:	bf00      	nop
 80058d8:	40002c00 	.word	0x40002c00

080058dc <WWDG_EnableIT>:
  * @param  None
  * @retval None
  */
void WWDG_EnableIT(void)
{
  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
 80058dc:	4b01      	ldr	r3, [pc, #4]	; (80058e4 <WWDG_EnableIT+0x8>)
 80058de:	2201      	movs	r2, #1
 80058e0:	601a      	str	r2, [r3, #0]
 80058e2:	4770      	bx	lr
 80058e4:	420580a4 	.word	0x420580a4

080058e8 <WWDG_SetCounter>:
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  /* Write to T[6:0] bits to configure the counter value, no need to do
     a read-modify-write; writing a 0 to WDGA bit does nothing */
  WWDG->CR = Counter & BIT_MASK;
 80058e8:	4b02      	ldr	r3, [pc, #8]	; (80058f4 <WWDG_SetCounter+0xc>)
 80058ea:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80058ee:	6018      	str	r0, [r3, #0]
 80058f0:	4770      	bx	lr
 80058f2:	bf00      	nop
 80058f4:	40002c00 	.word	0x40002c00

080058f8 <WWDG_Enable>:
  */
void WWDG_Enable(uint8_t Counter)
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  WWDG->CR = WWDG_CR_WDGA | Counter;
 80058f8:	4b02      	ldr	r3, [pc, #8]	; (8005904 <WWDG_Enable+0xc>)
 80058fa:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80058fe:	6018      	str	r0, [r3, #0]
 8005900:	4770      	bx	lr
 8005902:	bf00      	nop
 8005904:	40002c00 	.word	0x40002c00

08005908 <WWDG_GetFlagStatus>:
  */
FlagStatus WWDG_GetFlagStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((WWDG->SR) != (uint32_t)RESET)
 8005908:	4b02      	ldr	r3, [pc, #8]	; (8005914 <WWDG_GetFlagStatus+0xc>)
 800590a:	6898      	ldr	r0, [r3, #8]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800590c:	3000      	adds	r0, #0
 800590e:	bf18      	it	ne
 8005910:	2001      	movne	r0, #1
 8005912:	4770      	bx	lr
 8005914:	40002c00 	.word	0x40002c00

08005918 <WWDG_ClearFlag>:
  * @param  None
  * @retval None
  */
void WWDG_ClearFlag(void)
{
  WWDG->SR = (uint32_t)RESET;
 8005918:	4b01      	ldr	r3, [pc, #4]	; (8005920 <WWDG_ClearFlag+0x8>)
 800591a:	2200      	movs	r2, #0
 800591c:	609a      	str	r2, [r3, #8]
 800591e:	4770      	bx	lr
 8005920:	40002c00 	.word	0x40002c00

08005924 <ADC3_CH12_DMA_Config>:
  * @brief  ADC3 channel12 with DMA configuration
  * @param  None
  * @retval None
  */
void ADC3_CH12_DMA_Config(void)
{
 8005924:	b570      	push	{r4, r5, r6, lr}
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  DMA_InitTypeDef       DMA_InitStructure;
  GPIO_InitTypeDef      GPIO_InitStructure;

  /* Enable ADC3, DMA2 and GPIO clocks ****************************************/
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
 8005926:	2101      	movs	r1, #1
  * @brief  ADC3 channel12 with DMA configuration
  * @param  None
  * @retval None
  */
void ADC3_CH12_DMA_Config(void)
{
 8005928:	b09c      	sub	sp, #112	; 0x70
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  DMA_InitTypeDef       DMA_InitStructure;
  GPIO_InitTypeDef      GPIO_InitStructure;

  /* Enable ADC3, DMA2 and GPIO clocks ****************************************/
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
 800592a:	4831      	ldr	r0, [pc, #196]	; (80059f0 <ADC3_CH12_DMA_Config+0xcc>)
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 800592c:	4e31      	ldr	r6, [pc, #196]	; (80059f4 <ADC3_CH12_DMA_Config+0xd0>)
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  DMA_InitTypeDef       DMA_InitStructure;
  GPIO_InitTypeDef      GPIO_InitStructure;

  /* Enable ADC3, DMA2 and GPIO clocks ****************************************/
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
 800592e:	f7fd fee9 	bl	8003704 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
 8005932:	2101      	movs	r1, #1
 8005934:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005938:	f7fd ff14 	bl	8003764 <RCC_APB2PeriphClockCmd>

  /* DMA2 Stream0 channel0 configuration **************************************/
  DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
 800593c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8005940:	930d      	str	r3, [sp, #52]	; 0x34
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
 8005942:	4b2d      	ldr	r3, [pc, #180]	; (80059f8 <ADC3_CH12_DMA_Config+0xd4>)
 8005944:	930e      	str	r3, [sp, #56]	; 0x38
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
 8005946:	4b2d      	ldr	r3, [pc, #180]	; (80059fc <ADC3_CH12_DMA_Config+0xd8>)
 8005948:	930f      	str	r3, [sp, #60]	; 0x3c
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
  DMA_InitStructure.DMA_BufferSize = 1;
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 800594a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800594e:	9314      	str	r3, [sp, #80]	; 0x50
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 8005950:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005954:	9315      	str	r3, [sp, #84]	; 0x54
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8005956:	f44f 7380 	mov.w	r3, #256	; 0x100

  /* DMA2 Stream0 channel0 configuration **************************************/
  DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 800595a:	2400      	movs	r4, #0
  DMA_InitStructure.DMA_BufferSize = 1;
 800595c:	2501      	movs	r5, #1
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800595e:	9316      	str	r3, [sp, #88]	; 0x58
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 8005960:	4630      	mov	r0, r6
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8005962:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 8005966:	a90d      	add	r1, sp, #52	; 0x34
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8005968:	9317      	str	r3, [sp, #92]	; 0x5c

  /* DMA2 Stream0 channel0 configuration **************************************/
  DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 800596a:	9410      	str	r4, [sp, #64]	; 0x40
  DMA_InitStructure.DMA_BufferSize = 1;
 800596c:	9511      	str	r5, [sp, #68]	; 0x44
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800596e:	9412      	str	r4, [sp, #72]	; 0x48
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
 8005970:	9413      	str	r4, [sp, #76]	; 0x4c
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
 8005972:	9418      	str	r4, [sp, #96]	; 0x60
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
 8005974:	9519      	str	r5, [sp, #100]	; 0x64
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8005976:	941a      	str	r4, [sp, #104]	; 0x68
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8005978:	941b      	str	r4, [sp, #108]	; 0x6c
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 800597a:	f7fc f9b3 	bl	8001ce4 <DMA_Init>
  DMA_Cmd(DMA2_Stream0, ENABLE);
 800597e:	4630      	mov	r0, r6
 8005980:	4629      	mov	r1, r5
 8005982:	f7fc f9ea 	bl	8001d5a <DMA_Cmd>

  /* Configure ADC3 Channel12 pin as analog input ******************************/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8005986:	2304      	movs	r3, #4
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 1;
  ADC_Init(ADC3, &ADC_InitStructure);
 8005988:	4e1d      	ldr	r6, [pc, #116]	; (8005a00 <ADC3_CH12_DMA_Config+0xdc>)
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
  DMA_Cmd(DMA2_Stream0, ENABLE);

  /* Configure ADC3 Channel12 pin as analog input ******************************/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 800598a:	9301      	str	r3, [sp, #4]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800598c:	a901      	add	r1, sp, #4
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
  DMA_Cmd(DMA2_Stream0, ENABLE);

  /* Configure ADC3 Channel12 pin as analog input ******************************/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800598e:	2303      	movs	r3, #3
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005990:	481c      	ldr	r0, [pc, #112]	; (8005a04 <ADC3_CH12_DMA_Config+0xe0>)
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
  DMA_Cmd(DMA2_Stream0, ENABLE);

  /* Configure ADC3 Channel12 pin as analog input ******************************/
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8005992:	f88d 3008 	strb.w	r3, [sp, #8]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8005996:	f88d 400b 	strb.w	r4, [sp, #11]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800599a:	f7fc ffbb 	bl	8002914 <GPIO_Init>
  /* ADC Common Init **********************************************************/
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
  ADC_CommonInit(&ADC_CommonInitStructure);
 800599e:	a803      	add	r0, sp, #12
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  /* ADC Common Init **********************************************************/
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 80059a0:	9403      	str	r4, [sp, #12]
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 80059a2:	9404      	str	r4, [sp, #16]
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 80059a4:	9405      	str	r4, [sp, #20]
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 80059a6:	9406      	str	r4, [sp, #24]
  ADC_CommonInit(&ADC_CommonInitStructure);
 80059a8:	f7fa fc8a 	bl	80002c0 <ADC_CommonInit>
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 1;
  ADC_Init(ADC3, &ADC_InitStructure);
 80059ac:	4630      	mov	r0, r6
 80059ae:	a907      	add	r1, sp, #28
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
  ADC_CommonInit(&ADC_CommonInitStructure);

  /* ADC3 Init ****************************************************************/
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 80059b0:	9407      	str	r4, [sp, #28]
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 80059b2:	f88d 4020 	strb.w	r4, [sp, #32]
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 80059b6:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 80059ba:	9409      	str	r4, [sp, #36]	; 0x24
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 80059bc:	940b      	str	r4, [sp, #44]	; 0x2c
  ADC_InitStructure.ADC_NbrOfConversion = 1;
 80059be:	f88d 5030 	strb.w	r5, [sp, #48]	; 0x30
  ADC_Init(ADC3, &ADC_InitStructure);
 80059c2:	f7fa fc4e 	bl	8000262 <ADC_Init>

  /* ADC3 regular channel12 configuration *************************************/
  ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 1, ADC_SampleTime_3Cycles);
 80059c6:	462a      	mov	r2, r5
 80059c8:	4623      	mov	r3, r4
 80059ca:	4630      	mov	r0, r6
 80059cc:	210c      	movs	r1, #12
 80059ce:	f7fa fcc3 	bl	8000358 <ADC_RegularChannelConfig>

 /* Enable DMA request after last transfer (Single-ADC mode) */
  ADC_DMARequestAfterLastTransferCmd(ADC3, ENABLE);
 80059d2:	4630      	mov	r0, r6
 80059d4:	4629      	mov	r1, r5
 80059d6:	f7fa fd4e 	bl	8000476 <ADC_DMARequestAfterLastTransferCmd>

  /* Enable ADC3 DMA */
  ADC_DMACmd(ADC3, ENABLE);
 80059da:	4630      	mov	r0, r6
 80059dc:	4629      	mov	r1, r5
 80059de:	f7fa fd41 	bl	8000464 <ADC_DMACmd>

  /* Enable ADC3 */
  ADC_Cmd(ADC3, ENABLE);
 80059e2:	4630      	mov	r0, r6
 80059e4:	4629      	mov	r1, r5
 80059e6:	f7fa fc85 	bl	80002f4 <ADC_Cmd>
}
 80059ea:	b01c      	add	sp, #112	; 0x70
 80059ec:	bd70      	pop	{r4, r5, r6, pc}
 80059ee:	bf00      	nop
 80059f0:	00400004 	.word	0x00400004
 80059f4:	40026410 	.word	0x40026410
 80059f8:	4001224c 	.word	0x4001224c
 80059fc:	20000640 	.word	0x20000640
 8005a00:	40012200 	.word	0x40012200
 8005a04:	40020800 	.word	0x40020800

08005a08 <TIM2_timer_start>:
/**
 * @brief  millisecond
 * @param  none
 * @retval None
 */
void TIM2_timer_start(void) {
 8005a08:	b530      	push	{r4, r5, lr}
 8005a0a:	b089      	sub	sp, #36	; 0x24
	// TIM_TimeBaseInitTypeDef's order is {uint16_t TIM_Prescaler, uint16_t TIM_CounterMode, uint16_t TIM_Period, uint16_t TIM_ClockDivision, uint8_t TIM_RepetitionCounter}
	TIM_TimeBaseInitTypeDef TimeBaseStructure;
//			= { 84, TIM_CounterMode_Up, 999, TIM_CKD_DIV1, 0 };

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);
 8005a0c:	a804      	add	r0, sp, #16
 8005a0e:	f7fd fe09 	bl	8003624 <RCC_GetClocksFreq>
	TimeBaseStructure.TIM_Prescaler = (RCC_Clocks.SYSCLK_Frequency>>1)/1000000L ;
 8005a12:	9b04      	ldr	r3, [sp, #16]
 8005a14:	4a1d      	ldr	r2, [pc, #116]	; (8005a8c <TIM2_timer_start+0x84>)
 8005a16:	085b      	lsrs	r3, r3, #1
 8005a18:	fbb3 f3f2 	udiv	r3, r3, r2
	TimeBaseStructure.TIM_Period = 1000 - 1;
	TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TimeBaseStructure.TIM_RepetitionCounter = 0;

	//Supply APB1 Clock
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 8005a1c:	2001      	movs	r0, #1
//			= { 84, TIM_CounterMode_Up, 999, TIM_CKD_DIV1, 0 };

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);
	TimeBaseStructure.TIM_Prescaler = (RCC_Clocks.SYSCLK_Frequency>>1)/1000000L ;
	TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8005a1e:	2400      	movs	r4, #0
	TimeBaseStructure.TIM_Period = 1000 - 1;
	TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TimeBaseStructure.TIM_RepetitionCounter = 0;

	//Supply APB1 Clock
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 8005a20:	4601      	mov	r1, r0
	TIM_TimeBaseInitTypeDef TimeBaseStructure;
//			= { 84, TIM_CounterMode_Up, 999, TIM_CKD_DIV1, 0 };

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);
	TimeBaseStructure.TIM_Prescaler = (RCC_Clocks.SYSCLK_Frequency>>1)/1000000L ;
 8005a22:	f8ad 3004 	strh.w	r3, [sp, #4]
	TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TimeBaseStructure.TIM_Period = 1000 - 1;
 8005a26:	f240 33e7 	movw	r3, #999	; 0x3e7
 8005a2a:	9302      	str	r3, [sp, #8]
//			= { 84, TIM_CounterMode_Up, 999, TIM_CKD_DIV1, 0 };

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);
	TimeBaseStructure.TIM_Prescaler = (RCC_Clocks.SYSCLK_Frequency>>1)/1000000L ;
	TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8005a2c:	f8ad 4006 	strh.w	r4, [sp, #6]
	TimeBaseStructure.TIM_Period = 1000 - 1;
	TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8005a30:	f8ad 400c 	strh.w	r4, [sp, #12]
	TimeBaseStructure.TIM_RepetitionCounter = 0;
 8005a34:	f88d 400e 	strb.w	r4, [sp, #14]

	//Supply APB1 Clock
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 8005a38:	f7fd fe88 	bl	800374c <RCC_APB1PeriphClockCmd>

	/* Time base configuration */
	TIM_TimeBaseInit(TIM2, &TimeBaseStructure);
 8005a3c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005a40:	a901      	add	r1, sp, #4
 8005a42:	f7ff f8b3 	bl	8004bac <TIM_TimeBaseInit>
//  TIM_SelectOnePulseMode(TIM2, TIM_OPMode_Repetitive);
	TIM_SetCounter(TIM2, 0);
 8005a46:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005a4a:	4621      	mov	r1, r4
 8005a4c:	f7ff f900 	bl	8004c50 <TIM_SetCounter>
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
 8005a50:	2101      	movs	r1, #1
 8005a52:	460a      	mov	r2, r1
 8005a54:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005a58:	f7ff fc5f 	bl	800531a <TIM_ITConfig>

	NVIC_InitTypeDef NVIC_InitStructure;
	/* Enable the TIM2 gloabal Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8005a5c:	2501      	movs	r5, #1
	TIM_SetCounter(TIM2, 0);
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	NVIC_InitTypeDef NVIC_InitStructure;
	/* Enable the TIM2 gloabal Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
 8005a5e:	231c      	movs	r3, #28
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8005a60:	4668      	mov	r0, sp
	TIM_SetCounter(TIM2, 0);
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	NVIC_InitTypeDef NVIC_InitStructure;
	/* Enable the TIM2 gloabal Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
 8005a62:	f88d 3000 	strb.w	r3, [sp]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8005a66:	f88d 4001 	strb.w	r4, [sp, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8005a6a:	f88d 5002 	strb.w	r5, [sp, #2]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005a6e:	f88d 5003 	strb.w	r5, [sp, #3]
	NVIC_Init(&NVIC_InitStructure);
 8005a72:	f7fa fb93 	bl	800019c <NVIC_Init>

	/* TIM enable counter */
	TIM_Cmd(TIM2, ENABLE);
 8005a76:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005a7a:	4629      	mov	r1, r5
 8005a7c:	f7ff f92b 	bl	8004cd6 <TIM_Cmd>

	__counter_micros = 0;
 8005a80:	4b03      	ldr	r3, [pc, #12]	; (8005a90 <TIM2_timer_start+0x88>)
 8005a82:	601c      	str	r4, [r3, #0]
	__counter_millis = 0;
 8005a84:	4b03      	ldr	r3, [pc, #12]	; (8005a94 <TIM2_timer_start+0x8c>)
 8005a86:	601c      	str	r4, [r3, #0]
}
 8005a88:	b009      	add	sp, #36	; 0x24
 8005a8a:	bd30      	pop	{r4, r5, pc}
 8005a8c:	000f4240 	.word	0x000f4240
 8005a90:	2000068c 	.word	0x2000068c
 8005a94:	20000690 	.word	0x20000690

08005a98 <micros>:

uint32_t micros(void) {
	return __counter_micros + TIM_GetCounter(TIM2 );
 8005a98:	4b04      	ldr	r3, [pc, #16]	; (8005aac <micros+0x14>)

	__counter_micros = 0;
	__counter_millis = 0;
}

uint32_t micros(void) {
 8005a9a:	b510      	push	{r4, lr}
	return __counter_micros + TIM_GetCounter(TIM2 );
 8005a9c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005aa0:	681c      	ldr	r4, [r3, #0]
 8005aa2:	f7ff f8d9 	bl	8004c58 <TIM_GetCounter>
}
 8005aa6:	1900      	adds	r0, r0, r4
 8005aa8:	bd10      	pop	{r4, pc}
 8005aaa:	bf00      	nop
 8005aac:	2000068c 	.word	0x2000068c

08005ab0 <millis>:

uint32_t millis(void) {
	return __counter_millis;
 8005ab0:	4b01      	ldr	r3, [pc, #4]	; (8005ab8 <millis+0x8>)
 8005ab2:	6818      	ldr	r0, [r3, #0]
}
 8005ab4:	4770      	bx	lr
 8005ab6:	bf00      	nop
 8005ab8:	20000690 	.word	0x20000690

08005abc <delay_ms>:
uint32_t micros(void) {
	return __counter_micros + TIM_GetCounter(TIM2 );
}

uint32_t millis(void) {
	return __counter_millis;
 8005abc:	4b06      	ldr	r3, [pc, #24]	; (8005ad8 <delay_ms+0x1c>)
 8005abe:	681a      	ldr	r2, [r3, #0]
}

void delay_ms(uint32_t w) {
	uint32_t wtill = millis() + w;
 8005ac0:	1880      	adds	r0, r0, r2
uint32_t micros(void) {
	return __counter_micros + TIM_GetCounter(TIM2 );
}

uint32_t millis(void) {
	return __counter_millis;
 8005ac2:	681a      	ldr	r2, [r3, #0]
}

void delay_ms(uint32_t w) {
	uint32_t wtill = millis() + w;
	if ( wtill < millis() ) {
 8005ac4:	4290      	cmp	r0, r2
 8005ac6:	d202      	bcs.n	8005ace <delay_ms+0x12>
uint32_t micros(void) {
	return __counter_micros + TIM_GetCounter(TIM2 );
}

uint32_t millis(void) {
	return __counter_millis;
 8005ac8:	681a      	ldr	r2, [r3, #0]
}

void delay_ms(uint32_t w) {
	uint32_t wtill = millis() + w;
	if ( wtill < millis() ) {
		while ( millis() >= wtill );
 8005aca:	4282      	cmp	r2, r0
 8005acc:	d2fc      	bcs.n	8005ac8 <delay_ms+0xc>
uint32_t micros(void) {
	return __counter_micros + TIM_GetCounter(TIM2 );
}

uint32_t millis(void) {
	return __counter_millis;
 8005ace:	4a02      	ldr	r2, [pc, #8]	; (8005ad8 <delay_ms+0x1c>)
 8005ad0:	6813      	ldr	r3, [r2, #0]
void delay_ms(uint32_t w) {
	uint32_t wtill = millis() + w;
	if ( wtill < millis() ) {
		while ( millis() >= wtill );
	}
	while (millis() < wtill)
 8005ad2:	4283      	cmp	r3, r0
 8005ad4:	d3fc      	bcc.n	8005ad0 <delay_ms+0x14>
		;
}
 8005ad6:	4770      	bx	lr
 8005ad8:	20000690 	.word	0x20000690

08005adc <delay_us>:

void delay_us(uint32_t w) {
 8005adc:	b510      	push	{r4, lr}
 8005ade:	4604      	mov	r4, r0
	uint32_t wtill = micros() + w;
 8005ae0:	f7ff ffda 	bl	8005a98 <micros>
 8005ae4:	1904      	adds	r4, r0, r4
	if ( wtill < micros() ) {
 8005ae6:	f7ff ffd7 	bl	8005a98 <micros>
 8005aea:	4284      	cmp	r4, r0
 8005aec:	d203      	bcs.n	8005af6 <delay_us+0x1a>
		// overflow
		while ( micros() >= wtill );
 8005aee:	f7ff ffd3 	bl	8005a98 <micros>
 8005af2:	42a0      	cmp	r0, r4
 8005af4:	d2fb      	bcs.n	8005aee <delay_us+0x12>
	}
	while (micros() < wtill)
 8005af6:	f7ff ffcf 	bl	8005a98 <micros>
 8005afa:	42a0      	cmp	r0, r4
 8005afc:	d3fb      	bcc.n	8005af6 <delay_us+0x1a>
		;
}
 8005afe:	bd10      	pop	{r4, pc}

08005b00 <TIM2_IRQHandler>:

void TIM2_IRQHandler(void) {
 8005b00:	b508      	push	{r3, lr}
	if (TIM_GetITStatus(TIM2, TIM_IT_Update ) != RESET) {
 8005b02:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005b06:	2101      	movs	r1, #1
 8005b08:	f7ff fc1b 	bl	8005342 <TIM_GetITStatus>
 8005b0c:	b168      	cbz	r0, 8005b2a <TIM2_IRQHandler+0x2a>
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update );
 8005b0e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8005b12:	2101      	movs	r1, #1
 8005b14:	f7ff fc20 	bl	8005358 <TIM_ClearITPendingBit>
		__counter_micros += 1000;
 8005b18:	4b04      	ldr	r3, [pc, #16]	; (8005b2c <TIM2_IRQHandler+0x2c>)
 8005b1a:	681a      	ldr	r2, [r3, #0]
 8005b1c:	f502 727a 	add.w	r2, r2, #1000	; 0x3e8
 8005b20:	601a      	str	r2, [r3, #0]
		__counter_millis += 1;
 8005b22:	4b03      	ldr	r3, [pc, #12]	; (8005b30 <TIM2_IRQHandler+0x30>)
 8005b24:	681a      	ldr	r2, [r3, #0]
 8005b26:	3201      	adds	r2, #1
 8005b28:	601a      	str	r2, [r3, #0]
 8005b2a:	bd08      	pop	{r3, pc}
 8005b2c:	2000068c 	.word	0x2000068c
 8005b30:	20000690 	.word	0x20000690

08005b34 <PinPort>:
		GPIO_Pin_10, GPIO_Pin_11, GPIO_Pin_12, GPIO_Pin_13, GPIO_Pin_14,
		GPIO_Pin_15, GPIO_Pin_All };

GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}
 8005b34:	4b02      	ldr	r3, [pc, #8]	; (8005b40 <PinPort+0xc>)
		GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7, GPIO_Pin_8, GPIO_Pin_9,
		GPIO_Pin_10, GPIO_Pin_11, GPIO_Pin_12, GPIO_Pin_13, GPIO_Pin_14,
		GPIO_Pin_15, GPIO_Pin_All };

GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
 8005b36:	f3c0 2003 	ubfx	r0, r0, #8, #4
}
 8005b3a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8005b3e:	4770      	bx	lr
 8005b40:	20000010 	.word	0x20000010

08005b44 <PinBit>:

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005b44:	2301      	movs	r3, #1
 8005b46:	f000 000f 	and.w	r0, r0, #15
 8005b4a:	fa03 f000 	lsl.w	r0, r3, r0
}
 8005b4e:	b280      	uxth	r0, r0
 8005b50:	4770      	bx	lr

08005b52 <PinSource>:

uint8_t PinSource(GPIOPin portpin) {
	return portpin & 0x0f;
}
 8005b52:	f000 000f 	and.w	r0, r0, #15
 8005b56:	4770      	bx	lr

08005b58 <pinMode>:

void pinMode(GPIOPin portpin, GPIOMode_TypeDef mode) {
 8005b58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);
 8005b5a:	4c11      	ldr	r4, [pc, #68]	; (8005ba0 <pinMode+0x48>)
 8005b5c:	f3c0 2503 	ubfx	r5, r0, #8, #4
 8005b60:	eb04 0385 	add.w	r3, r4, r5, lsl #2

uint8_t PinSource(GPIOPin portpin) {
	return portpin & 0x0f;
}

void pinMode(GPIOPin portpin, GPIOMode_TypeDef mode) {
 8005b64:	460f      	mov	r7, r1
 8005b66:	4606      	mov	r6, r0

	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);
 8005b68:	2101      	movs	r1, #1
 8005b6a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8005b6c:	f7fd fdca 	bl	8003704 <RCC_AHB1PeriphClockCmd>
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005b70:	f006 060f 	and.w	r6, r6, #15
 8005b74:	f44f 3380 	mov.w	r3, #65536	; 0x10000

uint8_t PinSource(GPIOPin portpin) {
	return portpin & 0x0f;
}

void pinMode(GPIOPin portpin, GPIOMode_TypeDef mode) {
 8005b78:	fa03 f606 	lsl.w	r6, r3, r6

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);

	GPIO_InitStructure.GPIO_Pin = PinBit(portpin);
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8005b7c:	2300      	movs	r3, #0

uint8_t PinSource(GPIOPin portpin) {
	return portpin & 0x0f;
}

void pinMode(GPIOPin portpin, GPIOMode_TypeDef mode) {
 8005b7e:	0c36      	lsrs	r6, r6, #16

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);

	GPIO_InitStructure.GPIO_Pin = PinBit(portpin);
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8005b80:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8005b84:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	//
	GPIO_Init(Port[portpin>>8 & 0x0f], &GPIO_InitStructure);
 8005b88:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]

	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);

	GPIO_InitStructure.GPIO_Pin = PinBit(portpin);
 8005b8c:	9600      	str	r6, [sp, #0]
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005b8e:	2302      	movs	r3, #2
	//
	GPIO_Init(Port[portpin>>8 & 0x0f], &GPIO_InitStructure);
 8005b90:	4669      	mov	r1, sp
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(PortPeriph[portpin>>8 & 0x0f], ENABLE);

	GPIO_InitStructure.GPIO_Pin = PinBit(portpin);
	GPIO_InitStructure.GPIO_Mode = mode;
 8005b92:	f88d 7004 	strb.w	r7, [sp, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005b96:	f88d 3005 	strb.w	r3, [sp, #5]
	//
	GPIO_Init(Port[portpin>>8 & 0x0f], &GPIO_InitStructure);
 8005b9a:	f7fc febb 	bl	8002914 <GPIO_Init>
}
 8005b9e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005ba0:	20000010 	.word	0x20000010

08005ba4 <digitalWrite>:

void digitalWrite(GPIOPin portpin, uint8_t bit) {
 8005ba4:	0a02      	lsrs	r2, r0, #8
 8005ba6:	4b0b      	ldr	r3, [pc, #44]	; (8005bd4 <digitalWrite+0x30>)
	if (bit) {
		//? Bit_SET : Bit_RESET ));
		GPIO_SetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
 8005ba8:	f002 020f 	and.w	r2, r2, #15
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005bac:	f000 000f 	and.w	r0, r0, #15
	//
	GPIO_Init(Port[portpin>>8 & 0x0f], &GPIO_InitStructure);
}

void digitalWrite(GPIOPin portpin, uint8_t bit) {
	if (bit) {
 8005bb0:	b139      	cbz	r1, 8005bc2 <digitalWrite+0x1e>
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005bb2:	2101      	movs	r1, #1
 8005bb4:	fa01 f100 	lsl.w	r1, r1, r0
}

void digitalWrite(GPIOPin portpin, uint8_t bit) {
	if (bit) {
		//? Bit_SET : Bit_RESET ));
		GPIO_SetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
 8005bb8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8005bbc:	b289      	uxth	r1, r1
 8005bbe:	f7fc bf1b 	b.w	80029f8 <GPIO_SetBits>
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005bc2:	2101      	movs	r1, #1
 8005bc4:	fa01 f100 	lsl.w	r1, r1, r0
void digitalWrite(GPIOPin portpin, uint8_t bit) {
	if (bit) {
		//? Bit_SET : Bit_RESET ));
		GPIO_SetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
	} else {
		GPIO_ResetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
 8005bc8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8005bcc:	b289      	uxth	r1, r1
 8005bce:	f7fc bf15 	b.w	80029fc <GPIO_ResetBits>
 8005bd2:	bf00      	nop
 8005bd4:	20000010 	.word	0x20000010

08005bd8 <digitalRead>:
	}
}

uint8_t digitalRead(GPIOPin portpin) {
	GPIO_TypeDef * port = Port[portpin>>8 & 0x0f];
 8005bd8:	f3c0 2103 	ubfx	r1, r0, #8, #4
 8005bdc:	4a0d      	ldr	r2, [pc, #52]	; (8005c14 <digitalRead+0x3c>)
	} else {
		GPIO_ResetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
	}
}

uint8_t digitalRead(GPIOPin portpin) {
 8005bde:	b508      	push	{r3, lr}
 8005be0:	4603      	mov	r3, r0
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005be2:	f003 030f 	and.w	r3, r3, #15
		GPIO_ResetBits(Port[portpin >>8 & 0x0f], PinBit(portpin));
	}
}

uint8_t digitalRead(GPIOPin portpin) {
	GPIO_TypeDef * port = Port[portpin>>8 & 0x0f];
 8005be6:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005bea:	2101      	movs	r1, #1
 8005bec:	fa01 f303 	lsl.w	r3, r1, r3
	}
}

uint8_t digitalRead(GPIOPin portpin) {
	GPIO_TypeDef * port = Port[portpin>>8 & 0x0f];
	uint8_t mode = (port->MODER) >> (PinBit(portpin) * 2);
 8005bf0:	6802      	ldr	r2, [r0, #0]
GPIO_TypeDef * PinPort(GPIOPin portpin) {
	return Port[portpin >> 8 & 0x0f];
}

uint16_t PinBit(GPIOPin portpin) {
	return ((uint16_t)1)<<(portpin &0x0f);
 8005bf2:	b299      	uxth	r1, r3
	}
}

uint8_t digitalRead(GPIOPin portpin) {
	GPIO_TypeDef * port = Port[portpin>>8 & 0x0f];
	uint8_t mode = (port->MODER) >> (PinBit(portpin) * 2);
 8005bf4:	004b      	lsls	r3, r1, #1
 8005bf6:	fa22 f303 	lsr.w	r3, r2, r3
	if (mode == GPIO_Mode_OUT)
 8005bfa:	b2db      	uxtb	r3, r3
 8005bfc:	2b01      	cmp	r3, #1
 8005bfe:	d102      	bne.n	8005c06 <digitalRead+0x2e>
		return (GPIO_ReadOutputDataBit(port, PinBit(portpin)) ? SET : RESET);
 8005c00:	f7fc fef1 	bl	80029e6 <GPIO_ReadOutputDataBit>
 8005c04:	e001      	b.n	8005c0a <digitalRead+0x32>
	return (GPIO_ReadInputDataBit(port, PinBit(portpin)) ? SET : RESET);
 8005c06:	f7fc fee5 	bl	80029d4 <GPIO_ReadInputDataBit>
 8005c0a:	3000      	adds	r0, #0
 8005c0c:	bf18      	it	ne
 8005c0e:	2001      	movne	r0, #1
}
 8005c10:	bd08      	pop	{r3, pc}
 8005c12:	bf00      	nop
 8005c14:	20000010 	.word	0x20000010

08005c18 <GPIOMode>:

void GPIOMode(GPIO_TypeDef * port, uint16_t pinbit, GPIOMode_TypeDef mode,
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
 8005c18:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005c1a:	461d      	mov	r5, r3
	if ( port == GPIOB ) {
 8005c1c:	4b1f      	ldr	r3, [pc, #124]	; (8005c9c <GPIOMode+0x84>)
		return (GPIO_ReadOutputDataBit(port, PinBit(portpin)) ? SET : RESET);
	return (GPIO_ReadInputDataBit(port, PinBit(portpin)) ? SET : RESET);
}

void GPIOMode(GPIO_TypeDef * port, uint16_t pinbit, GPIOMode_TypeDef mode,
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
 8005c1e:	4604      	mov	r4, r0
	if ( port == GPIOB ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8005c20:	2002      	movs	r0, #2
	return (GPIO_ReadInputDataBit(port, PinBit(portpin)) ? SET : RESET);
}

void GPIOMode(GPIO_TypeDef * port, uint16_t pinbit, GPIOMode_TypeDef mode,
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
	if ( port == GPIOB ) {
 8005c22:	429c      	cmp	r4, r3
		return (GPIO_ReadOutputDataBit(port, PinBit(portpin)) ? SET : RESET);
	return (GPIO_ReadInputDataBit(port, PinBit(portpin)) ? SET : RESET);
}

void GPIOMode(GPIO_TypeDef * port, uint16_t pinbit, GPIOMode_TypeDef mode,
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
 8005c24:	460f      	mov	r7, r1
 8005c26:	4616      	mov	r6, r2
	if ( port == GPIOB ) {
 8005c28:	d01c      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	} else if ( port == GPIOC ) {
 8005c2a:	4b1d      	ldr	r3, [pc, #116]	; (8005ca0 <GPIOMode+0x88>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8005c2c:	2004      	movs	r0, #4

void GPIOMode(GPIO_TypeDef * port, uint16_t pinbit, GPIOMode_TypeDef mode,
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
	if ( port == GPIOB ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	} else if ( port == GPIOC ) {
 8005c2e:	429c      	cmp	r4, r3
 8005c30:	d018      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	} else if ( port == GPIOD ) {
 8005c32:	4b1c      	ldr	r3, [pc, #112]	; (8005ca4 <GPIOMode+0x8c>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8005c34:	2008      	movs	r0, #8
              GPIOSpeed_TypeDef clk, GPIOOType_TypeDef otype, GPIOPuPd_TypeDef pupd) {
	if ( port == GPIOB ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	} else if ( port == GPIOC ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	} else if ( port == GPIOD ) {
 8005c36:	429c      	cmp	r4, r3
 8005c38:	d014      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	} else if ( port == GPIOE ) {
 8005c3a:	4b1b      	ldr	r3, [pc, #108]	; (8005ca8 <GPIOMode+0x90>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 8005c3c:	2010      	movs	r0, #16
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	} else if ( port == GPIOC ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	} else if ( port == GPIOD ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	} else if ( port == GPIOE ) {
 8005c3e:	429c      	cmp	r4, r3
 8005c40:	d010      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
	} else if ( port == GPIOF ) {
 8005c42:	4b1a      	ldr	r3, [pc, #104]	; (8005cac <GPIOMode+0x94>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 8005c44:	2020      	movs	r0, #32
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	} else if ( port == GPIOD ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	} else if ( port == GPIOE ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
	} else if ( port == GPIOF ) {
 8005c46:	429c      	cmp	r4, r3
 8005c48:	d00c      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
	} else if ( port == GPIOG ) {
 8005c4a:	4b19      	ldr	r3, [pc, #100]	; (8005cb0 <GPIOMode+0x98>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 8005c4c:	2040      	movs	r0, #64	; 0x40
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	} else if ( port == GPIOE ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
	} else if ( port == GPIOF ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
	} else if ( port == GPIOG ) {
 8005c4e:	429c      	cmp	r4, r3
 8005c50:	d008      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
	} else if ( port == GPIOH ) {
 8005c52:	4b18      	ldr	r3, [pc, #96]	; (8005cb4 <GPIOMode+0x9c>)
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 8005c54:	2080      	movs	r0, #128	; 0x80
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
	} else if ( port == GPIOF ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
	} else if ( port == GPIOG ) {
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
	} else if ( port == GPIOH ) {
 8005c56:	429c      	cmp	r4, r3
 8005c58:	d004      	beq.n	8005c64 <GPIOMode+0x4c>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
	} else if ( port == GPIOI ) {
 8005c5a:	4b17      	ldr	r3, [pc, #92]	; (8005cb8 <GPIOMode+0xa0>)
 8005c5c:	429c      	cmp	r4, r3
 8005c5e:	d103      	bne.n	8005c68 <GPIOMode+0x50>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 8005c60:	f44f 7080 	mov.w	r0, #256	; 0x100
 8005c64:	2101      	movs	r1, #1
 8005c66:	e004      	b.n	8005c72 <GPIOMode+0x5a>
	} else if ( port == GPIOA ) {
 8005c68:	4b14      	ldr	r3, [pc, #80]	; (8005cbc <GPIOMode+0xa4>)
 8005c6a:	429c      	cmp	r4, r3
 8005c6c:	d103      	bne.n	8005c76 <GPIOMode+0x5e>
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8005c6e:	2001      	movs	r0, #1
 8005c70:	4601      	mov	r1, r0
 8005c72:	f7fd fd47 	bl	8003704 <RCC_AHB1PeriphClockCmd>

	GPIO_InitTypeDef GPIO_InitStructure;
        
	GPIO_InitStructure.GPIO_Pin = pinbit;
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = otype;
 8005c76:	f89d 3020 	ldrb.w	r3, [sp, #32]
	}
	// assumes port is already waked up.

	GPIO_InitTypeDef GPIO_InitStructure;
        
	GPIO_InitStructure.GPIO_Pin = pinbit;
 8005c7a:	9700      	str	r7, [sp, #0]
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = otype;
 8005c7c:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_InitStructure.GPIO_PuPd = pupd;
 8005c80:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
	// assumes port is already waked up.

	GPIO_InitTypeDef GPIO_InitStructure;
        
	GPIO_InitStructure.GPIO_Pin = pinbit;
	GPIO_InitStructure.GPIO_Mode = mode;
 8005c84:	f88d 6004 	strb.w	r6, [sp, #4]
	GPIO_InitStructure.GPIO_OType = otype;
	GPIO_InitStructure.GPIO_PuPd = pupd;
	GPIO_InitStructure.GPIO_Speed = clk;
	//
	GPIO_Init(port, &GPIO_InitStructure);
 8005c88:	4620      	mov	r0, r4
 8005c8a:	4669      	mov	r1, sp
	GPIO_InitTypeDef GPIO_InitStructure;
        
	GPIO_InitStructure.GPIO_Pin = pinbit;
	GPIO_InitStructure.GPIO_Mode = mode;
	GPIO_InitStructure.GPIO_OType = otype;
	GPIO_InitStructure.GPIO_PuPd = pupd;
 8005c8c:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_InitStructure.GPIO_Speed = clk;
 8005c90:	f88d 5005 	strb.w	r5, [sp, #5]
	//
	GPIO_Init(port, &GPIO_InitStructure);
 8005c94:	f7fc fe3e 	bl	8002914 <GPIO_Init>
}
 8005c98:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005c9a:	bf00      	nop
 8005c9c:	40020400 	.word	0x40020400
 8005ca0:	40020800 	.word	0x40020800
 8005ca4:	40020c00 	.word	0x40020c00
 8005ca8:	40021000 	.word	0x40021000
 8005cac:	40021400 	.word	0x40021400
 8005cb0:	40021800 	.word	0x40021800
 8005cb4:	40021c00 	.word	0x40021c00
 8005cb8:	40022000 	.word	0x40022000
 8005cbc:	40020000 	.word	0x40020000

08005cc0 <GPIOWrite>:


inline void GPIOWrite(GPIO_TypeDef * port, uint16_t bits) {
	GPIO_Write(port, bits);
 8005cc0:	f7fc bea3 	b.w	8002a0a <GPIO_Write>

08005cc4 <i2c_begin>:
} CommDirection;

//I2C_Status i2c1_status;
//CommDirection i2c1_direction;

boolean i2c_begin(I2CBus * wirex, GPIOPin sda, GPIOPin scl, uint32_t clkspeed) {
 8005cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005cc6:	461d      	mov	r5, r3
	// set default to I2C1
	uint8_t gpio_af = GPIO_AF_I2C1;
	uint32_t periph_i2c = RCC_APB1Periph_I2C1;

	wirex->sda = sda; //PB9;
	wirex->scl = scl; //PB8;
 8005cc8:	80c2      	strh	r2, [r0, #6]

	if (wirex->I2Cx == I2C2 ) {
 8005cca:	6803      	ldr	r3, [r0, #0]
 8005ccc:	4a38      	ldr	r2, [pc, #224]	; (8005db0 <i2c_begin+0xec>)
	I2C_InitTypeDef I2C_InitStructure;
	// set default to I2C1
	uint8_t gpio_af = GPIO_AF_I2C1;
	uint32_t periph_i2c = RCC_APB1Periph_I2C1;

	wirex->sda = sda; //PB9;
 8005cce:	8081      	strh	r1, [r0, #4]
	wirex->scl = scl; //PB8;

	if (wirex->I2Cx == I2C2 ) {
 8005cd0:	4293      	cmp	r3, r2
} CommDirection;

//I2C_Status i2c1_status;
//CommDirection i2c1_direction;

boolean i2c_begin(I2CBus * wirex, GPIOPin sda, GPIOPin scl, uint32_t clkspeed) {
 8005cd2:	b087      	sub	sp, #28
 8005cd4:	4604      	mov	r4, r0
	uint32_t periph_i2c = RCC_APB1Periph_I2C1;

	wirex->sda = sda; //PB9;
	wirex->scl = scl; //PB8;

	if (wirex->I2Cx == I2C2 ) {
 8005cd6:	d007      	beq.n	8005ce8 <i2c_begin+0x24>

boolean i2c_begin(I2CBus * wirex, GPIOPin sda, GPIOPin scl, uint32_t clkspeed) {
	I2C_InitTypeDef I2C_InitStructure;
	// set default to I2C1
	uint8_t gpio_af = GPIO_AF_I2C1;
	uint32_t periph_i2c = RCC_APB1Periph_I2C1;
 8005cd8:	4836      	ldr	r0, [pc, #216]	; (8005db4 <i2c_begin+0xf0>)
 8005cda:	4283      	cmp	r3, r0
 8005cdc:	bf0c      	ite	eq
 8005cde:	f44f 0000 	moveq.w	r0, #8388608	; 0x800000
 8005ce2:	f44f 1000 	movne.w	r0, #2097152	; 0x200000
 8005ce6:	e001      	b.n	8005cec <i2c_begin+0x28>
	wirex->sda = sda; //PB9;
	wirex->scl = scl; //PB8;

	if (wirex->I2Cx == I2C2 ) {
		gpio_af = GPIO_AF_I2C2;
		periph_i2c = RCC_APB1Periph_I2C2;
 8005ce8:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
		gpio_af = GPIO_AF_I2C1;
		periph_i2c = RCC_APB1Periph_I2C1;
	} */

	/* I2C Periph clock enable */
	RCC_APB1PeriphClockCmd(periph_i2c, ENABLE); //  RCC_APB1PeriphClockCmd(I2C1_RCC, ENABLE);
 8005cec:	2101      	movs	r1, #1
 8005cee:	f7fd fd2d 	bl	800374c <RCC_APB1PeriphClockCmd>
	/* GPIO Periph clock enable */
	//RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE); // PB5 (SMBA), PB6 (SCL), PB9 (SDA)  // RCC_APB2PeriphClockCmd(I2C1_GPIO_RCC, ENABLE);
	GPIOMode(PinPort(wirex->scl), PinBit(wirex->scl), GPIO_Mode_AF,
 8005cf2:	88e0      	ldrh	r0, [r4, #6]
 8005cf4:	f7ff ff1e 	bl	8005b34 <PinPort>
 8005cf8:	4607      	mov	r7, r0
 8005cfa:	88e0      	ldrh	r0, [r4, #6]
 8005cfc:	f7ff ff22 	bl	8005b44 <PinBit>
 8005d00:	2601      	movs	r6, #1
 8005d02:	2202      	movs	r2, #2
 8005d04:	4601      	mov	r1, r0
 8005d06:	4613      	mov	r3, r2
 8005d08:	4638      	mov	r0, r7
 8005d0a:	9600      	str	r6, [sp, #0]
 8005d0c:	9601      	str	r6, [sp, #4]
 8005d0e:	f7ff ff83 	bl	8005c18 <GPIOMode>
			GPIO_Speed_50MHz, GPIO_OType_OD, GPIO_PuPd_UP);
	GPIOMode(PinPort(wirex->sda), PinBit(wirex->sda), GPIO_Mode_AF,
 8005d12:	88a0      	ldrh	r0, [r4, #4]
 8005d14:	f7ff ff0e 	bl	8005b34 <PinPort>
 8005d18:	4607      	mov	r7, r0
 8005d1a:	88a0      	ldrh	r0, [r4, #4]
 8005d1c:	f7ff ff12 	bl	8005b44 <PinBit>
 8005d20:	2202      	movs	r2, #2
 8005d22:	4613      	mov	r3, r2
 8005d24:	4601      	mov	r1, r0
 8005d26:	9600      	str	r6, [sp, #0]
 8005d28:	9601      	str	r6, [sp, #4]
 8005d2a:	4638      	mov	r0, r7
 8005d2c:	f7ff ff74 	bl	8005c18 <GPIOMode>
			GPIO_Speed_50MHz, GPIO_OType_OD, GPIO_PuPd_UP);

	/* Configure I2C pins: SCL and SDA */
	GPIO_PinAFConfig(PinPort(wirex->scl), PinSource(wirex->scl), gpio_af); //GPIO_AF_I2C1 );
 8005d30:	88e0      	ldrh	r0, [r4, #6]
 8005d32:	f7ff feff 	bl	8005b34 <PinPort>
 8005d36:	4606      	mov	r6, r0
 8005d38:	88e0      	ldrh	r0, [r4, #6]
 8005d3a:	f7ff ff0a 	bl	8005b52 <PinSource>
 8005d3e:	2204      	movs	r2, #4
 8005d40:	4601      	mov	r1, r0
 8005d42:	4630      	mov	r0, r6
 8005d44:	f7fc fe67 	bl	8002a16 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PinPort(wirex->sda), PinSource(wirex->sda), gpio_af); //GPIO_AF_I2C1 );
 8005d48:	88a0      	ldrh	r0, [r4, #4]
 8005d4a:	f7ff fef3 	bl	8005b34 <PinPort>
 8005d4e:	4606      	mov	r6, r0
 8005d50:	88a0      	ldrh	r0, [r4, #4]
 8005d52:	f7ff fefe 	bl	8005b52 <PinSource>
 8005d56:	2204      	movs	r2, #4
 8005d58:	4601      	mov	r1, r0
 8005d5a:	4630      	mov	r0, r6
 8005d5c:	f7fc fe5b 	bl	8002a16 <GPIO_PinAFConfig>

//#if defined (REMAP_I2C1)
//Remap_I2C1_Configuration();
//#endif
	switch (clkspeed) {
 8005d60:	4b15      	ldr	r3, [pc, #84]	; (8005db8 <i2c_begin+0xf4>)
 8005d62:	429d      	cmp	r5, r3
 8005d64:	d004      	beq.n	8005d70 <i2c_begin+0xac>
 8005d66:	4a15      	ldr	r2, [pc, #84]	; (8005dbc <i2c_begin+0xf8>)
	case 100000:
	case 400000:
		break;
	default:
		clkspeed = 100000;
 8005d68:	4295      	cmp	r5, r2
 8005d6a:	bf0c      	ite	eq
 8005d6c:	4615      	moveq	r5, r2
 8005d6e:	461d      	movne	r5, r3
		break;
	}
	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8005d70:	2300      	movs	r3, #0
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
	I2C_InitStructure.I2C_ClockSpeed = clkspeed;
 8005d72:	a906      	add	r1, sp, #24
	default:
		clkspeed = 100000;
		break;
	}
	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8005d74:	461e      	mov	r6, r3
 8005d76:	f8ad 300c 	strh.w	r3, [sp, #12]
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8005d7a:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 8005d7e:	f8ad 300e 	strh.w	r3, [sp, #14]
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8005d82:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005d86:	f8ad 3012 	strh.w	r3, [sp, #18]
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
	I2C_InitStructure.I2C_ClockSpeed = clkspeed;
 8005d8a:	f841 5d10 	str.w	r5, [r1, #-16]!
	}
	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8005d8e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	I2C_InitStructure.I2C_ClockSpeed = clkspeed;

	/* Apply I2C configuration after enabling it */
	I2C_Init(wirex->I2Cx, &I2C_InitStructure);
 8005d92:	6820      	ldr	r0, [r4, #0]
	}
	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8005d94:	f8ad 3014 	strh.w	r3, [sp, #20]
	I2C_InitStructure.I2C_ClockSpeed = clkspeed;

	/* Apply I2C configuration after enabling it */
	I2C_Init(wirex->I2Cx, &I2C_InitStructure);
 8005d98:	f7fd f92a 	bl	8002ff0 <I2C_Init>
	/* I2C Peripheral Enable */
	I2C_Cmd(wirex->I2Cx, ENABLE);
 8005d9c:	6820      	ldr	r0, [r4, #0]
 8005d9e:	2101      	movs	r1, #1
 8005da0:	f7fd f998 	bl	80030d4 <I2C_Cmd>

	wirex->status = NOT_READY;
 8005da4:	20ff      	movs	r0, #255	; 0xff
 8005da6:	7260      	strb	r0, [r4, #9]
	wirex->mode = I2C_MODE_NOTDEFINED;
 8005da8:	72a6      	strb	r6, [r4, #10]

	return true;
}
 8005daa:	b007      	add	sp, #28
 8005dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005dae:	bf00      	nop
 8005db0:	40005800 	.word	0x40005800
 8005db4:	40005c00 	.word	0x40005c00
 8005db8:	000186a0 	.word	0x000186a0
 8005dbc:	00061a80 	.word	0x00061a80

08005dc0 <i2c_start>:
}

boolean i2c_start(I2CBus * wirex, uint8_t addr) {
	uint16_t wc;
	//
	wirex->status = NOT_READY;
 8005dc0:	23ff      	movs	r3, #255	; 0xff
	wirex->mode = I2C_MODE_NOTDEFINED;

	return true;
}

boolean i2c_start(I2CBus * wirex, uint8_t addr) {
 8005dc2:	b570      	push	{r4, r5, r6, lr}
 8005dc4:	4604      	mov	r4, r0
 8005dc6:	460e      	mov	r6, r1
	uint16_t wc;
	//
	wirex->status = NOT_READY;
 8005dc8:	7243      	strb	r3, [r0, #9]
	for (wc = 5; I2C_GetFlagStatus(wirex->I2Cx, I2C_FLAG_BUSY ); wc--) {
 8005dca:	2506      	movs	r5, #6
 8005dcc:	e008      	b.n	8005de0 <i2c_start+0x20>
 8005dce:	3d01      	subs	r5, #1
 8005dd0:	b2ad      	uxth	r5, r5
		if (wc == 0)
 8005dd2:	b90d      	cbnz	r5, 8005dd8 <i2c_start+0x18>
			return false;
 8005dd4:	2000      	movs	r0, #0
 8005dd6:	bd70      	pop	{r4, r5, r6, pc}
		delay_us(667);
 8005dd8:	f240 209b 	movw	r0, #667	; 0x29b
 8005ddc:	f7ff fe7e 	bl	8005adc <delay_us>

boolean i2c_start(I2CBus * wirex, uint8_t addr) {
	uint16_t wc;
	//
	wirex->status = NOT_READY;
	for (wc = 5; I2C_GetFlagStatus(wirex->I2Cx, I2C_FLAG_BUSY ); wc--) {
 8005de0:	6820      	ldr	r0, [r4, #0]
 8005de2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8005de6:	f7fd fa8b 	bl	8003300 <I2C_GetFlagStatus>
 8005dea:	2800      	cmp	r0, #0
 8005dec:	d1ef      	bne.n	8005dce <i2c_start+0xe>
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = READY;
 8005dee:	7260      	strb	r0, [r4, #9]

	/* Send STRAT condition */
	I2C_GenerateSTART(wirex->I2Cx, ENABLE);
 8005df0:	2101      	movs	r1, #1
 8005df2:	6820      	ldr	r0, [r4, #0]
 8005df4:	f7fd f97a 	bl	80030ec <I2C_GenerateSTART>
	/* Test on EV5 and clear it */
	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_MODE_SELECT );
 8005df8:	2506      	movs	r5, #6
 8005dfa:	e007      	b.n	8005e0c <i2c_start+0x4c>
 8005dfc:	3d01      	subs	r5, #1
 8005dfe:	b2ad      	uxth	r5, r5
			wc--) {
		if (wc == 0)
 8005e00:	2d00      	cmp	r5, #0
 8005e02:	d0e7      	beq.n	8005dd4 <i2c_start+0x14>
			return false;
		delay_us(667);
 8005e04:	f240 209b 	movw	r0, #667	; 0x29b
 8005e08:	f7ff fe68 	bl	8005adc <delay_us>
	wirex->status = READY;

	/* Send STRAT condition */
	I2C_GenerateSTART(wirex->I2Cx, ENABLE);
	/* Test on EV5 and clear it */
	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_MODE_SELECT );
 8005e0c:	6820      	ldr	r0, [r4, #0]
 8005e0e:	4911      	ldr	r1, [pc, #68]	; (8005e54 <i2c_start+0x94>)
 8005e10:	f7fd fa62 	bl	80032d8 <I2C_CheckEvent>
 8005e14:	2800      	cmp	r0, #0
 8005e16:	d0f1      	beq.n	8005dfc <i2c_start+0x3c>
			wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = START_ISSUED;
 8005e18:	2301      	movs	r3, #1

	/* Send address for write */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Transmitter );
 8005e1a:	fa06 f103 	lsl.w	r1, r6, r3
			wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = START_ISSUED;
 8005e1e:	7263      	strb	r3, [r4, #9]

	/* Send address for write */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Transmitter );
 8005e20:	6820      	ldr	r0, [r4, #0]
 8005e22:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8005e26:	2200      	movs	r2, #0
 8005e28:	f7fd f978 	bl	800311c <I2C_Send7bitAddress>
 8005e2c:	2506      	movs	r5, #6
 8005e2e:	e007      	b.n	8005e40 <i2c_start+0x80>
 8005e30:	3d01      	subs	r5, #1
 8005e32:	b2ad      	uxth	r5, r5
	/* Test on EV6 and clear it */
	for (wc = 5;
			!I2C_CheckEvent(wirex->I2Cx,
					I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ); wc--) {
		if (wc == 0)
 8005e34:	2d00      	cmp	r5, #0
 8005e36:	d0cd      	beq.n	8005dd4 <i2c_start+0x14>
			return false;
		delay_us(667);
 8005e38:	f240 209b 	movw	r0, #667	; 0x29b
 8005e3c:	f7ff fe4e 	bl	8005adc <delay_us>

	/* Send address for write */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Transmitter );
	/* Test on EV6 and clear it */
	for (wc = 5;
			!I2C_CheckEvent(wirex->I2Cx,
 8005e40:	6820      	ldr	r0, [r4, #0]
 8005e42:	4905      	ldr	r1, [pc, #20]	; (8005e58 <i2c_start+0x98>)
 8005e44:	f7fd fa48 	bl	80032d8 <I2C_CheckEvent>
	wirex->status = START_ISSUED;

	/* Send address for write */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Transmitter );
	/* Test on EV6 and clear it */
	for (wc = 5;
 8005e48:	2800      	cmp	r0, #0
 8005e4a:	d0f1      	beq.n	8005e30 <i2c_start+0x70>
					I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED ); wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = DST_ADDRESS_SENT;
 8005e4c:	2302      	movs	r3, #2
 8005e4e:	7263      	strb	r3, [r4, #9]
	return true;
 8005e50:	20ff      	movs	r0, #255	; 0xff
 8005e52:	bd70      	pop	{r4, r5, r6, pc}
 8005e54:	00030001 	.word	0x00030001
 8005e58:	00070082 	.word	0x00070082

08005e5c <i2c_receive>:

	return true;
}

boolean i2c_receive(I2CBus * wirex, uint8_t addr, uint8_t req, uint8_t * recv,
		uint16_t lim) {
 8005e5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005e60:	461d      	mov	r5, r3
	uint16_t i;
	uint16_t wc;

	wirex->mode = I2C_MODE_MASTERRECEIVER;
 8005e62:	2302      	movs	r3, #2
 8005e64:	7283      	strb	r3, [r0, #10]

	return true;
}

boolean i2c_receive(I2CBus * wirex, uint8_t addr, uint8_t req, uint8_t * recv,
		uint16_t lim) {
 8005e66:	4604      	mov	r4, r0
 8005e68:	4688      	mov	r8, r1
 8005e6a:	4616      	mov	r6, r2
 8005e6c:	f8bd 7018 	ldrh.w	r7, [sp, #24]
	uint16_t i;
	uint16_t wc;

	wirex->mode = I2C_MODE_MASTERRECEIVER;
	//
	if (!i2c_start(wirex, addr))
 8005e70:	f7ff ffa6 	bl	8005dc0 <i2c_start>
 8005e74:	b910      	cbnz	r0, 8005e7c <i2c_receive+0x20>
		return false;
 8005e76:	2000      	movs	r0, #0
 8005e78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(wirex->I2Cx, req);
 8005e7c:	4631      	mov	r1, r6
 8005e7e:	6820      	ldr	r0, [r4, #0]
 8005e80:	f7fd f9ce 	bl	8003220 <I2C_SendData>
	wirex->status = BYTE_TRANSMITTING;
 8005e84:	2304      	movs	r3, #4
 8005e86:	7263      	strb	r3, [r4, #9]
	/* Test on EV8 and clear it */

	for (wc = 5;
 8005e88:	2606      	movs	r6, #6
 8005e8a:	e007      	b.n	8005e9c <i2c_receive+0x40>
 8005e8c:	3e01      	subs	r6, #1
 8005e8e:	b2b6      	uxth	r6, r6
			!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED );
			wc--) {
		if (wc == 0)
 8005e90:	2e00      	cmp	r6, #0
 8005e92:	d0f0      	beq.n	8005e76 <i2c_receive+0x1a>
			return false;
		delay_us(667);
 8005e94:	f240 209b 	movw	r0, #667	; 0x29b
 8005e98:	f7ff fe20 	bl	8005adc <delay_us>
	I2C_SendData(wirex->I2Cx, req);
	wirex->status = BYTE_TRANSMITTING;
	/* Test on EV8 and clear it */

	for (wc = 5;
			!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED );
 8005e9c:	6820      	ldr	r0, [r4, #0]
 8005e9e:	4941      	ldr	r1, [pc, #260]	; (8005fa4 <i2c_receive+0x148>)
 8005ea0:	f7fd fa1a 	bl	80032d8 <I2C_CheckEvent>
	/* Send the EEPROM's internal address to read from: MSB of the address first */
	I2C_SendData(wirex->I2Cx, req);
	wirex->status = BYTE_TRANSMITTING;
	/* Test on EV8 and clear it */

	for (wc = 5;
 8005ea4:	2800      	cmp	r0, #0
 8005ea6:	d0f1      	beq.n	8005e8c <i2c_receive+0x30>
			wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = TRANSMISSION_COMPLETED;
 8005ea8:	2606      	movs	r6, #6
 8005eaa:	7266      	strb	r6, [r4, #9]

	/* Send STRAT condition a second time */
	I2C_GenerateSTART(wirex->I2Cx, ENABLE);
 8005eac:	6820      	ldr	r0, [r4, #0]
 8005eae:	2101      	movs	r1, #1
 8005eb0:	f7fd f91c 	bl	80030ec <I2C_GenerateSTART>
	/* Test on EV5 and clear it */
	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_MODE_SELECT );
 8005eb4:	e007      	b.n	8005ec6 <i2c_receive+0x6a>
 8005eb6:	3e01      	subs	r6, #1
 8005eb8:	b2b6      	uxth	r6, r6
			wc--) {
		if (wc == 0)
 8005eba:	2e00      	cmp	r6, #0
 8005ebc:	d0db      	beq.n	8005e76 <i2c_receive+0x1a>
			return false;
		delay_us(667);
 8005ebe:	f240 209b 	movw	r0, #667	; 0x29b
 8005ec2:	f7ff fe0b 	bl	8005adc <delay_us>
	wirex->status = TRANSMISSION_COMPLETED;

	/* Send STRAT condition a second time */
	I2C_GenerateSTART(wirex->I2Cx, ENABLE);
	/* Test on EV5 and clear it */
	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_MODE_SELECT );
 8005ec6:	6820      	ldr	r0, [r4, #0]
 8005ec8:	4937      	ldr	r1, [pc, #220]	; (8005fa8 <i2c_receive+0x14c>)
 8005eca:	f7fd fa05 	bl	80032d8 <I2C_CheckEvent>
 8005ece:	2800      	cmp	r0, #0
 8005ed0:	d0f1      	beq.n	8005eb6 <i2c_receive+0x5a>
			wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = RESTART_ISSUED;
 8005ed2:	2307      	movs	r3, #7

	/* Send EEPROM address for read */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Receiver );
 8005ed4:	ea4f 0148 	mov.w	r1, r8, lsl #1
			wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = RESTART_ISSUED;
 8005ed8:	7263      	strb	r3, [r4, #9]

	/* Send EEPROM address for read */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Receiver );
 8005eda:	6820      	ldr	r0, [r4, #0]
 8005edc:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8005ee0:	2201      	movs	r2, #1
 8005ee2:	f7fd f91b 	bl	800311c <I2C_Send7bitAddress>
	/* Test on EV6 and clear it */
	for (wc = 5;
 8005ee6:	2606      	movs	r6, #6
 8005ee8:	e007      	b.n	8005efa <i2c_receive+0x9e>
 8005eea:	3e01      	subs	r6, #1
 8005eec:	b2b6      	uxth	r6, r6
			!I2C_CheckEvent(wirex->I2Cx,
					I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED ); wc--) {
		if (wc == 0)
 8005eee:	2e00      	cmp	r6, #0
 8005ef0:	d0c1      	beq.n	8005e76 <i2c_receive+0x1a>
			return false;
		delay_us(667);
 8005ef2:	f240 209b 	movw	r0, #667	; 0x29b
 8005ef6:	f7ff fdf1 	bl	8005adc <delay_us>

	/* Send EEPROM address for read */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Receiver );
	/* Test on EV6 and clear it */
	for (wc = 5;
			!I2C_CheckEvent(wirex->I2Cx,
 8005efa:	6820      	ldr	r0, [r4, #0]
 8005efc:	492b      	ldr	r1, [pc, #172]	; (8005fac <i2c_receive+0x150>)
 8005efe:	f7fd f9eb 	bl	80032d8 <I2C_CheckEvent>
	wirex->status = RESTART_ISSUED;

	/* Send EEPROM address for read */
	I2C_Send7bitAddress(wirex->I2Cx, addr << 1, I2C_Direction_Receiver );
	/* Test on EV6 and clear it */
	for (wc = 5;
 8005f02:	2800      	cmp	r0, #0
 8005f04:	d0f1      	beq.n	8005eea <i2c_receive+0x8e>
					I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED ); wc--) {
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = SRC_ADDRESS_SENT;
 8005f06:	2303      	movs	r3, #3
 8005f08:	7263      	strb	r3, [r4, #9]
	wirex->mode = I2C_MODE_NOTDEFINED;

	return true;
}

boolean i2c_receive(I2CBus * wirex, uint8_t addr, uint8_t req, uint8_t * recv,
 8005f0a:	f1c5 0801 	rsb	r8, r5, #1
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = SRC_ADDRESS_SENT;
	for (i = 1; i < lim; i++) {
 8005f0e:	e018      	b.n	8005f42 <i2c_receive+0xe6>
		wirex->status = RECEIVE_BYTE_READY;
 8005f10:	2308      	movs	r3, #8
 8005f12:	7263      	strb	r3, [r4, #9]
		for (wc = 5;
 8005f14:	2606      	movs	r6, #6
 8005f16:	e007      	b.n	8005f28 <i2c_receive+0xcc>
 8005f18:	3e01      	subs	r6, #1
 8005f1a:	b2b6      	uxth	r6, r6
				!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED );
				wc--) {
			if (wc == 0)
 8005f1c:	2e00      	cmp	r6, #0
 8005f1e:	d0aa      	beq.n	8005e76 <i2c_receive+0x1a>
				return false;
			delay_us(667);
 8005f20:	f240 209b 	movw	r0, #667	; 0x29b
 8005f24:	f7ff fdda 	bl	8005adc <delay_us>
	}
	wirex->status = SRC_ADDRESS_SENT;
	for (i = 1; i < lim; i++) {
		wirex->status = RECEIVE_BYTE_READY;
		for (wc = 5;
				!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED );
 8005f28:	6820      	ldr	r0, [r4, #0]
 8005f2a:	4921      	ldr	r1, [pc, #132]	; (8005fb0 <i2c_receive+0x154>)
 8005f2c:	f7fd f9d4 	bl	80032d8 <I2C_CheckEvent>
		delay_us(667);
	}
	wirex->status = SRC_ADDRESS_SENT;
	for (i = 1; i < lim; i++) {
		wirex->status = RECEIVE_BYTE_READY;
		for (wc = 5;
 8005f30:	2800      	cmp	r0, #0
 8005f32:	d0f1      	beq.n	8005f18 <i2c_receive+0xbc>
				return false;
			delay_us(667);

		}
		/* Read a byte from the EEPROM */
		*recv++ = I2C_ReceiveData(wirex->I2Cx);
 8005f34:	6820      	ldr	r0, [r4, #0]
 8005f36:	f7fd f975 	bl	8003224 <I2C_ReceiveData>
		wirex->status = BYTE_RECEIVED;
 8005f3a:	2309      	movs	r3, #9
				return false;
			delay_us(667);

		}
		/* Read a byte from the EEPROM */
		*recv++ = I2C_ReceiveData(wirex->I2Cx);
 8005f3c:	f805 0b01 	strb.w	r0, [r5], #1
		wirex->status = BYTE_RECEIVED;
 8005f40:	7263      	strb	r3, [r4, #9]
		if (wc == 0)
			return false;
		delay_us(667);
	}
	wirex->status = SRC_ADDRESS_SENT;
	for (i = 1; i < lim; i++) {
 8005f42:	eb08 0305 	add.w	r3, r8, r5
 8005f46:	b29b      	uxth	r3, r3
 8005f48:	42bb      	cmp	r3, r7
 8005f4a:	d3e1      	bcc.n	8005f10 <i2c_receive+0xb4>
		}
		/* Read a byte from the EEPROM */
		*recv++ = I2C_ReceiveData(wirex->I2Cx);
		wirex->status = BYTE_RECEIVED;
	}
	wirex->status = BEFORELAST_BYTE_RECEIVED;
 8005f4c:	230a      	movs	r3, #10
 8005f4e:	7263      	strb	r3, [r4, #9]

	/* Disable Acknowledgement */
	I2C_AcknowledgeConfig(wirex->I2Cx, DISABLE);
 8005f50:	6820      	ldr	r0, [r4, #0]
 8005f52:	2100      	movs	r1, #0
 8005f54:	f7fd f8ea 	bl	800312c <I2C_AcknowledgeConfig>
	/* Send STOP Condition */
	I2C_GenerateSTOP(wirex->I2Cx, ENABLE);
 8005f58:	6820      	ldr	r0, [r4, #0]
 8005f5a:	2101      	movs	r1, #1
 8005f5c:	f7fd f8d2 	bl	8003104 <I2C_GenerateSTOP>
	wirex->status = LAST_BYTE_READY;
 8005f60:	230b      	movs	r3, #11
 8005f62:	7263      	strb	r3, [r4, #9]

	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED );
 8005f64:	2606      	movs	r6, #6
 8005f66:	e007      	b.n	8005f78 <i2c_receive+0x11c>
 8005f68:	3e01      	subs	r6, #1
 8005f6a:	b2b6      	uxth	r6, r6
			wc--) {
		if (wc == 0)
 8005f6c:	2e00      	cmp	r6, #0
 8005f6e:	d082      	beq.n	8005e76 <i2c_receive+0x1a>
			return false;
		delay_us(667);
 8005f70:	f240 209b 	movw	r0, #667	; 0x29b
 8005f74:	f7ff fdb2 	bl	8005adc <delay_us>
	I2C_AcknowledgeConfig(wirex->I2Cx, DISABLE);
	/* Send STOP Condition */
	I2C_GenerateSTOP(wirex->I2Cx, ENABLE);
	wirex->status = LAST_BYTE_READY;

	for (wc = 5; !I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED );
 8005f78:	6820      	ldr	r0, [r4, #0]
 8005f7a:	490d      	ldr	r1, [pc, #52]	; (8005fb0 <i2c_receive+0x154>)
 8005f7c:	f7fd f9ac 	bl	80032d8 <I2C_CheckEvent>
 8005f80:	2800      	cmp	r0, #0
 8005f82:	d0f1      	beq.n	8005f68 <i2c_receive+0x10c>
		if (wc == 0)
			return false;
		delay_us(667);
	}
	/* Read a byte from the EEPROM */
	*recv = I2C_ReceiveData(wirex->I2Cx);
 8005f84:	6820      	ldr	r0, [r4, #0]
 8005f86:	f7fd f94d 	bl	8003224 <I2C_ReceiveData>
	wirex->status = RECEIVE_BYTE_COMPLETED;
 8005f8a:	230c      	movs	r3, #12
		if (wc == 0)
			return false;
		delay_us(667);
	}
	/* Read a byte from the EEPROM */
	*recv = I2C_ReceiveData(wirex->I2Cx);
 8005f8c:	7028      	strb	r0, [r5, #0]
	wirex->status = RECEIVE_BYTE_COMPLETED;

	/* Enable Acknowledgement to be ready for another reception */
	I2C_AcknowledgeConfig(wirex->I2Cx, ENABLE);
 8005f8e:	6820      	ldr	r0, [r4, #0]
			return false;
		delay_us(667);
	}
	/* Read a byte from the EEPROM */
	*recv = I2C_ReceiveData(wirex->I2Cx);
	wirex->status = RECEIVE_BYTE_COMPLETED;
 8005f90:	7263      	strb	r3, [r4, #9]

	/* Enable Acknowledgement to be ready for another reception */
	I2C_AcknowledgeConfig(wirex->I2Cx, ENABLE);
 8005f92:	2101      	movs	r1, #1
 8005f94:	f7fd f8ca 	bl	800312c <I2C_AcknowledgeConfig>
	wirex->status = NOT_READY;
 8005f98:	20ff      	movs	r0, #255	; 0xff
	wirex->mode = I2C_MODE_NOTDEFINED;
 8005f9a:	2300      	movs	r3, #0
	*recv = I2C_ReceiveData(wirex->I2Cx);
	wirex->status = RECEIVE_BYTE_COMPLETED;

	/* Enable Acknowledgement to be ready for another reception */
	I2C_AcknowledgeConfig(wirex->I2Cx, ENABLE);
	wirex->status = NOT_READY;
 8005f9c:	7260      	strb	r0, [r4, #9]
	wirex->mode = I2C_MODE_NOTDEFINED;
 8005f9e:	72a3      	strb	r3, [r4, #10]

	return true;
}
 8005fa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005fa4:	00070084 	.word	0x00070084
 8005fa8:	00030001 	.word	0x00030001
 8005fac:	00030002 	.word	0x00030002
 8005fb0:	00030040 	.word	0x00030040

08005fb4 <i2c_transmit>:

	return true;
}

boolean i2c_transmit(I2CBus * wirex, uint8_t addr, uint8_t * data,
		uint16_t length) {
 8005fb4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005fb8:	461f      	mov	r7, r3
	uint16_t i;
	uint16_t wc;

	wirex->mode = I2C_MODE_MASTERTRANSMITTER;
 8005fba:	2301      	movs	r3, #1
 8005fbc:	7283      	strb	r3, [r0, #10]

	return true;
}

boolean i2c_transmit(I2CBus * wirex, uint8_t addr, uint8_t * data,
		uint16_t length) {
 8005fbe:	4604      	mov	r4, r0
 8005fc0:	4690      	mov	r8, r2
	uint16_t i;
	uint16_t wc;

	wirex->mode = I2C_MODE_MASTERTRANSMITTER;
	//
	if (!i2c_start(wirex, addr))
 8005fc2:	f7ff fefd 	bl	8005dc0 <i2c_start>
 8005fc6:	b9e8      	cbnz	r0, 8006004 <i2c_transmit+0x50>
		return false;
 8005fc8:	2000      	movs	r0, #0
 8005fca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	for (i = 0; i < length; i++) {
		I2C_SendData(wirex->I2Cx, data[i]);
 8005fce:	6820      	ldr	r0, [r4, #0]
 8005fd0:	f818 1005 	ldrb.w	r1, [r8, r5]
 8005fd4:	f7fd f924 	bl	8003220 <I2C_SendData>
		wirex->status = BYTE_TRANSMITTING;
		// Test on EV8 and clear it
		for (wc = 5;
 8005fd8:	2606      	movs	r6, #6
	if (!i2c_start(wirex, addr))
		return false;

	for (i = 0; i < length; i++) {
		I2C_SendData(wirex->I2Cx, data[i]);
		wirex->status = BYTE_TRANSMITTING;
 8005fda:	f884 9009 	strb.w	r9, [r4, #9]
		// Test on EV8 and clear it
		for (wc = 5;
 8005fde:	e007      	b.n	8005ff0 <i2c_transmit+0x3c>
 8005fe0:	3e01      	subs	r6, #1
 8005fe2:	b2b6      	uxth	r6, r6
				!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED );
				wc--) {
			if (wc == 0)
 8005fe4:	2e00      	cmp	r6, #0
 8005fe6:	d0ef      	beq.n	8005fc8 <i2c_transmit+0x14>
				return false;
			delay_us(667);
 8005fe8:	f240 209b 	movw	r0, #667	; 0x29b
 8005fec:	f7ff fd76 	bl	8005adc <delay_us>
	for (i = 0; i < length; i++) {
		I2C_SendData(wirex->I2Cx, data[i]);
		wirex->status = BYTE_TRANSMITTING;
		// Test on EV8 and clear it
		for (wc = 5;
				!I2C_CheckEvent(wirex->I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED );
 8005ff0:	6820      	ldr	r0, [r4, #0]
 8005ff2:	490d      	ldr	r1, [pc, #52]	; (8006028 <i2c_transmit+0x74>)
 8005ff4:	f7fd f970 	bl	80032d8 <I2C_CheckEvent>

	for (i = 0; i < length; i++) {
		I2C_SendData(wirex->I2Cx, data[i]);
		wirex->status = BYTE_TRANSMITTING;
		// Test on EV8 and clear it
		for (wc = 5;
 8005ff8:	2800      	cmp	r0, #0
 8005ffa:	d0f1      	beq.n	8005fe0 <i2c_transmit+0x2c>
				wc--) {
			if (wc == 0)
				return false;
			delay_us(667);
		}
		wirex->status = BYTE_TRANSMITTED;
 8005ffc:	2305      	movs	r3, #5
 8005ffe:	7263      	strb	r3, [r4, #9]
 8006000:	3501      	adds	r5, #1
 8006002:	e002      	b.n	800600a <i2c_transmit+0x56>
	uint16_t i;
	uint16_t wc;

	wirex->mode = I2C_MODE_MASTERTRANSMITTER;
	//
	if (!i2c_start(wirex, addr))
 8006004:	2500      	movs	r5, #0
		return false;

	for (i = 0; i < length; i++) {
		I2C_SendData(wirex->I2Cx, data[i]);
		wirex->status = BYTE_TRANSMITTING;
 8006006:	f04f 0904 	mov.w	r9, #4
	wirex->mode = I2C_MODE_MASTERTRANSMITTER;
	//
	if (!i2c_start(wirex, addr))
		return false;

	for (i = 0; i < length; i++) {
 800600a:	b2ab      	uxth	r3, r5
 800600c:	42bb      	cmp	r3, r7
 800600e:	d3de      	bcc.n	8005fce <i2c_transmit+0x1a>
			delay_us(667);
		}
		wirex->status = BYTE_TRANSMITTED;
	}

	wirex->status = TRANSMISSION_COMPLETED;
 8006010:	2306      	movs	r3, #6
 8006012:	7263      	strb	r3, [r4, #9]

	// generate stop condition
	I2C_GenerateSTOP(wirex->I2Cx, ENABLE);
 8006014:	6820      	ldr	r0, [r4, #0]
 8006016:	2101      	movs	r1, #1
 8006018:	f7fd f874 	bl	8003104 <I2C_GenerateSTOP>
	wirex->status = NOT_READY;
 800601c:	20ff      	movs	r0, #255	; 0xff
	wirex->mode = I2C_MODE_NOTDEFINED;
 800601e:	2300      	movs	r3, #0

	wirex->status = TRANSMISSION_COMPLETED;

	// generate stop condition
	I2C_GenerateSTOP(wirex->I2Cx, ENABLE);
	wirex->status = NOT_READY;
 8006020:	7260      	strb	r0, [r4, #9]
	wirex->mode = I2C_MODE_NOTDEFINED;
 8006022:	72a3      	strb	r3, [r4, #10]

	return true;
}
 8006024:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006028:	00070084 	.word	0x00070084

0800602c <spi_begin>:
#include "spi.h"

//SPI_TypeDef * spix[] = { SPI1, SPI2, SPI3 };

void spi_begin(SPI_TypeDef * SPIx, GPIOPin sck, GPIOPin miso, GPIOPin mosi,
		GPIOPin nss) {
 800602c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006030:	4698      	mov	r8, r3
//	GPIOPin sck, miso, mosi, nss;

	/* PCLK2 = HCLK/2 */
	//RCC_PCLK2Config(RCC_HCLK_Div2);
//	SPIx = spix[spibus];
	if (SPIx == SPI1) {
 8006032:	4b57      	ldr	r3, [pc, #348]	; (8006190 <spi_begin+0x164>)
#include "spi.h"

//SPI_TypeDef * spix[] = { SPI1, SPI2, SPI3 };

void spi_begin(SPI_TypeDef * SPIx, GPIOPin sck, GPIOPin miso, GPIOPin mosi,
		GPIOPin nss) {
 8006034:	b08b      	sub	sp, #44	; 0x2c
//	GPIOPin sck, miso, mosi, nss;

	/* PCLK2 = HCLK/2 */
	//RCC_PCLK2Config(RCC_HCLK_Div2);
//	SPIx = spix[spibus];
	if (SPIx == SPI1) {
 8006036:	4298      	cmp	r0, r3
#include "spi.h"

//SPI_TypeDef * spix[] = { SPI1, SPI2, SPI3 };

void spi_begin(SPI_TypeDef * SPIx, GPIOPin sck, GPIOPin miso, GPIOPin mosi,
		GPIOPin nss) {
 8006038:	4607      	mov	r7, r0
 800603a:	468a      	mov	sl, r1
 800603c:	4691      	mov	r9, r2
 800603e:	f8bd b050 	ldrh.w	fp, [sp, #80]	; 0x50
//	GPIOPin sck, miso, mosi, nss;

	/* PCLK2 = HCLK/2 */
	//RCC_PCLK2Config(RCC_HCLK_Div2);
//	SPIx = spix[spibus];
	if (SPIx == SPI1) {
 8006042:	d105      	bne.n	8006050 <spi_begin+0x24>
//	case SPI1Bus:
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8006044:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006048:	2101      	movs	r1, #1
 800604a:	f7fd fb8b 	bl	8003764 <RCC_APB2PeriphClockCmd>
 800604e:	e007      	b.n	8006060 <spi_begin+0x34>
//		 sck = PA5; // PB3
//		 miso = PA6; // PB4
//		 mosi = PA7; // PB5
//		 nss = PA4; // PA15
//		break;
	} else if ( SPIx == SPI2 ) {
 8006050:	4b50      	ldr	r3, [pc, #320]	; (8006194 <spi_begin+0x168>)
 8006052:	4298      	cmp	r0, r3
 8006054:	d106      	bne.n	8006064 <spi_begin+0x38>
//	case SPI2Bus:
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8006056:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800605a:	2101      	movs	r1, #1
 800605c:	f7fd fb76 	bl	800374c <RCC_APB1PeriphClockCmd>
		af = GPIO_AF_SPI2;
 8006060:	2605      	movs	r6, #5
 8006062:	e005      	b.n	8006070 <spi_begin+0x44>
		// PB12, 13, 14, 15
//		break;
	} else {
//	case SPI3Bus:
//	default:
		RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 8006064:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006068:	2101      	movs	r1, #1
 800606a:	f7fd fbab 	bl	80037c4 <RCC_APB1PeriphResetCmd>
		af = GPIO_AF_SPI3;
 800606e:	2606      	movs	r6, #6
//		 mosi = PB5;
//		 nss = PA15; // PA4;
//		break;
	}

	GPIOMode(PinPort(sck), PinBit(sck), GPIO_Mode_AF, GPIO_Speed_25MHz,
 8006070:	4650      	mov	r0, sl
 8006072:	f7ff fd5f 	bl	8005b34 <PinPort>
 8006076:	4603      	mov	r3, r0
 8006078:	4650      	mov	r0, sl
 800607a:	9303      	str	r3, [sp, #12]
 800607c:	f7ff fd62 	bl	8005b44 <PinBit>
 8006080:	9b03      	ldr	r3, [sp, #12]
 8006082:	2401      	movs	r4, #1
 8006084:	2500      	movs	r5, #0
 8006086:	4601      	mov	r1, r0
 8006088:	2202      	movs	r2, #2
 800608a:	4618      	mov	r0, r3
 800608c:	9500      	str	r5, [sp, #0]
 800608e:	4623      	mov	r3, r4
 8006090:	9401      	str	r4, [sp, #4]
 8006092:	f7ff fdc1 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_UP);
	GPIOMode(PinPort(miso), PinBit(miso), GPIO_Mode_AF, GPIO_Speed_25MHz,
 8006096:	4648      	mov	r0, r9
 8006098:	f7ff fd4c 	bl	8005b34 <PinPort>
 800609c:	4603      	mov	r3, r0
 800609e:	4648      	mov	r0, r9
 80060a0:	9303      	str	r3, [sp, #12]
 80060a2:	f7ff fd4f 	bl	8005b44 <PinBit>
 80060a6:	9b03      	ldr	r3, [sp, #12]
 80060a8:	9500      	str	r5, [sp, #0]
 80060aa:	4601      	mov	r1, r0
 80060ac:	2202      	movs	r2, #2
 80060ae:	4618      	mov	r0, r3
 80060b0:	9401      	str	r4, [sp, #4]
 80060b2:	4623      	mov	r3, r4
 80060b4:	f7ff fdb0 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_UP);
	GPIOMode(PinPort(mosi), PinBit(mosi), GPIO_Mode_AF, GPIO_Speed_25MHz,
 80060b8:	4640      	mov	r0, r8
 80060ba:	f7ff fd3b 	bl	8005b34 <PinPort>
 80060be:	4603      	mov	r3, r0
 80060c0:	4640      	mov	r0, r8
 80060c2:	9303      	str	r3, [sp, #12]
 80060c4:	f7ff fd3e 	bl	8005b44 <PinBit>
 80060c8:	9b03      	ldr	r3, [sp, #12]
 80060ca:	9500      	str	r5, [sp, #0]
 80060cc:	4601      	mov	r1, r0
 80060ce:	2202      	movs	r2, #2
 80060d0:	4618      	mov	r0, r3
 80060d2:	9401      	str	r4, [sp, #4]
 80060d4:	4623      	mov	r3, r4
 80060d6:	f7ff fd9f 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_UP);
	GPIO_PinAFConfig(PinPort(sck), PinSource(sck), af);
 80060da:	4650      	mov	r0, sl
 80060dc:	f7ff fd2a 	bl	8005b34 <PinPort>
 80060e0:	4603      	mov	r3, r0
 80060e2:	4650      	mov	r0, sl
 80060e4:	9303      	str	r3, [sp, #12]
 80060e6:	f7ff fd34 	bl	8005b52 <PinSource>
 80060ea:	9b03      	ldr	r3, [sp, #12]
 80060ec:	4601      	mov	r1, r0
 80060ee:	4632      	mov	r2, r6
 80060f0:	4618      	mov	r0, r3
 80060f2:	f7fc fc90 	bl	8002a16 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PinPort(miso), PinSource(miso), af);
 80060f6:	4648      	mov	r0, r9
 80060f8:	f7ff fd1c 	bl	8005b34 <PinPort>
 80060fc:	4682      	mov	sl, r0
 80060fe:	4648      	mov	r0, r9
 8006100:	f7ff fd27 	bl	8005b52 <PinSource>
 8006104:	4632      	mov	r2, r6
 8006106:	4601      	mov	r1, r0
 8006108:	4650      	mov	r0, sl
 800610a:	f7fc fc84 	bl	8002a16 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PinPort(mosi), PinSource(mosi), af);
 800610e:	4640      	mov	r0, r8
 8006110:	f7ff fd10 	bl	8005b34 <PinPort>
 8006114:	4681      	mov	r9, r0
 8006116:	4640      	mov	r0, r8
 8006118:	f7ff fd1b 	bl	8005b52 <PinSource>
 800611c:	4632      	mov	r2, r6
 800611e:	4601      	mov	r1, r0
 8006120:	4648      	mov	r0, r9
 8006122:	f7fc fc78 	bl	8002a16 <GPIO_PinAFConfig>
	// nSS by software
	GPIOMode(PinPort(nss), PinBit(nss), GPIO_Mode_OUT, GPIO_Speed_25MHz,
 8006126:	4658      	mov	r0, fp
 8006128:	f7ff fd04 	bl	8005b34 <PinPort>
 800612c:	4606      	mov	r6, r0
 800612e:	4658      	mov	r0, fp
 8006130:	f7ff fd08 	bl	8005b44 <PinBit>
 8006134:	4622      	mov	r2, r4
 8006136:	4623      	mov	r3, r4
 8006138:	4601      	mov	r1, r0
 800613a:	9500      	str	r5, [sp, #0]
 800613c:	4630      	mov	r0, r6
 800613e:	9401      	str	r4, [sp, #4]
 8006140:	f7ff fd6a 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_UP);
	digitalWrite(nss, HIGH);
 8006144:	4658      	mov	r0, fp
 8006146:	4621      	mov	r1, r4
 8006148:	f7ff fd2c 	bl	8005ba4 <digitalWrite>
	//GPIO_PinAFConfig(PinPort(nss), PinSource(nss), af);

	SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;
 800614c:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006150:	f8ad 3016 	strh.w	r3, [sp, #22]
	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;
 8006154:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006158:	f8ad 301e 	strh.w	r3, [sp, #30]
	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStruct.SPI_CRCPolynomial = SPI_CRC_Rx;

	SPI_Init(SPIx, &SPI_InitStruct);
 800615c:	4638      	mov	r0, r7
	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;
	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 800615e:	2310      	movs	r3, #16
	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStruct.SPI_CRCPolynomial = SPI_CRC_Rx;

	SPI_Init(SPIx, &SPI_InitStruct);
 8006160:	a905      	add	r1, sp, #20
	GPIOMode(PinPort(nss), PinBit(nss), GPIO_Mode_OUT, GPIO_Speed_25MHz,
			GPIO_OType_PP, GPIO_PuPd_UP);
	digitalWrite(nss, HIGH);
	//GPIO_PinAFConfig(PinPort(nss), PinSource(nss), af);

	SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8006162:	f8ad 5014 	strh.w	r5, [sp, #20]
	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;
	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;
 8006166:	f8ad 5018 	strh.w	r5, [sp, #24]
	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;
 800616a:	f8ad 501a 	strh.w	r5, [sp, #26]
	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;
 800616e:	f8ad 501c 	strh.w	r5, [sp, #28]
	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8006172:	f8ad 3020 	strh.w	r3, [sp, #32]
	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;
 8006176:	f8ad 5022 	strh.w	r5, [sp, #34]	; 0x22
	SPI_InitStruct.SPI_CRCPolynomial = SPI_CRC_Rx;
 800617a:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24

	SPI_Init(SPIx, &SPI_InitStruct);
 800617e:	f7fe fa83 	bl	8004688 <SPI_Init>

	SPI_Cmd(SPIx, ENABLE);
 8006182:	4638      	mov	r0, r7
 8006184:	4621      	mov	r1, r4
 8006186:	f7fe fb18 	bl	80047ba <SPI_Cmd>
	 *              - Enable or disable the SS output using the SPI_SSOutputCmd() function
	 *
	 *          10. To use the CRC Hardware calculation feature refer to the Peripheral
	 *              CRC hardware Calculation subsection.
	 */
}
 800618a:	b00b      	add	sp, #44	; 0x2c
 800618c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006190:	40013000 	.word	0x40013000
 8006194:	40003800 	.word	0x40003800

08006198 <spi_transfer>:

void spi_transfer(SPI_TypeDef * SPIx, /*SPIBus spibus,*/ uint8_t * data, uint16_t nbytes) {
 8006198:	b570      	push	{r4, r5, r6, lr}
 800619a:	4604      	mov	r4, r0
 800619c:	4615      	mov	r5, r2
 800619e:	1e4e      	subs	r6, r1, #1
//	SPI_TypeDef * SPIx = spix[spibus];
	uint8_t rcvdata;

	for (; nbytes; nbytes--) {
 80061a0:	e016      	b.n	80061d0 <spi_transfer+0x38>
		/* Wait for SPIx Tx buffer empty */
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE ) == RESET)
 80061a2:	4620      	mov	r0, r4
 80061a4:	2102      	movs	r1, #2
 80061a6:	f7fe fbbb 	bl	8004920 <SPI_I2S_GetFlagStatus>
 80061aa:	2800      	cmp	r0, #0
 80061ac:	d0f9      	beq.n	80061a2 <spi_transfer+0xa>
			;
		SPI_I2S_SendData(SPIx, (uint16_t) *data);
 80061ae:	4620      	mov	r0, r4
 80061b0:	7871      	ldrb	r1, [r6, #1]
 80061b2:	f7fe fb7f 	bl	80048b4 <SPI_I2S_SendData>
		/* Wait for SPIx data reception */
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE ) == RESET)
 80061b6:	4620      	mov	r0, r4
 80061b8:	2101      	movs	r1, #1
 80061ba:	f7fe fbb1 	bl	8004920 <SPI_I2S_GetFlagStatus>
 80061be:	2800      	cmp	r0, #0
 80061c0:	d0f9      	beq.n	80061b6 <spi_transfer+0x1e>
			;
		/* Read SPIy received data */
		rcvdata = SPI_I2S_ReceiveData(SPIx);
 80061c2:	4620      	mov	r0, r4
 80061c4:	f7fe fb73 	bl	80048ae <SPI_I2S_ReceiveData>

void spi_transfer(SPI_TypeDef * SPIx, /*SPIBus spibus,*/ uint8_t * data, uint16_t nbytes) {
//	SPI_TypeDef * SPIx = spix[spibus];
	uint8_t rcvdata;

	for (; nbytes; nbytes--) {
 80061c8:	3d01      	subs	r5, #1
		SPI_I2S_SendData(SPIx, (uint16_t) *data);
		/* Wait for SPIx data reception */
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE ) == RESET)
			;
		/* Read SPIy received data */
		rcvdata = SPI_I2S_ReceiveData(SPIx);
 80061ca:	f806 0f01 	strb.w	r0, [r6, #1]!

void spi_transfer(SPI_TypeDef * SPIx, /*SPIBus spibus,*/ uint8_t * data, uint16_t nbytes) {
//	SPI_TypeDef * SPIx = spix[spibus];
	uint8_t rcvdata;

	for (; nbytes; nbytes--) {
 80061ce:	b2ad      	uxth	r5, r5
 80061d0:	2d00      	cmp	r5, #0
 80061d2:	d1e6      	bne.n	80061a2 <spi_transfer+0xa>
		/* Read SPIy received data */
		rcvdata = SPI_I2S_ReceiveData(SPIx);
		*data = rcvdata;
		data++;
	}
}
 80061d4:	bd70      	pop	{r4, r5, r6, pc}
 80061d6:	bf00      	nop

080061d8 <SysTick_Handler>:
#include "systick.h"

volatile uint32_t _systick_counter;

void SysTick_Handler(void) {
	_systick_counter++; /* increment timeTicks counter */
 80061d8:	4b02      	ldr	r3, [pc, #8]	; (80061e4 <SysTick_Handler+0xc>)
 80061da:	681a      	ldr	r2, [r3, #0]
 80061dc:	3201      	adds	r2, #1
 80061de:	601a      	str	r2, [r3, #0]
 80061e0:	4770      	bx	lr
 80061e2:	bf00      	nop
 80061e4:	20000694 	.word	0x20000694

080061e8 <SysTick_delay>:
}

void SysTick_delay(const uint32_t dlyTicks) {
	uint32_t currTicks = _systick_counter;
 80061e8:	4b03      	ldr	r3, [pc, #12]	; (80061f8 <SysTick_delay+0x10>)
 80061ea:	6819      	ldr	r1, [r3, #0]

	while ((_systick_counter - currTicks) < dlyTicks)
 80061ec:	681a      	ldr	r2, [r3, #0]
 80061ee:	1a52      	subs	r2, r2, r1
 80061f0:	4282      	cmp	r2, r0
 80061f2:	d3fb      	bcc.n	80061ec <SysTick_delay+0x4>
		;
}
 80061f4:	4770      	bx	lr
 80061f6:	bf00      	nop
 80061f8:	20000694 	.word	0x20000694

080061fc <SysTick_Start>:

void SysTick_Start(void) {
 80061fc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	RCC_ClocksTypeDef RCC_Clocks;
	  /* SysTick end of count event each 1ms */
	  RCC_GetClocksFreq(&RCC_Clocks);
 80061fe:	4668      	mov	r0, sp
 8006200:	f7fd fa10 	bl	8003624 <RCC_GetClocksFreq>
	  SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000);
 8006204:	9b01      	ldr	r3, [sp, #4]
 8006206:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800620a:	fbb3 f3f2 	udiv	r3, r3, r2
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 800620e:	1e5a      	subs	r2, r3, #1
 8006210:	4b05      	ldr	r3, [pc, #20]	; (8006228 <SysTick_Start+0x2c>)
 8006212:	605a      	str	r2, [r3, #4]
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8006214:	4a05      	ldr	r2, [pc, #20]	; (800622c <SysTick_Start+0x30>)
 8006216:	21f0      	movs	r1, #240	; 0xf0
 8006218:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 800621c:	2200      	movs	r2, #0
 800621e:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8006220:	2207      	movs	r2, #7
 8006222:	601a      	str	r2, [r3, #0]
		// Handle Error
		while (1)
			;
	}
*/
}
 8006224:	b005      	add	sp, #20
 8006226:	bd00      	pop	{pc}
 8006228:	e000e010 	.word	0xe000e010
 800622c:	e000ed00 	.word	0xe000ed00

08006230 <SysTick_count>:

uint32_t SysTick_count() {
	return _systick_counter;
 8006230:	4b01      	ldr	r3, [pc, #4]	; (8006238 <SysTick_count+0x8>)
 8006232:	6818      	ldr	r0, [r3, #0]
}
 8006234:	4770      	bx	lr
 8006236:	bf00      	nop
 8006238:	20000694 	.word	0x20000694

0800623c <ring_clear>:
};

USARTRing rxring[6], txring[6];

void ring_clear(USARTRing * r) {
	r->head = 0;
 800623c:	2300      	movs	r3, #0
 800623e:	f8a0 3100 	strh.w	r3, [r0, #256]	; 0x100
	r->tail = 0;
 8006242:	f8a0 3102 	strh.w	r3, [r0, #258]	; 0x102
	r->count = 0;
 8006246:	f8a0 3104 	strh.w	r3, [r0, #260]	; 0x104
 800624a:	4770      	bx	lr

0800624c <ring_count>:
}

uint16_t ring_count(USARTRing * r) {
	return r->count;
}
 800624c:	f8b0 0104 	ldrh.w	r0, [r0, #260]	; 0x104
 8006250:	4770      	bx	lr

08006252 <ring_is_full>:

uint8_t ring_is_full(USARTRing * r) {
	if ((r->head == r->tail) && (r->count > 0)) {
 8006252:	f9b0 2100 	ldrsh.w	r2, [r0, #256]	; 0x100
 8006256:	f9b0 3102 	ldrsh.w	r3, [r0, #258]	; 0x102
 800625a:	429a      	cmp	r2, r3
 800625c:	d105      	bne.n	800626a <ring_is_full+0x18>
 800625e:	f8b0 0104 	ldrh.w	r0, [r0, #260]	; 0x104
		return 1;
 8006262:	3000      	adds	r0, #0
 8006264:	bf18      	it	ne
 8006266:	2001      	movne	r0, #1
 8006268:	4770      	bx	lr
	}
	return 0;
 800626a:	2000      	movs	r0, #0
}
 800626c:	4770      	bx	lr

0800626e <ring_enque>:

uint16_t ring_enque(USARTRing * r, uint16_t w) {
 800626e:	b538      	push	{r3, r4, r5, lr}
 8006270:	4604      	mov	r4, r0
 8006272:	460d      	mov	r5, r1
	if (ring_is_full(r))
 8006274:	f7ff ffed 	bl	8006252 <ring_is_full>
 8006278:	b9b0      	cbnz	r0, 80062a8 <ring_enque+0x3a>
		return 0xffff;
	r->buf[r->head++] = w;
 800627a:	f8b4 3100 	ldrh.w	r3, [r4, #256]	; 0x100
 800627e:	b21a      	sxth	r2, r3
 8006280:	3301      	adds	r3, #1
 8006282:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
	r->count++;
 8006286:	f8b4 2104 	ldrh.w	r2, [r4, #260]	; 0x104
 800628a:	3201      	adds	r2, #1
 800628c:	f8a4 2104 	strh.w	r2, [r4, #260]	; 0x104
	r->head %= USART_BUFFER_SIZE;
 8006290:	b21a      	sxth	r2, r3
 8006292:	4b07      	ldr	r3, [pc, #28]	; (80062b0 <ring_enque+0x42>)
 8006294:	4013      	ands	r3, r2
 8006296:	2b00      	cmp	r3, #0
 8006298:	da03      	bge.n	80062a2 <ring_enque+0x34>
 800629a:	3b01      	subs	r3, #1
 800629c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80062a0:	3301      	adds	r3, #1
 80062a2:	f8a4 3100 	strh.w	r3, [r4, #256]	; 0x100
 80062a6:	e001      	b.n	80062ac <ring_enque+0x3e>
	return 0;
}

uint16_t ring_enque(USARTRing * r, uint16_t w) {
	if (ring_is_full(r))
		return 0xffff;
 80062a8:	f64f 75ff 	movw	r5, #65535	; 0xffff
	r->buf[r->head++] = w;
	r->count++;
	r->head %= USART_BUFFER_SIZE;
	return w;
}
 80062ac:	4628      	mov	r0, r5
 80062ae:	bd38      	pop	{r3, r4, r5, pc}
 80062b0:	8000007f 	.word	0x8000007f

080062b4 <ring_deque>:
	r->tail = 0;
	r->count = 0;
}

uint16_t ring_count(USARTRing * r) {
	return r->count;
 80062b4:	f8b0 1104 	ldrh.w	r1, [r0, #260]	; 0x104
	r->count++;
	r->head %= USART_BUFFER_SIZE;
	return w;
}

uint16_t ring_deque(USARTRing * r) {
 80062b8:	4602      	mov	r2, r0
	uint16_t w;
	if (ring_count(r) == 0)
 80062ba:	b1a1      	cbz	r1, 80062e6 <ring_deque+0x32>
		return 0xffff;
	w = r->buf[r->tail++];
 80062bc:	f8b0 3102 	ldrh.w	r3, [r0, #258]	; 0x102
	r->count--;
 80062c0:	3901      	subs	r1, #1

uint16_t ring_deque(USARTRing * r) {
	uint16_t w;
	if (ring_count(r) == 0)
		return 0xffff;
	w = r->buf[r->tail++];
 80062c2:	b218      	sxth	r0, r3
 80062c4:	3301      	adds	r3, #1
	r->count--;
 80062c6:	f8a2 1104 	strh.w	r1, [r2, #260]	; 0x104
	r->tail %= USART_BUFFER_SIZE;
 80062ca:	b219      	sxth	r1, r3
 80062cc:	4b07      	ldr	r3, [pc, #28]	; (80062ec <ring_deque+0x38>)

uint16_t ring_deque(USARTRing * r) {
	uint16_t w;
	if (ring_count(r) == 0)
		return 0xffff;
	w = r->buf[r->tail++];
 80062ce:	f832 0010 	ldrh.w	r0, [r2, r0, lsl #1]
	r->count--;
	r->tail %= USART_BUFFER_SIZE;
 80062d2:	400b      	ands	r3, r1
 80062d4:	2b00      	cmp	r3, #0
 80062d6:	da03      	bge.n	80062e0 <ring_deque+0x2c>
 80062d8:	3b01      	subs	r3, #1
 80062da:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80062de:	3301      	adds	r3, #1
 80062e0:	f8a2 3102 	strh.w	r3, [r2, #258]	; 0x102
	return w;
 80062e4:	4770      	bx	lr
}

uint16_t ring_deque(USARTRing * r) {
	uint16_t w;
	if (ring_count(r) == 0)
		return 0xffff;
 80062e6:	f64f 70ff 	movw	r0, #65535	; 0xffff
	w = r->buf[r->tail++];
	r->count--;
	r->tail %= USART_BUFFER_SIZE;
	return w;
}
 80062ea:	4770      	bx	lr
 80062ec:	8000007f 	.word	0x8000007f

080062f0 <ring_peek>:

uint16_t ring_peek(USARTRing * r) {
	if (ring_count(r) == 0)
 80062f0:	f8b0 3104 	ldrh.w	r3, [r0, #260]	; 0x104
 80062f4:	b123      	cbz	r3, 8006300 <ring_peek+0x10>
		return 0xffff;
	return r->buf[r->tail];
 80062f6:	f9b0 3102 	ldrsh.w	r3, [r0, #258]	; 0x102
 80062fa:	f830 0013 	ldrh.w	r0, [r0, r3, lsl #1]
 80062fe:	4770      	bx	lr
	return w;
}

uint16_t ring_peek(USARTRing * r) {
	if (ring_count(r) == 0)
		return 0xffff;
 8006300:	f64f 70ff 	movw	r0, #65535	; 0xffff
	return r->buf[r->tail];
}
 8006304:	4770      	bx	lr

08006306 <usart_begin>:

void usart_begin(USART_TypeDef * usartx, USART * usx, GPIOPin rx, GPIOPin tx, uint32_t baud) {
 8006306:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800630a:	4698      	mov	r8, r3
	//
	usx->USARTx = usartx;
	uint8_t af = GPIO_AF_USART1;
	IRQn_Type irq = USART1_IRQn;

	if (usartx == USART1) {
 800630c:	4b6a      	ldr	r3, [pc, #424]	; (80064b8 <usart_begin+0x1b2>)

void usart_begin(USART_TypeDef * usartx, USART * usx, GPIOPin rx, GPIOPin tx, uint32_t baud) {
	USART_InitTypeDef USART_InitStruct; // this is for the USART1 initilization
	NVIC_InitTypeDef NVIC_InitStructure; // this is used to configure the NVIC (nested vector interrupt controller)
	//
	usx->USARTx = usartx;
 800630e:	6048      	str	r0, [r1, #4]
	uint8_t af = GPIO_AF_USART1;
	IRQn_Type irq = USART1_IRQn;

	if (usartx == USART1) {
 8006310:	4298      	cmp	r0, r3
	if (ring_count(r) == 0)
		return 0xffff;
	return r->buf[r->tail];
}

void usart_begin(USART_TypeDef * usartx, USART * usx, GPIOPin rx, GPIOPin tx, uint32_t baud) {
 8006312:	b088      	sub	sp, #32
 8006314:	460c      	mov	r4, r1
 8006316:	4691      	mov	r9, r2
	//
	usx->USARTx = usartx;
	uint8_t af = GPIO_AF_USART1;
	IRQn_Type irq = USART1_IRQn;

	if (usartx == USART1) {
 8006318:	d10b      	bne.n	8006332 <usart_begin+0x2c>
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 800631a:	2010      	movs	r0, #16
 800631c:	2101      	movs	r1, #1
 800631e:	f7fd fa21 	bl	8003764 <RCC_APB2PeriphClockCmd>
		af = GPIO_AF_USART1;
		irq = USART1_IRQn;
		usx->usid = USART1Serial;
 8006322:	2300      	movs	r3, #0
 8006324:	7023      	strb	r3, [r4, #0]
		usx->rxring = &rxring[USART1Serial];
 8006326:	4b65      	ldr	r3, [pc, #404]	; (80064bc <usart_begin+0x1b6>)
 8006328:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[USART1Serial];
 800632a:	4b65      	ldr	r3, [pc, #404]	; (80064c0 <usart_begin+0x1ba>)
	IRQn_Type irq = USART1_IRQn;

	if (usartx == USART1) {
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
		af = GPIO_AF_USART1;
		irq = USART1_IRQn;
 800632c:	2725      	movs	r7, #37	; 0x25
		usx->usid = USART1Serial;
		usx->rxring = &rxring[USART1Serial];
		usx->txring = &txring[USART1Serial];
 800632e:	60e3      	str	r3, [r4, #12]
 8006330:	e00e      	b.n	8006350 <usart_begin+0x4a>
	} else if (usx->USARTx == USART2) {
 8006332:	4b64      	ldr	r3, [pc, #400]	; (80064c4 <usart_begin+0x1be>)
 8006334:	4298      	cmp	r0, r3
 8006336:	d10d      	bne.n	8006354 <usart_begin+0x4e>
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 8006338:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800633c:	2101      	movs	r1, #1
 800633e:	f7fd fa05 	bl	800374c <RCC_APB1PeriphClockCmd>
		af = GPIO_AF_USART2;
		irq = USART2_IRQn;
		usx->usid = USART2Serial;
 8006342:	2301      	movs	r3, #1
 8006344:	7023      	strb	r3, [r4, #0]
//		usx->USARTx = USART2;
		usx->rxring = &rxring[USART2Serial];
 8006346:	4b60      	ldr	r3, [pc, #384]	; (80064c8 <usart_begin+0x1c2>)
 8006348:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[USART2Serial];
 800634a:	4b60      	ldr	r3, [pc, #384]	; (80064cc <usart_begin+0x1c6>)
		usx->rxring = &rxring[USART1Serial];
		usx->txring = &txring[USART1Serial];
	} else if (usx->USARTx == USART2) {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
		af = GPIO_AF_USART2;
		irq = USART2_IRQn;
 800634c:	2726      	movs	r7, #38	; 0x26
		usx->usid = USART2Serial;
//		usx->USARTx = USART2;
		usx->rxring = &rxring[USART2Serial];
		usx->txring = &txring[USART2Serial];
 800634e:	60e3      	str	r3, [r4, #12]
		usx->usid = USART1Serial;
		usx->rxring = &rxring[USART1Serial];
		usx->txring = &txring[USART1Serial];
	} else if (usx->USARTx == USART2) {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
		af = GPIO_AF_USART2;
 8006350:	2607      	movs	r6, #7
 8006352:	e03b      	b.n	80063cc <usart_begin+0xc6>
		irq = USART2_IRQn;
		usx->usid = USART2Serial;
//		usx->USARTx = USART2;
		usx->rxring = &rxring[USART2Serial];
		usx->txring = &txring[USART2Serial];
	} else if (usx->USARTx == USART3) {
 8006354:	4b5e      	ldr	r3, [pc, #376]	; (80064d0 <usart_begin+0x1ca>)
 8006356:	4298      	cmp	r0, r3
 8006358:	d10c      	bne.n	8006374 <usart_begin+0x6e>
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 800635a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800635e:	2101      	movs	r1, #1
 8006360:	f7fd f9f4 	bl	800374c <RCC_APB1PeriphClockCmd>
		af = GPIO_AF_USART3;
		irq = USART3_IRQn;
		usx->usid = USART3Serial;
 8006364:	2302      	movs	r3, #2
 8006366:	7023      	strb	r3, [r4, #0]
//		usx->USARTx = USART3;
		usx->rxring = &rxring[USART3Serial];
 8006368:	4b5a      	ldr	r3, [pc, #360]	; (80064d4 <usart_begin+0x1ce>)
 800636a:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[USART3Serial];
 800636c:	4b5a      	ldr	r3, [pc, #360]	; (80064d8 <usart_begin+0x1d2>)
		usx->rxring = &rxring[USART2Serial];
		usx->txring = &txring[USART2Serial];
	} else if (usx->USARTx == USART3) {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
		af = GPIO_AF_USART3;
		irq = USART3_IRQn;
 800636e:	2727      	movs	r7, #39	; 0x27
		usx->usid = USART3Serial;
//		usx->USARTx = USART3;
		usx->rxring = &rxring[USART3Serial];
		usx->txring = &txring[USART3Serial];
 8006370:	60e3      	str	r3, [r4, #12]
 8006372:	e7ed      	b.n	8006350 <usart_begin+0x4a>
	} else if (usx->USARTx == UART4) {
 8006374:	4b59      	ldr	r3, [pc, #356]	; (80064dc <usart_begin+0x1d6>)
 8006376:	4298      	cmp	r0, r3
 8006378:	d10c      	bne.n	8006394 <usart_begin+0x8e>
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
 800637a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800637e:	2101      	movs	r1, #1
 8006380:	f7fd f9e4 	bl	800374c <RCC_APB1PeriphClockCmd>
		af = GPIO_AF_UART4;
		irq = UART4_IRQn;
		usx->usid = UART4Serial;
 8006384:	2303      	movs	r3, #3
 8006386:	7023      	strb	r3, [r4, #0]
//		usx->USARTx = UART4;
		usx->rxring = &rxring[UART4Serial];
 8006388:	4b55      	ldr	r3, [pc, #340]	; (80064e0 <usart_begin+0x1da>)
 800638a:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[UART4Serial];
 800638c:	4b55      	ldr	r3, [pc, #340]	; (80064e4 <usart_begin+0x1de>)
		usx->rxring = &rxring[USART3Serial];
		usx->txring = &txring[USART3Serial];
	} else if (usx->USARTx == UART4) {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
		af = GPIO_AF_UART4;
		irq = UART4_IRQn;
 800638e:	2734      	movs	r7, #52	; 0x34
		usx->usid = UART4Serial;
//		usx->USARTx = UART4;
		usx->rxring = &rxring[UART4Serial];
		usx->txring = &txring[UART4Serial];
 8006390:	60e3      	str	r3, [r4, #12]
 8006392:	e01a      	b.n	80063ca <usart_begin+0xc4>
	} else if (usx->USARTx == UART5) {
 8006394:	4b54      	ldr	r3, [pc, #336]	; (80064e8 <usart_begin+0x1e2>)
 8006396:	4298      	cmp	r0, r3
 8006398:	d10c      	bne.n	80063b4 <usart_begin+0xae>
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
 800639a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800639e:	2101      	movs	r1, #1
 80063a0:	f7fd f9d4 	bl	800374c <RCC_APB1PeriphClockCmd>
		af = GPIO_AF_UART5;
		irq = UART5_IRQn;
		usx->usid = UART5Serial;
 80063a4:	2304      	movs	r3, #4
 80063a6:	7023      	strb	r3, [r4, #0]
//		usx->USARTx = UART5;
		usx->rxring = &rxring[UART5Serial];
 80063a8:	4b50      	ldr	r3, [pc, #320]	; (80064ec <usart_begin+0x1e6>)
 80063aa:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[UART5Serial];
 80063ac:	4b50      	ldr	r3, [pc, #320]	; (80064f0 <usart_begin+0x1ea>)
		usx->rxring = &rxring[UART4Serial];
		usx->txring = &txring[UART4Serial];
	} else if (usx->USARTx == UART5) {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
		af = GPIO_AF_UART5;
		irq = UART5_IRQn;
 80063ae:	2735      	movs	r7, #53	; 0x35
		usx->usid = UART5Serial;
//		usx->USARTx = UART5;
		usx->rxring = &rxring[UART5Serial];
		usx->txring = &txring[UART5Serial];
 80063b0:	60e3      	str	r3, [r4, #12]
 80063b2:	e00a      	b.n	80063ca <usart_begin+0xc4>
	} else { // Serial6
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
 80063b4:	2020      	movs	r0, #32
 80063b6:	2101      	movs	r1, #1
 80063b8:	f7fd f9d4 	bl	8003764 <RCC_APB2PeriphClockCmd>
		af = GPIO_AF_USART6;
		irq = USART6_IRQn;
		usx->usid = USART6Serial;
 80063bc:	2305      	movs	r3, #5
 80063be:	7023      	strb	r3, [r4, #0]
//		usx->USARTx = USART6;
		usx->rxring = &rxring[USART6Serial];
 80063c0:	4b4c      	ldr	r3, [pc, #304]	; (80064f4 <usart_begin+0x1ee>)
 80063c2:	60a3      	str	r3, [r4, #8]
		usx->txring = &txring[USART6Serial];
 80063c4:	4b4c      	ldr	r3, [pc, #304]	; (80064f8 <usart_begin+0x1f2>)
		usx->rxring = &rxring[UART5Serial];
		usx->txring = &txring[UART5Serial];
	} else { // Serial6
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
		af = GPIO_AF_USART6;
		irq = USART6_IRQn;
 80063c6:	2747      	movs	r7, #71	; 0x47
		usx->usid = USART6Serial;
//		usx->USARTx = USART6;
		usx->rxring = &rxring[USART6Serial];
		usx->txring = &txring[USART6Serial];
 80063c8:	60e3      	str	r3, [r4, #12]
//		usx->USARTx = UART5;
		usx->rxring = &rxring[UART5Serial];
		usx->txring = &txring[UART5Serial];
	} else { // Serial6
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
		af = GPIO_AF_USART6;
 80063ca:	2608      	movs	r6, #8
//		usx->USARTx = USART6;
		usx->rxring = &rxring[USART6Serial];
		usx->txring = &txring[USART6Serial];
	}

	GPIOMode(PinPort(rx), PinBit(rx), GPIO_Mode_AF, GPIO_Speed_50MHz,
 80063cc:	4648      	mov	r0, r9
 80063ce:	f7ff fbb1 	bl	8005b34 <PinPort>
 80063d2:	4682      	mov	sl, r0
 80063d4:	4648      	mov	r0, r9
 80063d6:	f7ff fbb5 	bl	8005b44 <PinBit>
 80063da:	2500      	movs	r5, #0
 80063dc:	2202      	movs	r2, #2
 80063de:	4601      	mov	r1, r0
 80063e0:	4613      	mov	r3, r2
 80063e2:	4650      	mov	r0, sl
 80063e4:	9500      	str	r5, [sp, #0]
 80063e6:	9501      	str	r5, [sp, #4]
 80063e8:	f7ff fc16 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_NOPULL);
	GPIOMode(PinPort(tx), PinBit(tx), GPIO_Mode_AF, GPIO_Speed_50MHz,
 80063ec:	4640      	mov	r0, r8
 80063ee:	f7ff fba1 	bl	8005b34 <PinPort>
 80063f2:	4682      	mov	sl, r0
 80063f4:	4640      	mov	r0, r8
 80063f6:	f7ff fba5 	bl	8005b44 <PinBit>
 80063fa:	2202      	movs	r2, #2
 80063fc:	4613      	mov	r3, r2
 80063fe:	4601      	mov	r1, r0
 8006400:	9500      	str	r5, [sp, #0]
 8006402:	4650      	mov	r0, sl
 8006404:	9501      	str	r5, [sp, #4]
 8006406:	f7ff fc07 	bl	8005c18 <GPIOMode>
			GPIO_OType_PP, GPIO_PuPd_NOPULL);

	GPIO_PinAFConfig(PinPort(rx), PinSource(rx), af);
 800640a:	4648      	mov	r0, r9
 800640c:	f7ff fb92 	bl	8005b34 <PinPort>
 8006410:	4682      	mov	sl, r0
 8006412:	4648      	mov	r0, r9
 8006414:	f7ff fb9d 	bl	8005b52 <PinSource>
 8006418:	4632      	mov	r2, r6
 800641a:	4601      	mov	r1, r0
 800641c:	4650      	mov	r0, sl
 800641e:	f7fc fafa 	bl	8002a16 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(PinPort(tx), PinSource(tx), af);
 8006422:	4640      	mov	r0, r8
 8006424:	f7ff fb86 	bl	8005b34 <PinPort>
 8006428:	4681      	mov	r9, r0
 800642a:	4640      	mov	r0, r8
 800642c:	f7ff fb91 	bl	8005b52 <PinSource>
 8006430:	4632      	mov	r2, r6
 8006432:	4601      	mov	r1, r0
 8006434:	4648      	mov	r0, r9
 8006436:	f7fc faee 	bl	8002a16 <GPIO_PinAFConfig>

	USART_InitStruct.USART_BaudRate = baud;	// the baudrate is set to the value we passed into this init function
 800643a:	9b10      	ldr	r3, [sp, #64]	; 0x40
	USART_InitStruct.USART_StopBits = USART_StopBits_1;	// we want 1 stop bit (standard)
	USART_InitStruct.USART_Parity = USART_Parity_No;// we don't want a parity bit (standard)
	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // we don't want flow control (standard)
	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // we want to enable the transmitter and the receiver

	USART_Init(usx->USARTx, &USART_InitStruct); // again all the properties are passed to the USART_Init function which takes care of all the bit setting
 800643c:	6860      	ldr	r0, [r4, #4]
			GPIO_OType_PP, GPIO_PuPd_NOPULL);

	GPIO_PinAFConfig(PinPort(rx), PinSource(rx), af);
	GPIO_PinAFConfig(PinPort(tx), PinSource(tx), af);

	USART_InitStruct.USART_BaudRate = baud;	// the baudrate is set to the value we passed into this init function
 800643e:	9304      	str	r3, [sp, #16]
	USART_InitStruct.USART_StopBits = USART_StopBits_1;	// we want 1 stop bit (standard)
	USART_InitStruct.USART_Parity = USART_Parity_No;// we don't want a parity bit (standard)
	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // we don't want flow control (standard)
	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // we want to enable the transmitter and the receiver

	USART_Init(usx->USARTx, &USART_InitStruct); // again all the properties are passed to the USART_Init function which takes care of all the bit setting
 8006440:	a904      	add	r1, sp, #16
	USART_InitStruct.USART_BaudRate = baud;	// the baudrate is set to the value we passed into this init function
	USART_InitStruct.USART_WordLength = USART_WordLength_8b;// we want the data frame size to be 8 bits (standard)
	USART_InitStruct.USART_StopBits = USART_StopBits_1;	// we want 1 stop bit (standard)
	USART_InitStruct.USART_Parity = USART_Parity_No;// we don't want a parity bit (standard)
	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // we don't want flow control (standard)
	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // we want to enable the transmitter and the receiver
 8006442:	230c      	movs	r3, #12
 8006444:	f8ad 301a 	strh.w	r3, [sp, #26]

	GPIO_PinAFConfig(PinPort(rx), PinSource(rx), af);
	GPIO_PinAFConfig(PinPort(tx), PinSource(tx), af);

	USART_InitStruct.USART_BaudRate = baud;	// the baudrate is set to the value we passed into this init function
	USART_InitStruct.USART_WordLength = USART_WordLength_8b;// we want the data frame size to be 8 bits (standard)
 8006448:	f8ad 5014 	strh.w	r5, [sp, #20]
	USART_InitStruct.USART_StopBits = USART_StopBits_1;	// we want 1 stop bit (standard)
 800644c:	f8ad 5016 	strh.w	r5, [sp, #22]
	USART_InitStruct.USART_Parity = USART_Parity_No;// we don't want a parity bit (standard)
 8006450:	f8ad 5018 	strh.w	r5, [sp, #24]
	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // we don't want flow control (standard)
 8006454:	f8ad 501c 	strh.w	r5, [sp, #28]
	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // we want to enable the transmitter and the receiver

	USART_Init(usx->USARTx, &USART_InitStruct); // again all the properties are passed to the USART_Init function which takes care of all the bit setting
 8006458:	f7ff f892 	bl	8005580 <USART_Init>

	USART_ITConfig(usx->USARTx, USART_IT_RXNE, ENABLE); // enable the USART3 receive interrupt
 800645c:	6860      	ldr	r0, [r4, #4]
 800645e:	2201      	movs	r2, #1
 8006460:	f240 5125 	movw	r1, #1317	; 0x525
 8006464:	f7ff f9c7 	bl	80057f6 <USART_ITConfig>
	USART_ITConfig(usx->USARTx, USART_IT_TXE, DISABLE);
 8006468:	6860      	ldr	r0, [r4, #4]
 800646a:	f240 7127 	movw	r1, #1831	; 0x727
 800646e:	462a      	mov	r2, r5
 8006470:	f7ff f9c1 	bl	80057f6 <USART_ITConfig>

	NVIC_InitStructure.NVIC_IRQChannel = irq;
	// we want to configure the USART3 interrupts
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // this sets the priority group of the USART3 interrupts
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // this sets the subpriority inside the group
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	// the USART3 interrupts are globally enabled
 8006474:	2601      	movs	r6, #1
	NVIC_Init(&NVIC_InitStructure);	// the properties are passed to the NVIC_Init function which takes care of the low level stuff
 8006476:	a803      	add	r0, sp, #12
	USART_Init(usx->USARTx, &USART_InitStruct); // again all the properties are passed to the USART_Init function which takes care of all the bit setting

	USART_ITConfig(usx->USARTx, USART_IT_RXNE, ENABLE); // enable the USART3 receive interrupt
	USART_ITConfig(usx->USARTx, USART_IT_TXE, DISABLE);

	NVIC_InitStructure.NVIC_IRQChannel = irq;
 8006478:	f88d 700c 	strb.w	r7, [sp, #12]
	// we want to configure the USART3 interrupts
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // this sets the priority group of the USART3 interrupts
 800647c:	f88d 500d 	strb.w	r5, [sp, #13]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // this sets the subpriority inside the group
 8006480:	f88d 500e 	strb.w	r5, [sp, #14]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	// the USART3 interrupts are globally enabled
 8006484:	f88d 600f 	strb.w	r6, [sp, #15]
	NVIC_Init(&NVIC_InitStructure);	// the properties are passed to the NVIC_Init function which takes care of the low level stuff
 8006488:	f7f9 fe88 	bl	800019c <NVIC_Init>
	//
	ring_clear(usx->rxring); //&rxring[usx->usid]);
 800648c:	68a3      	ldr	r3, [r4, #8]
	ring_clear(usx->txring); //&txring[usx->usid]);
	// finally this enables the complete USART3 peripheral
	USART_Cmd(usx->USARTx, ENABLE);
 800648e:	6860      	ldr	r0, [r4, #4]
};

USARTRing rxring[6], txring[6];

void ring_clear(USARTRing * r) {
	r->head = 0;
 8006490:	f8a3 5100 	strh.w	r5, [r3, #256]	; 0x100
	r->tail = 0;
 8006494:	f8a3 5102 	strh.w	r5, [r3, #258]	; 0x102
	r->count = 0;
 8006498:	f8a3 5104 	strh.w	r5, [r3, #260]	; 0x104
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // this sets the subpriority inside the group
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	// the USART3 interrupts are globally enabled
	NVIC_Init(&NVIC_InitStructure);	// the properties are passed to the NVIC_Init function which takes care of the low level stuff
	//
	ring_clear(usx->rxring); //&rxring[usx->usid]);
	ring_clear(usx->txring); //&txring[usx->usid]);
 800649c:	68e3      	ldr	r3, [r4, #12]
	// finally this enables the complete USART3 peripheral
	USART_Cmd(usx->USARTx, ENABLE);
 800649e:	4631      	mov	r1, r6
};

USARTRing rxring[6], txring[6];

void ring_clear(USARTRing * r) {
	r->head = 0;
 80064a0:	f8a3 5100 	strh.w	r5, [r3, #256]	; 0x100
	r->tail = 0;
 80064a4:	f8a3 5102 	strh.w	r5, [r3, #258]	; 0x102
	r->count = 0;
 80064a8:	f8a3 5104 	strh.w	r5, [r3, #260]	; 0x104
	NVIC_Init(&NVIC_InitStructure);	// the properties are passed to the NVIC_Init function which takes care of the low level stuff
	//
	ring_clear(usx->rxring); //&rxring[usx->usid]);
	ring_clear(usx->txring); //&txring[usx->usid]);
	// finally this enables the complete USART3 peripheral
	USART_Cmd(usx->USARTx, ENABLE);
 80064ac:	f7ff f8e3 	bl	8005676 <USART_Cmd>
}
 80064b0:	b008      	add	sp, #32
 80064b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80064b6:	bf00      	nop
 80064b8:	40011000 	.word	0x40011000
 80064bc:	20000cbc 	.word	0x20000cbc
 80064c0:	20000698 	.word	0x20000698
 80064c4:	40004400 	.word	0x40004400
 80064c8:	20000dc2 	.word	0x20000dc2
 80064cc:	2000079e 	.word	0x2000079e
 80064d0:	40004800 	.word	0x40004800
 80064d4:	20000ec8 	.word	0x20000ec8
 80064d8:	200008a4 	.word	0x200008a4
 80064dc:	40004c00 	.word	0x40004c00
 80064e0:	20000fce 	.word	0x20000fce
 80064e4:	200009aa 	.word	0x200009aa
 80064e8:	40005000 	.word	0x40005000
 80064ec:	200010d4 	.word	0x200010d4
 80064f0:	20000ab0 	.word	0x20000ab0
 80064f4:	200011da 	.word	0x200011da
 80064f8:	20000bb6 	.word	0x20000bb6

080064fc <usart_polling_write>:

void usart_polling_write(USART * usx, const uint16_t w) {
 80064fc:	b538      	push	{r3, r4, r5, lr}
 80064fe:	4604      	mov	r4, r0
 8006500:	460d      	mov	r5, r1
	while (USART_GetFlagStatus(usx->USARTx, USART_FLAG_TXE ) == RESET)
 8006502:	6860      	ldr	r0, [r4, #4]
 8006504:	2180      	movs	r1, #128	; 0x80
 8006506:	f7ff f98f 	bl	8005828 <USART_GetFlagStatus>
 800650a:	2800      	cmp	r0, #0
 800650c:	d0f9      	beq.n	8006502 <usart_polling_write+0x6>
		;
	USART_SendData(usx->USARTx, w);
 800650e:	6860      	ldr	r0, [r4, #4]
 8006510:	4629      	mov	r1, r5
//	while (USART_GetFlagStatus(USART3, USART_FLAG_TC ) == RESET) ;
}
 8006512:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
}

void usart_polling_write(USART * usx, const uint16_t w) {
	while (USART_GetFlagStatus(usx->USARTx, USART_FLAG_TXE ) == RESET)
		;
	USART_SendData(usx->USARTx, w);
 8006516:	f7ff b8da 	b.w	80056ce <USART_SendData>

0800651a <usart_write>:
//	while (USART_GetFlagStatus(USART3, USART_FLAG_TC ) == RESET) ;
}

size_t usart_write(USART * usx, const uint16_t w) {
 800651a:	b570      	push	{r4, r5, r6, lr}
 800651c:	4604      	mov	r4, r0
 800651e:	460e      	mov	r6, r1
	uint16_t waitcount = 3;
	while (ring_is_full(usx->txring) && (waitcount > 0) ) {
 8006520:	2504      	movs	r5, #4
 8006522:	e003      	b.n	800652c <usart_write+0x12>
		delay_us(667);
 8006524:	f240 209b 	movw	r0, #667	; 0x29b
 8006528:	f7ff fad8 	bl	8005adc <delay_us>
//	while (USART_GetFlagStatus(USART3, USART_FLAG_TC ) == RESET) ;
}

size_t usart_write(USART * usx, const uint16_t w) {
	uint16_t waitcount = 3;
	while (ring_is_full(usx->txring) && (waitcount > 0) ) {
 800652c:	68e0      	ldr	r0, [r4, #12]
 800652e:	f7ff fe90 	bl	8006252 <ring_is_full>
 8006532:	b118      	cbz	r0, 800653c <usart_write+0x22>
 8006534:	3d01      	subs	r5, #1
 8006536:	b2ad      	uxth	r5, r5
 8006538:	2d00      	cmp	r5, #0
 800653a:	d1f3      	bne.n	8006524 <usart_write+0xa>
		delay_us(667);
		waitcount--;
	}
	USART_ITConfig(usx->USARTx, USART_IT_TXE, DISABLE);
 800653c:	2200      	movs	r2, #0
 800653e:	6860      	ldr	r0, [r4, #4]
 8006540:	f240 7127 	movw	r1, #1831	; 0x727
 8006544:	f7ff f957 	bl	80057f6 <USART_ITConfig>
	ring_enque(usx->txring, w); //&txring[usx->usid], w);
 8006548:	4631      	mov	r1, r6
 800654a:	68e0      	ldr	r0, [r4, #12]
 800654c:	f7ff fe8f 	bl	800626e <ring_enque>
	USART_ITConfig(usx->USARTx, USART_IT_TXE, ENABLE);
 8006550:	6860      	ldr	r0, [r4, #4]
 8006552:	f240 7127 	movw	r1, #1831	; 0x727
 8006556:	2201      	movs	r2, #1
 8006558:	f7ff f94d 	bl	80057f6 <USART_ITConfig>
	return 1;
}
 800655c:	2001      	movs	r0, #1
 800655e:	bd70      	pop	{r4, r5, r6, pc}

08006560 <usart_print>:

size_t usart_print(USART * usx, const char * s) {
 8006560:	b570      	push	{r4, r5, r6, lr}
 8006562:	4606      	mov	r6, r0
 8006564:	460d      	mov	r5, r1
	size_t n = 0;
 8006566:	2400      	movs	r4, #0
	while (s[n])
 8006568:	e003      	b.n	8006572 <usart_print+0x12>
		usart_write(usx, (uint16_t) s[n++]);
 800656a:	4630      	mov	r0, r6
 800656c:	3401      	adds	r4, #1
 800656e:	f7ff ffd4 	bl	800651a <usart_write>
	return 1;
}

size_t usart_print(USART * usx, const char * s) {
	size_t n = 0;
	while (s[n])
 8006572:	5d29      	ldrb	r1, [r5, r4]
 8006574:	2900      	cmp	r1, #0
 8006576:	d1f8      	bne.n	800656a <usart_print+0xa>
		usart_write(usx, (uint16_t) s[n++]);
	return n;
}
 8006578:	4620      	mov	r0, r4
 800657a:	bd70      	pop	{r4, r5, r6, pc}

0800657c <usart_polling_read>:

uint16_t usart_polling_read(USART_TypeDef * USARTx /*usartx[usx]*/) {
	return USART_ReceiveData(USARTx);
 800657c:	f7ff b8ab 	b.w	80056d6 <USART_ReceiveData>

08006580 <usart_read>:
}

uint16_t usart_read(USART * usx) {
 8006580:	b508      	push	{r3, lr}
	uint16_t w = ring_deque(usx->rxring); //&rxring[usx->usid]);
 8006582:	6880      	ldr	r0, [r0, #8]
 8006584:	f7ff fe96 	bl	80062b4 <ring_deque>
	if (w == 0xffff)
		return 0; // buffer is empty
	return w;
}
 8006588:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800658c:	4298      	cmp	r0, r3
 800658e:	bf08      	it	eq
 8006590:	2000      	moveq	r0, #0
 8006592:	bd08      	pop	{r3, pc}

08006594 <usart_flush>:

void usart_flush(USART * usx) {
 8006594:	b538      	push	{r3, r4, r5, lr}
 8006596:	4604      	mov	r4, r0
	uint32_t wtill = millis() + 100;
 8006598:	f7ff fa8a 	bl	8005ab0 <millis>
 800659c:	f100 0564 	add.w	r5, r0, #100	; 0x64
	while (ring_count(usx->txring) > 0) {
 80065a0:	e00c      	b.n	80065bc <usart_flush+0x28>
		if (millis() > wtill)
 80065a2:	f7ff fa85 	bl	8005ab0 <millis>
 80065a6:	42a8      	cmp	r0, r5
 80065a8:	d908      	bls.n	80065bc <usart_flush+0x28>
	 USART_SendData(usx->USARTx, buffer_deque(usx->txring)); //&txring[usx->usid]));
	 while (USART_GetFlagStatus(usx->USARTx, USART_FLAG_TC ) == RESET);
	 }
	 USART_ClearITPendingBit(usx->USARTx, USART_IT_TXE );
	 */
	ring_clear(usx->rxring); //&txring[usx->usid]);
 80065aa:	68a3      	ldr	r3, [r4, #8]
};

USARTRing rxring[6], txring[6];

void ring_clear(USARTRing * r) {
	r->head = 0;
 80065ac:	2200      	movs	r2, #0
 80065ae:	f8a3 2100 	strh.w	r2, [r3, #256]	; 0x100
	r->tail = 0;
 80065b2:	f8a3 2102 	strh.w	r2, [r3, #258]	; 0x102
	r->count = 0;
 80065b6:	f8a3 2104 	strh.w	r2, [r3, #260]	; 0x104
 80065ba:	bd38      	pop	{r3, r4, r5, pc}
}

uint16_t ring_count(USARTRing * r) {
	return r->count;
 80065bc:	68e3      	ldr	r3, [r4, #12]
	return w;
}

void usart_flush(USART * usx) {
	uint32_t wtill = millis() + 100;
	while (ring_count(usx->txring) > 0) {
 80065be:	f8b3 3104 	ldrh.w	r3, [r3, #260]	; 0x104
 80065c2:	2b00      	cmp	r3, #0
 80065c4:	d1ed      	bne.n	80065a2 <usart_flush+0xe>
 80065c6:	e7f0      	b.n	80065aa <usart_flush+0x16>

080065c8 <usart_peek>:
}

uint16_t usart_peek(USART * usx) {
//	if ( buffer_count(&(usx->rxring)) == 0 )
//		return 0xffff;
	return ring_peek(usx->rxring); //	rxring[usx->usid].buf[rxring[usx->usid].tail];
 80065c8:	6880      	ldr	r0, [r0, #8]
 80065ca:	f7ff be91 	b.w	80062f0 <ring_peek>

080065ce <usart_available>:
	r->tail = 0;
	r->count = 0;
}

uint16_t ring_count(USARTRing * r) {
	return r->count;
 80065ce:	6883      	ldr	r3, [r0, #8]
}

uint16_t usart_available(USART * usx) {
	return ring_count(usx->rxring);
	//return buffer_count(&rxring[usx->usid]);
}
 80065d0:	f8b3 0104 	ldrh.w	r0, [r3, #260]	; 0x104
 80065d4:	4770      	bx	lr

080065d6 <USART1_IRQHandler>:

// this is the interrupt request handler (IRQ) for ALL USART3 interrupts

void USART1_IRQHandler(void) {
 80065d6:	b508      	push	{r3, lr}
	if (USART_GetITStatus(USART1, USART_IT_RXNE )) {
 80065d8:	4816      	ldr	r0, [pc, #88]	; (8006634 <USART1_IRQHandler+0x5e>)
 80065da:	f240 5125 	movw	r1, #1317	; 0x525
 80065de:	f7ff f92c 	bl	800583a <USART_GetITStatus>
 80065e2:	b130      	cbz	r0, 80065f2 <USART1_IRQHandler+0x1c>
		ring_enque(&rxring[USART1Serial],
 80065e4:	4813      	ldr	r0, [pc, #76]	; (8006634 <USART1_IRQHandler+0x5e>)
 80065e6:	f7ff f876 	bl	80056d6 <USART_ReceiveData>
 80065ea:	4601      	mov	r1, r0
 80065ec:	4812      	ldr	r0, [pc, #72]	; (8006638 <USART1_IRQHandler+0x62>)
 80065ee:	f7ff fe3e 	bl	800626e <ring_enque>
				USART_ReceiveData(USART1 ));
	}

	if (USART_GetITStatus(USART1, USART_IT_TXE )) {
 80065f2:	4810      	ldr	r0, [pc, #64]	; (8006634 <USART1_IRQHandler+0x5e>)
 80065f4:	f240 7127 	movw	r1, #1831	; 0x727
 80065f8:	f7ff f91f 	bl	800583a <USART_GetITStatus>
 80065fc:	2800      	cmp	r0, #0
 80065fe:	d017      	beq.n	8006630 <USART1_IRQHandler+0x5a>
		if (txring[USART1Serial].count
 8006600:	480e      	ldr	r0, [pc, #56]	; (800663c <USART1_IRQHandler+0x66>)
 8006602:	f8b0 2104 	ldrh.w	r2, [r0, #260]	; 0x104
 8006606:	b95a      	cbnz	r2, 8006620 <USART1_IRQHandler+0x4a>
				== 0) {
			USART_ITConfig(USART1, USART_IT_TXE, (FunctionalState) DISABLE);
 8006608:	480a      	ldr	r0, [pc, #40]	; (8006634 <USART1_IRQHandler+0x5e>)
 800660a:	f240 7127 	movw	r1, #1831	; 0x727
 800660e:	f7ff f8f2 	bl	80057f6 <USART_ITConfig>
			USART_ClearITPendingBit(USART1, USART_IT_TXE );
 8006612:	4808      	ldr	r0, [pc, #32]	; (8006634 <USART1_IRQHandler+0x5e>)
 8006614:	f240 7127 	movw	r1, #1831	; 0x727
		} else {
			USART_SendData(USART1, ring_deque(&txring[USART1Serial]) );
		}
	}
}
 8006618:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	if (USART_GetITStatus(USART1, USART_IT_TXE )) {
		if (txring[USART1Serial].count
				== 0) {
			USART_ITConfig(USART1, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART1, USART_IT_TXE );
 800661c:	f7ff b92d 	b.w	800587a <USART_ClearITPendingBit>
		} else {
			USART_SendData(USART1, ring_deque(&txring[USART1Serial]) );
 8006620:	f7ff fe48 	bl	80062b4 <ring_deque>
 8006624:	4601      	mov	r1, r0
 8006626:	4803      	ldr	r0, [pc, #12]	; (8006634 <USART1_IRQHandler+0x5e>)
		}
	}
}
 8006628:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		if (txring[USART1Serial].count
				== 0) {
			USART_ITConfig(USART1, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART1, USART_IT_TXE );
		} else {
			USART_SendData(USART1, ring_deque(&txring[USART1Serial]) );
 800662c:	f7ff b84f 	b.w	80056ce <USART_SendData>
 8006630:	bd08      	pop	{r3, pc}
 8006632:	bf00      	nop
 8006634:	40011000 	.word	0x40011000
 8006638:	20000cbc 	.word	0x20000cbc
 800663c:	20000698 	.word	0x20000698

08006640 <USART2_IRQHandler>:
		}
	}
}

void USART2_IRQHandler(void) {
 8006640:	b508      	push	{r3, lr}
	if (USART_GetITStatus(USART2, USART_IT_RXNE )) {
 8006642:	4817      	ldr	r0, [pc, #92]	; (80066a0 <USART2_IRQHandler+0x60>)
 8006644:	f240 5125 	movw	r1, #1317	; 0x525
 8006648:	f7ff f8f7 	bl	800583a <USART_GetITStatus>
 800664c:	b130      	cbz	r0, 800665c <USART2_IRQHandler+0x1c>
		ring_enque(&rxring[USART2Serial]
 800664e:	4814      	ldr	r0, [pc, #80]	; (80066a0 <USART2_IRQHandler+0x60>)
 8006650:	f7ff f841 	bl	80056d6 <USART_ReceiveData>
 8006654:	4601      	mov	r1, r0
 8006656:	4813      	ldr	r0, [pc, #76]	; (80066a4 <USART2_IRQHandler+0x64>)
 8006658:	f7ff fe09 	bl	800626e <ring_enque>
				, USART_ReceiveData(USART2 ));
	}
	if (USART_GetITStatus(USART2, USART_IT_TXE )) {
 800665c:	4810      	ldr	r0, [pc, #64]	; (80066a0 <USART2_IRQHandler+0x60>)
 800665e:	f240 7127 	movw	r1, #1831	; 0x727
 8006662:	f7ff f8ea 	bl	800583a <USART_GetITStatus>
 8006666:	2800      	cmp	r0, #0
 8006668:	d019      	beq.n	800669e <USART2_IRQHandler+0x5e>
		if (txring[USART2Serial].count
 800666a:	480f      	ldr	r0, [pc, #60]	; (80066a8 <USART2_IRQHandler+0x68>)
 800666c:	f8b0 220a 	ldrh.w	r2, [r0, #522]	; 0x20a
 8006670:	b95a      	cbnz	r2, 800668a <USART2_IRQHandler+0x4a>
		== 0) {
			USART_ITConfig(USART2, USART_IT_TXE, (FunctionalState) DISABLE);
 8006672:	480b      	ldr	r0, [pc, #44]	; (80066a0 <USART2_IRQHandler+0x60>)
 8006674:	f240 7127 	movw	r1, #1831	; 0x727
 8006678:	f7ff f8bd 	bl	80057f6 <USART_ITConfig>
			USART_ClearITPendingBit(USART2, USART_IT_TXE );
 800667c:	4808      	ldr	r0, [pc, #32]	; (80066a0 <USART2_IRQHandler+0x60>)
 800667e:	f240 7127 	movw	r1, #1831	; 0x727
		} else {
			USART_SendData(USART2, ring_deque(&txring[USART2Serial]));
		}
	}
}
 8006682:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	}
	if (USART_GetITStatus(USART2, USART_IT_TXE )) {
		if (txring[USART2Serial].count
		== 0) {
			USART_ITConfig(USART2, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART2, USART_IT_TXE );
 8006686:	f7ff b8f8 	b.w	800587a <USART_ClearITPendingBit>
		} else {
			USART_SendData(USART2, ring_deque(&txring[USART2Serial]));
 800668a:	f500 7083 	add.w	r0, r0, #262	; 0x106
 800668e:	f7ff fe11 	bl	80062b4 <ring_deque>
 8006692:	4601      	mov	r1, r0
 8006694:	4802      	ldr	r0, [pc, #8]	; (80066a0 <USART2_IRQHandler+0x60>)
		}
	}
}
 8006696:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		if (txring[USART2Serial].count
		== 0) {
			USART_ITConfig(USART2, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART2, USART_IT_TXE );
		} else {
			USART_SendData(USART2, ring_deque(&txring[USART2Serial]));
 800669a:	f7ff b818 	b.w	80056ce <USART_SendData>
 800669e:	bd08      	pop	{r3, pc}
 80066a0:	40004400 	.word	0x40004400
 80066a4:	20000dc2 	.word	0x20000dc2
 80066a8:	20000698 	.word	0x20000698

080066ac <USART3_IRQHandler>:
		}
	}
}

void USART3_IRQHandler(void) {
 80066ac:	b508      	push	{r3, lr}
	if (USART_GetITStatus(USART3, USART_IT_RXNE )) {
 80066ae:	4817      	ldr	r0, [pc, #92]	; (800670c <USART3_IRQHandler+0x60>)
 80066b0:	f240 5125 	movw	r1, #1317	; 0x525
 80066b4:	f7ff f8c1 	bl	800583a <USART_GetITStatus>
 80066b8:	b130      	cbz	r0, 80066c8 <USART3_IRQHandler+0x1c>
		ring_enque(&rxring[USART3Serial],
 80066ba:	4814      	ldr	r0, [pc, #80]	; (800670c <USART3_IRQHandler+0x60>)
 80066bc:	f7ff f80b 	bl	80056d6 <USART_ReceiveData>
 80066c0:	4601      	mov	r1, r0
 80066c2:	4813      	ldr	r0, [pc, #76]	; (8006710 <USART3_IRQHandler+0x64>)
 80066c4:	f7ff fdd3 	bl	800626e <ring_enque>
				USART_ReceiveData(USART3 ));
	}

	if (USART_GetITStatus(USART3, USART_IT_TXE )) {
 80066c8:	4810      	ldr	r0, [pc, #64]	; (800670c <USART3_IRQHandler+0x60>)
 80066ca:	f240 7127 	movw	r1, #1831	; 0x727
 80066ce:	f7ff f8b4 	bl	800583a <USART_GetITStatus>
 80066d2:	2800      	cmp	r0, #0
 80066d4:	d019      	beq.n	800670a <USART3_IRQHandler+0x5e>
		if (txring[USART3Serial].count == 0) {
 80066d6:	480f      	ldr	r0, [pc, #60]	; (8006714 <USART3_IRQHandler+0x68>)
 80066d8:	f8b0 2310 	ldrh.w	r2, [r0, #784]	; 0x310
 80066dc:	b95a      	cbnz	r2, 80066f6 <USART3_IRQHandler+0x4a>
			USART_ITConfig(USART3, USART_IT_TXE, (FunctionalState) DISABLE);
 80066de:	480b      	ldr	r0, [pc, #44]	; (800670c <USART3_IRQHandler+0x60>)
 80066e0:	f240 7127 	movw	r1, #1831	; 0x727
 80066e4:	f7ff f887 	bl	80057f6 <USART_ITConfig>
			USART_ClearITPendingBit(USART3, USART_IT_TXE );
 80066e8:	4808      	ldr	r0, [pc, #32]	; (800670c <USART3_IRQHandler+0x60>)
 80066ea:	f240 7127 	movw	r1, #1831	; 0x727
		} else {
			USART_SendData(USART3,
					ring_deque(&txring[USART3Serial]));
		}
	}
}
 80066ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	}

	if (USART_GetITStatus(USART3, USART_IT_TXE )) {
		if (txring[USART3Serial].count == 0) {
			USART_ITConfig(USART3, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART3, USART_IT_TXE );
 80066f2:	f7ff b8c2 	b.w	800587a <USART_ClearITPendingBit>
		} else {
			USART_SendData(USART3,
 80066f6:	f500 7003 	add.w	r0, r0, #524	; 0x20c
 80066fa:	f7ff fddb 	bl	80062b4 <ring_deque>
 80066fe:	4601      	mov	r1, r0
 8006700:	4802      	ldr	r0, [pc, #8]	; (800670c <USART3_IRQHandler+0x60>)
					ring_deque(&txring[USART3Serial]));
		}
	}
}
 8006702:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	if (USART_GetITStatus(USART3, USART_IT_TXE )) {
		if (txring[USART3Serial].count == 0) {
			USART_ITConfig(USART3, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(USART3, USART_IT_TXE );
		} else {
			USART_SendData(USART3,
 8006706:	f7fe bfe2 	b.w	80056ce <USART_SendData>
 800670a:	bd08      	pop	{r3, pc}
 800670c:	40004800 	.word	0x40004800
 8006710:	20000ec8 	.word	0x20000ec8
 8006714:	20000698 	.word	0x20000698

08006718 <UART4_IRQHandler>:
					ring_deque(&txring[USART3Serial]));
		}
	}
}

void UART4_IRQHandler(void) {
 8006718:	b508      	push	{r3, lr}
	if (USART_GetITStatus(UART4, USART_IT_RXNE )) {
 800671a:	4817      	ldr	r0, [pc, #92]	; (8006778 <UART4_IRQHandler+0x60>)
 800671c:	f240 5125 	movw	r1, #1317	; 0x525
 8006720:	f7ff f88b 	bl	800583a <USART_GetITStatus>
 8006724:	b130      	cbz	r0, 8006734 <UART4_IRQHandler+0x1c>
		ring_enque(&txring[UART4Serial], USART_ReceiveData(UART4 ));
 8006726:	4814      	ldr	r0, [pc, #80]	; (8006778 <UART4_IRQHandler+0x60>)
 8006728:	f7fe ffd5 	bl	80056d6 <USART_ReceiveData>
 800672c:	4601      	mov	r1, r0
 800672e:	4813      	ldr	r0, [pc, #76]	; (800677c <UART4_IRQHandler+0x64>)
 8006730:	f7ff fd9d 	bl	800626e <ring_enque>
	}

	if (USART_GetITStatus(UART4, USART_IT_TXE )) {
 8006734:	4810      	ldr	r0, [pc, #64]	; (8006778 <UART4_IRQHandler+0x60>)
 8006736:	f240 7127 	movw	r1, #1831	; 0x727
 800673a:	f7ff f87e 	bl	800583a <USART_GetITStatus>
 800673e:	2800      	cmp	r0, #0
 8006740:	d018      	beq.n	8006774 <UART4_IRQHandler+0x5c>
		if (txring[UART4Serial].count == 0) {
 8006742:	4b0f      	ldr	r3, [pc, #60]	; (8006780 <UART4_IRQHandler+0x68>)
 8006744:	f8b3 2416 	ldrh.w	r2, [r3, #1046]	; 0x416
 8006748:	b95a      	cbnz	r2, 8006762 <UART4_IRQHandler+0x4a>
			USART_ITConfig(UART4, USART_IT_TXE, (FunctionalState) DISABLE);
 800674a:	480b      	ldr	r0, [pc, #44]	; (8006778 <UART4_IRQHandler+0x60>)
 800674c:	f240 7127 	movw	r1, #1831	; 0x727
 8006750:	f7ff f851 	bl	80057f6 <USART_ITConfig>
			USART_ClearITPendingBit(UART4, USART_IT_TXE );
 8006754:	4808      	ldr	r0, [pc, #32]	; (8006778 <UART4_IRQHandler+0x60>)
 8006756:	f240 7127 	movw	r1, #1831	; 0x727
		} else {
			USART_SendData(UART4, ring_deque(&txring[UART4Serial]));
		}
	}
}
 800675a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	}

	if (USART_GetITStatus(UART4, USART_IT_TXE )) {
		if (txring[UART4Serial].count == 0) {
			USART_ITConfig(UART4, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(UART4, USART_IT_TXE );
 800675e:	f7ff b88c 	b.w	800587a <USART_ClearITPendingBit>
		} else {
			USART_SendData(UART4, ring_deque(&txring[UART4Serial]));
 8006762:	4806      	ldr	r0, [pc, #24]	; (800677c <UART4_IRQHandler+0x64>)
 8006764:	f7ff fda6 	bl	80062b4 <ring_deque>
 8006768:	4601      	mov	r1, r0
 800676a:	4803      	ldr	r0, [pc, #12]	; (8006778 <UART4_IRQHandler+0x60>)
		}
	}
}
 800676c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	if (USART_GetITStatus(UART4, USART_IT_TXE )) {
		if (txring[UART4Serial].count == 0) {
			USART_ITConfig(UART4, USART_IT_TXE, (FunctionalState) DISABLE);
			USART_ClearITPendingBit(UART4, USART_IT_TXE );
		} else {
			USART_SendData(UART4, ring_deque(&txring[UART4Serial]));
 8006770:	f7fe bfad 	b.w	80056ce <USART_SendData>
 8006774:	bd08      	pop	{r3, pc}
 8006776:	bf00      	nop
 8006778:	40004c00 	.word	0x40004c00
 800677c:	200009aa 	.word	0x200009aa
 8006780:	20000698 	.word	0x20000698

08006784 <_close>:
	}
}

int _close(int file) {
	return -1;
}
 8006784:	f04f 30ff 	mov.w	r0, #4294967295
 8006788:	4770      	bx	lr

0800678a <_execve>:
/*
 execve
 Transfer control to a new process. Minimal implementation (for a system without processes):
 */
int _execve(char *name, char **argv, char **env) {
	errno = ENOMEM;
 800678a:	4b03      	ldr	r3, [pc, #12]	; (8006798 <_execve+0xe>)
 800678c:	220c      	movs	r2, #12
 800678e:	601a      	str	r2, [r3, #0]
	return -1;
}
 8006790:	f04f 30ff 	mov.w	r0, #4294967295
 8006794:	4770      	bx	lr
 8006796:	bf00      	nop
 8006798:	200012e0 	.word	0x200012e0

0800679c <_fork>:
 fork
 Create a new process. Minimal implementation (for a system without processes):
 */

int _fork() {
	errno = EAGAIN;
 800679c:	4b02      	ldr	r3, [pc, #8]	; (80067a8 <_fork+0xc>)
 800679e:	220b      	movs	r2, #11
 80067a0:	601a      	str	r2, [r3, #0]
	return -1;
}
 80067a2:	f04f 30ff 	mov.w	r0, #4294967295
 80067a6:	4770      	bx	lr
 80067a8:	200012e0 	.word	0x200012e0

080067ac <_fstat>:
 Status of an open file. For consistency with other minimal implementations in these examples,
 all files are regarded as character special devices.
 The `sys/stat.h' header file required is distributed in the `include' subdirectory for this C library.
 */
int _fstat(int file, struct stat *st) {
	st->st_mode = S_IFCHR;
 80067ac:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80067b0:	604b      	str	r3, [r1, #4]
	return 0;
}
 80067b2:	2000      	movs	r0, #0
 80067b4:	4770      	bx	lr

080067b6 <_getpid>:
 Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes. Minimal implementation, for a system without processes:
 */

int _getpid() {
	return 1;
}
 80067b6:	2001      	movs	r0, #1
 80067b8:	4770      	bx	lr

080067ba <_isatty>:
/*
 isatty
 Query whether output stream is a terminal. For consistency with the other minimal implementations,
 */
int _isatty(int file) {
	switch (file) {
 80067ba:	2802      	cmp	r0, #2
 80067bc:	d904      	bls.n	80067c8 <_isatty+0xe>
	case STDERR_FILENO:
	case STDIN_FILENO:
		return 1;
	default:
		//errno = ENOTTY;
		errno = EBADF;
 80067be:	4b03      	ldr	r3, [pc, #12]	; (80067cc <_isatty+0x12>)
 80067c0:	2209      	movs	r2, #9
 80067c2:	601a      	str	r2, [r3, #0]
		return 0;
 80067c4:	2000      	movs	r0, #0
 80067c6:	4770      	bx	lr
int _isatty(int file) {
	switch (file) {
	case STDOUT_FILENO:
	case STDERR_FILENO:
	case STDIN_FILENO:
		return 1;
 80067c8:	2001      	movs	r0, #1
	default:
		//errno = ENOTTY;
		errno = EBADF;
		return 0;
	}
}
 80067ca:	4770      	bx	lr
 80067cc:	200012e0 	.word	0x200012e0

080067d0 <_kill>:
/*
 kill
 Send a signal. Minimal implementation:
 */
int _kill(int pid, int sig) {
	errno = EINVAL;
 80067d0:	4b02      	ldr	r3, [pc, #8]	; (80067dc <_kill+0xc>)
 80067d2:	2216      	movs	r2, #22
 80067d4:	601a      	str	r2, [r3, #0]
	return (-1);
}
 80067d6:	f04f 30ff 	mov.w	r0, #4294967295
 80067da:	4770      	bx	lr
 80067dc:	200012e0 	.word	0x200012e0

080067e0 <_link>:
 link
 Establish a new name for an existing file. Minimal implementation:
 */

int _link(char *old, char *new) {
	errno = EMLINK;
 80067e0:	4b02      	ldr	r3, [pc, #8]	; (80067ec <_link+0xc>)
 80067e2:	221f      	movs	r2, #31
 80067e4:	601a      	str	r2, [r3, #0]
	return -1;
}
 80067e6:	f04f 30ff 	mov.w	r0, #4294967295
 80067ea:	4770      	bx	lr
 80067ec:	200012e0 	.word	0x200012e0

080067f0 <_lseek>:
 lseek
 Set position in a file. Minimal implementation:
 */
int _lseek(int file, int ptr, int dir) {
	return 0;
}
 80067f0:	2000      	movs	r0, #0
 80067f2:	4770      	bx	lr

080067f4 <_read>:
 read
 Read a character to a file. `libc' subroutines will use this system routine for input from all files, including stdin
 Returns -1 on error or blocks until the number of characters have been read.
 */

int _read(int file, char *ptr, int len) {
 80067f4:	b530      	push	{r4, r5, lr}
	int n;
	int num = 0;
	switch (file) {
 80067f6:	b150      	cbz	r0, 800680e <_read+0x1a>
 80067f8:	e010      	b.n	800681c <_read+0x28>
	case STDIN_FILENO:
		for (n = 0; n < len; n++) {
#if   STDIN_USART == 1
			while ((USART1->SR & USART_FLAG_RXNE) == (uint16_t)RESET) {}
 80067fa:	881d      	ldrh	r5, [r3, #0]
 80067fc:	f005 0520 	and.w	r5, r5, #32
 8006800:	b2ad      	uxth	r5, r5
 8006802:	2d00      	cmp	r5, #0
 8006804:	d0f9      	beq.n	80067fa <_read+0x6>
			char c = (char)(USART1->DR & (uint16_t)0x01FF);
 8006806:	88a5      	ldrh	r5, [r4, #4]
 8006808:	540d      	strb	r5, [r1, r0]
int _read(int file, char *ptr, int len) {
	int n;
	int num = 0;
	switch (file) {
	case STDIN_FILENO:
		for (n = 0; n < len; n++) {
 800680a:	3001      	adds	r0, #1
 800680c:	e001      	b.n	8006812 <_read+0x1e>
#if   STDIN_USART == 1
			while ((USART1->SR & USART_FLAG_RXNE) == (uint16_t)RESET) {}
 800680e:	4b06      	ldr	r3, [pc, #24]	; (8006828 <_read+0x34>)
 8006810:	461c      	mov	r4, r3
int _read(int file, char *ptr, int len) {
	int n;
	int num = 0;
	switch (file) {
	case STDIN_FILENO:
		for (n = 0; n < len; n++) {
 8006812:	4290      	cmp	r0, r2
 8006814:	dbf1      	blt.n	80067fa <_read+0x6>
 8006816:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
 800681a:	bd30      	pop	{r4, r5, pc}
					*ptr++ = c;
					num++;
				}
				break;
				default:
				errno = EBADF;
 800681c:	4b03      	ldr	r3, [pc, #12]	; (800682c <_read+0x38>)
 800681e:	2209      	movs	r2, #9
 8006820:	601a      	str	r2, [r3, #0]
				return -1;
 8006822:	f04f 30ff 	mov.w	r0, #4294967295
			}
	return num;
}
 8006826:	bd30      	pop	{r4, r5, pc}
 8006828:	40011000 	.word	0x40011000
 800682c:	200012e0 	.word	0x200012e0

08006830 <_stat>:
 Status of a file (by name). Minimal implementation:
 int    _EXFUN(stat,( const char *__path, struct stat *__sbuf ));
 */

int _stat(const char *filepath, struct stat *st) {
	st->st_mode = S_IFCHR;
 8006830:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006834:	604b      	str	r3, [r1, #4]
	return 0;
}
 8006836:	2000      	movs	r0, #0
 8006838:	4770      	bx	lr

0800683a <_times>:
 Timing information for current process. Minimal implementation:
 */

clock_t _times(struct tms *buf) {
	return -1;
}
 800683a:	f04f 30ff 	mov.w	r0, #4294967295
 800683e:	4770      	bx	lr

08006840 <_unlink>:
/*
 unlink
 Remove a file's directory entry. Minimal implementation:
 */
int _unlink(char *name) {
	errno = ENOENT;
 8006840:	4b02      	ldr	r3, [pc, #8]	; (800684c <_unlink+0xc>)
 8006842:	2202      	movs	r2, #2
 8006844:	601a      	str	r2, [r3, #0]
	return -1;
}
 8006846:	f04f 30ff 	mov.w	r0, #4294967295
 800684a:	4770      	bx	lr
 800684c:	200012e0 	.word	0x200012e0

08006850 <_wait>:
/*
 wait
 Wait for a child process. Minimal implementation:
 */
int _wait(int *status) {
	errno = ECHILD;
 8006850:	4b02      	ldr	r3, [pc, #8]	; (800685c <_wait+0xc>)
 8006852:	220a      	movs	r2, #10
 8006854:	601a      	str	r2, [r3, #0]
	return -1;
}
 8006856:	f04f 30ff 	mov.w	r0, #4294967295
 800685a:	4770      	bx	lr
 800685c:	200012e0 	.word	0x200012e0

08006860 <_write>:
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
	int n;
	switch (file) {
 8006860:	2801      	cmp	r0, #1
/*
 write
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
 8006862:	b530      	push	{r4, r5, lr}
	int n;
	switch (file) {
 8006864:	d00c      	beq.n	8006880 <_write+0x20>
 8006866:	2802      	cmp	r0, #2
 8006868:	d120      	bne.n	80068ac <_write+0x4c>
 800686a:	e019      	b.n	80068a0 <_write+0x40>
	case STDOUT_FILENO: /*stdout*/
		for (n = 0; n < len; n++) {
#if STDOUT_USART == 1
			while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 800686c:	8805      	ldrh	r5, [r0, #0]
 800686e:	f005 0540 	and.w	r5, r5, #64	; 0x40
 8006872:	b2ad      	uxth	r5, r5
 8006874:	2d00      	cmp	r5, #0
 8006876:	d0f9      	beq.n	800686c <_write+0xc>
			USART1->DR = (*ptr++ & (uint16_t)0x01FF);
 8006878:	5ccd      	ldrb	r5, [r1, r3]
 */
int _write(int file, char *ptr, int len) {
	int n;
	switch (file) {
	case STDOUT_FILENO: /*stdout*/
		for (n = 0; n < len; n++) {
 800687a:	3301      	adds	r3, #1
#if STDOUT_USART == 1
			while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
			USART1->DR = (*ptr++ & (uint16_t)0x01FF);
 800687c:	80a5      	strh	r5, [r4, #4]
 800687e:	e002      	b.n	8006886 <_write+0x26>
	int n;
	switch (file) {
	case STDOUT_FILENO: /*stdout*/
		for (n = 0; n < len; n++) {
#if STDOUT_USART == 1
			while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 8006880:	480e      	ldr	r0, [pc, #56]	; (80068bc <_write+0x5c>)
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
	int n;
	switch (file) {
 8006882:	2300      	movs	r3, #0
	case STDOUT_FILENO: /*stdout*/
		for (n = 0; n < len; n++) {
#if STDOUT_USART == 1
			while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 8006884:	4604      	mov	r4, r0
 */
int _write(int file, char *ptr, int len) {
	int n;
	switch (file) {
	case STDOUT_FILENO: /*stdout*/
		for (n = 0; n < len; n++) {
 8006886:	4293      	cmp	r3, r2
 8006888:	dbf0      	blt.n	800686c <_write+0xc>
 800688a:	e014      	b.n	80068b6 <_write+0x56>
				}
				break;
				case STDERR_FILENO: /* stderr */
				for (n = 0; n < len; n++) {
#if STDERR_USART == 1
					while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 800688c:	8805      	ldrh	r5, [r0, #0]
 800688e:	f005 0540 	and.w	r5, r5, #64	; 0x40
 8006892:	b2ad      	uxth	r5, r5
 8006894:	2d00      	cmp	r5, #0
 8006896:	d0f9      	beq.n	800688c <_write+0x2c>
					USART1->DR = (*ptr++ & (uint16_t)0x01FF);
 8006898:	5ccd      	ldrb	r5, [r1, r3]
					USART3->DR = (*ptr++ & (uint16_t)0x01FF);
#endif
				}
				break;
				case STDERR_FILENO: /* stderr */
				for (n = 0; n < len; n++) {
 800689a:	3301      	adds	r3, #1
#if STDERR_USART == 1
					while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
					USART1->DR = (*ptr++ & (uint16_t)0x01FF);
 800689c:	80a5      	strh	r5, [r4, #4]
 800689e:	e002      	b.n	80068a6 <_write+0x46>
				}
				break;
				case STDERR_FILENO: /* stderr */
				for (n = 0; n < len; n++) {
#if STDERR_USART == 1
					while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 80068a0:	4806      	ldr	r0, [pc, #24]	; (80068bc <_write+0x5c>)
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
	int n;
	switch (file) {
 80068a2:	2300      	movs	r3, #0
				}
				break;
				case STDERR_FILENO: /* stderr */
				for (n = 0; n < len; n++) {
#if STDERR_USART == 1
					while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET) {}
 80068a4:	4604      	mov	r4, r0
					USART3->DR = (*ptr++ & (uint16_t)0x01FF);
#endif
				}
				break;
				case STDERR_FILENO: /* stderr */
				for (n = 0; n < len; n++) {
 80068a6:	4293      	cmp	r3, r2
 80068a8:	dbf0      	blt.n	800688c <_write+0x2c>
 80068aa:	e004      	b.n	80068b6 <_write+0x56>
					USART3->DR = (*ptr++ & (uint16_t)0x01FF);
#endif
				}
				break;
				default:
				errno = EBADF;
 80068ac:	4b04      	ldr	r3, [pc, #16]	; (80068c0 <_write+0x60>)
 80068ae:	2209      	movs	r2, #9
 80068b0:	601a      	str	r2, [r3, #0]
				return -1;
 80068b2:	f04f 32ff 	mov.w	r2, #4294967295
			}
	return len;
}
 80068b6:	4610      	mov	r0, r2
 80068b8:	bd30      	pop	{r4, r5, pc}
 80068ba:	bf00      	nop
 80068bc:	40011000 	.word	0x40011000
 80068c0:	200012e0 	.word	0x200012e0

080068c4 <_sbrk>:
/*
 sbrk
 Increase program data space.
 Malloc and related functions depend on this
 */
caddr_t _sbrk(int incr) {
 80068c4:	b508      	push	{r3, lr}

	extern char _ebss; // Defined by the linker
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0) {
 80068c6:	4b0d      	ldr	r3, [pc, #52]	; (80068fc <_sbrk+0x38>)
 80068c8:	681a      	ldr	r2, [r3, #0]
 80068ca:	b90a      	cbnz	r2, 80068d0 <_sbrk+0xc>
		heap_end = &_ebss;
 80068cc:	4a0c      	ldr	r2, [pc, #48]	; (8006900 <_sbrk+0x3c>)
 80068ce:	601a      	str	r2, [r3, #0]
	}
	prev_heap_end = heap_end;
 80068d0:	681b      	ldr	r3, [r3, #0]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 80068d2:	f3ef 8208 	mrs	r2, MSP

	char * stack = (char*) __get_MSP();
	if (heap_end + incr > stack) {
 80068d6:	1818      	adds	r0, r3, r0
 80068d8:	4290      	cmp	r0, r2
 80068da:	d90a      	bls.n	80068f2 <_sbrk+0x2e>
		_write(STDERR_FILENO, "Heap and stack collision\n", 25);
 80068dc:	2219      	movs	r2, #25
 80068de:	2002      	movs	r0, #2
 80068e0:	4908      	ldr	r1, [pc, #32]	; (8006904 <_sbrk+0x40>)
 80068e2:	f7ff ffbd 	bl	8006860 <_write>
		errno = ENOMEM;
 80068e6:	4b08      	ldr	r3, [pc, #32]	; (8006908 <_sbrk+0x44>)
 80068e8:	220c      	movs	r2, #12
 80068ea:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 80068ec:	f04f 33ff 	mov.w	r3, #4294967295
 80068f0:	e001      	b.n	80068f6 <_sbrk+0x32>
		//abort ();
	}

	heap_end += incr;
 80068f2:	4a02      	ldr	r2, [pc, #8]	; (80068fc <_sbrk+0x38>)
 80068f4:	6010      	str	r0, [r2, #0]
	return (caddr_t) prev_heap_end;

}
 80068f6:	4618      	mov	r0, r3
 80068f8:	bd08      	pop	{r3, pc}
 80068fa:	bf00      	nop
 80068fc:	20000644 	.word	0x20000644
 8006900:	200012e4 	.word	0x200012e4
 8006904:	0800d137 	.word	0x0800d137
 8006908:	200012e0 	.word	0x200012e0

0800690c <_exit>:
char *__env[1] = { 0 };
char **environ = __env;

int _write(int file, char *ptr, int len);

void _exit(int status) {
 800690c:	b508      	push	{r3, lr}
	_write(1, "exit", 4);
 800690e:	2001      	movs	r0, #1
 8006910:	4902      	ldr	r1, [pc, #8]	; (800691c <_exit+0x10>)
 8006912:	2204      	movs	r2, #4
 8006914:	f7ff ffa4 	bl	8006860 <_write>
 8006918:	e7fe      	b.n	8006918 <_exit+0xc>
 800691a:	bf00      	nop
 800691c:	0800d151 	.word	0x0800d151
 8006920:	0800d1c4 	.word	0x0800d1c4
 8006924:	20000000 	.word	0x20000000
 8006928:	20000640 	.word	0x20000640
 800692c:	20000640 	.word	0x20000640
 8006930:	200012e4 	.word	0x200012e4

08006934 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8006934:	4770      	bx	lr

08006936 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8006936:	e7fe      	b.n	8006936 <HardFault_Handler>

08006938 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8006938:	e7fe      	b.n	8006938 <MemManage_Handler>

0800693a <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800693a:	e7fe      	b.n	800693a <BusFault_Handler>

0800693c <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800693c:	e7fe      	b.n	800693c <UsageFault_Handler>

0800693e <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 800693e:	4770      	bx	lr

08006940 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8006940:	4770      	bx	lr

08006942 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8006942:	4770      	bx	lr

08006944 <SystemInit>:
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8006944:	4b34      	ldr	r3, [pc, #208]	; (8006a18 <SystemInit+0xd4>)
 8006946:	681a      	ldr	r2, [r3, #0]
 8006948:	f042 0201 	orr.w	r2, r2, #1
 800694c:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800694e:	2200      	movs	r2, #0
 8006950:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006952:	6819      	ldr	r1, [r3, #0]
 8006954:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 8006958:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800695c:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800695e:	492f      	ldr	r1, [pc, #188]	; (8006a1c <SystemInit+0xd8>)
 8006960:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8006962:	6819      	ldr	r1, [r3, #0]
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8006964:	b082      	sub	sp, #8

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8006966:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800696a:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800696c:	60da      	str	r2, [r3, #12]
static void SetSysClock(void)
{
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800696e:	9200      	str	r2, [sp, #0]
 8006970:	9201      	str	r2, [sp, #4]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8006972:	681a      	ldr	r2, [r3, #0]
 8006974:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006978:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800697a:	681a      	ldr	r2, [r3, #0]
 800697c:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8006980:	9201      	str	r2, [sp, #4]
    StartUpCounter++;
 8006982:	9a00      	ldr	r2, [sp, #0]
 8006984:	3201      	adds	r2, #1
 8006986:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8006988:	9a01      	ldr	r2, [sp, #4]
 800698a:	b91a      	cbnz	r2, 8006994 <SystemInit+0x50>
 800698c:	9a00      	ldr	r2, [sp, #0]
 800698e:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8006992:	d1f2      	bne.n	800697a <SystemInit+0x36>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8006994:	4b20      	ldr	r3, [pc, #128]	; (8006a18 <SystemInit+0xd4>)
 8006996:	681b      	ldr	r3, [r3, #0]
 8006998:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 800699c:	bf18      	it	ne
 800699e:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80069a0:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 80069a2:	9b01      	ldr	r3, [sp, #4]
 80069a4:	2b01      	cmp	r3, #1
 80069a6:	d004      	beq.n	80069b2 <SystemInit+0x6e>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80069a8:	4b1d      	ldr	r3, [pc, #116]	; (8006a20 <SystemInit+0xdc>)
 80069aa:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80069ae:	609a      	str	r2, [r3, #8]
 80069b0:	e02f      	b.n	8006a12 <SystemInit+0xce>
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 80069b2:	4b19      	ldr	r3, [pc, #100]	; (8006a18 <SystemInit+0xd4>)
 80069b4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80069b6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80069ba:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_VOS;
 80069bc:	4a19      	ldr	r2, [pc, #100]	; (8006a24 <SystemInit+0xe0>)
 80069be:	6811      	ldr	r1, [r2, #0]
 80069c0:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 80069c4:	6011      	str	r1, [r2, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 80069c6:	689a      	ldr	r2, [r3, #8]
 80069c8:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 80069ca:	689a      	ldr	r2, [r3, #8]
 80069cc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80069d0:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 80069d2:	689a      	ldr	r2, [r3, #8]
 80069d4:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 80069d8:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 80069da:	4a13      	ldr	r2, [pc, #76]	; (8006a28 <SystemInit+0xe4>)
 80069dc:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 80069de:	681a      	ldr	r2, [r3, #0]
 80069e0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80069e4:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80069e6:	6819      	ldr	r1, [r3, #0]
 80069e8:	4a0b      	ldr	r2, [pc, #44]	; (8006a18 <SystemInit+0xd4>)
 80069ea:	0189      	lsls	r1, r1, #6
 80069ec:	d5fb      	bpl.n	80069e6 <SystemInit+0xa2>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80069ee:	4b0f      	ldr	r3, [pc, #60]	; (8006a2c <SystemInit+0xe8>)
 80069f0:	f240 6105 	movw	r1, #1541	; 0x605
 80069f4:	6019      	str	r1, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80069f6:	6893      	ldr	r3, [r2, #8]
 80069f8:	f023 0303 	bic.w	r3, r3, #3
 80069fc:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 80069fe:	6893      	ldr	r3, [r2, #8]
 8006a00:	f043 0302 	orr.w	r3, r3, #2
 8006a04:	6093      	str	r3, [r2, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8006a06:	6893      	ldr	r3, [r2, #8]
 8006a08:	f003 030c 	and.w	r3, r3, #12
 8006a0c:	2b08      	cmp	r3, #8
 8006a0e:	d1fa      	bne.n	8006a06 <SystemInit+0xc2>
 8006a10:	e7ca      	b.n	80069a8 <SystemInit+0x64>
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif
}
 8006a12:	b002      	add	sp, #8
 8006a14:	4770      	bx	lr
 8006a16:	bf00      	nop
 8006a18:	40023800 	.word	0x40023800
 8006a1c:	24003010 	.word	0x24003010
 8006a20:	e000ed00 	.word	0xe000ed00
 8006a24:	40007000 	.word	0x40007000
 8006a28:	07405408 	.word	0x07405408
 8006a2c:	40023c00 	.word	0x40023c00

08006a30 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8006a30:	4b18      	ldr	r3, [pc, #96]	; (8006a94 <SystemCoreClockUpdate+0x64>)
 8006a32:	4a19      	ldr	r2, [pc, #100]	; (8006a98 <SystemCoreClockUpdate+0x68>)
 8006a34:	6899      	ldr	r1, [r3, #8]
 8006a36:	f001 010c 	and.w	r1, r1, #12

  switch (tmp)
 8006a3a:	2904      	cmp	r1, #4
 8006a3c:	d003      	beq.n	8006a46 <SystemCoreClockUpdate+0x16>
 8006a3e:	2908      	cmp	r1, #8
 8006a40:	d003      	beq.n	8006a4a <SystemCoreClockUpdate+0x1a>
 8006a42:	4b16      	ldr	r3, [pc, #88]	; (8006a9c <SystemCoreClockUpdate+0x6c>)
 8006a44:	e019      	b.n	8006a7a <SystemCoreClockUpdate+0x4a>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8006a46:	4b16      	ldr	r3, [pc, #88]	; (8006aa0 <SystemCoreClockUpdate+0x70>)
 8006a48:	e017      	b.n	8006a7a <SystemCoreClockUpdate+0x4a>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8006a4a:	6859      	ldr	r1, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8006a4c:	685a      	ldr	r2, [r3, #4]
      
      if (pllsource != 0)
 8006a4e:	f411 0f80 	tst.w	r1, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8006a52:	6859      	ldr	r1, [r3, #4]
 8006a54:	bf14      	ite	ne
 8006a56:	4b12      	ldrne	r3, [pc, #72]	; (8006aa0 <SystemCoreClockUpdate+0x70>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8006a58:	4b10      	ldreq	r3, [pc, #64]	; (8006a9c <SystemCoreClockUpdate+0x6c>)

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8006a5a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8006a5e:	fbb3 f3f2 	udiv	r3, r3, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8006a62:	4a0c      	ldr	r2, [pc, #48]	; (8006a94 <SystemCoreClockUpdate+0x64>)
 8006a64:	6852      	ldr	r2, [r2, #4]
 8006a66:	f3c2 4201 	ubfx	r2, r2, #16, #2
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8006a6a:	f3c1 1188 	ubfx	r1, r1, #6, #9
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8006a6e:	3201      	adds	r2, #1
 8006a70:	0052      	lsls	r2, r2, #1
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8006a72:	434b      	muls	r3, r1
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      SystemCoreClock = pllvco/pllp;
 8006a74:	fbb3 f3f2 	udiv	r3, r3, r2
 8006a78:	4a07      	ldr	r2, [pc, #28]	; (8006a98 <SystemCoreClockUpdate+0x68>)
 8006a7a:	6013      	str	r3, [r2, #0]
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8006a7c:	4b05      	ldr	r3, [pc, #20]	; (8006a94 <SystemCoreClockUpdate+0x64>)
 8006a7e:	689a      	ldr	r2, [r3, #8]
 8006a80:	4b05      	ldr	r3, [pc, #20]	; (8006a98 <SystemCoreClockUpdate+0x68>)
 8006a82:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8006a86:	189a      	adds	r2, r3, r2
 8006a88:	7911      	ldrb	r1, [r2, #4]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 8006a8a:	681a      	ldr	r2, [r3, #0]
 8006a8c:	fa22 f201 	lsr.w	r2, r2, r1
 8006a90:	601a      	str	r2, [r3, #0]
 8006a92:	4770      	bx	lr
 8006a94:	40023800 	.word	0x40023800
 8006a98:	200000ac 	.word	0x200000ac
 8006a9c:	00f42400 	.word	0x00f42400
 8006aa0:	007a1200 	.word	0x007a1200

08006aa4 <cleanup_glue>:
 8006aa4:	b538      	push	{r3, r4, r5, lr}
 8006aa6:	460c      	mov	r4, r1
 8006aa8:	6809      	ldr	r1, [r1, #0]
 8006aaa:	4605      	mov	r5, r0
 8006aac:	b109      	cbz	r1, 8006ab2 <cleanup_glue+0xe>
 8006aae:	f7ff fff9 	bl	8006aa4 <cleanup_glue>
 8006ab2:	4628      	mov	r0, r5
 8006ab4:	4621      	mov	r1, r4
 8006ab6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006aba:	f002 bbeb 	b.w	8009294 <_free_r>
 8006abe:	bf00      	nop

08006ac0 <_reclaim_reent>:
 8006ac0:	f240 03c0 	movw	r3, #192	; 0xc0
 8006ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ac8:	b570      	push	{r4, r5, r6, lr}
 8006aca:	4605      	mov	r5, r0
 8006acc:	681b      	ldr	r3, [r3, #0]
 8006ace:	4298      	cmp	r0, r3
 8006ad0:	d047      	beq.n	8006b62 <_reclaim_reent+0xa2>
 8006ad2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8006ad4:	b1eb      	cbz	r3, 8006b12 <_reclaim_reent+0x52>
 8006ad6:	68da      	ldr	r2, [r3, #12]
 8006ad8:	b1b2      	cbz	r2, 8006b08 <_reclaim_reent+0x48>
 8006ada:	2300      	movs	r3, #0
 8006adc:	461e      	mov	r6, r3
 8006ade:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8006ae2:	b141      	cbz	r1, 8006af6 <_reclaim_reent+0x36>
 8006ae4:	680c      	ldr	r4, [r1, #0]
 8006ae6:	4628      	mov	r0, r5
 8006ae8:	f002 fbd4 	bl	8009294 <_free_r>
 8006aec:	4621      	mov	r1, r4
 8006aee:	2c00      	cmp	r4, #0
 8006af0:	d1f8      	bne.n	8006ae4 <_reclaim_reent+0x24>
 8006af2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8006af4:	68da      	ldr	r2, [r3, #12]
 8006af6:	3601      	adds	r6, #1
 8006af8:	2e20      	cmp	r6, #32
 8006afa:	4633      	mov	r3, r6
 8006afc:	d1ef      	bne.n	8006ade <_reclaim_reent+0x1e>
 8006afe:	4628      	mov	r0, r5
 8006b00:	4611      	mov	r1, r2
 8006b02:	f002 fbc7 	bl	8009294 <_free_r>
 8006b06:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8006b08:	6819      	ldr	r1, [r3, #0]
 8006b0a:	b111      	cbz	r1, 8006b12 <_reclaim_reent+0x52>
 8006b0c:	4628      	mov	r0, r5
 8006b0e:	f002 fbc1 	bl	8009294 <_free_r>
 8006b12:	6969      	ldr	r1, [r5, #20]
 8006b14:	b111      	cbz	r1, 8006b1c <_reclaim_reent+0x5c>
 8006b16:	4628      	mov	r0, r5
 8006b18:	f002 fbbc 	bl	8009294 <_free_r>
 8006b1c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8006b1e:	b111      	cbz	r1, 8006b26 <_reclaim_reent+0x66>
 8006b20:	4628      	mov	r0, r5
 8006b22:	f002 fbb7 	bl	8009294 <_free_r>
 8006b26:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8006b28:	b111      	cbz	r1, 8006b30 <_reclaim_reent+0x70>
 8006b2a:	4628      	mov	r0, r5
 8006b2c:	f002 fbb2 	bl	8009294 <_free_r>
 8006b30:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8006b32:	b111      	cbz	r1, 8006b3a <_reclaim_reent+0x7a>
 8006b34:	4628      	mov	r0, r5
 8006b36:	f002 fbad 	bl	8009294 <_free_r>
 8006b3a:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8006b3c:	b111      	cbz	r1, 8006b44 <_reclaim_reent+0x84>
 8006b3e:	4628      	mov	r0, r5
 8006b40:	f002 fba8 	bl	8009294 <_free_r>
 8006b44:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8006b46:	b12b      	cbz	r3, 8006b54 <_reclaim_reent+0x94>
 8006b48:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 8006b4c:	b111      	cbz	r1, 8006b54 <_reclaim_reent+0x94>
 8006b4e:	4628      	mov	r0, r5
 8006b50:	f002 fba0 	bl	8009294 <_free_r>
 8006b54:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8006b56:	b111      	cbz	r1, 8006b5e <_reclaim_reent+0x9e>
 8006b58:	4628      	mov	r0, r5
 8006b5a:	f002 fb9b 	bl	8009294 <_free_r>
 8006b5e:	69ab      	ldr	r3, [r5, #24]
 8006b60:	b903      	cbnz	r3, 8006b64 <_reclaim_reent+0xa4>
 8006b62:	bd70      	pop	{r4, r5, r6, pc}
 8006b64:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006b66:	4628      	mov	r0, r5
 8006b68:	4798      	blx	r3
 8006b6a:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 8006b6e:	2900      	cmp	r1, #0
 8006b70:	d0f7      	beq.n	8006b62 <_reclaim_reent+0xa2>
 8006b72:	4628      	mov	r0, r5
 8006b74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006b78:	f7ff bf94 	b.w	8006aa4 <cleanup_glue>

08006b7c <_wrapup_reent>:
 8006b7c:	b570      	push	{r4, r5, r6, lr}
 8006b7e:	4606      	mov	r6, r0
 8006b80:	b198      	cbz	r0, 8006baa <_wrapup_reent+0x2e>
 8006b82:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8006b84:	b15b      	cbz	r3, 8006b9e <_wrapup_reent+0x22>
 8006b86:	685d      	ldr	r5, [r3, #4]
 8006b88:	1e6c      	subs	r4, r5, #1
 8006b8a:	d408      	bmi.n	8006b9e <_wrapup_reent+0x22>
 8006b8c:	3502      	adds	r5, #2
 8006b8e:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8006b92:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8006b96:	3c01      	subs	r4, #1
 8006b98:	4798      	blx	r3
 8006b9a:	1c63      	adds	r3, r4, #1
 8006b9c:	d1f9      	bne.n	8006b92 <_wrapup_reent+0x16>
 8006b9e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8006ba0:	b113      	cbz	r3, 8006ba8 <_wrapup_reent+0x2c>
 8006ba2:	4630      	mov	r0, r6
 8006ba4:	4798      	blx	r3
 8006ba6:	bd70      	pop	{r4, r5, r6, pc}
 8006ba8:	bd70      	pop	{r4, r5, r6, pc}
 8006baa:	f240 03c0 	movw	r3, #192	; 0xc0
 8006bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bb2:	681e      	ldr	r6, [r3, #0]
 8006bb4:	e7e5      	b.n	8006b82 <_wrapup_reent+0x6>
 8006bb6:	bf00      	nop

08006bb8 <_sprintf_r>:
 8006bb8:	b40c      	push	{r2, r3}
 8006bba:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006bbc:	b09d      	sub	sp, #116	; 0x74
 8006bbe:	ac22      	add	r4, sp, #136	; 0x88
 8006bc0:	460e      	mov	r6, r1
 8006bc2:	a902      	add	r1, sp, #8
 8006bc4:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 8006bc8:	f854 2b04 	ldr.w	r2, [r4], #4
 8006bcc:	f44f 7702 	mov.w	r7, #520	; 0x208
 8006bd0:	9504      	str	r5, [sp, #16]
 8006bd2:	4623      	mov	r3, r4
 8006bd4:	9507      	str	r5, [sp, #28]
 8006bd6:	9602      	str	r6, [sp, #8]
 8006bd8:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8006bdc:	f8ad 7014 	strh.w	r7, [sp, #20]
 8006be0:	9606      	str	r6, [sp, #24]
 8006be2:	f8ad 5016 	strh.w	r5, [sp, #22]
 8006be6:	9401      	str	r4, [sp, #4]
 8006be8:	f000 f830 	bl	8006c4c <_svfprintf_r>
 8006bec:	9b02      	ldr	r3, [sp, #8]
 8006bee:	2200      	movs	r2, #0
 8006bf0:	701a      	strb	r2, [r3, #0]
 8006bf2:	b01d      	add	sp, #116	; 0x74
 8006bf4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006bf8:	b002      	add	sp, #8
 8006bfa:	4770      	bx	lr

08006bfc <sprintf>:
 8006bfc:	b40e      	push	{r1, r2, r3}
 8006bfe:	f240 03c0 	movw	r3, #192	; 0xc0
 8006c02:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006c04:	b09c      	sub	sp, #112	; 0x70
 8006c06:	ac21      	add	r4, sp, #132	; 0x84
 8006c08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c0c:	4606      	mov	r6, r0
 8006c0e:	a902      	add	r1, sp, #8
 8006c10:	f854 2b04 	ldr.w	r2, [r4], #4
 8006c14:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 8006c18:	6818      	ldr	r0, [r3, #0]
 8006c1a:	f44f 7702 	mov.w	r7, #520	; 0x208
 8006c1e:	4623      	mov	r3, r4
 8006c20:	9504      	str	r5, [sp, #16]
 8006c22:	9507      	str	r5, [sp, #28]
 8006c24:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8006c28:	9602      	str	r6, [sp, #8]
 8006c2a:	f8ad 7014 	strh.w	r7, [sp, #20]
 8006c2e:	9606      	str	r6, [sp, #24]
 8006c30:	f8ad 5016 	strh.w	r5, [sp, #22]
 8006c34:	9401      	str	r4, [sp, #4]
 8006c36:	f000 f809 	bl	8006c4c <_svfprintf_r>
 8006c3a:	9b02      	ldr	r3, [sp, #8]
 8006c3c:	2200      	movs	r2, #0
 8006c3e:	701a      	strb	r2, [r3, #0]
 8006c40:	b01c      	add	sp, #112	; 0x70
 8006c42:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8006c46:	b003      	add	sp, #12
 8006c48:	4770      	bx	lr
 8006c4a:	bf00      	nop

08006c4c <_svfprintf_r>:
 8006c4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006c50:	b0c9      	sub	sp, #292	; 0x124
 8006c52:	4689      	mov	r9, r1
 8006c54:	4614      	mov	r4, r2
 8006c56:	9311      	str	r3, [sp, #68]	; 0x44
 8006c58:	2600      	movs	r6, #0
 8006c5a:	900f      	str	r0, [sp, #60]	; 0x3c
 8006c5c:	f002 fc20 	bl	80094a0 <_localeconv_r>
 8006c60:	2700      	movs	r7, #0
 8006c62:	e9cd 671e 	strd	r6, r7, [sp, #120]	; 0x78
 8006c66:	6800      	ldr	r0, [r0, #0]
 8006c68:	901c      	str	r0, [sp, #112]	; 0x70
 8006c6a:	f003 fdc1 	bl	800a7f0 <strlen>
 8006c6e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8006c72:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006c76:	b21b      	sxth	r3, r3
 8006c78:	901d      	str	r0, [sp, #116]	; 0x74
 8006c7a:	b123      	cbz	r3, 8006c86 <_svfprintf_r+0x3a>
 8006c7c:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8006c80:	2b00      	cmp	r3, #0
 8006c82:	f001 80dd 	beq.w	8007e40 <_svfprintf_r+0x11f4>
 8006c86:	f10d 0be0 	add.w	fp, sp, #224	; 0xe0
 8006c8a:	f24d 1564 	movw	r5, #53604	; 0xd164
 8006c8e:	46d8      	mov	r8, fp
 8006c90:	f24d 1660 	movw	r6, #53600	; 0xd160
 8006c94:	f24d 175c 	movw	r7, #53596	; 0xd15c
 8006c98:	940a      	str	r4, [sp, #40]	; 0x28
 8006c9a:	f24d 1458 	movw	r4, #53592	; 0xd158
 8006c9e:	2300      	movs	r3, #0
 8006ca0:	f6c0 0500 	movt	r5, #2048	; 0x800
 8006ca4:	f6c0 0600 	movt	r6, #2048	; 0x800
 8006ca8:	f6c0 0700 	movt	r7, #2048	; 0x800
 8006cac:	f6c0 0400 	movt	r4, #2048	; 0x800
 8006cb0:	9312      	str	r3, [sp, #72]	; 0x48
 8006cb2:	931a      	str	r3, [sp, #104]	; 0x68
 8006cb4:	9320      	str	r3, [sp, #128]	; 0x80
 8006cb6:	930c      	str	r3, [sp, #48]	; 0x30
 8006cb8:	9518      	str	r5, [sp, #96]	; 0x60
 8006cba:	9619      	str	r6, [sp, #100]	; 0x64
 8006cbc:	9716      	str	r7, [sp, #88]	; 0x58
 8006cbe:	9417      	str	r4, [sp, #92]	; 0x5c
 8006cc0:	f8cd b0ac 	str.w	fp, [sp, #172]	; 0xac
 8006cc4:	932d      	str	r3, [sp, #180]	; 0xb4
 8006cc6:	932c      	str	r3, [sp, #176]	; 0xb0
 8006cc8:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8006ccc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8006cce:	782b      	ldrb	r3, [r5, #0]
 8006cd0:	2b25      	cmp	r3, #37	; 0x25
 8006cd2:	bf18      	it	ne
 8006cd4:	2b00      	cmpne	r3, #0
 8006cd6:	f000 80b9 	beq.w	8006e4c <_svfprintf_r+0x200>
 8006cda:	1c6a      	adds	r2, r5, #1
 8006cdc:	4616      	mov	r6, r2
 8006cde:	3201      	adds	r2, #1
 8006ce0:	7833      	ldrb	r3, [r6, #0]
 8006ce2:	2b25      	cmp	r3, #37	; 0x25
 8006ce4:	bf18      	it	ne
 8006ce6:	2b00      	cmpne	r3, #0
 8006ce8:	d1f8      	bne.n	8006cdc <_svfprintf_r+0x90>
 8006cea:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006cec:	1b37      	subs	r7, r6, r4
 8006cee:	d010      	beq.n	8006d12 <_svfprintf_r+0xc6>
 8006cf0:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8006cf2:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006cf4:	3401      	adds	r4, #1
 8006cf6:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8006cf8:	2c07      	cmp	r4, #7
 8006cfa:	e888 0081 	stmia.w	r8, {r0, r7}
 8006cfe:	443d      	add	r5, r7
 8006d00:	942c      	str	r4, [sp, #176]	; 0xb0
 8006d02:	bfd8      	it	le
 8006d04:	f108 0808 	addle.w	r8, r8, #8
 8006d08:	952d      	str	r5, [sp, #180]	; 0xb4
 8006d0a:	dc7e      	bgt.n	8006e0a <_svfprintf_r+0x1be>
 8006d0c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8006d0e:	19e4      	adds	r4, r4, r7
 8006d10:	940c      	str	r4, [sp, #48]	; 0x30
 8006d12:	7833      	ldrb	r3, [r6, #0]
 8006d14:	2b00      	cmp	r3, #0
 8006d16:	f000 87d3 	beq.w	8007cc0 <_svfprintf_r+0x1074>
 8006d1a:	1c75      	adds	r5, r6, #1
 8006d1c:	7877      	ldrb	r7, [r6, #1]
 8006d1e:	2300      	movs	r3, #0
 8006d20:	f04f 39ff 	mov.w	r9, #4294967295
 8006d24:	930d      	str	r3, [sp, #52]	; 0x34
 8006d26:	2020      	movs	r0, #32
 8006d28:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 8006d2c:	212b      	movs	r1, #43	; 0x2b
 8006d2e:	9308      	str	r3, [sp, #32]
 8006d30:	462b      	mov	r3, r5
 8006d32:	950a      	str	r5, [sp, #40]	; 0x28
 8006d34:	3301      	adds	r3, #1
 8006d36:	f1a7 0220 	sub.w	r2, r7, #32
 8006d3a:	2a58      	cmp	r2, #88	; 0x58
 8006d3c:	f200 8248 	bhi.w	80071d0 <_svfprintf_r+0x584>
 8006d40:	e8df f012 	tbh	[pc, r2, lsl #1]
 8006d44:	024602ec 	.word	0x024602ec
 8006d48:	02db0246 	.word	0x02db0246
 8006d4c:	02460246 	.word	0x02460246
 8006d50:	02460246 	.word	0x02460246
 8006d54:	02460246 	.word	0x02460246
 8006d58:	008602e1 	.word	0x008602e1
 8006d5c:	005d0246 	.word	0x005d0246
 8006d60:	0246008a 	.word	0x0246008a
 8006d64:	00af00a9 	.word	0x00af00a9
 8006d68:	00af00af 	.word	0x00af00af
 8006d6c:	00af00af 	.word	0x00af00af
 8006d70:	00af00af 	.word	0x00af00af
 8006d74:	00af00af 	.word	0x00af00af
 8006d78:	02460246 	.word	0x02460246
 8006d7c:	02460246 	.word	0x02460246
 8006d80:	02460246 	.word	0x02460246
 8006d84:	02460246 	.word	0x02460246
 8006d88:	02460246 	.word	0x02460246
 8006d8c:	018400c0 	.word	0x018400c0
 8006d90:	01840246 	.word	0x01840246
 8006d94:	02460246 	.word	0x02460246
 8006d98:	02460246 	.word	0x02460246
 8006d9c:	024601bc 	.word	0x024601bc
 8006da0:	01c20246 	.word	0x01c20246
 8006da4:	02460246 	.word	0x02460246
 8006da8:	02460246 	.word	0x02460246
 8006dac:	01df0246 	.word	0x01df0246
 8006db0:	02460246 	.word	0x02460246
 8006db4:	024601ec 	.word	0x024601ec
 8006db8:	02460246 	.word	0x02460246
 8006dbc:	02460246 	.word	0x02460246
 8006dc0:	02460246 	.word	0x02460246
 8006dc4:	02460246 	.word	0x02460246
 8006dc8:	02710246 	.word	0x02710246
 8006dcc:	01840258 	.word	0x01840258
 8006dd0:	01840184 	.word	0x01840184
 8006dd4:	0258026b 	.word	0x0258026b
 8006dd8:	02460246 	.word	0x02460246
 8006ddc:	0246023c 	.word	0x0246023c
 8006de0:	028502b5 	.word	0x028502b5
 8006de4:	020b029a 	.word	0x020b029a
 8006de8:	02110246 	.word	0x02110246
 8006dec:	02c70246 	.word	0x02c70246
 8006df0:	02460246 	.word	0x02460246
 8006df4:	02f5      	.short	0x02f5
 8006df6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8006df8:	9211      	str	r2, [sp, #68]	; 0x44
 8006dfa:	4276      	negs	r6, r6
 8006dfc:	960d      	str	r6, [sp, #52]	; 0x34
 8006dfe:	9f08      	ldr	r7, [sp, #32]
 8006e00:	f047 0704 	orr.w	r7, r7, #4
 8006e04:	9708      	str	r7, [sp, #32]
 8006e06:	781f      	ldrb	r7, [r3, #0]
 8006e08:	e794      	b.n	8006d34 <_svfprintf_r+0xe8>
 8006e0a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8006e0c:	aa2b      	add	r2, sp, #172	; 0xac
 8006e0e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006e10:	f003 fd1e 	bl	800a850 <__ssprint_r>
 8006e14:	b948      	cbnz	r0, 8006e2a <_svfprintf_r+0x1de>
 8006e16:	46d8      	mov	r8, fp
 8006e18:	e778      	b.n	8006d0c <_svfprintf_r+0xc0>
 8006e1a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8006e1c:	aa2b      	add	r2, sp, #172	; 0xac
 8006e1e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006e20:	f003 fd16 	bl	800a850 <__ssprint_r>
 8006e24:	2800      	cmp	r0, #0
 8006e26:	f000 8370 	beq.w	800750a <_svfprintf_r+0x8be>
 8006e2a:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8006e2e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8006e32:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8006e34:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006e38:	b21b      	sxth	r3, r3
 8006e3a:	2b00      	cmp	r3, #0
 8006e3c:	bf18      	it	ne
 8006e3e:	f04f 34ff 	movne.w	r4, #4294967295
 8006e42:	940c      	str	r4, [sp, #48]	; 0x30
 8006e44:	980c      	ldr	r0, [sp, #48]	; 0x30
 8006e46:	b049      	add	sp, #292	; 0x124
 8006e48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006e4c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8006e4e:	e760      	b.n	8006d12 <_svfprintf_r+0xc6>
 8006e50:	f88d 108b 	strb.w	r1, [sp, #139]	; 0x8b
 8006e54:	781f      	ldrb	r7, [r3, #0]
 8006e56:	e76d      	b.n	8006d34 <_svfprintf_r+0xe8>
 8006e58:	461c      	mov	r4, r3
 8006e5a:	f814 7b01 	ldrb.w	r7, [r4], #1
 8006e5e:	2f2a      	cmp	r7, #42	; 0x2a
 8006e60:	f001 8166 	beq.w	8008130 <_svfprintf_r+0x14e4>
 8006e64:	f1a7 0230 	sub.w	r2, r7, #48	; 0x30
 8006e68:	2a09      	cmp	r2, #9
 8006e6a:	bf84      	itt	hi
 8006e6c:	4623      	movhi	r3, r4
 8006e6e:	f04f 0900 	movhi.w	r9, #0
 8006e72:	f63f af60 	bhi.w	8006d36 <_svfprintf_r+0xea>
 8006e76:	f04f 0900 	mov.w	r9, #0
 8006e7a:	f814 7b01 	ldrb.w	r7, [r4], #1
 8006e7e:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 8006e82:	eb02 0949 	add.w	r9, r2, r9, lsl #1
 8006e86:	f1a7 0230 	sub.w	r2, r7, #48	; 0x30
 8006e8a:	2a09      	cmp	r2, #9
 8006e8c:	4623      	mov	r3, r4
 8006e8e:	d9f4      	bls.n	8006e7a <_svfprintf_r+0x22e>
 8006e90:	ea49 79e9 	orr.w	r9, r9, r9, asr #31
 8006e94:	e74f      	b.n	8006d36 <_svfprintf_r+0xea>
 8006e96:	9e08      	ldr	r6, [sp, #32]
 8006e98:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 8006e9c:	9608      	str	r6, [sp, #32]
 8006e9e:	781f      	ldrb	r7, [r3, #0]
 8006ea0:	e748      	b.n	8006d34 <_svfprintf_r+0xe8>
 8006ea2:	461c      	mov	r4, r3
 8006ea4:	2200      	movs	r2, #0
 8006ea6:	f1a7 0630 	sub.w	r6, r7, #48	; 0x30
 8006eaa:	f814 7b01 	ldrb.w	r7, [r4], #1
 8006eae:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8006eb2:	f1a7 0530 	sub.w	r5, r7, #48	; 0x30
 8006eb6:	4623      	mov	r3, r4
 8006eb8:	2d09      	cmp	r5, #9
 8006eba:	eb06 0242 	add.w	r2, r6, r2, lsl #1
 8006ebe:	d9f2      	bls.n	8006ea6 <_svfprintf_r+0x25a>
 8006ec0:	920d      	str	r2, [sp, #52]	; 0x34
 8006ec2:	e738      	b.n	8006d36 <_svfprintf_r+0xea>
 8006ec4:	9c08      	ldr	r4, [sp, #32]
 8006ec6:	930a      	str	r3, [sp, #40]	; 0x28
 8006ec8:	f044 0410 	orr.w	r4, r4, #16
 8006ecc:	9408      	str	r4, [sp, #32]
 8006ece:	9d08      	ldr	r5, [sp, #32]
 8006ed0:	06ad      	lsls	r5, r5, #26
 8006ed2:	f140 8194 	bpl.w	80071fe <_svfprintf_r+0x5b2>
 8006ed6:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8006ed8:	1df3      	adds	r3, r6, #7
 8006eda:	f023 0307 	bic.w	r3, r3, #7
 8006ede:	f103 0408 	add.w	r4, r3, #8
 8006ee2:	9411      	str	r4, [sp, #68]	; 0x44
 8006ee4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006ee8:	4614      	mov	r4, r2
 8006eea:	461d      	mov	r5, r3
 8006eec:	2a00      	cmp	r2, #0
 8006eee:	f173 0600 	sbcs.w	r6, r3, #0
 8006ef2:	f2c0 85ff 	blt.w	8007af4 <_svfprintf_r+0xea8>
 8006ef6:	ea54 0005 	orrs.w	r0, r4, r5
 8006efa:	f04f 0301 	mov.w	r3, #1
 8006efe:	bf0c      	ite	eq
 8006f00:	2200      	moveq	r2, #0
 8006f02:	2201      	movne	r2, #1
 8006f04:	f1b9 0f00 	cmp.w	r9, #0
 8006f08:	bfa2      	ittt	ge
 8006f0a:	9e08      	ldrge	r6, [sp, #32]
 8006f0c:	f026 0680 	bicge.w	r6, r6, #128	; 0x80
 8006f10:	9608      	strge	r6, [sp, #32]
 8006f12:	f1b9 0f00 	cmp.w	r9, #0
 8006f16:	bf18      	it	ne
 8006f18:	f042 0201 	orrne.w	r2, r2, #1
 8006f1c:	2a00      	cmp	r2, #0
 8006f1e:	f000 835c 	beq.w	80075da <_svfprintf_r+0x98e>
 8006f22:	2b01      	cmp	r3, #1
 8006f24:	f000 849f 	beq.w	8007866 <_svfprintf_r+0xc1a>
 8006f28:	2b02      	cmp	r3, #2
 8006f2a:	f000 847a 	beq.w	8007822 <_svfprintf_r+0xbd6>
 8006f2e:	f10d 00df 	add.w	r0, sp, #223	; 0xdf
 8006f32:	46bc      	mov	ip, r7
 8006f34:	08e1      	lsrs	r1, r4, #3
 8006f36:	2607      	movs	r6, #7
 8006f38:	ea04 0206 	and.w	r2, r4, r6
 8006f3c:	ea41 7145 	orr.w	r1, r1, r5, lsl #29
 8006f40:	08ee      	lsrs	r6, r5, #3
 8006f42:	460c      	mov	r4, r1
 8006f44:	4635      	mov	r5, r6
 8006f46:	4603      	mov	r3, r0
 8006f48:	3230      	adds	r2, #48	; 0x30
 8006f4a:	3801      	subs	r0, #1
 8006f4c:	ea54 0705 	orrs.w	r7, r4, r5
 8006f50:	b2d2      	uxtb	r2, r2
 8006f52:	701a      	strb	r2, [r3, #0]
 8006f54:	d1ee      	bne.n	8006f34 <_svfprintf_r+0x2e8>
 8006f56:	9c08      	ldr	r4, [sp, #32]
 8006f58:	4667      	mov	r7, ip
 8006f5a:	9314      	str	r3, [sp, #80]	; 0x50
 8006f5c:	07e4      	lsls	r4, r4, #31
 8006f5e:	f100 85bd 	bmi.w	8007adc <_svfprintf_r+0xe90>
 8006f62:	ebc3 050b 	rsb	r5, r3, fp
 8006f66:	950e      	str	r5, [sp, #56]	; 0x38
 8006f68:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8006f6c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8006f6e:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
 8006f72:	454e      	cmp	r6, r9
 8006f74:	bfb8      	it	lt
 8006f76:	464e      	movlt	r6, r9
 8006f78:	f04f 0900 	mov.w	r9, #0
 8006f7c:	960b      	str	r6, [sp, #44]	; 0x2c
 8006f7e:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
 8006f82:	b12b      	cbz	r3, 8006f90 <_svfprintf_r+0x344>
 8006f84:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8006f88:	f109 0901 	add.w	r9, r9, #1
 8006f8c:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8006f90:	9b08      	ldr	r3, [sp, #32]
 8006f92:	f013 0302 	ands.w	r3, r3, #2
 8006f96:	9313      	str	r3, [sp, #76]	; 0x4c
 8006f98:	d002      	beq.n	8006fa0 <_svfprintf_r+0x354>
 8006f9a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8006f9c:	3402      	adds	r4, #2
 8006f9e:	940b      	str	r4, [sp, #44]	; 0x2c
 8006fa0:	9d08      	ldr	r5, [sp, #32]
 8006fa2:	f015 0584 	ands.w	r5, r5, #132	; 0x84
 8006fa6:	9515      	str	r5, [sp, #84]	; 0x54
 8006fa8:	f040 81d7 	bne.w	800735a <_svfprintf_r+0x70e>
 8006fac:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8006fae:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8006fb0:	1b66      	subs	r6, r4, r5
 8006fb2:	2e00      	cmp	r6, #0
 8006fb4:	f340 81d1 	ble.w	800735a <_svfprintf_r+0x70e>
 8006fb8:	2e10      	cmp	r6, #16
 8006fba:	f64c 6aa8 	movw	sl, #52904	; 0xcea8
 8006fbe:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8006fc0:	f6c0 0a00 	movt	sl, #2048	; 0x800
 8006fc4:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8006fc6:	dd28      	ble.n	800701a <_svfprintf_r+0x3ce>
 8006fc8:	9721      	str	r7, [sp, #132]	; 0x84
 8006fca:	f04f 0910 	mov.w	r9, #16
 8006fce:	4657      	mov	r7, sl
 8006fd0:	46b2      	mov	sl, r6
 8006fd2:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8006fd4:	e004      	b.n	8006fe0 <_svfprintf_r+0x394>
 8006fd6:	f1aa 0a10 	sub.w	sl, sl, #16
 8006fda:	f1ba 0f10 	cmp.w	sl, #16
 8006fde:	dd19      	ble.n	8007014 <_svfprintf_r+0x3c8>
 8006fe0:	3401      	adds	r4, #1
 8006fe2:	3510      	adds	r5, #16
 8006fe4:	2c07      	cmp	r4, #7
 8006fe6:	e888 0280 	stmia.w	r8, {r7, r9}
 8006fea:	942c      	str	r4, [sp, #176]	; 0xb0
 8006fec:	f108 0808 	add.w	r8, r8, #8
 8006ff0:	952d      	str	r5, [sp, #180]	; 0xb4
 8006ff2:	ddf0      	ble.n	8006fd6 <_svfprintf_r+0x38a>
 8006ff4:	4630      	mov	r0, r6
 8006ff6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8006ff8:	aa2b      	add	r2, sp, #172	; 0xac
 8006ffa:	46d8      	mov	r8, fp
 8006ffc:	f003 fc28 	bl	800a850 <__ssprint_r>
 8007000:	2800      	cmp	r0, #0
 8007002:	f47f af12 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007006:	f1aa 0a10 	sub.w	sl, sl, #16
 800700a:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 800700c:	f1ba 0f10 	cmp.w	sl, #16
 8007010:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007012:	dce5      	bgt.n	8006fe0 <_svfprintf_r+0x394>
 8007014:	4656      	mov	r6, sl
 8007016:	46ba      	mov	sl, r7
 8007018:	9f21      	ldr	r7, [sp, #132]	; 0x84
 800701a:	3401      	adds	r4, #1
 800701c:	f8c8 a000 	str.w	sl, [r8]
 8007020:	2c07      	cmp	r4, #7
 8007022:	f8c8 6004 	str.w	r6, [r8, #4]
 8007026:	4435      	add	r5, r6
 8007028:	942c      	str	r4, [sp, #176]	; 0xb0
 800702a:	952d      	str	r5, [sp, #180]	; 0xb4
 800702c:	bfd8      	it	le
 800702e:	f108 0808 	addle.w	r8, r8, #8
 8007032:	f340 8193 	ble.w	800735c <_svfprintf_r+0x710>
 8007036:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007038:	aa2b      	add	r2, sp, #172	; 0xac
 800703a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800703c:	f003 fc08 	bl	800a850 <__ssprint_r>
 8007040:	2800      	cmp	r0, #0
 8007042:	f47f aef2 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007046:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007048:	46d8      	mov	r8, fp
 800704a:	e187      	b.n	800735c <_svfprintf_r+0x710>
 800704c:	9c08      	ldr	r4, [sp, #32]
 800704e:	930a      	str	r3, [sp, #40]	; 0x28
 8007050:	0721      	lsls	r1, r4, #28
 8007052:	f140 857c 	bpl.w	8007b4e <_svfprintf_r+0xf02>
 8007056:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8007058:	1de9      	adds	r1, r5, #7
 800705a:	f021 0107 	bic.w	r1, r1, #7
 800705e:	f101 0608 	add.w	r6, r1, #8
 8007062:	9611      	str	r6, [sp, #68]	; 0x44
 8007064:	680e      	ldr	r6, [r1, #0]
 8007066:	684d      	ldr	r5, [r1, #4]
 8007068:	4630      	mov	r0, r6
 800706a:	4629      	mov	r1, r5
 800706c:	e9cd 011e 	strd	r0, r1, [sp, #120]	; 0x78
 8007070:	4630      	mov	r0, r6
 8007072:	4629      	mov	r1, r5
 8007074:	f003 fa92 	bl	800a59c <__fpclassifyd>
 8007078:	2801      	cmp	r0, #1
 800707a:	4630      	mov	r0, r6
 800707c:	f040 854b 	bne.w	8007b16 <_svfprintf_r+0xeca>
 8007080:	2200      	movs	r2, #0
 8007082:	2300      	movs	r3, #0
 8007084:	4629      	mov	r1, r5
 8007086:	f005 fa0b 	bl	800c4a0 <__aeabi_dcmplt>
 800708a:	2800      	cmp	r0, #0
 800708c:	f040 8765 	bne.w	8007f5a <_svfprintf_r+0x130e>
 8007090:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007094:	2403      	movs	r4, #3
 8007096:	9e16      	ldr	r6, [sp, #88]	; 0x58
 8007098:	940b      	str	r4, [sp, #44]	; 0x2c
 800709a:	2500      	movs	r5, #0
 800709c:	9c08      	ldr	r4, [sp, #32]
 800709e:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
 80070a2:	9510      	str	r5, [sp, #64]	; 0x40
 80070a4:	f024 0480 	bic.w	r4, r4, #128	; 0x80
 80070a8:	2f47      	cmp	r7, #71	; 0x47
 80070aa:	bfd8      	it	le
 80070ac:	464e      	movle	r6, r9
 80070ae:	2503      	movs	r5, #3
 80070b0:	9614      	str	r6, [sp, #80]	; 0x50
 80070b2:	2600      	movs	r6, #0
 80070b4:	9408      	str	r4, [sp, #32]
 80070b6:	950e      	str	r5, [sp, #56]	; 0x38
 80070b8:	961b      	str	r6, [sp, #108]	; 0x6c
 80070ba:	e762      	b.n	8006f82 <_svfprintf_r+0x336>
 80070bc:	9f08      	ldr	r7, [sp, #32]
 80070be:	f047 0708 	orr.w	r7, r7, #8
 80070c2:	9708      	str	r7, [sp, #32]
 80070c4:	781f      	ldrb	r7, [r3, #0]
 80070c6:	e635      	b.n	8006d34 <_svfprintf_r+0xe8>
 80070c8:	9c08      	ldr	r4, [sp, #32]
 80070ca:	930a      	str	r3, [sp, #40]	; 0x28
 80070cc:	f044 0410 	orr.w	r4, r4, #16
 80070d0:	9408      	str	r4, [sp, #32]
 80070d2:	9d08      	ldr	r5, [sp, #32]
 80070d4:	f015 0320 	ands.w	r3, r5, #32
 80070d8:	f000 80bf 	beq.w	800725a <_svfprintf_r+0x60e>
 80070dc:	9e11      	ldr	r6, [sp, #68]	; 0x44
 80070de:	2300      	movs	r3, #0
 80070e0:	1df2      	adds	r2, r6, #7
 80070e2:	f022 0207 	bic.w	r2, r2, #7
 80070e6:	f102 0408 	add.w	r4, r2, #8
 80070ea:	9411      	str	r4, [sp, #68]	; 0x44
 80070ec:	e9d2 4500 	ldrd	r4, r5, [r2]
 80070f0:	ea54 0605 	orrs.w	r6, r4, r5
 80070f4:	bf0c      	ite	eq
 80070f6:	2200      	moveq	r2, #0
 80070f8:	2201      	movne	r2, #1
 80070fa:	2100      	movs	r1, #0
 80070fc:	f88d 108b 	strb.w	r1, [sp, #139]	; 0x8b
 8007100:	e700      	b.n	8006f04 <_svfprintf_r+0x2b8>
 8007102:	9c08      	ldr	r4, [sp, #32]
 8007104:	930a      	str	r3, [sp, #40]	; 0x28
 8007106:	f044 0410 	orr.w	r4, r4, #16
 800710a:	9408      	str	r4, [sp, #32]
 800710c:	9d08      	ldr	r5, [sp, #32]
 800710e:	06ad      	lsls	r5, r5, #26
 8007110:	f140 80e4 	bpl.w	80072dc <_svfprintf_r+0x690>
 8007114:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007116:	2301      	movs	r3, #1
 8007118:	1df2      	adds	r2, r6, #7
 800711a:	e7e2      	b.n	80070e2 <_svfprintf_r+0x496>
 800711c:	9d08      	ldr	r5, [sp, #32]
 800711e:	f24d 1468 	movw	r4, #53608	; 0xd168
 8007122:	f6c0 0400 	movt	r4, #2048	; 0x800
 8007126:	930a      	str	r3, [sp, #40]	; 0x28
 8007128:	06a9      	lsls	r1, r5, #26
 800712a:	941a      	str	r4, [sp, #104]	; 0x68
 800712c:	f140 8109 	bpl.w	8007342 <_svfprintf_r+0x6f6>
 8007130:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007132:	1df3      	adds	r3, r6, #7
 8007134:	f023 0307 	bic.w	r3, r3, #7
 8007138:	f103 0408 	add.w	r4, r3, #8
 800713c:	9411      	str	r4, [sp, #68]	; 0x44
 800713e:	e9d3 4500 	ldrd	r4, r5, [r3]
 8007142:	9e08      	ldr	r6, [sp, #32]
 8007144:	07f6      	lsls	r6, r6, #31
 8007146:	f100 83db 	bmi.w	8007900 <_svfprintf_r+0xcb4>
 800714a:	ea54 0005 	orrs.w	r0, r4, r5
 800714e:	f04f 0302 	mov.w	r3, #2
 8007152:	bf0c      	ite	eq
 8007154:	2200      	moveq	r2, #0
 8007156:	2201      	movne	r2, #1
 8007158:	e7cf      	b.n	80070fa <_svfprintf_r+0x4ae>
 800715a:	9f08      	ldr	r7, [sp, #32]
 800715c:	f047 0720 	orr.w	r7, r7, #32
 8007160:	9708      	str	r7, [sp, #32]
 8007162:	781f      	ldrb	r7, [r3, #0]
 8007164:	e5e6      	b.n	8006d34 <_svfprintf_r+0xe8>
 8007166:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007168:	2400      	movs	r4, #0
 800716a:	f88d 408b 	strb.w	r4, [sp, #139]	; 0x8b
 800716e:	930a      	str	r3, [sp, #40]	; 0x28
 8007170:	6836      	ldr	r6, [r6, #0]
 8007172:	9614      	str	r6, [sp, #80]	; 0x50
 8007174:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007176:	1d35      	adds	r5, r6, #4
 8007178:	9e14      	ldr	r6, [sp, #80]	; 0x50
 800717a:	2e00      	cmp	r6, #0
 800717c:	f000 86dc 	beq.w	8007f38 <_svfprintf_r+0x12ec>
 8007180:	f1b9 0f00 	cmp.w	r9, #0
 8007184:	9814      	ldr	r0, [sp, #80]	; 0x50
 8007186:	f2c0 86a8 	blt.w	8007eda <_svfprintf_r+0x128e>
 800718a:	4621      	mov	r1, r4
 800718c:	464a      	mov	r2, r9
 800718e:	f002 fc75 	bl	8009a7c <memchr>
 8007192:	2800      	cmp	r0, #0
 8007194:	f000 8741 	beq.w	800801a <_svfprintf_r+0x13ce>
 8007198:	9e14      	ldr	r6, [sp, #80]	; 0x50
 800719a:	9410      	str	r4, [sp, #64]	; 0x40
 800719c:	1b80      	subs	r0, r0, r6
 800719e:	900e      	str	r0, [sp, #56]	; 0x38
 80071a0:	4548      	cmp	r0, r9
 80071a2:	f340 85a2 	ble.w	8007cea <_svfprintf_r+0x109e>
 80071a6:	9511      	str	r5, [sp, #68]	; 0x44
 80071a8:	ea29 74e9 	bic.w	r4, r9, r9, asr #31
 80071ac:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80071ae:	940b      	str	r4, [sp, #44]	; 0x2c
 80071b0:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 80071b4:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 80071b8:	951b      	str	r5, [sp, #108]	; 0x6c
 80071ba:	e6e2      	b.n	8006f82 <_svfprintf_r+0x336>
 80071bc:	781f      	ldrb	r7, [r3, #0]
 80071be:	461a      	mov	r2, r3
 80071c0:	2f6c      	cmp	r7, #108	; 0x6c
 80071c2:	f000 858a 	beq.w	8007cda <_svfprintf_r+0x108e>
 80071c6:	9e08      	ldr	r6, [sp, #32]
 80071c8:	f046 0610 	orr.w	r6, r6, #16
 80071cc:	9608      	str	r6, [sp, #32]
 80071ce:	e5b1      	b.n	8006d34 <_svfprintf_r+0xe8>
 80071d0:	930a      	str	r3, [sp, #40]	; 0x28
 80071d2:	2f00      	cmp	r7, #0
 80071d4:	f000 8574 	beq.w	8007cc0 <_svfprintf_r+0x1074>
 80071d8:	2401      	movs	r4, #1
 80071da:	2300      	movs	r3, #0
 80071dc:	ad2e      	add	r5, sp, #184	; 0xb8
 80071de:	940b      	str	r4, [sp, #44]	; 0x2c
 80071e0:	f88d 70b8 	strb.w	r7, [sp, #184]	; 0xb8
 80071e4:	940e      	str	r4, [sp, #56]	; 0x38
 80071e6:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 80071ea:	9514      	str	r5, [sp, #80]	; 0x50
 80071ec:	2500      	movs	r5, #0
 80071ee:	9510      	str	r5, [sp, #64]	; 0x40
 80071f0:	951b      	str	r5, [sp, #108]	; 0x6c
 80071f2:	e6cd      	b.n	8006f90 <_svfprintf_r+0x344>
 80071f4:	9d08      	ldr	r5, [sp, #32]
 80071f6:	930a      	str	r3, [sp, #40]	; 0x28
 80071f8:	06ad      	lsls	r5, r5, #26
 80071fa:	f53f ae6c 	bmi.w	8006ed6 <_svfprintf_r+0x28a>
 80071fe:	9d08      	ldr	r5, [sp, #32]
 8007200:	06ec      	lsls	r4, r5, #27
 8007202:	f140 84ad 	bpl.w	8007b60 <_svfprintf_r+0xf14>
 8007206:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007208:	3604      	adds	r6, #4
 800720a:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800720e:	9611      	str	r6, [sp, #68]	; 0x44
 8007210:	461c      	mov	r4, r3
 8007212:	461a      	mov	r2, r3
 8007214:	17dd      	asrs	r5, r3, #31
 8007216:	462b      	mov	r3, r5
 8007218:	e668      	b.n	8006eec <_svfprintf_r+0x2a0>
 800721a:	9c08      	ldr	r4, [sp, #32]
 800721c:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 8007220:	9408      	str	r4, [sp, #32]
 8007222:	781f      	ldrb	r7, [r3, #0]
 8007224:	e586      	b.n	8006d34 <_svfprintf_r+0xe8>
 8007226:	930a      	str	r3, [sp, #40]	; 0x28
 8007228:	f04f 0901 	mov.w	r9, #1
 800722c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800722e:	2200      	movs	r2, #0
 8007230:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007232:	ae2e      	add	r6, sp, #184	; 0xb8
 8007234:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8007238:	681b      	ldr	r3, [r3, #0]
 800723a:	3404      	adds	r4, #4
 800723c:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8007240:	9411      	str	r4, [sp, #68]	; 0x44
 8007242:	f88d 208b 	strb.w	r2, [sp, #139]	; 0x8b
 8007246:	9614      	str	r6, [sp, #80]	; 0x50
 8007248:	f88d 30b8 	strb.w	r3, [sp, #184]	; 0xb8
 800724c:	e7ce      	b.n	80071ec <_svfprintf_r+0x5a0>
 800724e:	9d08      	ldr	r5, [sp, #32]
 8007250:	930a      	str	r3, [sp, #40]	; 0x28
 8007252:	f015 0320 	ands.w	r3, r5, #32
 8007256:	f47f af41 	bne.w	80070dc <_svfprintf_r+0x490>
 800725a:	9c08      	ldr	r4, [sp, #32]
 800725c:	f014 0210 	ands.w	r2, r4, #16
 8007260:	f000 848c 	beq.w	8007b7c <_svfprintf_r+0xf30>
 8007264:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8007266:	1d2e      	adds	r6, r5, #4
 8007268:	9611      	str	r6, [sp, #68]	; 0x44
 800726a:	682a      	ldr	r2, [r5, #0]
 800726c:	4614      	mov	r4, r2
 800726e:	3200      	adds	r2, #0
 8007270:	bf18      	it	ne
 8007272:	2201      	movne	r2, #1
 8007274:	2500      	movs	r5, #0
 8007276:	e740      	b.n	80070fa <_svfprintf_r+0x4ae>
 8007278:	930a      	str	r3, [sp, #40]	; 0x28
 800727a:	2778      	movs	r7, #120	; 0x78
 800727c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800727e:	f24d 167c 	movw	r6, #53628	; 0xd17c
 8007282:	9d08      	ldr	r5, [sp, #32]
 8007284:	f6c0 0600 	movt	r6, #2048	; 0x800
 8007288:	1d1c      	adds	r4, r3, #4
 800728a:	9411      	str	r4, [sp, #68]	; 0x44
 800728c:	681a      	ldr	r2, [r3, #0]
 800728e:	f045 0502 	orr.w	r5, r5, #2
 8007292:	9508      	str	r5, [sp, #32]
 8007294:	2500      	movs	r5, #0
 8007296:	2330      	movs	r3, #48	; 0x30
 8007298:	4614      	mov	r4, r2
 800729a:	1b52      	subs	r2, r2, r5
 800729c:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 80072a0:	bf18      	it	ne
 80072a2:	2201      	movne	r2, #1
 80072a4:	f88d 708d 	strb.w	r7, [sp, #141]	; 0x8d
 80072a8:	961a      	str	r6, [sp, #104]	; 0x68
 80072aa:	2302      	movs	r3, #2
 80072ac:	e725      	b.n	80070fa <_svfprintf_r+0x4ae>
 80072ae:	9f08      	ldr	r7, [sp, #32]
 80072b0:	930a      	str	r3, [sp, #40]	; 0x28
 80072b2:	06ba      	lsls	r2, r7, #26
 80072b4:	f140 8480 	bpl.w	8007bb8 <_svfprintf_r+0xf6c>
 80072b8:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
 80072bc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80072be:	f109 0904 	add.w	r9, r9, #4
 80072c2:	f859 3c04 	ldr.w	r3, [r9, #-4]
 80072c6:	17d1      	asrs	r1, r2, #31
 80072c8:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
 80072cc:	601a      	str	r2, [r3, #0]
 80072ce:	6059      	str	r1, [r3, #4]
 80072d0:	e4fc      	b.n	8006ccc <_svfprintf_r+0x80>
 80072d2:	9d08      	ldr	r5, [sp, #32]
 80072d4:	930a      	str	r3, [sp, #40]	; 0x28
 80072d6:	06ad      	lsls	r5, r5, #26
 80072d8:	f53f af1c 	bmi.w	8007114 <_svfprintf_r+0x4c8>
 80072dc:	9c08      	ldr	r4, [sp, #32]
 80072de:	06e4      	lsls	r4, r4, #27
 80072e0:	f140 8485 	bpl.w	8007bee <_svfprintf_r+0xfa2>
 80072e4:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80072e6:	1d2e      	adds	r6, r5, #4
 80072e8:	9611      	str	r6, [sp, #68]	; 0x44
 80072ea:	682a      	ldr	r2, [r5, #0]
 80072ec:	2301      	movs	r3, #1
 80072ee:	4614      	mov	r4, r2
 80072f0:	3200      	adds	r2, #0
 80072f2:	bf18      	it	ne
 80072f4:	2201      	movne	r2, #1
 80072f6:	2500      	movs	r5, #0
 80072f8:	e6ff      	b.n	80070fa <_svfprintf_r+0x4ae>
 80072fa:	9f08      	ldr	r7, [sp, #32]
 80072fc:	f047 0701 	orr.w	r7, r7, #1
 8007300:	9708      	str	r7, [sp, #32]
 8007302:	781f      	ldrb	r7, [r3, #0]
 8007304:	e516      	b.n	8006d34 <_svfprintf_r+0xe8>
 8007306:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007308:	9d11      	ldr	r5, [sp, #68]	; 0x44
 800730a:	6824      	ldr	r4, [r4, #0]
 800730c:	1d2a      	adds	r2, r5, #4
 800730e:	2c00      	cmp	r4, #0
 8007310:	940d      	str	r4, [sp, #52]	; 0x34
 8007312:	f6ff ad70 	blt.w	8006df6 <_svfprintf_r+0x1aa>
 8007316:	781f      	ldrb	r7, [r3, #0]
 8007318:	9211      	str	r2, [sp, #68]	; 0x44
 800731a:	e50b      	b.n	8006d34 <_svfprintf_r+0xe8>
 800731c:	f89d 208b 	ldrb.w	r2, [sp, #139]	; 0x8b
 8007320:	2a00      	cmp	r2, #0
 8007322:	f040 83f5 	bne.w	8007b10 <_svfprintf_r+0xec4>
 8007326:	f88d 008b 	strb.w	r0, [sp, #139]	; 0x8b
 800732a:	781f      	ldrb	r7, [r3, #0]
 800732c:	e502      	b.n	8006d34 <_svfprintf_r+0xe8>
 800732e:	9d08      	ldr	r5, [sp, #32]
 8007330:	f24d 167c 	movw	r6, #53628	; 0xd17c
 8007334:	f6c0 0600 	movt	r6, #2048	; 0x800
 8007338:	930a      	str	r3, [sp, #40]	; 0x28
 800733a:	06a9      	lsls	r1, r5, #26
 800733c:	961a      	str	r6, [sp, #104]	; 0x68
 800733e:	f53f aef7 	bmi.w	8007130 <_svfprintf_r+0x4e4>
 8007342:	9d08      	ldr	r5, [sp, #32]
 8007344:	06ea      	lsls	r2, r5, #27
 8007346:	f140 842b 	bpl.w	8007ba0 <_svfprintf_r+0xf54>
 800734a:	9e11      	ldr	r6, [sp, #68]	; 0x44
 800734c:	2500      	movs	r5, #0
 800734e:	3604      	adds	r6, #4
 8007350:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8007354:	9611      	str	r6, [sp, #68]	; 0x44
 8007356:	461c      	mov	r4, r3
 8007358:	e6f3      	b.n	8007142 <_svfprintf_r+0x4f6>
 800735a:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 800735c:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007360:	b18b      	cbz	r3, 8007386 <_svfprintf_r+0x73a>
 8007362:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007364:	f10d 038b 	add.w	r3, sp, #139	; 0x8b
 8007368:	f8c8 3000 	str.w	r3, [r8]
 800736c:	2301      	movs	r3, #1
 800736e:	3401      	adds	r4, #1
 8007370:	f8c8 3004 	str.w	r3, [r8, #4]
 8007374:	2c07      	cmp	r4, #7
 8007376:	441d      	add	r5, r3
 8007378:	942c      	str	r4, [sp, #176]	; 0xb0
 800737a:	bfd8      	it	le
 800737c:	f108 0808 	addle.w	r8, r8, #8
 8007380:	952d      	str	r5, [sp, #180]	; 0xb4
 8007382:	f300 81e6 	bgt.w	8007752 <_svfprintf_r+0xb06>
 8007386:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 8007388:	b186      	cbz	r6, 80073ac <_svfprintf_r+0x760>
 800738a:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800738c:	ab23      	add	r3, sp, #140	; 0x8c
 800738e:	f8c8 3000 	str.w	r3, [r8]
 8007392:	2302      	movs	r3, #2
 8007394:	3401      	adds	r4, #1
 8007396:	f8c8 3004 	str.w	r3, [r8, #4]
 800739a:	2c07      	cmp	r4, #7
 800739c:	441d      	add	r5, r3
 800739e:	942c      	str	r4, [sp, #176]	; 0xb0
 80073a0:	bfd8      	it	le
 80073a2:	f108 0808 	addle.w	r8, r8, #8
 80073a6:	952d      	str	r5, [sp, #180]	; 0xb4
 80073a8:	f300 81de 	bgt.w	8007768 <_svfprintf_r+0xb1c>
 80073ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80073ae:	2b80      	cmp	r3, #128	; 0x80
 80073b0:	f000 8127 	beq.w	8007602 <_svfprintf_r+0x9b6>
 80073b4:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80073b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80073b8:	ebc3 0904 	rsb	r9, r3, r4
 80073bc:	f1b9 0f00 	cmp.w	r9, #0
 80073c0:	dd42      	ble.n	8007448 <_svfprintf_r+0x7fc>
 80073c2:	f1b9 0f10 	cmp.w	r9, #16
 80073c6:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80073c8:	bfd8      	it	le
 80073ca:	4e98      	ldrle	r6, [pc, #608]	; (800762c <_svfprintf_r+0x9e0>)
 80073cc:	dd27      	ble.n	800741e <_svfprintf_r+0x7d2>
 80073ce:	4e97      	ldr	r6, [pc, #604]	; (800762c <_svfprintf_r+0x9e0>)
 80073d0:	f04f 0a10 	mov.w	sl, #16
 80073d4:	9710      	str	r7, [sp, #64]	; 0x40
 80073d6:	4637      	mov	r7, r6
 80073d8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80073da:	e004      	b.n	80073e6 <_svfprintf_r+0x79a>
 80073dc:	f1a9 0910 	sub.w	r9, r9, #16
 80073e0:	f1b9 0f10 	cmp.w	r9, #16
 80073e4:	dd19      	ble.n	800741a <_svfprintf_r+0x7ce>
 80073e6:	3401      	adds	r4, #1
 80073e8:	3510      	adds	r5, #16
 80073ea:	2c07      	cmp	r4, #7
 80073ec:	e888 0480 	stmia.w	r8, {r7, sl}
 80073f0:	942c      	str	r4, [sp, #176]	; 0xb0
 80073f2:	f108 0808 	add.w	r8, r8, #8
 80073f6:	952d      	str	r5, [sp, #180]	; 0xb4
 80073f8:	ddf0      	ble.n	80073dc <_svfprintf_r+0x790>
 80073fa:	4630      	mov	r0, r6
 80073fc:	9909      	ldr	r1, [sp, #36]	; 0x24
 80073fe:	aa2b      	add	r2, sp, #172	; 0xac
 8007400:	46d8      	mov	r8, fp
 8007402:	f003 fa25 	bl	800a850 <__ssprint_r>
 8007406:	2800      	cmp	r0, #0
 8007408:	f47f ad0f 	bne.w	8006e2a <_svfprintf_r+0x1de>
 800740c:	f1a9 0910 	sub.w	r9, r9, #16
 8007410:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007412:	f1b9 0f10 	cmp.w	r9, #16
 8007416:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007418:	dce5      	bgt.n	80073e6 <_svfprintf_r+0x79a>
 800741a:	463e      	mov	r6, r7
 800741c:	9f10      	ldr	r7, [sp, #64]	; 0x40
 800741e:	3401      	adds	r4, #1
 8007420:	e888 0240 	stmia.w	r8, {r6, r9}
 8007424:	2c07      	cmp	r4, #7
 8007426:	444d      	add	r5, r9
 8007428:	942c      	str	r4, [sp, #176]	; 0xb0
 800742a:	bfd8      	it	le
 800742c:	f108 0808 	addle.w	r8, r8, #8
 8007430:	952d      	str	r5, [sp, #180]	; 0xb4
 8007432:	dd09      	ble.n	8007448 <_svfprintf_r+0x7fc>
 8007434:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007436:	aa2b      	add	r2, sp, #172	; 0xac
 8007438:	9909      	ldr	r1, [sp, #36]	; 0x24
 800743a:	f003 fa09 	bl	800a850 <__ssprint_r>
 800743e:	2800      	cmp	r0, #0
 8007440:	f47f acf3 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007444:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007446:	46d8      	mov	r8, fp
 8007448:	9e08      	ldr	r6, [sp, #32]
 800744a:	05f1      	lsls	r1, r6, #23
 800744c:	d462      	bmi.n	8007514 <_svfprintf_r+0x8c8>
 800744e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007450:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8007452:	3401      	adds	r4, #1
 8007454:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007456:	2c07      	cmp	r4, #7
 8007458:	443d      	add	r5, r7
 800745a:	e888 00c0 	stmia.w	r8, {r6, r7}
 800745e:	952d      	str	r5, [sp, #180]	; 0xb4
 8007460:	942c      	str	r4, [sp, #176]	; 0xb0
 8007462:	f300 8167 	bgt.w	8007734 <_svfprintf_r+0xae8>
 8007466:	f108 0808 	add.w	r8, r8, #8
 800746a:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800746e:	f019 0f04 	tst.w	r9, #4
 8007472:	d03f      	beq.n	80074f4 <_svfprintf_r+0x8a8>
 8007474:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8007476:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8007478:	1be6      	subs	r6, r4, r7
 800747a:	2e00      	cmp	r6, #0
 800747c:	dd3a      	ble.n	80074f4 <_svfprintf_r+0x8a8>
 800747e:	2e10      	cmp	r6, #16
 8007480:	f64c 6aa8 	movw	sl, #52904	; 0xcea8
 8007484:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007486:	f6c0 0a00 	movt	sl, #2048	; 0x800
 800748a:	dd20      	ble.n	80074ce <_svfprintf_r+0x882>
 800748c:	2710      	movs	r7, #16
 800748e:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
 8007492:	e002      	b.n	800749a <_svfprintf_r+0x84e>
 8007494:	3e10      	subs	r6, #16
 8007496:	2e10      	cmp	r6, #16
 8007498:	dd19      	ble.n	80074ce <_svfprintf_r+0x882>
 800749a:	3401      	adds	r4, #1
 800749c:	3510      	adds	r5, #16
 800749e:	2c07      	cmp	r4, #7
 80074a0:	f8c8 a000 	str.w	sl, [r8]
 80074a4:	f8c8 7004 	str.w	r7, [r8, #4]
 80074a8:	f108 0808 	add.w	r8, r8, #8
 80074ac:	942c      	str	r4, [sp, #176]	; 0xb0
 80074ae:	952d      	str	r5, [sp, #180]	; 0xb4
 80074b0:	ddf0      	ble.n	8007494 <_svfprintf_r+0x848>
 80074b2:	4648      	mov	r0, r9
 80074b4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80074b6:	aa2b      	add	r2, sp, #172	; 0xac
 80074b8:	46d8      	mov	r8, fp
 80074ba:	f003 f9c9 	bl	800a850 <__ssprint_r>
 80074be:	2800      	cmp	r0, #0
 80074c0:	f47f acb3 	bne.w	8006e2a <_svfprintf_r+0x1de>
 80074c4:	3e10      	subs	r6, #16
 80074c6:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80074c8:	2e10      	cmp	r6, #16
 80074ca:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80074cc:	dce5      	bgt.n	800749a <_svfprintf_r+0x84e>
 80074ce:	3401      	adds	r4, #1
 80074d0:	f8c8 a000 	str.w	sl, [r8]
 80074d4:	2c07      	cmp	r4, #7
 80074d6:	f8c8 6004 	str.w	r6, [r8, #4]
 80074da:	4435      	add	r5, r6
 80074dc:	942c      	str	r4, [sp, #176]	; 0xb0
 80074de:	952d      	str	r5, [sp, #180]	; 0xb4
 80074e0:	dd08      	ble.n	80074f4 <_svfprintf_r+0x8a8>
 80074e2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80074e4:	aa2b      	add	r2, sp, #172	; 0xac
 80074e6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80074e8:	f003 f9b2 	bl	800a850 <__ssprint_r>
 80074ec:	2800      	cmp	r0, #0
 80074ee:	f47f ac9c 	bne.w	8006e2a <_svfprintf_r+0x1de>
 80074f2:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80074f4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80074f6:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80074f8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80074fa:	42b7      	cmp	r7, r6
 80074fc:	bfac      	ite	ge
 80074fe:	19e4      	addge	r4, r4, r7
 8007500:	19a4      	addlt	r4, r4, r6
 8007502:	940c      	str	r4, [sp, #48]	; 0x30
 8007504:	2d00      	cmp	r5, #0
 8007506:	f47f ac88 	bne.w	8006e1a <_svfprintf_r+0x1ce>
 800750a:	2300      	movs	r3, #0
 800750c:	46d8      	mov	r8, fp
 800750e:	932c      	str	r3, [sp, #176]	; 0xb0
 8007510:	f7ff bbdc 	b.w	8006ccc <_svfprintf_r+0x80>
 8007514:	2f65      	cmp	r7, #101	; 0x65
 8007516:	f340 80c3 	ble.w	80076a0 <_svfprintf_r+0xa54>
 800751a:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 800751e:	2200      	movs	r2, #0
 8007520:	2300      	movs	r3, #0
 8007522:	f004 ffb3 	bl	800c48c <__aeabi_dcmpeq>
 8007526:	2800      	cmp	r0, #0
 8007528:	f000 8129 	beq.w	800777e <_svfprintf_r+0xb32>
 800752c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800752e:	f24d 1398 	movw	r3, #53656	; 0xd198
 8007532:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007536:	f8c8 3000 	str.w	r3, [r8]
 800753a:	3401      	adds	r4, #1
 800753c:	2301      	movs	r3, #1
 800753e:	2c07      	cmp	r4, #7
 8007540:	f8c8 3004 	str.w	r3, [r8, #4]
 8007544:	441d      	add	r5, r3
 8007546:	942c      	str	r4, [sp, #176]	; 0xb0
 8007548:	952d      	str	r5, [sp, #180]	; 0xb4
 800754a:	bfd8      	it	le
 800754c:	f108 0808 	addle.w	r8, r8, #8
 8007550:	f300 8355 	bgt.w	8007bfe <_svfprintf_r+0xfb2>
 8007554:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007556:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8007558:	42bb      	cmp	r3, r7
 800755a:	db04      	blt.n	8007566 <_svfprintf_r+0x91a>
 800755c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8007560:	f019 0f01 	tst.w	r9, #1
 8007564:	d081      	beq.n	800746a <_svfprintf_r+0x81e>
 8007566:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007568:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 800756a:	3401      	adds	r4, #1
 800756c:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 800756e:	2c07      	cmp	r4, #7
 8007570:	4435      	add	r5, r6
 8007572:	f8c8 6004 	str.w	r6, [r8, #4]
 8007576:	f8c8 7000 	str.w	r7, [r8]
 800757a:	bfd8      	it	le
 800757c:	f108 0808 	addle.w	r8, r8, #8
 8007580:	952d      	str	r5, [sp, #180]	; 0xb4
 8007582:	942c      	str	r4, [sp, #176]	; 0xb0
 8007584:	f300 8448 	bgt.w	8007e18 <_svfprintf_r+0x11cc>
 8007588:	9c12      	ldr	r4, [sp, #72]	; 0x48
 800758a:	1e67      	subs	r7, r4, #1
 800758c:	2f00      	cmp	r7, #0
 800758e:	f77f af6c 	ble.w	800746a <_svfprintf_r+0x81e>
 8007592:	2f10      	cmp	r7, #16
 8007594:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007596:	f340 81c6 	ble.w	8007926 <_svfprintf_r+0xcda>
 800759a:	f04f 0910 	mov.w	r9, #16
 800759e:	4e23      	ldr	r6, [pc, #140]	; (800762c <_svfprintf_r+0x9e0>)
 80075a0:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
 80075a4:	e003      	b.n	80075ae <_svfprintf_r+0x962>
 80075a6:	3f10      	subs	r7, #16
 80075a8:	2f10      	cmp	r7, #16
 80075aa:	f340 81bd 	ble.w	8007928 <_svfprintf_r+0xcdc>
 80075ae:	3401      	adds	r4, #1
 80075b0:	3510      	adds	r5, #16
 80075b2:	2c07      	cmp	r4, #7
 80075b4:	e888 0240 	stmia.w	r8, {r6, r9}
 80075b8:	942c      	str	r4, [sp, #176]	; 0xb0
 80075ba:	f108 0808 	add.w	r8, r8, #8
 80075be:	952d      	str	r5, [sp, #180]	; 0xb4
 80075c0:	ddf1      	ble.n	80075a6 <_svfprintf_r+0x95a>
 80075c2:	4650      	mov	r0, sl
 80075c4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80075c6:	aa2b      	add	r2, sp, #172	; 0xac
 80075c8:	46d8      	mov	r8, fp
 80075ca:	f003 f941 	bl	800a850 <__ssprint_r>
 80075ce:	2800      	cmp	r0, #0
 80075d0:	f47f ac2b 	bne.w	8006e2a <_svfprintf_r+0x1de>
 80075d4:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80075d6:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80075d8:	e7e5      	b.n	80075a6 <_svfprintf_r+0x95a>
 80075da:	2b00      	cmp	r3, #0
 80075dc:	f040 80b5 	bne.w	800774a <_svfprintf_r+0xafe>
 80075e0:	9c08      	ldr	r4, [sp, #32]
 80075e2:	07e0      	lsls	r0, r4, #31
 80075e4:	bf5c      	itt	pl
 80075e6:	930e      	strpl	r3, [sp, #56]	; 0x38
 80075e8:	f8cd b050 	strpl.w	fp, [sp, #80]	; 0x50
 80075ec:	f57f acbc 	bpl.w	8006f68 <_svfprintf_r+0x31c>
 80075f0:	ab48      	add	r3, sp, #288	; 0x120
 80075f2:	2230      	movs	r2, #48	; 0x30
 80075f4:	f803 2d41 	strb.w	r2, [r3, #-65]!
 80075f8:	ebc3 050b 	rsb	r5, r3, fp
 80075fc:	9314      	str	r3, [sp, #80]	; 0x50
 80075fe:	950e      	str	r5, [sp, #56]	; 0x38
 8007600:	e4b2      	b.n	8006f68 <_svfprintf_r+0x31c>
 8007602:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8007604:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8007606:	ebc6 0904 	rsb	r9, r6, r4
 800760a:	f1b9 0f00 	cmp.w	r9, #0
 800760e:	f77f aed1 	ble.w	80073b4 <_svfprintf_r+0x768>
 8007612:	f1b9 0f10 	cmp.w	r9, #16
 8007616:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007618:	bfd8      	it	le
 800761a:	4e04      	ldrle	r6, [pc, #16]	; (800762c <_svfprintf_r+0x9e0>)
 800761c:	dd29      	ble.n	8007672 <_svfprintf_r+0xa26>
 800761e:	4e03      	ldr	r6, [pc, #12]	; (800762c <_svfprintf_r+0x9e0>)
 8007620:	f04f 0a10 	mov.w	sl, #16
 8007624:	9713      	str	r7, [sp, #76]	; 0x4c
 8007626:	4637      	mov	r7, r6
 8007628:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 800762a:	e006      	b.n	800763a <_svfprintf_r+0x9ee>
 800762c:	0800ceb8 	.word	0x0800ceb8
 8007630:	f1a9 0910 	sub.w	r9, r9, #16
 8007634:	f1b9 0f10 	cmp.w	r9, #16
 8007638:	dd19      	ble.n	800766e <_svfprintf_r+0xa22>
 800763a:	3401      	adds	r4, #1
 800763c:	3510      	adds	r5, #16
 800763e:	2c07      	cmp	r4, #7
 8007640:	e888 0480 	stmia.w	r8, {r7, sl}
 8007644:	942c      	str	r4, [sp, #176]	; 0xb0
 8007646:	f108 0808 	add.w	r8, r8, #8
 800764a:	952d      	str	r5, [sp, #180]	; 0xb4
 800764c:	ddf0      	ble.n	8007630 <_svfprintf_r+0x9e4>
 800764e:	4630      	mov	r0, r6
 8007650:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007652:	aa2b      	add	r2, sp, #172	; 0xac
 8007654:	46d8      	mov	r8, fp
 8007656:	f003 f8fb 	bl	800a850 <__ssprint_r>
 800765a:	2800      	cmp	r0, #0
 800765c:	f47f abe5 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007660:	f1a9 0910 	sub.w	r9, r9, #16
 8007664:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007666:	f1b9 0f10 	cmp.w	r9, #16
 800766a:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800766c:	dce5      	bgt.n	800763a <_svfprintf_r+0x9ee>
 800766e:	463e      	mov	r6, r7
 8007670:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 8007672:	3401      	adds	r4, #1
 8007674:	e888 0240 	stmia.w	r8, {r6, r9}
 8007678:	2c07      	cmp	r4, #7
 800767a:	444d      	add	r5, r9
 800767c:	942c      	str	r4, [sp, #176]	; 0xb0
 800767e:	bfd8      	it	le
 8007680:	f108 0808 	addle.w	r8, r8, #8
 8007684:	952d      	str	r5, [sp, #180]	; 0xb4
 8007686:	f77f ae95 	ble.w	80073b4 <_svfprintf_r+0x768>
 800768a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800768c:	aa2b      	add	r2, sp, #172	; 0xac
 800768e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007690:	f003 f8de 	bl	800a850 <__ssprint_r>
 8007694:	2800      	cmp	r0, #0
 8007696:	f47f abc8 	bne.w	8006e2a <_svfprintf_r+0x1de>
 800769a:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 800769c:	46d8      	mov	r8, fp
 800769e:	e689      	b.n	80073b4 <_svfprintf_r+0x768>
 80076a0:	9c12      	ldr	r4, [sp, #72]	; 0x48
 80076a2:	2c01      	cmp	r4, #1
 80076a4:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80076a6:	f340 81cd 	ble.w	8007a44 <_svfprintf_r+0xdf8>
 80076aa:	3401      	adds	r4, #1
 80076ac:	9e14      	ldr	r6, [sp, #80]	; 0x50
 80076ae:	3501      	adds	r5, #1
 80076b0:	2301      	movs	r3, #1
 80076b2:	2c07      	cmp	r4, #7
 80076b4:	f8c8 3004 	str.w	r3, [r8, #4]
 80076b8:	f8c8 6000 	str.w	r6, [r8]
 80076bc:	bfd8      	it	le
 80076be:	f108 0808 	addle.w	r8, r8, #8
 80076c2:	952d      	str	r5, [sp, #180]	; 0xb4
 80076c4:	942c      	str	r4, [sp, #176]	; 0xb0
 80076c6:	f300 81cf 	bgt.w	8007a68 <_svfprintf_r+0xe1c>
 80076ca:	3401      	adds	r4, #1
 80076cc:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 80076ce:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 80076d0:	2c07      	cmp	r4, #7
 80076d2:	4435      	add	r5, r6
 80076d4:	f8c8 6004 	str.w	r6, [r8, #4]
 80076d8:	f8c8 7000 	str.w	r7, [r8]
 80076dc:	bfd8      	it	le
 80076de:	f108 0808 	addle.w	r8, r8, #8
 80076e2:	942c      	str	r4, [sp, #176]	; 0xb0
 80076e4:	952d      	str	r5, [sp, #180]	; 0xb4
 80076e6:	f300 81cb 	bgt.w	8007a80 <_svfprintf_r+0xe34>
 80076ea:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
 80076ee:	2200      	movs	r2, #0
 80076f0:	2300      	movs	r3, #0
 80076f2:	f004 fecb 	bl	800c48c <__aeabi_dcmpeq>
 80076f6:	2800      	cmp	r0, #0
 80076f8:	f040 80c4 	bne.w	8007884 <_svfprintf_r+0xc38>
 80076fc:	9f12      	ldr	r7, [sp, #72]	; 0x48
 80076fe:	3401      	adds	r4, #1
 8007700:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007702:	1e7b      	subs	r3, r7, #1
 8007704:	f8c8 3004 	str.w	r3, [r8, #4]
 8007708:	1c72      	adds	r2, r6, #1
 800770a:	2c07      	cmp	r4, #7
 800770c:	f8c8 2000 	str.w	r2, [r8]
 8007710:	441d      	add	r5, r3
 8007712:	942c      	str	r4, [sp, #176]	; 0xb0
 8007714:	952d      	str	r5, [sp, #180]	; 0xb4
 8007716:	f300 80e7 	bgt.w	80078e8 <_svfprintf_r+0xc9c>
 800771a:	f108 0808 	add.w	r8, r8, #8
 800771e:	3401      	adds	r4, #1
 8007720:	9f20      	ldr	r7, [sp, #128]	; 0x80
 8007722:	2c07      	cmp	r4, #7
 8007724:	ab27      	add	r3, sp, #156	; 0x9c
 8007726:	443d      	add	r5, r7
 8007728:	e888 0088 	stmia.w	r8, {r3, r7}
 800772c:	952d      	str	r5, [sp, #180]	; 0xb4
 800772e:	942c      	str	r4, [sp, #176]	; 0xb0
 8007730:	f77f ae99 	ble.w	8007466 <_svfprintf_r+0x81a>
 8007734:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007736:	aa2b      	add	r2, sp, #172	; 0xac
 8007738:	9909      	ldr	r1, [sp, #36]	; 0x24
 800773a:	f003 f889 	bl	800a850 <__ssprint_r>
 800773e:	2800      	cmp	r0, #0
 8007740:	f47f ab73 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007744:	46d8      	mov	r8, fp
 8007746:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007748:	e68f      	b.n	800746a <_svfprintf_r+0x81e>
 800774a:	920e      	str	r2, [sp, #56]	; 0x38
 800774c:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
 8007750:	e40a      	b.n	8006f68 <_svfprintf_r+0x31c>
 8007752:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007754:	aa2b      	add	r2, sp, #172	; 0xac
 8007756:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007758:	f003 f87a 	bl	800a850 <__ssprint_r>
 800775c:	2800      	cmp	r0, #0
 800775e:	f47f ab64 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007762:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007764:	46d8      	mov	r8, fp
 8007766:	e60e      	b.n	8007386 <_svfprintf_r+0x73a>
 8007768:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800776a:	aa2b      	add	r2, sp, #172	; 0xac
 800776c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800776e:	f003 f86f 	bl	800a850 <__ssprint_r>
 8007772:	2800      	cmp	r0, #0
 8007774:	f47f ab59 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007778:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 800777a:	46d8      	mov	r8, fp
 800777c:	e616      	b.n	80073ac <_svfprintf_r+0x760>
 800777e:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8007780:	2f00      	cmp	r7, #0
 8007782:	f340 8247 	ble.w	8007c14 <_svfprintf_r+0xfc8>
 8007786:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8007788:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 800778c:	9c14      	ldr	r4, [sp, #80]	; 0x50
 800778e:	454e      	cmp	r6, r9
 8007790:	bfa8      	it	ge
 8007792:	464e      	movge	r6, r9
 8007794:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8007796:	2e00      	cmp	r6, #0
 8007798:	eb04 0a07 	add.w	sl, r4, r7
 800779c:	dd0f      	ble.n	80077be <_svfprintf_r+0xb72>
 800779e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80077a0:	19ad      	adds	r5, r5, r6
 80077a2:	9814      	ldr	r0, [sp, #80]	; 0x50
 80077a4:	3401      	adds	r4, #1
 80077a6:	f8c8 6004 	str.w	r6, [r8, #4]
 80077aa:	2c07      	cmp	r4, #7
 80077ac:	f8c8 0000 	str.w	r0, [r8]
 80077b0:	bfd8      	it	le
 80077b2:	f108 0808 	addle.w	r8, r8, #8
 80077b6:	952d      	str	r5, [sp, #180]	; 0xb4
 80077b8:	942c      	str	r4, [sp, #176]	; 0xb0
 80077ba:	f300 839c 	bgt.w	8007ef6 <_svfprintf_r+0x12aa>
 80077be:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
 80077c0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 80077c4:	1ba7      	subs	r7, r4, r6
 80077c6:	2f00      	cmp	r7, #0
 80077c8:	f340 80d3 	ble.w	8007972 <_svfprintf_r+0xd26>
 80077cc:	2f10      	cmp	r7, #16
 80077ce:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80077d0:	bfd8      	it	le
 80077d2:	4eb1      	ldrle	r6, [pc, #708]	; (8007a98 <_svfprintf_r+0xe4c>)
 80077d4:	f340 80b8 	ble.w	8007948 <_svfprintf_r+0xcfc>
 80077d8:	4eaf      	ldr	r6, [pc, #700]	; (8007a98 <_svfprintf_r+0xe4c>)
 80077da:	f04f 0910 	mov.w	r9, #16
 80077de:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 80077e2:	46ba      	mov	sl, r7
 80077e4:	4637      	mov	r7, r6
 80077e6:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80077e8:	e005      	b.n	80077f6 <_svfprintf_r+0xbaa>
 80077ea:	f1aa 0a10 	sub.w	sl, sl, #16
 80077ee:	f1ba 0f10 	cmp.w	sl, #16
 80077f2:	f340 80a5 	ble.w	8007940 <_svfprintf_r+0xcf4>
 80077f6:	3401      	adds	r4, #1
 80077f8:	3510      	adds	r5, #16
 80077fa:	2c07      	cmp	r4, #7
 80077fc:	e888 0280 	stmia.w	r8, {r7, r9}
 8007800:	942c      	str	r4, [sp, #176]	; 0xb0
 8007802:	f108 0808 	add.w	r8, r8, #8
 8007806:	952d      	str	r5, [sp, #180]	; 0xb4
 8007808:	ddef      	ble.n	80077ea <_svfprintf_r+0xb9e>
 800780a:	4630      	mov	r0, r6
 800780c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800780e:	aa2b      	add	r2, sp, #172	; 0xac
 8007810:	46d8      	mov	r8, fp
 8007812:	f003 f81d 	bl	800a850 <__ssprint_r>
 8007816:	2800      	cmp	r0, #0
 8007818:	f47f ab07 	bne.w	8006e2a <_svfprintf_r+0x1de>
 800781c:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 800781e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007820:	e7e3      	b.n	80077ea <_svfprintf_r+0xb9e>
 8007822:	9e1a      	ldr	r6, [sp, #104]	; 0x68
 8007824:	f10d 01df 	add.w	r1, sp, #223	; 0xdf
 8007828:	46c2      	mov	sl, r8
 800782a:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 800782e:	f04f 080f 	mov.w	r8, #15
 8007832:	0923      	lsrs	r3, r4, #4
 8007834:	ea04 0208 	and.w	r2, r4, r8
 8007838:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 800783c:	18b2      	adds	r2, r6, r2
 800783e:	ea4f 1c15 	mov.w	ip, r5, lsr #4
 8007842:	461c      	mov	r4, r3
 8007844:	4665      	mov	r5, ip
 8007846:	7812      	ldrb	r2, [r2, #0]
 8007848:	4608      	mov	r0, r1
 800784a:	3901      	subs	r1, #1
 800784c:	ea54 0905 	orrs.w	r9, r4, r5
 8007850:	7002      	strb	r2, [r0, #0]
 8007852:	d1ec      	bne.n	800782e <_svfprintf_r+0xbe2>
 8007854:	ebc0 030b 	rsb	r3, r0, fp
 8007858:	9014      	str	r0, [sp, #80]	; 0x50
 800785a:	46d0      	mov	r8, sl
 800785c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8007860:	930e      	str	r3, [sp, #56]	; 0x38
 8007862:	f7ff bb81 	b.w	8006f68 <_svfprintf_r+0x31c>
 8007866:	2d00      	cmp	r5, #0
 8007868:	bf08      	it	eq
 800786a:	2c0a      	cmpeq	r4, #10
 800786c:	f080 8116 	bcs.w	8007a9c <_svfprintf_r+0xe50>
 8007870:	ab48      	add	r3, sp, #288	; 0x120
 8007872:	3430      	adds	r4, #48	; 0x30
 8007874:	f803 4d41 	strb.w	r4, [r3, #-65]!
 8007878:	ebc3 050b 	rsb	r5, r3, fp
 800787c:	9314      	str	r3, [sp, #80]	; 0x50
 800787e:	950e      	str	r5, [sp, #56]	; 0x38
 8007880:	f7ff bb72 	b.w	8006f68 <_svfprintf_r+0x31c>
 8007884:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8007886:	1e77      	subs	r7, r6, #1
 8007888:	2f00      	cmp	r7, #0
 800788a:	f77f af48 	ble.w	800771e <_svfprintf_r+0xad2>
 800788e:	2f10      	cmp	r7, #16
 8007890:	4e81      	ldr	r6, [pc, #516]	; (8007a98 <_svfprintf_r+0xe4c>)
 8007892:	bfc4      	itt	gt
 8007894:	f04f 0910 	movgt.w	r9, #16
 8007898:	f8dd a03c 	ldrgt.w	sl, [sp, #60]	; 0x3c
 800789c:	dc03      	bgt.n	80078a6 <_svfprintf_r+0xc5a>
 800789e:	e01a      	b.n	80078d6 <_svfprintf_r+0xc8a>
 80078a0:	3f10      	subs	r7, #16
 80078a2:	2f10      	cmp	r7, #16
 80078a4:	dd17      	ble.n	80078d6 <_svfprintf_r+0xc8a>
 80078a6:	3401      	adds	r4, #1
 80078a8:	3510      	adds	r5, #16
 80078aa:	2c07      	cmp	r4, #7
 80078ac:	e888 0240 	stmia.w	r8, {r6, r9}
 80078b0:	942c      	str	r4, [sp, #176]	; 0xb0
 80078b2:	f108 0808 	add.w	r8, r8, #8
 80078b6:	952d      	str	r5, [sp, #180]	; 0xb4
 80078b8:	ddf2      	ble.n	80078a0 <_svfprintf_r+0xc54>
 80078ba:	4650      	mov	r0, sl
 80078bc:	9909      	ldr	r1, [sp, #36]	; 0x24
 80078be:	aa2b      	add	r2, sp, #172	; 0xac
 80078c0:	46d8      	mov	r8, fp
 80078c2:	f002 ffc5 	bl	800a850 <__ssprint_r>
 80078c6:	2800      	cmp	r0, #0
 80078c8:	f47f aaaf 	bne.w	8006e2a <_svfprintf_r+0x1de>
 80078cc:	3f10      	subs	r7, #16
 80078ce:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80078d0:	2f10      	cmp	r7, #16
 80078d2:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80078d4:	dce7      	bgt.n	80078a6 <_svfprintf_r+0xc5a>
 80078d6:	3401      	adds	r4, #1
 80078d8:	e888 00c0 	stmia.w	r8, {r6, r7}
 80078dc:	2c07      	cmp	r4, #7
 80078de:	443d      	add	r5, r7
 80078e0:	942c      	str	r4, [sp, #176]	; 0xb0
 80078e2:	952d      	str	r5, [sp, #180]	; 0xb4
 80078e4:	f77f af19 	ble.w	800771a <_svfprintf_r+0xace>
 80078e8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80078ea:	aa2b      	add	r2, sp, #172	; 0xac
 80078ec:	9909      	ldr	r1, [sp, #36]	; 0x24
 80078ee:	f002 ffaf 	bl	800a850 <__ssprint_r>
 80078f2:	2800      	cmp	r0, #0
 80078f4:	f47f aa99 	bne.w	8006e2a <_svfprintf_r+0x1de>
 80078f8:	46d8      	mov	r8, fp
 80078fa:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80078fc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80078fe:	e70e      	b.n	800771e <_svfprintf_r+0xad2>
 8007900:	2200      	movs	r2, #0
 8007902:	2302      	movs	r3, #2
 8007904:	ea54 0105 	orrs.w	r1, r4, r5
 8007908:	f43f abf7 	beq.w	80070fa <_svfprintf_r+0x4ae>
 800790c:	9e08      	ldr	r6, [sp, #32]
 800790e:	2330      	movs	r3, #48	; 0x30
 8007910:	f88d 708d 	strb.w	r7, [sp, #141]	; 0x8d
 8007914:	2201      	movs	r2, #1
 8007916:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
 800791a:	f046 0602 	orr.w	r6, r6, #2
 800791e:	2302      	movs	r3, #2
 8007920:	9608      	str	r6, [sp, #32]
 8007922:	f7ff bbea 	b.w	80070fa <_svfprintf_r+0x4ae>
 8007926:	4e5c      	ldr	r6, [pc, #368]	; (8007a98 <_svfprintf_r+0xe4c>)
 8007928:	3401      	adds	r4, #1
 800792a:	f8c8 6000 	str.w	r6, [r8]
 800792e:	2c07      	cmp	r4, #7
 8007930:	f8c8 7004 	str.w	r7, [r8, #4]
 8007934:	443d      	add	r5, r7
 8007936:	942c      	str	r4, [sp, #176]	; 0xb0
 8007938:	952d      	str	r5, [sp, #180]	; 0xb4
 800793a:	f77f ad94 	ble.w	8007466 <_svfprintf_r+0x81a>
 800793e:	e6f9      	b.n	8007734 <_svfprintf_r+0xae8>
 8007940:	463e      	mov	r6, r7
 8007942:	4657      	mov	r7, sl
 8007944:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 8007948:	3401      	adds	r4, #1
 800794a:	e888 00c0 	stmia.w	r8, {r6, r7}
 800794e:	2c07      	cmp	r4, #7
 8007950:	443d      	add	r5, r7
 8007952:	942c      	str	r4, [sp, #176]	; 0xb0
 8007954:	bfd8      	it	le
 8007956:	f108 0808 	addle.w	r8, r8, #8
 800795a:	952d      	str	r5, [sp, #180]	; 0xb4
 800795c:	dd09      	ble.n	8007972 <_svfprintf_r+0xd26>
 800795e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007960:	aa2b      	add	r2, sp, #172	; 0xac
 8007962:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007964:	f002 ff74 	bl	800a850 <__ssprint_r>
 8007968:	2800      	cmp	r0, #0
 800796a:	f47f aa5e 	bne.w	8006e2a <_svfprintf_r+0x1de>
 800796e:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007970:	46d8      	mov	r8, fp
 8007972:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007974:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007976:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007978:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 800797c:	42a3      	cmp	r3, r4
 800797e:	eb06 0709 	add.w	r7, r6, r9
 8007982:	db42      	blt.n	8007a0a <_svfprintf_r+0xdbe>
 8007984:	9e08      	ldr	r6, [sp, #32]
 8007986:	07f2      	lsls	r2, r6, #31
 8007988:	d43f      	bmi.n	8007a0a <_svfprintf_r+0xdbe>
 800798a:	9c12      	ldr	r4, [sp, #72]	; 0x48
 800798c:	ebc7 060a 	rsb	r6, r7, sl
 8007990:	1ae3      	subs	r3, r4, r3
 8007992:	42b3      	cmp	r3, r6
 8007994:	bfb8      	it	lt
 8007996:	461e      	movlt	r6, r3
 8007998:	2e00      	cmp	r6, #0
 800799a:	dd0e      	ble.n	80079ba <_svfprintf_r+0xd6e>
 800799c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800799e:	19ad      	adds	r5, r5, r6
 80079a0:	f8c8 7000 	str.w	r7, [r8]
 80079a4:	3401      	adds	r4, #1
 80079a6:	f8c8 6004 	str.w	r6, [r8, #4]
 80079aa:	2c07      	cmp	r4, #7
 80079ac:	952d      	str	r5, [sp, #180]	; 0xb4
 80079ae:	942c      	str	r4, [sp, #176]	; 0xb0
 80079b0:	bfd8      	it	le
 80079b2:	f108 0808 	addle.w	r8, r8, #8
 80079b6:	f300 82a9 	bgt.w	8007f0c <_svfprintf_r+0x12c0>
 80079ba:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 80079be:	1b9f      	subs	r7, r3, r6
 80079c0:	2f00      	cmp	r7, #0
 80079c2:	f77f ad52 	ble.w	800746a <_svfprintf_r+0x81e>
 80079c6:	2f10      	cmp	r7, #16
 80079c8:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 80079ca:	ddac      	ble.n	8007926 <_svfprintf_r+0xcda>
 80079cc:	f04f 0910 	mov.w	r9, #16
 80079d0:	4e31      	ldr	r6, [pc, #196]	; (8007a98 <_svfprintf_r+0xe4c>)
 80079d2:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
 80079d6:	e002      	b.n	80079de <_svfprintf_r+0xd92>
 80079d8:	3f10      	subs	r7, #16
 80079da:	2f10      	cmp	r7, #16
 80079dc:	dda4      	ble.n	8007928 <_svfprintf_r+0xcdc>
 80079de:	3401      	adds	r4, #1
 80079e0:	3510      	adds	r5, #16
 80079e2:	2c07      	cmp	r4, #7
 80079e4:	e888 0240 	stmia.w	r8, {r6, r9}
 80079e8:	942c      	str	r4, [sp, #176]	; 0xb0
 80079ea:	f108 0808 	add.w	r8, r8, #8
 80079ee:	952d      	str	r5, [sp, #180]	; 0xb4
 80079f0:	ddf2      	ble.n	80079d8 <_svfprintf_r+0xd8c>
 80079f2:	4650      	mov	r0, sl
 80079f4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80079f6:	aa2b      	add	r2, sp, #172	; 0xac
 80079f8:	46d8      	mov	r8, fp
 80079fa:	f002 ff29 	bl	800a850 <__ssprint_r>
 80079fe:	2800      	cmp	r0, #0
 8007a00:	f47f aa13 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007a04:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007a06:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007a08:	e7e6      	b.n	80079d8 <_svfprintf_r+0xd8c>
 8007a0a:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8007a0c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007a0e:	19ad      	adds	r5, r5, r6
 8007a10:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8007a12:	3401      	adds	r4, #1
 8007a14:	2c07      	cmp	r4, #7
 8007a16:	f8c8 6000 	str.w	r6, [r8]
 8007a1a:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8007a1c:	f8c8 6004 	str.w	r6, [r8, #4]
 8007a20:	bfd8      	it	le
 8007a22:	f108 0808 	addle.w	r8, r8, #8
 8007a26:	952d      	str	r5, [sp, #180]	; 0xb4
 8007a28:	942c      	str	r4, [sp, #176]	; 0xb0
 8007a2a:	ddae      	ble.n	800798a <_svfprintf_r+0xd3e>
 8007a2c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007a2e:	aa2b      	add	r2, sp, #172	; 0xac
 8007a30:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007a32:	f002 ff0d 	bl	800a850 <__ssprint_r>
 8007a36:	2800      	cmp	r0, #0
 8007a38:	f47f a9f7 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007a3c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007a3e:	46d8      	mov	r8, fp
 8007a40:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007a42:	e7a2      	b.n	800798a <_svfprintf_r+0xd3e>
 8007a44:	9e08      	ldr	r6, [sp, #32]
 8007a46:	07f3      	lsls	r3, r6, #31
 8007a48:	f53f ae2f 	bmi.w	80076aa <_svfprintf_r+0xa5e>
 8007a4c:	3401      	adds	r4, #1
 8007a4e:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007a50:	3501      	adds	r5, #1
 8007a52:	2301      	movs	r3, #1
 8007a54:	2c07      	cmp	r4, #7
 8007a56:	f8c8 3004 	str.w	r3, [r8, #4]
 8007a5a:	f8c8 6000 	str.w	r6, [r8]
 8007a5e:	952d      	str	r5, [sp, #180]	; 0xb4
 8007a60:	942c      	str	r4, [sp, #176]	; 0xb0
 8007a62:	f77f ae5a 	ble.w	800771a <_svfprintf_r+0xace>
 8007a66:	e73f      	b.n	80078e8 <_svfprintf_r+0xc9c>
 8007a68:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007a6a:	aa2b      	add	r2, sp, #172	; 0xac
 8007a6c:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007a6e:	f002 feef 	bl	800a850 <__ssprint_r>
 8007a72:	2800      	cmp	r0, #0
 8007a74:	f47f a9d9 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007a78:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007a7a:	46d8      	mov	r8, fp
 8007a7c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007a7e:	e624      	b.n	80076ca <_svfprintf_r+0xa7e>
 8007a80:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007a82:	aa2b      	add	r2, sp, #172	; 0xac
 8007a84:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007a86:	f002 fee3 	bl	800a850 <__ssprint_r>
 8007a8a:	2800      	cmp	r0, #0
 8007a8c:	f47f a9cd 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007a90:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007a92:	46d8      	mov	r8, fp
 8007a94:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007a96:	e628      	b.n	80076ea <_svfprintf_r+0xa9e>
 8007a98:	0800ceb8 	.word	0x0800ceb8
 8007a9c:	f10d 06df 	add.w	r6, sp, #223	; 0xdf
 8007aa0:	4620      	mov	r0, r4
 8007aa2:	4629      	mov	r1, r5
 8007aa4:	220a      	movs	r2, #10
 8007aa6:	2300      	movs	r3, #0
 8007aa8:	f004 fd4a 	bl	800c540 <__aeabi_uldivmod>
 8007aac:	46b2      	mov	sl, r6
 8007aae:	4620      	mov	r0, r4
 8007ab0:	4629      	mov	r1, r5
 8007ab2:	2300      	movs	r3, #0
 8007ab4:	3e01      	subs	r6, #1
 8007ab6:	f102 0430 	add.w	r4, r2, #48	; 0x30
 8007aba:	220a      	movs	r2, #10
 8007abc:	f88a 4000 	strb.w	r4, [sl]
 8007ac0:	f004 fd3e 	bl	800c540 <__aeabi_uldivmod>
 8007ac4:	4604      	mov	r4, r0
 8007ac6:	460d      	mov	r5, r1
 8007ac8:	ea54 0005 	orrs.w	r0, r4, r5
 8007acc:	d1e8      	bne.n	8007aa0 <_svfprintf_r+0xe54>
 8007ace:	ebca 030b 	rsb	r3, sl, fp
 8007ad2:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
 8007ad6:	930e      	str	r3, [sp, #56]	; 0x38
 8007ad8:	f7ff ba46 	b.w	8006f68 <_svfprintf_r+0x31c>
 8007adc:	2a30      	cmp	r2, #48	; 0x30
 8007ade:	f000 8223 	beq.w	8007f28 <_svfprintf_r+0x12dc>
 8007ae2:	ebc0 040b 	rsb	r4, r0, fp
 8007ae6:	2230      	movs	r2, #48	; 0x30
 8007ae8:	9014      	str	r0, [sp, #80]	; 0x50
 8007aea:	940e      	str	r4, [sp, #56]	; 0x38
 8007aec:	f803 2c01 	strb.w	r2, [r3, #-1]
 8007af0:	f7ff ba3a 	b.w	8006f68 <_svfprintf_r+0x31c>
 8007af4:	4264      	negs	r4, r4
 8007af6:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 8007afa:	232d      	movs	r3, #45	; 0x2d
 8007afc:	ea54 0105 	orrs.w	r1, r4, r5
 8007b00:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 8007b04:	bf0c      	ite	eq
 8007b06:	2200      	moveq	r2, #0
 8007b08:	2201      	movne	r2, #1
 8007b0a:	2301      	movs	r3, #1
 8007b0c:	f7ff b9fa 	b.w	8006f04 <_svfprintf_r+0x2b8>
 8007b10:	781f      	ldrb	r7, [r3, #0]
 8007b12:	f7ff b90f 	b.w	8006d34 <_svfprintf_r+0xe8>
 8007b16:	4629      	mov	r1, r5
 8007b18:	f002 fd40 	bl	800a59c <__fpclassifyd>
 8007b1c:	2800      	cmp	r0, #0
 8007b1e:	f040 80ff 	bne.w	8007d20 <_svfprintf_r+0x10d4>
 8007b22:	9e08      	ldr	r6, [sp, #32]
 8007b24:	f04f 0903 	mov.w	r9, #3
 8007b28:	9c18      	ldr	r4, [sp, #96]	; 0x60
 8007b2a:	9d19      	ldr	r5, [sp, #100]	; 0x64
 8007b2c:	f026 0680 	bic.w	r6, r6, #128	; 0x80
 8007b30:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8007b34:	2f47      	cmp	r7, #71	; 0x47
 8007b36:	bfd8      	it	le
 8007b38:	462c      	movle	r4, r5
 8007b3a:	9010      	str	r0, [sp, #64]	; 0x40
 8007b3c:	9414      	str	r4, [sp, #80]	; 0x50
 8007b3e:	9608      	str	r6, [sp, #32]
 8007b40:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007b44:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8007b48:	901b      	str	r0, [sp, #108]	; 0x6c
 8007b4a:	f7ff ba1a 	b.w	8006f82 <_svfprintf_r+0x336>
 8007b4e:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007b50:	1de1      	adds	r1, r4, #7
 8007b52:	f021 0107 	bic.w	r1, r1, #7
 8007b56:	f101 0508 	add.w	r5, r1, #8
 8007b5a:	9511      	str	r5, [sp, #68]	; 0x44
 8007b5c:	f7ff ba82 	b.w	8007064 <_svfprintf_r+0x418>
 8007b60:	9c08      	ldr	r4, [sp, #32]
 8007b62:	0660      	lsls	r0, r4, #25
 8007b64:	f140 814e 	bpl.w	8007e04 <_svfprintf_r+0x11b8>
 8007b68:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007b6a:	3604      	adds	r6, #4
 8007b6c:	f936 4c04 	ldrsh.w	r4, [r6, #-4]
 8007b70:	9611      	str	r6, [sp, #68]	; 0x44
 8007b72:	4622      	mov	r2, r4
 8007b74:	17e5      	asrs	r5, r4, #31
 8007b76:	462b      	mov	r3, r5
 8007b78:	f7ff b9b8 	b.w	8006eec <_svfprintf_r+0x2a0>
 8007b7c:	9c08      	ldr	r4, [sp, #32]
 8007b7e:	f014 0340 	ands.w	r3, r4, #64	; 0x40
 8007b82:	f000 80c2 	beq.w	8007d0a <_svfprintf_r+0x10be>
 8007b86:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007b88:	4613      	mov	r3, r2
 8007b8a:	8834      	ldrh	r4, [r6, #0]
 8007b8c:	2500      	movs	r5, #0
 8007b8e:	3604      	adds	r6, #4
 8007b90:	ea54 0005 	orrs.w	r0, r4, r5
 8007b94:	9611      	str	r6, [sp, #68]	; 0x44
 8007b96:	bf0c      	ite	eq
 8007b98:	2200      	moveq	r2, #0
 8007b9a:	2201      	movne	r2, #1
 8007b9c:	f7ff baad 	b.w	80070fa <_svfprintf_r+0x4ae>
 8007ba0:	9c08      	ldr	r4, [sp, #32]
 8007ba2:	0663      	lsls	r3, r4, #25
 8007ba4:	f140 8144 	bpl.w	8007e30 <_svfprintf_r+0x11e4>
 8007ba8:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007baa:	2500      	movs	r5, #0
 8007bac:	3604      	adds	r6, #4
 8007bae:	f836 4c04 	ldrh.w	r4, [r6, #-4]
 8007bb2:	9611      	str	r6, [sp, #68]	; 0x44
 8007bb4:	f7ff bac5 	b.w	8007142 <_svfprintf_r+0x4f6>
 8007bb8:	9c08      	ldr	r4, [sp, #32]
 8007bba:	06e3      	lsls	r3, r4, #27
 8007bbc:	d40e      	bmi.n	8007bdc <_svfprintf_r+0xf90>
 8007bbe:	9f08      	ldr	r7, [sp, #32]
 8007bc0:	067e      	lsls	r6, r7, #25
 8007bc2:	d50b      	bpl.n	8007bdc <_svfprintf_r+0xf90>
 8007bc4:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
 8007bc8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8007bca:	f109 0904 	add.w	r9, r9, #4
 8007bce:	f859 3c04 	ldr.w	r3, [r9, #-4]
 8007bd2:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
 8007bd6:	801c      	strh	r4, [r3, #0]
 8007bd8:	f7ff b878 	b.w	8006ccc <_svfprintf_r+0x80>
 8007bdc:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8007bde:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8007be0:	3504      	adds	r5, #4
 8007be2:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8007be6:	9511      	str	r5, [sp, #68]	; 0x44
 8007be8:	601e      	str	r6, [r3, #0]
 8007bea:	f7ff b86f 	b.w	8006ccc <_svfprintf_r+0x80>
 8007bee:	9c08      	ldr	r4, [sp, #32]
 8007bf0:	0660      	lsls	r0, r4, #25
 8007bf2:	f140 8084 	bpl.w	8007cfe <_svfprintf_r+0x10b2>
 8007bf6:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8007bf8:	2301      	movs	r3, #1
 8007bfa:	8834      	ldrh	r4, [r6, #0]
 8007bfc:	e7c6      	b.n	8007b8c <_svfprintf_r+0xf40>
 8007bfe:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007c00:	aa2b      	add	r2, sp, #172	; 0xac
 8007c02:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007c04:	f002 fe24 	bl	800a850 <__ssprint_r>
 8007c08:	2800      	cmp	r0, #0
 8007c0a:	f47f a90e 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007c0e:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007c10:	46d8      	mov	r8, fp
 8007c12:	e49f      	b.n	8007554 <_svfprintf_r+0x908>
 8007c14:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007c16:	f24d 1398 	movw	r3, #53656	; 0xd198
 8007c1a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007c1e:	f8c8 3000 	str.w	r3, [r8]
 8007c22:	3401      	adds	r4, #1
 8007c24:	2301      	movs	r3, #1
 8007c26:	2c07      	cmp	r4, #7
 8007c28:	f8c8 3004 	str.w	r3, [r8, #4]
 8007c2c:	441d      	add	r5, r3
 8007c2e:	942c      	str	r4, [sp, #176]	; 0xb0
 8007c30:	952d      	str	r5, [sp, #180]	; 0xb4
 8007c32:	bfd8      	it	le
 8007c34:	f108 0808 	addle.w	r8, r8, #8
 8007c38:	f300 8112 	bgt.w	8007e60 <_svfprintf_r+0x1214>
 8007c3c:	b93f      	cbnz	r7, 8007c4e <_svfprintf_r+0x1002>
 8007c3e:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8007c40:	b92e      	cbnz	r6, 8007c4e <_svfprintf_r+0x1002>
 8007c42:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8007c46:	f019 0f01 	tst.w	r9, #1
 8007c4a:	f43f ac0e 	beq.w	800746a <_svfprintf_r+0x81e>
 8007c4e:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8007c50:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007c52:	19ad      	adds	r5, r5, r6
 8007c54:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8007c56:	3401      	adds	r4, #1
 8007c58:	2c07      	cmp	r4, #7
 8007c5a:	f8c8 6000 	str.w	r6, [r8]
 8007c5e:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8007c60:	f8c8 6004 	str.w	r6, [r8, #4]
 8007c64:	bfd8      	it	le
 8007c66:	f108 0808 	addle.w	r8, r8, #8
 8007c6a:	952d      	str	r5, [sp, #180]	; 0xb4
 8007c6c:	942c      	str	r4, [sp, #176]	; 0xb0
 8007c6e:	f300 8122 	bgt.w	8007eb6 <_svfprintf_r+0x126a>
 8007c72:	427f      	negs	r7, r7
 8007c74:	2f00      	cmp	r7, #0
 8007c76:	f340 8118 	ble.w	8007eaa <_svfprintf_r+0x125e>
 8007c7a:	2f10      	cmp	r7, #16
 8007c7c:	4ead      	ldr	r6, [pc, #692]	; (8007f34 <_svfprintf_r+0x12e8>)
 8007c7e:	bfc4      	itt	gt
 8007c80:	f04f 0910 	movgt.w	r9, #16
 8007c84:	f8dd a03c 	ldrgt.w	sl, [sp, #60]	; 0x3c
 8007c88:	dc04      	bgt.n	8007c94 <_svfprintf_r+0x1048>
 8007c8a:	e0f8      	b.n	8007e7e <_svfprintf_r+0x1232>
 8007c8c:	3f10      	subs	r7, #16
 8007c8e:	2f10      	cmp	r7, #16
 8007c90:	f340 80f5 	ble.w	8007e7e <_svfprintf_r+0x1232>
 8007c94:	3401      	adds	r4, #1
 8007c96:	3510      	adds	r5, #16
 8007c98:	2c07      	cmp	r4, #7
 8007c9a:	e888 0240 	stmia.w	r8, {r6, r9}
 8007c9e:	942c      	str	r4, [sp, #176]	; 0xb0
 8007ca0:	f108 0808 	add.w	r8, r8, #8
 8007ca4:	952d      	str	r5, [sp, #180]	; 0xb4
 8007ca6:	ddf1      	ble.n	8007c8c <_svfprintf_r+0x1040>
 8007ca8:	4650      	mov	r0, sl
 8007caa:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007cac:	aa2b      	add	r2, sp, #172	; 0xac
 8007cae:	46d8      	mov	r8, fp
 8007cb0:	f002 fdce 	bl	800a850 <__ssprint_r>
 8007cb4:	2800      	cmp	r0, #0
 8007cb6:	f47f a8b8 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007cba:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007cbc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007cbe:	e7e5      	b.n	8007c8c <_svfprintf_r+0x1040>
 8007cc0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8007cc2:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8007cc6:	2b00      	cmp	r3, #0
 8007cc8:	f43f a8b1 	beq.w	8006e2e <_svfprintf_r+0x1e2>
 8007ccc:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007cce:	4649      	mov	r1, r9
 8007cd0:	aa2b      	add	r2, sp, #172	; 0xac
 8007cd2:	f002 fdbd 	bl	800a850 <__ssprint_r>
 8007cd6:	f7ff b8aa 	b.w	8006e2e <_svfprintf_r+0x1e2>
 8007cda:	9d08      	ldr	r5, [sp, #32]
 8007cdc:	3301      	adds	r3, #1
 8007cde:	7857      	ldrb	r7, [r2, #1]
 8007ce0:	f045 0520 	orr.w	r5, r5, #32
 8007ce4:	9508      	str	r5, [sp, #32]
 8007ce6:	f7ff b825 	b.w	8006d34 <_svfprintf_r+0xe8>
 8007cea:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8007cec:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007cf0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 8007cf4:	9511      	str	r5, [sp, #68]	; 0x44
 8007cf6:	960b      	str	r6, [sp, #44]	; 0x2c
 8007cf8:	941b      	str	r4, [sp, #108]	; 0x6c
 8007cfa:	f7ff b942 	b.w	8006f82 <_svfprintf_r+0x336>
 8007cfe:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007d00:	1d25      	adds	r5, r4, #4
 8007d02:	9511      	str	r5, [sp, #68]	; 0x44
 8007d04:	6822      	ldr	r2, [r4, #0]
 8007d06:	f7ff baf1 	b.w	80072ec <_svfprintf_r+0x6a0>
 8007d0a:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007d0c:	1d25      	adds	r5, r4, #4
 8007d0e:	9511      	str	r5, [sp, #68]	; 0x44
 8007d10:	6822      	ldr	r2, [r4, #0]
 8007d12:	4614      	mov	r4, r2
 8007d14:	3200      	adds	r2, #0
 8007d16:	bf18      	it	ne
 8007d18:	2201      	movne	r2, #1
 8007d1a:	2500      	movs	r5, #0
 8007d1c:	f7ff b9ed 	b.w	80070fa <_svfprintf_r+0x4ae>
 8007d20:	f1b9 3fff 	cmp.w	r9, #4294967295
 8007d24:	f027 0a20 	bic.w	sl, r7, #32
 8007d28:	bf08      	it	eq
 8007d2a:	f04f 0906 	moveq.w	r9, #6
 8007d2e:	d007      	beq.n	8007d40 <_svfprintf_r+0x10f4>
 8007d30:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 8007d34:	d104      	bne.n	8007d40 <_svfprintf_r+0x10f4>
 8007d36:	f1b9 0f00 	cmp.w	r9, #0
 8007d3a:	bf08      	it	eq
 8007d3c:	f04f 0901 	moveq.w	r9, #1
 8007d40:	9c08      	ldr	r4, [sp, #32]
 8007d42:	2d00      	cmp	r5, #0
 8007d44:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 8007d48:	9413      	str	r4, [sp, #76]	; 0x4c
 8007d4a:	f2c0 80c1 	blt.w	8007ed0 <_svfprintf_r+0x1284>
 8007d4e:	2400      	movs	r4, #0
 8007d50:	9410      	str	r4, [sp, #64]	; 0x40
 8007d52:	f1ba 0246 	subs.w	r2, sl, #70	; 0x46
 8007d56:	4251      	negs	r1, r2
 8007d58:	4151      	adcs	r1, r2
 8007d5a:	2900      	cmp	r1, #0
 8007d5c:	f040 8102 	bne.w	8007f64 <_svfprintf_r+0x1318>
 8007d60:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
 8007d64:	f040 8172 	bne.w	800804c <_svfprintf_r+0x1400>
 8007d68:	f109 0401 	add.w	r4, r9, #1
 8007d6c:	2102      	movs	r1, #2
 8007d6e:	9401      	str	r4, [sp, #4]
 8007d70:	4632      	mov	r2, r6
 8007d72:	9100      	str	r1, [sp, #0]
 8007d74:	462b      	mov	r3, r5
 8007d76:	a924      	add	r1, sp, #144	; 0x90
 8007d78:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007d7a:	9102      	str	r1, [sp, #8]
 8007d7c:	a925      	add	r1, sp, #148	; 0x94
 8007d7e:	9103      	str	r1, [sp, #12]
 8007d80:	a926      	add	r1, sp, #152	; 0x98
 8007d82:	9104      	str	r1, [sp, #16]
 8007d84:	f000 fa9c 	bl	80082c0 <_dtoa_r>
 8007d88:	1904      	adds	r4, r0, r4
 8007d8a:	9014      	str	r0, [sp, #80]	; 0x50
 8007d8c:	4630      	mov	r0, r6
 8007d8e:	2200      	movs	r2, #0
 8007d90:	2300      	movs	r3, #0
 8007d92:	4629      	mov	r1, r5
 8007d94:	f004 fb7a 	bl	800c48c <__aeabi_dcmpeq>
 8007d98:	b950      	cbnz	r0, 8007db0 <_svfprintf_r+0x1164>
 8007d9a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8007d9c:	429c      	cmp	r4, r3
 8007d9e:	bf98      	it	ls
 8007da0:	461c      	movls	r4, r3
 8007da2:	d905      	bls.n	8007db0 <_svfprintf_r+0x1164>
 8007da4:	2230      	movs	r2, #48	; 0x30
 8007da6:	f803 2b01 	strb.w	r2, [r3], #1
 8007daa:	42a3      	cmp	r3, r4
 8007dac:	9326      	str	r3, [sp, #152]	; 0x98
 8007dae:	d1fa      	bne.n	8007da6 <_svfprintf_r+0x115a>
 8007db0:	9d14      	ldr	r5, [sp, #80]	; 0x50
 8007db2:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 8007db6:	ebc5 0404 	rsb	r4, r5, r4
 8007dba:	9412      	str	r4, [sp, #72]	; 0x48
 8007dbc:	f000 8100 	beq.w	8007fc0 <_svfprintf_r+0x1374>
 8007dc0:	2f65      	cmp	r7, #101	; 0x65
 8007dc2:	f340 81dd 	ble.w	8008180 <_svfprintf_r+0x1534>
 8007dc6:	2f66      	cmp	r7, #102	; 0x66
 8007dc8:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8007dca:	f000 8170 	beq.w	80080ae <_svfprintf_r+0x1462>
 8007dce:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007dd0:	42a2      	cmp	r2, r4
 8007dd2:	f2c0 812e 	blt.w	8008032 <_svfprintf_r+0x13e6>
 8007dd6:	9d08      	ldr	r5, [sp, #32]
 8007dd8:	07e9      	lsls	r1, r5, #31
 8007dda:	f100 817f 	bmi.w	80080dc <_svfprintf_r+0x1490>
 8007dde:	2767      	movs	r7, #103	; 0x67
 8007de0:	ea22 76e2 	bic.w	r6, r2, r2, asr #31
 8007de4:	920e      	str	r2, [sp, #56]	; 0x38
 8007de6:	960b      	str	r6, [sp, #44]	; 0x2c
 8007de8:	921b      	str	r2, [sp, #108]	; 0x6c
 8007dea:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8007dec:	2c00      	cmp	r4, #0
 8007dee:	f000 80de 	beq.w	8007fae <_svfprintf_r+0x1362>
 8007df2:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8007df4:	232d      	movs	r3, #45	; 0x2d
 8007df6:	2600      	movs	r6, #0
 8007df8:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 8007dfc:	9610      	str	r6, [sp, #64]	; 0x40
 8007dfe:	9508      	str	r5, [sp, #32]
 8007e00:	f7ff b8c0 	b.w	8006f84 <_svfprintf_r+0x338>
 8007e04:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007e06:	1d25      	adds	r5, r4, #4
 8007e08:	9511      	str	r5, [sp, #68]	; 0x44
 8007e0a:	6823      	ldr	r3, [r4, #0]
 8007e0c:	461c      	mov	r4, r3
 8007e0e:	461a      	mov	r2, r3
 8007e10:	17dd      	asrs	r5, r3, #31
 8007e12:	462b      	mov	r3, r5
 8007e14:	f7ff b86a 	b.w	8006eec <_svfprintf_r+0x2a0>
 8007e18:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007e1a:	aa2b      	add	r2, sp, #172	; 0xac
 8007e1c:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007e1e:	f002 fd17 	bl	800a850 <__ssprint_r>
 8007e22:	2800      	cmp	r0, #0
 8007e24:	f47f a801 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007e28:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007e2a:	46d8      	mov	r8, fp
 8007e2c:	f7ff bbac 	b.w	8007588 <_svfprintf_r+0x93c>
 8007e30:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8007e32:	1d25      	adds	r5, r4, #4
 8007e34:	9511      	str	r5, [sp, #68]	; 0x44
 8007e36:	6823      	ldr	r3, [r4, #0]
 8007e38:	2500      	movs	r5, #0
 8007e3a:	461c      	mov	r4, r3
 8007e3c:	f7ff b981 	b.w	8007142 <_svfprintf_r+0x4f6>
 8007e40:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007e42:	2140      	movs	r1, #64	; 0x40
 8007e44:	f001 fb4e 	bl	80094e4 <_malloc_r>
 8007e48:	f8c9 0000 	str.w	r0, [r9]
 8007e4c:	f8c9 0010 	str.w	r0, [r9, #16]
 8007e50:	2800      	cmp	r0, #0
 8007e52:	f000 8188 	beq.w	8008166 <_svfprintf_r+0x151a>
 8007e56:	2340      	movs	r3, #64	; 0x40
 8007e58:	f8c9 3014 	str.w	r3, [r9, #20]
 8007e5c:	f7fe bf13 	b.w	8006c86 <_svfprintf_r+0x3a>
 8007e60:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007e62:	aa2b      	add	r2, sp, #172	; 0xac
 8007e64:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007e66:	f002 fcf3 	bl	800a850 <__ssprint_r>
 8007e6a:	2800      	cmp	r0, #0
 8007e6c:	f47e afdd 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007e70:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8007e72:	46d8      	mov	r8, fp
 8007e74:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007e76:	2f00      	cmp	r7, #0
 8007e78:	f47f aee9 	bne.w	8007c4e <_svfprintf_r+0x1002>
 8007e7c:	e6df      	b.n	8007c3e <_svfprintf_r+0xff2>
 8007e7e:	3401      	adds	r4, #1
 8007e80:	e888 00c0 	stmia.w	r8, {r6, r7}
 8007e84:	2c07      	cmp	r4, #7
 8007e86:	443d      	add	r5, r7
 8007e88:	942c      	str	r4, [sp, #176]	; 0xb0
 8007e8a:	bfd8      	it	le
 8007e8c:	f108 0808 	addle.w	r8, r8, #8
 8007e90:	952d      	str	r5, [sp, #180]	; 0xb4
 8007e92:	dd0a      	ble.n	8007eaa <_svfprintf_r+0x125e>
 8007e94:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007e96:	aa2b      	add	r2, sp, #172	; 0xac
 8007e98:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007e9a:	f002 fcd9 	bl	800a850 <__ssprint_r>
 8007e9e:	2800      	cmp	r0, #0
 8007ea0:	f47e afc3 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007ea4:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007ea6:	46d8      	mov	r8, fp
 8007ea8:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007eaa:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007eac:	3401      	adds	r4, #1
 8007eae:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8007eb0:	f8c8 6000 	str.w	r6, [r8]
 8007eb4:	e53b      	b.n	800792e <_svfprintf_r+0xce2>
 8007eb6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007eb8:	aa2b      	add	r2, sp, #172	; 0xac
 8007eba:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007ebc:	f002 fcc8 	bl	800a850 <__ssprint_r>
 8007ec0:	2800      	cmp	r0, #0
 8007ec2:	f47e afb2 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007ec6:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8007ec8:	46d8      	mov	r8, fp
 8007eca:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007ecc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 8007ece:	e6d0      	b.n	8007c72 <_svfprintf_r+0x1026>
 8007ed0:	242d      	movs	r4, #45	; 0x2d
 8007ed2:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
 8007ed6:	9410      	str	r4, [sp, #64]	; 0x40
 8007ed8:	e73b      	b.n	8007d52 <_svfprintf_r+0x1106>
 8007eda:	9410      	str	r4, [sp, #64]	; 0x40
 8007edc:	f002 fc88 	bl	800a7f0 <strlen>
 8007ee0:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007ee4:	9511      	str	r5, [sp, #68]	; 0x44
 8007ee6:	941b      	str	r4, [sp, #108]	; 0x6c
 8007ee8:	ea20 79e0 	bic.w	r9, r0, r0, asr #31
 8007eec:	900e      	str	r0, [sp, #56]	; 0x38
 8007eee:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8007ef2:	f7ff b846 	b.w	8006f82 <_svfprintf_r+0x336>
 8007ef6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007ef8:	aa2b      	add	r2, sp, #172	; 0xac
 8007efa:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007efc:	f002 fca8 	bl	800a850 <__ssprint_r>
 8007f00:	2800      	cmp	r0, #0
 8007f02:	f47e af92 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007f06:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007f08:	46d8      	mov	r8, fp
 8007f0a:	e458      	b.n	80077be <_svfprintf_r+0xb72>
 8007f0c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007f0e:	aa2b      	add	r2, sp, #172	; 0xac
 8007f10:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007f12:	f002 fc9d 	bl	800a850 <__ssprint_r>
 8007f16:	2800      	cmp	r0, #0
 8007f18:	f47e af87 	bne.w	8006e2a <_svfprintf_r+0x1de>
 8007f1c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007f1e:	46d8      	mov	r8, fp
 8007f20:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8007f22:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 8007f24:	1afb      	subs	r3, r7, r3
 8007f26:	e548      	b.n	80079ba <_svfprintf_r+0xd6e>
 8007f28:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8007f2a:	ebc6 060b 	rsb	r6, r6, fp
 8007f2e:	960e      	str	r6, [sp, #56]	; 0x38
 8007f30:	f7ff b81a 	b.w	8006f68 <_svfprintf_r+0x31c>
 8007f34:	0800ceb8 	.word	0x0800ceb8
 8007f38:	f1b9 0f06 	cmp.w	r9, #6
 8007f3c:	bf34      	ite	cc
 8007f3e:	464b      	movcc	r3, r9
 8007f40:	2306      	movcs	r3, #6
 8007f42:	f24d 1490 	movw	r4, #53648	; 0xd190
 8007f46:	ea23 76e3 	bic.w	r6, r3, r3, asr #31
 8007f4a:	f6c0 0400 	movt	r4, #2048	; 0x800
 8007f4e:	930e      	str	r3, [sp, #56]	; 0x38
 8007f50:	960b      	str	r6, [sp, #44]	; 0x2c
 8007f52:	9511      	str	r5, [sp, #68]	; 0x44
 8007f54:	9414      	str	r4, [sp, #80]	; 0x50
 8007f56:	f7ff b949 	b.w	80071ec <_svfprintf_r+0x5a0>
 8007f5a:	232d      	movs	r3, #45	; 0x2d
 8007f5c:	f88d 308b 	strb.w	r3, [sp, #139]	; 0x8b
 8007f60:	f7ff b898 	b.w	8007094 <_svfprintf_r+0x448>
 8007f64:	2003      	movs	r0, #3
 8007f66:	9000      	str	r0, [sp, #0]
 8007f68:	4632      	mov	r2, r6
 8007f6a:	a824      	add	r0, sp, #144	; 0x90
 8007f6c:	462b      	mov	r3, r5
 8007f6e:	9002      	str	r0, [sp, #8]
 8007f70:	ac26      	add	r4, sp, #152	; 0x98
 8007f72:	a825      	add	r0, sp, #148	; 0x94
 8007f74:	f8cd 9004 	str.w	r9, [sp, #4]
 8007f78:	9003      	str	r0, [sp, #12]
 8007f7a:	9404      	str	r4, [sp, #16]
 8007f7c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8007f7e:	9107      	str	r1, [sp, #28]
 8007f80:	f000 f99e 	bl	80082c0 <_dtoa_r>
 8007f84:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
 8007f88:	9907      	ldr	r1, [sp, #28]
 8007f8a:	9014      	str	r0, [sp, #80]	; 0x50
 8007f8c:	d102      	bne.n	8007f94 <_svfprintf_r+0x1348>
 8007f8e:	9c08      	ldr	r4, [sp, #32]
 8007f90:	07e3      	lsls	r3, r4, #31
 8007f92:	d512      	bpl.n	8007fba <_svfprintf_r+0x136e>
 8007f94:	9814      	ldr	r0, [sp, #80]	; 0x50
 8007f96:	eb00 0409 	add.w	r4, r0, r9
 8007f9a:	2900      	cmp	r1, #0
 8007f9c:	f43f aef6 	beq.w	8007d8c <_svfprintf_r+0x1140>
 8007fa0:	7803      	ldrb	r3, [r0, #0]
 8007fa2:	2b30      	cmp	r3, #48	; 0x30
 8007fa4:	f000 80a2 	beq.w	80080ec <_svfprintf_r+0x14a0>
 8007fa8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007faa:	18e4      	adds	r4, r4, r3
 8007fac:	e6ee      	b.n	8007d8c <_svfprintf_r+0x1140>
 8007fae:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 8007fb0:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8007fb4:	9608      	str	r6, [sp, #32]
 8007fb6:	f7fe bfe4 	b.w	8006f82 <_svfprintf_r+0x336>
 8007fba:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8007fbc:	1a1b      	subs	r3, r3, r0
 8007fbe:	9312      	str	r3, [sp, #72]	; 0x48
 8007fc0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8007fc2:	1cdd      	adds	r5, r3, #3
 8007fc4:	461a      	mov	r2, r3
 8007fc6:	db02      	blt.n	8007fce <_svfprintf_r+0x1382>
 8007fc8:	4599      	cmp	r9, r3
 8007fca:	f6bf af00 	bge.w	8007dce <_svfprintf_r+0x1182>
 8007fce:	3f02      	subs	r7, #2
 8007fd0:	3b01      	subs	r3, #1
 8007fd2:	f88d 709c 	strb.w	r7, [sp, #156]	; 0x9c
 8007fd6:	2b00      	cmp	r3, #0
 8007fd8:	9324      	str	r3, [sp, #144]	; 0x90
 8007fda:	f2c0 80b7 	blt.w	800814c <_svfprintf_r+0x1500>
 8007fde:	222b      	movs	r2, #43	; 0x2b
 8007fe0:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
 8007fe4:	2b09      	cmp	r3, #9
 8007fe6:	dc33      	bgt.n	8008050 <_svfprintf_r+0x1404>
 8007fe8:	2230      	movs	r2, #48	; 0x30
 8007fea:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
 8007fee:	aa28      	add	r2, sp, #160	; 0xa0
 8007ff0:	3330      	adds	r3, #48	; 0x30
 8007ff2:	f88d 309f 	strb.w	r3, [sp, #159]	; 0x9f
 8007ff6:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8007ff8:	ab27      	add	r3, sp, #156	; 0x9c
 8007ffa:	1ad3      	subs	r3, r2, r3
 8007ffc:	9320      	str	r3, [sp, #128]	; 0x80
 8007ffe:	2c01      	cmp	r4, #1
 8008000:	4423      	add	r3, r4
 8008002:	930e      	str	r3, [sp, #56]	; 0x38
 8008004:	f340 8089 	ble.w	800811a <_svfprintf_r+0x14ce>
 8008008:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800800a:	2400      	movs	r4, #0
 800800c:	941b      	str	r4, [sp, #108]	; 0x6c
 800800e:	3301      	adds	r3, #1
 8008010:	930e      	str	r3, [sp, #56]	; 0x38
 8008012:	ea23 75e3 	bic.w	r5, r3, r3, asr #31
 8008016:	950b      	str	r5, [sp, #44]	; 0x2c
 8008018:	e6e7      	b.n	8007dea <_svfprintf_r+0x119e>
 800801a:	ea29 74e9 	bic.w	r4, r9, r9, asr #31
 800801e:	9010      	str	r0, [sp, #64]	; 0x40
 8008020:	940b      	str	r4, [sp, #44]	; 0x2c
 8008022:	f89d 308b 	ldrb.w	r3, [sp, #139]	; 0x8b
 8008026:	9511      	str	r5, [sp, #68]	; 0x44
 8008028:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 800802c:	901b      	str	r0, [sp, #108]	; 0x6c
 800802e:	f7fe bfa8 	b.w	8006f82 <_svfprintf_r+0x336>
 8008032:	2a00      	cmp	r2, #0
 8008034:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8008036:	bfd4      	ite	le
 8008038:	f1c2 0302 	rsble	r3, r2, #2
 800803c:	2301      	movgt	r3, #1
 800803e:	191b      	adds	r3, r3, r4
 8008040:	2767      	movs	r7, #103	; 0x67
 8008042:	ea23 75e3 	bic.w	r5, r3, r3, asr #31
 8008046:	930e      	str	r3, [sp, #56]	; 0x38
 8008048:	950b      	str	r5, [sp, #44]	; 0x2c
 800804a:	e6cd      	b.n	8007de8 <_svfprintf_r+0x119c>
 800804c:	2002      	movs	r0, #2
 800804e:	e78a      	b.n	8007f66 <_svfprintf_r+0x131a>
 8008050:	f246 6067 	movw	r0, #26215	; 0x6667
 8008054:	f10d 05aa 	add.w	r5, sp, #170	; 0xaa
 8008058:	f2c6 6066 	movt	r0, #26214	; 0x6666
 800805c:	fb80 6403 	smull	r6, r4, r0, r3
 8008060:	17d9      	asrs	r1, r3, #31
 8008062:	462a      	mov	r2, r5
 8008064:	3d01      	subs	r5, #1
 8008066:	ebc1 01a4 	rsb	r1, r1, r4, asr #2
 800806a:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 800806e:	eba3 0444 	sub.w	r4, r3, r4, lsl #1
 8008072:	460b      	mov	r3, r1
 8008074:	2b09      	cmp	r3, #9
 8008076:	f104 0130 	add.w	r1, r4, #48	; 0x30
 800807a:	7011      	strb	r1, [r2, #0]
 800807c:	dcee      	bgt.n	800805c <_svfprintf_r+0x1410>
 800807e:	f10d 00ab 	add.w	r0, sp, #171	; 0xab
 8008082:	3330      	adds	r3, #48	; 0x30
 8008084:	42a8      	cmp	r0, r5
 8008086:	4619      	mov	r1, r3
 8008088:	f802 3c01 	strb.w	r3, [r2, #-1]
 800808c:	d975      	bls.n	800817a <_svfprintf_r+0x152e>
 800808e:	f10d 049d 	add.w	r4, sp, #157	; 0x9d
 8008092:	4613      	mov	r3, r2
 8008094:	e001      	b.n	800809a <_svfprintf_r+0x144e>
 8008096:	f813 1b01 	ldrb.w	r1, [r3], #1
 800809a:	4283      	cmp	r3, r0
 800809c:	f804 1f01 	strb.w	r1, [r4, #1]!
 80080a0:	d1f9      	bne.n	8008096 <_svfprintf_r+0x144a>
 80080a2:	f50d 7990 	add.w	r9, sp, #288	; 0x120
 80080a6:	ebc2 0249 	rsb	r2, r2, r9, lsl #1
 80080aa:	3af6      	subs	r2, #246	; 0xf6
 80080ac:	e7a3      	b.n	8007ff6 <_svfprintf_r+0x13aa>
 80080ae:	2a00      	cmp	r2, #0
 80080b0:	dd29      	ble.n	8008106 <_svfprintf_r+0x14ba>
 80080b2:	f1b9 0f00 	cmp.w	r9, #0
 80080b6:	d108      	bne.n	80080ca <_svfprintf_r+0x147e>
 80080b8:	9e08      	ldr	r6, [sp, #32]
 80080ba:	07f4      	lsls	r4, r6, #31
 80080bc:	d405      	bmi.n	80080ca <_svfprintf_r+0x147e>
 80080be:	ea22 79e2 	bic.w	r9, r2, r2, asr #31
 80080c2:	920e      	str	r2, [sp, #56]	; 0x38
 80080c4:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 80080c8:	e68e      	b.n	8007de8 <_svfprintf_r+0x119c>
 80080ca:	f109 0901 	add.w	r9, r9, #1
 80080ce:	eb02 0309 	add.w	r3, r2, r9
 80080d2:	930e      	str	r3, [sp, #56]	; 0x38
 80080d4:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
 80080d8:	940b      	str	r4, [sp, #44]	; 0x2c
 80080da:	e685      	b.n	8007de8 <_svfprintf_r+0x119c>
 80080dc:	1c57      	adds	r7, r2, #1
 80080de:	970e      	str	r7, [sp, #56]	; 0x38
 80080e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80080e2:	2767      	movs	r7, #103	; 0x67
 80080e4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80080e8:	930b      	str	r3, [sp, #44]	; 0x2c
 80080ea:	e67d      	b.n	8007de8 <_svfprintf_r+0x119c>
 80080ec:	4630      	mov	r0, r6
 80080ee:	2200      	movs	r2, #0
 80080f0:	2300      	movs	r3, #0
 80080f2:	4629      	mov	r1, r5
 80080f4:	f004 f9ca 	bl	800c48c <__aeabi_dcmpeq>
 80080f8:	2800      	cmp	r0, #0
 80080fa:	f47f af55 	bne.w	8007fa8 <_svfprintf_r+0x135c>
 80080fe:	f1c9 0301 	rsb	r3, r9, #1
 8008102:	9324      	str	r3, [sp, #144]	; 0x90
 8008104:	e751      	b.n	8007faa <_svfprintf_r+0x135e>
 8008106:	f1b9 0f00 	cmp.w	r9, #0
 800810a:	d124      	bne.n	8008156 <_svfprintf_r+0x150a>
 800810c:	9d08      	ldr	r5, [sp, #32]
 800810e:	07e8      	lsls	r0, r5, #31
 8008110:	d421      	bmi.n	8008156 <_svfprintf_r+0x150a>
 8008112:	2601      	movs	r6, #1
 8008114:	960b      	str	r6, [sp, #44]	; 0x2c
 8008116:	960e      	str	r6, [sp, #56]	; 0x38
 8008118:	e666      	b.n	8007de8 <_svfprintf_r+0x119c>
 800811a:	9d08      	ldr	r5, [sp, #32]
 800811c:	f015 0301 	ands.w	r3, r5, #1
 8008120:	f47f af72 	bne.w	8008008 <_svfprintf_r+0x13bc>
 8008124:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8008126:	931b      	str	r3, [sp, #108]	; 0x6c
 8008128:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 800812c:	960b      	str	r6, [sp, #44]	; 0x2c
 800812e:	e65c      	b.n	8007dea <_svfprintf_r+0x119e>
 8008130:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8008132:	785f      	ldrb	r7, [r3, #1]
 8008134:	4623      	mov	r3, r4
 8008136:	1d2a      	adds	r2, r5, #4
 8008138:	9211      	str	r2, [sp, #68]	; 0x44
 800813a:	f8d5 9000 	ldr.w	r9, [r5]
 800813e:	f1b9 0f00 	cmp.w	r9, #0
 8008142:	bfb8      	it	lt
 8008144:	f04f 39ff 	movlt.w	r9, #4294967295
 8008148:	f7fe bdf4 	b.w	8006d34 <_svfprintf_r+0xe8>
 800814c:	222d      	movs	r2, #45	; 0x2d
 800814e:	425b      	negs	r3, r3
 8008150:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
 8008154:	e746      	b.n	8007fe4 <_svfprintf_r+0x1398>
 8008156:	f109 0602 	add.w	r6, r9, #2
 800815a:	960e      	str	r6, [sp, #56]	; 0x38
 800815c:	ea26 79e6 	bic.w	r9, r6, r6, asr #31
 8008160:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8008164:	e640      	b.n	8007de8 <_svfprintf_r+0x119c>
 8008166:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 800816a:	f04f 37ff 	mov.w	r7, #4294967295
 800816e:	230c      	movs	r3, #12
 8008170:	970c      	str	r7, [sp, #48]	; 0x30
 8008172:	f8c8 3000 	str.w	r3, [r8]
 8008176:	f7fe be65 	b.w	8006e44 <_svfprintf_r+0x1f8>
 800817a:	f10d 029e 	add.w	r2, sp, #158	; 0x9e
 800817e:	e73a      	b.n	8007ff6 <_svfprintf_r+0x13aa>
 8008180:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8008182:	e725      	b.n	8007fd0 <_svfprintf_r+0x1384>
 8008184:	0000      	movs	r0, r0
	...

08008188 <quorem>:
 8008188:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800818c:	4681      	mov	r9, r0
 800818e:	6903      	ldr	r3, [r0, #16]
 8008190:	b083      	sub	sp, #12
 8008192:	690d      	ldr	r5, [r1, #16]
 8008194:	2000      	movs	r0, #0
 8008196:	9101      	str	r1, [sp, #4]
 8008198:	429d      	cmp	r5, r3
 800819a:	f300 808e 	bgt.w	80082ba <quorem+0x132>
 800819e:	1cea      	adds	r2, r5, #3
 80081a0:	f101 0414 	add.w	r4, r1, #20
 80081a4:	3d01      	subs	r5, #1
 80081a6:	f109 0814 	add.w	r8, r9, #20
 80081aa:	0092      	lsls	r2, r2, #2
 80081ac:	188b      	adds	r3, r1, r2
 80081ae:	444a      	add	r2, r9
 80081b0:	1d1f      	adds	r7, r3, #4
 80081b2:	6859      	ldr	r1, [r3, #4]
 80081b4:	6850      	ldr	r0, [r2, #4]
 80081b6:	3101      	adds	r1, #1
 80081b8:	f003 fc0a 	bl	800b9d0 <__aeabi_uidiv>
 80081bc:	4606      	mov	r6, r0
 80081be:	2800      	cmp	r0, #0
 80081c0:	d041      	beq.n	8008246 <quorem+0xbe>
 80081c2:	f04f 0e00 	mov.w	lr, #0
 80081c6:	4642      	mov	r2, r8
 80081c8:	4623      	mov	r3, r4
 80081ca:	4670      	mov	r0, lr
 80081cc:	46a2      	mov	sl, r4
 80081ce:	f853 1b04 	ldr.w	r1, [r3], #4
 80081d2:	6814      	ldr	r4, [r2, #0]
 80081d4:	fa1f fc81 	uxth.w	ip, r1
 80081d8:	ea4f 4b11 	mov.w	fp, r1, lsr #16
 80081dc:	b2a1      	uxth	r1, r4
 80081de:	fb06 ec0c 	mla	ip, r6, ip, lr
 80081e2:	1809      	adds	r1, r1, r0
 80081e4:	fb06 fe0b 	mul.w	lr, r6, fp
 80081e8:	eb0e 4e1c 	add.w	lr, lr, ip, lsr #16
 80081ec:	fa1f fc8c 	uxth.w	ip, ip
 80081f0:	ebcc 0101 	rsb	r1, ip, r1
 80081f4:	fa1f f08e 	uxth.w	r0, lr
 80081f8:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
 80081fc:	ebc0 4014 	rsb	r0, r0, r4, lsr #16
 8008200:	fa1f fc81 	uxth.w	ip, r1
 8008204:	eb00 4021 	add.w	r0, r0, r1, asr #16
 8008208:	ea4c 4100 	orr.w	r1, ip, r0, lsl #16
 800820c:	1400      	asrs	r0, r0, #16
 800820e:	429f      	cmp	r7, r3
 8008210:	f842 1b04 	str.w	r1, [r2], #4
 8008214:	d2db      	bcs.n	80081ce <quorem+0x46>
 8008216:	1d2b      	adds	r3, r5, #4
 8008218:	4654      	mov	r4, sl
 800821a:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800821e:	685a      	ldr	r2, [r3, #4]
 8008220:	b98a      	cbnz	r2, 8008246 <quorem+0xbe>
 8008222:	1d1a      	adds	r2, r3, #4
 8008224:	4598      	cmp	r8, r3
 8008226:	d20c      	bcs.n	8008242 <quorem+0xba>
 8008228:	f852 2c04 	ldr.w	r2, [r2, #-4]
 800822c:	b94a      	cbnz	r2, 8008242 <quorem+0xba>
 800822e:	3b04      	subs	r3, #4
 8008230:	e001      	b.n	8008236 <quorem+0xae>
 8008232:	6812      	ldr	r2, [r2, #0]
 8008234:	b92a      	cbnz	r2, 8008242 <quorem+0xba>
 8008236:	3d01      	subs	r5, #1
 8008238:	4598      	cmp	r8, r3
 800823a:	461a      	mov	r2, r3
 800823c:	f1a3 0304 	sub.w	r3, r3, #4
 8008240:	d3f7      	bcc.n	8008232 <quorem+0xaa>
 8008242:	f8c9 5010 	str.w	r5, [r9, #16]
 8008246:	4648      	mov	r0, r9
 8008248:	9901      	ldr	r1, [sp, #4]
 800824a:	f001 ffa1 	bl	800a190 <__mcmp>
 800824e:	2800      	cmp	r0, #0
 8008250:	db32      	blt.n	80082b8 <quorem+0x130>
 8008252:	3601      	adds	r6, #1
 8008254:	4643      	mov	r3, r8
 8008256:	f04f 0c00 	mov.w	ip, #0
 800825a:	f854 0b04 	ldr.w	r0, [r4], #4
 800825e:	6819      	ldr	r1, [r3, #0]
 8008260:	fa1f fa80 	uxth.w	sl, r0
 8008264:	0c00      	lsrs	r0, r0, #16
 8008266:	b28a      	uxth	r2, r1
 8008268:	ebc0 4111 	rsb	r1, r0, r1, lsr #16
 800826c:	ebca 0202 	rsb	r2, sl, r2
 8008270:	42a7      	cmp	r7, r4
 8008272:	4494      	add	ip, r2
 8008274:	eb01 422c 	add.w	r2, r1, ip, asr #16
 8008278:	fa1f fc8c 	uxth.w	ip, ip
 800827c:	ea4c 4102 	orr.w	r1, ip, r2, lsl #16
 8008280:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8008284:	f843 1b04 	str.w	r1, [r3], #4
 8008288:	d2e7      	bcs.n	800825a <quorem+0xd2>
 800828a:	1d2b      	adds	r3, r5, #4
 800828c:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 8008290:	685a      	ldr	r2, [r3, #4]
 8008292:	b98a      	cbnz	r2, 80082b8 <quorem+0x130>
 8008294:	1d1a      	adds	r2, r3, #4
 8008296:	4598      	cmp	r8, r3
 8008298:	d20c      	bcs.n	80082b4 <quorem+0x12c>
 800829a:	f852 2c04 	ldr.w	r2, [r2, #-4]
 800829e:	b94a      	cbnz	r2, 80082b4 <quorem+0x12c>
 80082a0:	3b04      	subs	r3, #4
 80082a2:	e001      	b.n	80082a8 <quorem+0x120>
 80082a4:	6812      	ldr	r2, [r2, #0]
 80082a6:	b92a      	cbnz	r2, 80082b4 <quorem+0x12c>
 80082a8:	3d01      	subs	r5, #1
 80082aa:	4598      	cmp	r8, r3
 80082ac:	461a      	mov	r2, r3
 80082ae:	f1a3 0304 	sub.w	r3, r3, #4
 80082b2:	d3f7      	bcc.n	80082a4 <quorem+0x11c>
 80082b4:	f8c9 5010 	str.w	r5, [r9, #16]
 80082b8:	4630      	mov	r0, r6
 80082ba:	b003      	add	sp, #12
 80082bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080082c0 <_dtoa_r>:
 80082c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80082c4:	b09f      	sub	sp, #124	; 0x7c
 80082c6:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80082c8:	4606      	mov	r6, r0
 80082ca:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80082ce:	9c2b      	ldr	r4, [sp, #172]	; 0xac
 80082d0:	2d00      	cmp	r5, #0
 80082d2:	f000 82ac 	beq.w	800882e <_dtoa_r+0x56e>
 80082d6:	682b      	ldr	r3, [r5, #0]
 80082d8:	b15b      	cbz	r3, 80082f2 <_dtoa_r+0x32>
 80082da:	686a      	ldr	r2, [r5, #4]
 80082dc:	2501      	movs	r5, #1
 80082de:	4619      	mov	r1, r3
 80082e0:	fa05 f502 	lsl.w	r5, r5, r2
 80082e4:	609d      	str	r5, [r3, #8]
 80082e6:	605a      	str	r2, [r3, #4]
 80082e8:	f001 fd06 	bl	8009cf8 <_Bfree>
 80082ec:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80082ee:	2200      	movs	r2, #0
 80082f0:	601a      	str	r2, [r3, #0]
 80082f2:	f8dd 9014 	ldr.w	r9, [sp, #20]
 80082f6:	f1b9 0f00 	cmp.w	r9, #0
 80082fa:	db39      	blt.n	8008370 <_dtoa_r+0xb0>
 80082fc:	2300      	movs	r3, #0
 80082fe:	6023      	str	r3, [r4, #0]
 8008300:	2300      	movs	r3, #0
 8008302:	461a      	mov	r2, r3
 8008304:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 8008308:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 800830c:	ea09 0303 	and.w	r3, r9, r3
 8008310:	4293      	cmp	r3, r2
 8008312:	d017      	beq.n	8008344 <_dtoa_r+0x84>
 8008314:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 8008318:	2200      	movs	r2, #0
 800831a:	2300      	movs	r3, #0
 800831c:	4620      	mov	r0, r4
 800831e:	4629      	mov	r1, r5
 8008320:	f004 f8b4 	bl	800c48c <__aeabi_dcmpeq>
 8008324:	2800      	cmp	r0, #0
 8008326:	d02a      	beq.n	800837e <_dtoa_r+0xbe>
 8008328:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 800832a:	2301      	movs	r3, #1
 800832c:	6013      	str	r3, [r2, #0]
 800832e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8008330:	2b00      	cmp	r3, #0
 8008332:	f000 80dc 	beq.w	80084ee <_dtoa_r+0x22e>
 8008336:	4bae      	ldr	r3, [pc, #696]	; (80085f0 <_dtoa_r+0x330>)
 8008338:	1e58      	subs	r0, r3, #1
 800833a:	992c      	ldr	r1, [sp, #176]	; 0xb0
 800833c:	600b      	str	r3, [r1, #0]
 800833e:	b01f      	add	sp, #124	; 0x7c
 8008340:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008344:	992a      	ldr	r1, [sp, #168]	; 0xa8
 8008346:	f24d 10a8 	movw	r0, #53672	; 0xd1a8
 800834a:	9a04      	ldr	r2, [sp, #16]
 800834c:	f242 730f 	movw	r3, #9999	; 0x270f
 8008350:	f6c0 0000 	movt	r0, #2048	; 0x800
 8008354:	600b      	str	r3, [r1, #0]
 8008356:	2a00      	cmp	r2, #0
 8008358:	f000 80a8 	beq.w	80084ac <_dtoa_r+0x1ec>
 800835c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800835e:	2b00      	cmp	r3, #0
 8008360:	d0ed      	beq.n	800833e <_dtoa_r+0x7e>
 8008362:	78c3      	ldrb	r3, [r0, #3]
 8008364:	2b00      	cmp	r3, #0
 8008366:	f000 80b0 	beq.w	80084ca <_dtoa_r+0x20a>
 800836a:	f100 0308 	add.w	r3, r0, #8
 800836e:	e7e4      	b.n	800833a <_dtoa_r+0x7a>
 8008370:	f029 4900 	bic.w	r9, r9, #2147483648	; 0x80000000
 8008374:	2301      	movs	r3, #1
 8008376:	f8cd 9014 	str.w	r9, [sp, #20]
 800837a:	6023      	str	r3, [r4, #0]
 800837c:	e7c0      	b.n	8008300 <_dtoa_r+0x40>
 800837e:	ab1d      	add	r3, sp, #116	; 0x74
 8008380:	4630      	mov	r0, r6
 8008382:	9300      	str	r3, [sp, #0]
 8008384:	4622      	mov	r2, r4
 8008386:	ab1c      	add	r3, sp, #112	; 0x70
 8008388:	9301      	str	r3, [sp, #4]
 800838a:	462b      	mov	r3, r5
 800838c:	f3c9 570a 	ubfx	r7, r9, #20, #11
 8008390:	f002 f80c 	bl	800a3ac <__d2b>
 8008394:	4683      	mov	fp, r0
 8008396:	2f00      	cmp	r7, #0
 8008398:	f040 8099 	bne.w	80084ce <_dtoa_r+0x20e>
 800839c:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 80083a0:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 80083a4:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 80083a6:	4447      	add	r7, r8
 80083a8:	429f      	cmp	r7, r3
 80083aa:	f2c0 8265 	blt.w	8008878 <_dtoa_r+0x5b8>
 80083ae:	9804      	ldr	r0, [sp, #16]
 80083b0:	f64f 430e 	movw	r3, #64526	; 0xfc0e
 80083b4:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80083b8:	f207 4212 	addw	r2, r7, #1042	; 0x412
 80083bc:	1bdb      	subs	r3, r3, r7
 80083be:	fa20 f202 	lsr.w	r2, r0, r2
 80083c2:	fa09 f003 	lsl.w	r0, r9, r3
 80083c6:	4310      	orrs	r0, r2
 80083c8:	f003 fd82 	bl	800bed0 <__aeabi_ui2d>
 80083cc:	3f01      	subs	r7, #1
 80083ce:	2201      	movs	r2, #1
 80083d0:	921a      	str	r2, [sp, #104]	; 0x68
 80083d2:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 80083d6:	2300      	movs	r3, #0
 80083d8:	2200      	movs	r2, #0
 80083da:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 80083de:	f003 fc39 	bl	800bc54 <__aeabi_dsub>
 80083e2:	a37d      	add	r3, pc, #500	; (adr r3, 80085d8 <_dtoa_r+0x318>)
 80083e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083e8:	f003 fde8 	bl	800bfbc <__aeabi_dmul>
 80083ec:	a37c      	add	r3, pc, #496	; (adr r3, 80085e0 <_dtoa_r+0x320>)
 80083ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083f2:	f003 fc31 	bl	800bc58 <__adddf3>
 80083f6:	4604      	mov	r4, r0
 80083f8:	4638      	mov	r0, r7
 80083fa:	460d      	mov	r5, r1
 80083fc:	f003 fd78 	bl	800bef0 <__aeabi_i2d>
 8008400:	a379      	add	r3, pc, #484	; (adr r3, 80085e8 <_dtoa_r+0x328>)
 8008402:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008406:	f003 fdd9 	bl	800bfbc <__aeabi_dmul>
 800840a:	4602      	mov	r2, r0
 800840c:	460b      	mov	r3, r1
 800840e:	4620      	mov	r0, r4
 8008410:	4629      	mov	r1, r5
 8008412:	f003 fc21 	bl	800bc58 <__adddf3>
 8008416:	4604      	mov	r4, r0
 8008418:	460d      	mov	r5, r1
 800841a:	f004 f869 	bl	800c4f0 <__aeabi_d2iz>
 800841e:	4629      	mov	r1, r5
 8008420:	2200      	movs	r2, #0
 8008422:	2300      	movs	r3, #0
 8008424:	9009      	str	r0, [sp, #36]	; 0x24
 8008426:	4620      	mov	r0, r4
 8008428:	f004 f83a 	bl	800c4a0 <__aeabi_dcmplt>
 800842c:	2800      	cmp	r0, #0
 800842e:	f040 8210 	bne.w	8008852 <_dtoa_r+0x592>
 8008432:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008434:	2816      	cmp	r0, #22
 8008436:	f200 81f7 	bhi.w	8008828 <_dtoa_r+0x568>
 800843a:	f64c 61e0 	movw	r1, #52960	; 0xcee0
 800843e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008442:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008446:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800844a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800844e:	f004 f845 	bl	800c4dc <__aeabi_dcmpgt>
 8008452:	2800      	cmp	r0, #0
 8008454:	f000 8219 	beq.w	800888a <_dtoa_r+0x5ca>
 8008458:	9909      	ldr	r1, [sp, #36]	; 0x24
 800845a:	2200      	movs	r2, #0
 800845c:	9214      	str	r2, [sp, #80]	; 0x50
 800845e:	3901      	subs	r1, #1
 8008460:	9109      	str	r1, [sp, #36]	; 0x24
 8008462:	ebc7 0708 	rsb	r7, r7, r8
 8008466:	3f01      	subs	r7, #1
 8008468:	f100 8201 	bmi.w	800886e <_dtoa_r+0x5ae>
 800846c:	2100      	movs	r1, #0
 800846e:	970b      	str	r7, [sp, #44]	; 0x2c
 8008470:	9110      	str	r1, [sp, #64]	; 0x40
 8008472:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008474:	2a00      	cmp	r2, #0
 8008476:	f2c0 81e3 	blt.w	8008840 <_dtoa_r+0x580>
 800847a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800847c:	2000      	movs	r0, #0
 800847e:	9213      	str	r2, [sp, #76]	; 0x4c
 8008480:	189b      	adds	r3, r3, r2
 8008482:	9011      	str	r0, [sp, #68]	; 0x44
 8008484:	930b      	str	r3, [sp, #44]	; 0x2c
 8008486:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8008488:	2909      	cmp	r1, #9
 800848a:	d835      	bhi.n	80084f8 <_dtoa_r+0x238>
 800848c:	2401      	movs	r4, #1
 800848e:	2905      	cmp	r1, #5
 8008490:	dd02      	ble.n	8008498 <_dtoa_r+0x1d8>
 8008492:	2400      	movs	r4, #0
 8008494:	3904      	subs	r1, #4
 8008496:	9128      	str	r1, [sp, #160]	; 0xa0
 8008498:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800849a:	1e93      	subs	r3, r2, #2
 800849c:	2b03      	cmp	r3, #3
 800849e:	d82d      	bhi.n	80084fc <_dtoa_r+0x23c>
 80084a0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80084a4:	03720375 	.word	0x03720375
 80084a8:	035d0233 	.word	0x035d0233
 80084ac:	f24d 129c 	movw	r2, #53660	; 0xd19c
 80084b0:	f24d 13a8 	movw	r3, #53672	; 0xd1a8
 80084b4:	f3c9 0013 	ubfx	r0, r9, #0, #20
 80084b8:	f6c0 0200 	movt	r2, #2048	; 0x800
 80084bc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80084c0:	2800      	cmp	r0, #0
 80084c2:	bf0c      	ite	eq
 80084c4:	4610      	moveq	r0, r2
 80084c6:	4618      	movne	r0, r3
 80084c8:	e748      	b.n	800835c <_dtoa_r+0x9c>
 80084ca:	1cc3      	adds	r3, r0, #3
 80084cc:	e735      	b.n	800833a <_dtoa_r+0x7a>
 80084ce:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 80084d2:	2200      	movs	r2, #0
 80084d4:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80084d8:	4620      	mov	r0, r4
 80084da:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 80084de:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 80084e2:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 80084e6:	f443 1140 	orr.w	r1, r3, #3145728	; 0x300000
 80084ea:	921a      	str	r2, [sp, #104]	; 0x68
 80084ec:	e773      	b.n	80083d6 <_dtoa_r+0x116>
 80084ee:	f24d 1098 	movw	r0, #53656	; 0xd198
 80084f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80084f6:	e722      	b.n	800833e <_dtoa_r+0x7e>
 80084f8:	2300      	movs	r3, #0
 80084fa:	9328      	str	r3, [sp, #160]	; 0xa0
 80084fc:	6a74      	ldr	r4, [r6, #36]	; 0x24
 80084fe:	2300      	movs	r3, #0
 8008500:	4619      	mov	r1, r3
 8008502:	4630      	mov	r0, r6
 8008504:	f04f 32ff 	mov.w	r2, #4294967295
 8008508:	9329      	str	r3, [sp, #164]	; 0xa4
 800850a:	6063      	str	r3, [r4, #4]
 800850c:	2301      	movs	r3, #1
 800850e:	920c      	str	r2, [sp, #48]	; 0x30
 8008510:	9312      	str	r3, [sp, #72]	; 0x48
 8008512:	f001 fbbb 	bl	8009c8c <_Balloc>
 8008516:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8008518:	990c      	ldr	r1, [sp, #48]	; 0x30
 800851a:	9115      	str	r1, [sp, #84]	; 0x54
 800851c:	6020      	str	r0, [r4, #0]
 800851e:	681b      	ldr	r3, [r3, #0]
 8008520:	930d      	str	r3, [sp, #52]	; 0x34
 8008522:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8008524:	2b00      	cmp	r3, #0
 8008526:	f2c0 80c5 	blt.w	80086b4 <_dtoa_r+0x3f4>
 800852a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800852c:	290e      	cmp	r1, #14
 800852e:	f300 80c1 	bgt.w	80086b4 <_dtoa_r+0x3f4>
 8008532:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8008534:	f64c 63e0 	movw	r3, #52960	; 0xcee0
 8008538:	f6c0 0300 	movt	r3, #2048	; 0x800
 800853c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800853e:	0fc2      	lsrs	r2, r0, #31
 8008540:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008542:	2900      	cmp	r1, #0
 8008544:	bfcc      	ite	gt
 8008546:	2200      	movgt	r2, #0
 8008548:	f002 0201 	andle.w	r2, r2, #1
 800854c:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 8008550:	e9d3 0100 	ldrd	r0, r1, [r3]
 8008554:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8008558:	2a00      	cmp	r2, #0
 800855a:	f040 8465 	bne.w	8008e28 <_dtoa_r+0xb68>
 800855e:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 8008562:	4602      	mov	r2, r0
 8008564:	460b      	mov	r3, r1
 8008566:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008568:	4620      	mov	r0, r4
 800856a:	4629      	mov	r1, r5
 800856c:	f003 fe50 	bl	800c210 <__aeabi_ddiv>
 8008570:	f003 ffbe 	bl	800c4f0 <__aeabi_d2iz>
 8008574:	4680      	mov	r8, r0
 8008576:	f003 fcbb 	bl	800bef0 <__aeabi_i2d>
 800857a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 800857e:	f003 fd1d 	bl	800bfbc <__aeabi_dmul>
 8008582:	4602      	mov	r2, r0
 8008584:	460b      	mov	r3, r1
 8008586:	4620      	mov	r0, r4
 8008588:	4629      	mov	r1, r5
 800858a:	f003 fb63 	bl	800bc54 <__aeabi_dsub>
 800858e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008590:	f108 0330 	add.w	r3, r8, #48	; 0x30
 8008594:	f807 3b01 	strb.w	r3, [r7], #1
 8008598:	2a01      	cmp	r2, #1
 800859a:	4604      	mov	r4, r0
 800859c:	460d      	mov	r5, r1
 800859e:	d05c      	beq.n	800865a <_dtoa_r+0x39a>
 80085a0:	2300      	movs	r3, #0
 80085a2:	2200      	movs	r2, #0
 80085a4:	f2c4 0324 	movt	r3, #16420	; 0x4024
 80085a8:	f003 fd08 	bl	800bfbc <__aeabi_dmul>
 80085ac:	2200      	movs	r2, #0
 80085ae:	2300      	movs	r3, #0
 80085b0:	4604      	mov	r4, r0
 80085b2:	460d      	mov	r5, r1
 80085b4:	f003 ff6a 	bl	800c48c <__aeabi_dcmpeq>
 80085b8:	2800      	cmp	r0, #0
 80085ba:	f040 8124 	bne.w	8008806 <_dtoa_r+0x546>
 80085be:	980d      	ldr	r0, [sp, #52]	; 0x34
 80085c0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80085c2:	960a      	str	r6, [sp, #40]	; 0x28
 80085c4:	f100 0902 	add.w	r9, r0, #2
 80085c8:	eb00 0a01 	add.w	sl, r0, r1
 80085cc:	f8cd b010 	str.w	fp, [sp, #16]
 80085d0:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 80085d4:	e019      	b.n	800860a <_dtoa_r+0x34a>
 80085d6:	bf00      	nop
 80085d8:	636f4361 	.word	0x636f4361
 80085dc:	3fd287a7 	.word	0x3fd287a7
 80085e0:	8b60c8b3 	.word	0x8b60c8b3
 80085e4:	3fc68a28 	.word	0x3fc68a28
 80085e8:	509f79fb 	.word	0x509f79fb
 80085ec:	3fd34413 	.word	0x3fd34413
 80085f0:	0800d199 	.word	0x0800d199
 80085f4:	f003 fce2 	bl	800bfbc <__aeabi_dmul>
 80085f8:	2200      	movs	r2, #0
 80085fa:	2300      	movs	r3, #0
 80085fc:	4604      	mov	r4, r0
 80085fe:	460d      	mov	r5, r1
 8008600:	f003 ff44 	bl	800c48c <__aeabi_dcmpeq>
 8008604:	2800      	cmp	r0, #0
 8008606:	f040 852c 	bne.w	8009062 <_dtoa_r+0xda2>
 800860a:	4632      	mov	r2, r6
 800860c:	463b      	mov	r3, r7
 800860e:	4620      	mov	r0, r4
 8008610:	4629      	mov	r1, r5
 8008612:	f003 fdfd 	bl	800c210 <__aeabi_ddiv>
 8008616:	46cb      	mov	fp, r9
 8008618:	f003 ff6a 	bl	800c4f0 <__aeabi_d2iz>
 800861c:	4680      	mov	r8, r0
 800861e:	f003 fc67 	bl	800bef0 <__aeabi_i2d>
 8008622:	4632      	mov	r2, r6
 8008624:	463b      	mov	r3, r7
 8008626:	f003 fcc9 	bl	800bfbc <__aeabi_dmul>
 800862a:	4602      	mov	r2, r0
 800862c:	460b      	mov	r3, r1
 800862e:	4620      	mov	r0, r4
 8008630:	4629      	mov	r1, r5
 8008632:	f003 fb0f 	bl	800bc54 <__aeabi_dsub>
 8008636:	2300      	movs	r3, #0
 8008638:	2200      	movs	r2, #0
 800863a:	45d1      	cmp	r9, sl
 800863c:	f108 0e30 	add.w	lr, r8, #48	; 0x30
 8008640:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008644:	f809 ec01 	strb.w	lr, [r9, #-1]
 8008648:	f109 0901 	add.w	r9, r9, #1
 800864c:	4604      	mov	r4, r0
 800864e:	460d      	mov	r5, r1
 8008650:	d1d0      	bne.n	80085f4 <_dtoa_r+0x334>
 8008652:	465f      	mov	r7, fp
 8008654:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8008656:	f8dd b010 	ldr.w	fp, [sp, #16]
 800865a:	4622      	mov	r2, r4
 800865c:	462b      	mov	r3, r5
 800865e:	4620      	mov	r0, r4
 8008660:	4629      	mov	r1, r5
 8008662:	f003 faf9 	bl	800bc58 <__adddf3>
 8008666:	4604      	mov	r4, r0
 8008668:	460d      	mov	r5, r1
 800866a:	4622      	mov	r2, r4
 800866c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008670:	462b      	mov	r3, r5
 8008672:	f003 ff15 	bl	800c4a0 <__aeabi_dcmplt>
 8008676:	2800      	cmp	r0, #0
 8008678:	f000 8540 	beq.w	80090fc <_dtoa_r+0xe3c>
 800867c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800867e:	f817 ac01 	ldrb.w	sl, [r7, #-1]
 8008682:	921b      	str	r2, [sp, #108]	; 0x6c
 8008684:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008686:	e002      	b.n	800868e <_dtoa_r+0x3ce>
 8008688:	f813 ac01 	ldrb.w	sl, [r3, #-1]
 800868c:	461f      	mov	r7, r3
 800868e:	1e7b      	subs	r3, r7, #1
 8008690:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 8008694:	f040 851a 	bne.w	80090cc <_dtoa_r+0xe0c>
 8008698:	4293      	cmp	r3, r2
 800869a:	d1f5      	bne.n	8008688 <_dtoa_r+0x3c8>
 800869c:	920d      	str	r2, [sp, #52]	; 0x34
 800869e:	f04f 0a31 	mov.w	sl, #49	; 0x31
 80086a2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80086a4:	2230      	movs	r2, #48	; 0x30
 80086a6:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80086a8:	700a      	strb	r2, [r1, #0]
 80086aa:	3001      	adds	r0, #1
 80086ac:	9009      	str	r0, [sp, #36]	; 0x24
 80086ae:	f883 a000 	strb.w	sl, [r3]
 80086b2:	e0a8      	b.n	8008806 <_dtoa_r+0x546>
 80086b4:	9812      	ldr	r0, [sp, #72]	; 0x48
 80086b6:	2800      	cmp	r0, #0
 80086b8:	f040 80e9 	bne.w	800888e <_dtoa_r+0x5ce>
 80086bc:	ac10      	add	r4, sp, #64	; 0x40
 80086be:	e894 0430 	ldmia.w	r4, {r4, r5, sl}
 80086c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80086c4:	2b00      	cmp	r3, #0
 80086c6:	bfc8      	it	gt
 80086c8:	2c00      	cmpgt	r4, #0
 80086ca:	dd09      	ble.n	80086e0 <_dtoa_r+0x420>
 80086cc:	42a3      	cmp	r3, r4
 80086ce:	bfa8      	it	ge
 80086d0:	4623      	movge	r3, r4
 80086d2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80086d4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80086d6:	1ae4      	subs	r4, r4, r3
 80086d8:	1ac0      	subs	r0, r0, r3
 80086da:	9010      	str	r0, [sp, #64]	; 0x40
 80086dc:	1ac9      	subs	r1, r1, r3
 80086de:	910b      	str	r1, [sp, #44]	; 0x2c
 80086e0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80086e2:	2a00      	cmp	r2, #0
 80086e4:	dd1a      	ble.n	800871c <_dtoa_r+0x45c>
 80086e6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80086e8:	2b00      	cmp	r3, #0
 80086ea:	f000 8457 	beq.w	8008f9c <_dtoa_r+0xcdc>
 80086ee:	2d00      	cmp	r5, #0
 80086f0:	dd10      	ble.n	8008714 <_dtoa_r+0x454>
 80086f2:	4651      	mov	r1, sl
 80086f4:	462a      	mov	r2, r5
 80086f6:	4630      	mov	r0, r6
 80086f8:	f001 fc9e 	bl	800a038 <__pow5mult>
 80086fc:	465a      	mov	r2, fp
 80086fe:	4682      	mov	sl, r0
 8008700:	4630      	mov	r0, r6
 8008702:	4651      	mov	r1, sl
 8008704:	f001 fbfa 	bl	8009efc <__multiply>
 8008708:	4659      	mov	r1, fp
 800870a:	4607      	mov	r7, r0
 800870c:	4630      	mov	r0, r6
 800870e:	f001 faf3 	bl	8009cf8 <_Bfree>
 8008712:	46bb      	mov	fp, r7
 8008714:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008716:	1b42      	subs	r2, r0, r5
 8008718:	f040 847a 	bne.w	8009010 <_dtoa_r+0xd50>
 800871c:	2101      	movs	r1, #1
 800871e:	4630      	mov	r0, r6
 8008720:	f001 fbe2 	bl	8009ee8 <__i2b>
 8008724:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8008726:	2900      	cmp	r1, #0
 8008728:	4680      	mov	r8, r0
 800872a:	dd05      	ble.n	8008738 <_dtoa_r+0x478>
 800872c:	4641      	mov	r1, r8
 800872e:	4630      	mov	r0, r6
 8008730:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8008732:	f001 fc81 	bl	800a038 <__pow5mult>
 8008736:	4680      	mov	r8, r0
 8008738:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800873a:	2a01      	cmp	r2, #1
 800873c:	f340 80cc 	ble.w	80088d8 <_dtoa_r+0x618>
 8008740:	2500      	movs	r5, #0
 8008742:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8008744:	2001      	movs	r0, #1
 8008746:	2a00      	cmp	r2, #0
 8008748:	f040 8364 	bne.w	8008e14 <_dtoa_r+0xb54>
 800874c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800874e:	1843      	adds	r3, r0, r1
 8008750:	f013 031f 	ands.w	r3, r3, #31
 8008754:	f000 8296 	beq.w	8008c84 <_dtoa_r+0x9c4>
 8008758:	f1c3 0220 	rsb	r2, r3, #32
 800875c:	2a04      	cmp	r2, #4
 800875e:	f340 853e 	ble.w	80091de <_dtoa_r+0xf1e>
 8008762:	f1c3 031c 	rsb	r3, r3, #28
 8008766:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008768:	18e4      	adds	r4, r4, r3
 800876a:	18c9      	adds	r1, r1, r3
 800876c:	18d2      	adds	r2, r2, r3
 800876e:	910b      	str	r1, [sp, #44]	; 0x2c
 8008770:	9210      	str	r2, [sp, #64]	; 0x40
 8008772:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008774:	2a00      	cmp	r2, #0
 8008776:	dd04      	ble.n	8008782 <_dtoa_r+0x4c2>
 8008778:	4659      	mov	r1, fp
 800877a:	4630      	mov	r0, r6
 800877c:	f001 fcae 	bl	800a0dc <__lshift>
 8008780:	4683      	mov	fp, r0
 8008782:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008784:	2b00      	cmp	r3, #0
 8008786:	dd05      	ble.n	8008794 <_dtoa_r+0x4d4>
 8008788:	4641      	mov	r1, r8
 800878a:	4630      	mov	r0, r6
 800878c:	461a      	mov	r2, r3
 800878e:	f001 fca5 	bl	800a0dc <__lshift>
 8008792:	4680      	mov	r8, r0
 8008794:	9814      	ldr	r0, [sp, #80]	; 0x50
 8008796:	2800      	cmp	r0, #0
 8008798:	f040 831f 	bne.w	8008dda <_dtoa_r+0xb1a>
 800879c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800879e:	980c      	ldr	r0, [sp, #48]	; 0x30
 80087a0:	2a02      	cmp	r2, #2
 80087a2:	bfd4      	ite	le
 80087a4:	2300      	movle	r3, #0
 80087a6:	2301      	movgt	r3, #1
 80087a8:	2800      	cmp	r0, #0
 80087aa:	bfc8      	it	gt
 80087ac:	2300      	movgt	r3, #0
 80087ae:	2b00      	cmp	r3, #0
 80087b0:	f000 8223 	beq.w	8008bfa <_dtoa_r+0x93a>
 80087b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80087b6:	2b00      	cmp	r3, #0
 80087b8:	f040 8219 	bne.w	8008bee <_dtoa_r+0x92e>
 80087bc:	4641      	mov	r1, r8
 80087be:	2205      	movs	r2, #5
 80087c0:	4630      	mov	r0, r6
 80087c2:	f001 fab5 	bl	8009d30 <__multadd>
 80087c6:	4680      	mov	r8, r0
 80087c8:	4658      	mov	r0, fp
 80087ca:	4641      	mov	r1, r8
 80087cc:	f001 fce0 	bl	800a190 <__mcmp>
 80087d0:	2800      	cmp	r0, #0
 80087d2:	f340 820c 	ble.w	8008bee <_dtoa_r+0x92e>
 80087d6:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 80087d8:	2500      	movs	r5, #0
 80087da:	9909      	ldr	r1, [sp, #36]	; 0x24
 80087dc:	2331      	movs	r3, #49	; 0x31
 80087de:	3101      	adds	r1, #1
 80087e0:	f807 3b01 	strb.w	r3, [r7], #1
 80087e4:	9109      	str	r1, [sp, #36]	; 0x24
 80087e6:	4630      	mov	r0, r6
 80087e8:	4641      	mov	r1, r8
 80087ea:	f001 fa85 	bl	8009cf8 <_Bfree>
 80087ee:	f1ba 0f00 	cmp.w	sl, #0
 80087f2:	d008      	beq.n	8008806 <_dtoa_r+0x546>
 80087f4:	4555      	cmp	r5, sl
 80087f6:	bf18      	it	ne
 80087f8:	2d00      	cmpne	r5, #0
 80087fa:	f040 8253 	bne.w	8008ca4 <_dtoa_r+0x9e4>
 80087fe:	4630      	mov	r0, r6
 8008800:	4651      	mov	r1, sl
 8008802:	f001 fa79 	bl	8009cf8 <_Bfree>
 8008806:	4659      	mov	r1, fp
 8008808:	4630      	mov	r0, r6
 800880a:	f001 fa75 	bl	8009cf8 <_Bfree>
 800880e:	2200      	movs	r2, #0
 8008810:	703a      	strb	r2, [r7, #0]
 8008812:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8008814:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008816:	1c4b      	adds	r3, r1, #1
 8008818:	6013      	str	r3, [r2, #0]
 800881a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800881c:	2b00      	cmp	r3, #0
 800881e:	f000 8246 	beq.w	8008cae <_dtoa_r+0x9ee>
 8008822:	601f      	str	r7, [r3, #0]
 8008824:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008826:	e58a      	b.n	800833e <_dtoa_r+0x7e>
 8008828:	2301      	movs	r3, #1
 800882a:	9314      	str	r3, [sp, #80]	; 0x50
 800882c:	e619      	b.n	8008462 <_dtoa_r+0x1a2>
 800882e:	2010      	movs	r0, #16
 8008830:	f000 fe48 	bl	80094c4 <malloc>
 8008834:	6270      	str	r0, [r6, #36]	; 0x24
 8008836:	6045      	str	r5, [r0, #4]
 8008838:	6085      	str	r5, [r0, #8]
 800883a:	6005      	str	r5, [r0, #0]
 800883c:	60c5      	str	r5, [r0, #12]
 800883e:	e558      	b.n	80082f2 <_dtoa_r+0x32>
 8008840:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008842:	2000      	movs	r0, #0
 8008844:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008846:	9013      	str	r0, [sp, #76]	; 0x4c
 8008848:	1a89      	subs	r1, r1, r2
 800884a:	4253      	negs	r3, r2
 800884c:	9110      	str	r1, [sp, #64]	; 0x40
 800884e:	9311      	str	r3, [sp, #68]	; 0x44
 8008850:	e619      	b.n	8008486 <_dtoa_r+0x1c6>
 8008852:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008854:	f003 fb4c 	bl	800bef0 <__aeabi_i2d>
 8008858:	4622      	mov	r2, r4
 800885a:	462b      	mov	r3, r5
 800885c:	f003 fe16 	bl	800c48c <__aeabi_dcmpeq>
 8008860:	2800      	cmp	r0, #0
 8008862:	f47f ade6 	bne.w	8008432 <_dtoa_r+0x172>
 8008866:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008868:	3b01      	subs	r3, #1
 800886a:	9309      	str	r3, [sp, #36]	; 0x24
 800886c:	e5e1      	b.n	8008432 <_dtoa_r+0x172>
 800886e:	427f      	negs	r7, r7
 8008870:	2000      	movs	r0, #0
 8008872:	9710      	str	r7, [sp, #64]	; 0x40
 8008874:	900b      	str	r0, [sp, #44]	; 0x2c
 8008876:	e5fc      	b.n	8008472 <_dtoa_r+0x1b2>
 8008878:	f64f 30ee 	movw	r0, #64494	; 0xfbee
 800887c:	9904      	ldr	r1, [sp, #16]
 800887e:	f6cf 70ff 	movt	r0, #65535	; 0xffff
 8008882:	1bc0      	subs	r0, r0, r7
 8008884:	fa01 f000 	lsl.w	r0, r1, r0
 8008888:	e59e      	b.n	80083c8 <_dtoa_r+0x108>
 800888a:	9014      	str	r0, [sp, #80]	; 0x50
 800888c:	e5e9      	b.n	8008462 <_dtoa_r+0x1a2>
 800888e:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8008890:	2901      	cmp	r1, #1
 8008892:	f340 83de 	ble.w	8009052 <_dtoa_r+0xd92>
 8008896:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008898:	9911      	ldr	r1, [sp, #68]	; 0x44
 800889a:	1e43      	subs	r3, r0, #1
 800889c:	4299      	cmp	r1, r3
 800889e:	bfa8      	it	ge
 80088a0:	ebc3 0501 	rsbge	r5, r3, r1
 80088a4:	da06      	bge.n	80088b4 <_dtoa_r+0x5f4>
 80088a6:	9811      	ldr	r0, [sp, #68]	; 0x44
 80088a8:	2500      	movs	r5, #0
 80088aa:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80088ac:	1a1a      	subs	r2, r3, r0
 80088ae:	9311      	str	r3, [sp, #68]	; 0x44
 80088b0:	1889      	adds	r1, r1, r2
 80088b2:	9113      	str	r1, [sp, #76]	; 0x4c
 80088b4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80088b6:	2a00      	cmp	r2, #0
 80088b8:	f2c0 83f8 	blt.w	80090ac <_dtoa_r+0xdec>
 80088bc:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80088be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80088c0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80088c2:	4630      	mov	r0, r6
 80088c4:	2101      	movs	r1, #1
 80088c6:	18d2      	adds	r2, r2, r3
 80088c8:	9210      	str	r2, [sp, #64]	; 0x40
 80088ca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80088cc:	18d2      	adds	r2, r2, r3
 80088ce:	920b      	str	r2, [sp, #44]	; 0x2c
 80088d0:	f001 fb0a 	bl	8009ee8 <__i2b>
 80088d4:	4682      	mov	sl, r0
 80088d6:	e6f4      	b.n	80086c2 <_dtoa_r+0x402>
 80088d8:	9b04      	ldr	r3, [sp, #16]
 80088da:	2b00      	cmp	r3, #0
 80088dc:	f47f af30 	bne.w	8008740 <_dtoa_r+0x480>
 80088e0:	9b05      	ldr	r3, [sp, #20]
 80088e2:	f3c3 0213 	ubfx	r2, r3, #0, #20
 80088e6:	2a00      	cmp	r2, #0
 80088e8:	f040 843d 	bne.w	8009166 <_dtoa_r+0xea6>
 80088ec:	2500      	movs	r5, #0
 80088ee:	f6c7 75f0 	movt	r5, #32752	; 0x7ff0
 80088f2:	401d      	ands	r5, r3
 80088f4:	2d00      	cmp	r5, #0
 80088f6:	f43f af24 	beq.w	8008742 <_dtoa_r+0x482>
 80088fa:	9810      	ldr	r0, [sp, #64]	; 0x40
 80088fc:	2501      	movs	r5, #1
 80088fe:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008900:	3001      	adds	r0, #1
 8008902:	9010      	str	r0, [sp, #64]	; 0x40
 8008904:	3101      	adds	r1, #1
 8008906:	910b      	str	r1, [sp, #44]	; 0x2c
 8008908:	e71b      	b.n	8008742 <_dtoa_r+0x482>
 800890a:	2101      	movs	r1, #1
 800890c:	9112      	str	r1, [sp, #72]	; 0x48
 800890e:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8008910:	2800      	cmp	r0, #0
 8008912:	f340 833e 	ble.w	8008f92 <_dtoa_r+0xcd2>
 8008916:	4682      	mov	sl, r0
 8008918:	280e      	cmp	r0, #14
 800891a:	bf8c      	ite	hi
 800891c:	2400      	movhi	r4, #0
 800891e:	f004 0401 	andls.w	r4, r4, #1
 8008922:	9015      	str	r0, [sp, #84]	; 0x54
 8008924:	900c      	str	r0, [sp, #48]	; 0x30
 8008926:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8008928:	2300      	movs	r3, #0
 800892a:	f1ba 0f17 	cmp.w	sl, #23
 800892e:	606b      	str	r3, [r5, #4]
 8008930:	d909      	bls.n	8008946 <_dtoa_r+0x686>
 8008932:	2201      	movs	r2, #1
 8008934:	2304      	movs	r3, #4
 8008936:	005b      	lsls	r3, r3, #1
 8008938:	4610      	mov	r0, r2
 800893a:	f103 0114 	add.w	r1, r3, #20
 800893e:	3201      	adds	r2, #1
 8008940:	4551      	cmp	r1, sl
 8008942:	d9f8      	bls.n	8008936 <_dtoa_r+0x676>
 8008944:	6068      	str	r0, [r5, #4]
 8008946:	4630      	mov	r0, r6
 8008948:	6869      	ldr	r1, [r5, #4]
 800894a:	f001 f99f 	bl	8009c8c <_Balloc>
 800894e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8008950:	6028      	str	r0, [r5, #0]
 8008952:	681b      	ldr	r3, [r3, #0]
 8008954:	930d      	str	r3, [sp, #52]	; 0x34
 8008956:	2c00      	cmp	r4, #0
 8008958:	f43f ade3 	beq.w	8008522 <_dtoa_r+0x262>
 800895c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800895e:	2900      	cmp	r1, #0
 8008960:	f340 81a8 	ble.w	8008cb4 <_dtoa_r+0x9f4>
 8008964:	f001 020f 	and.w	r2, r1, #15
 8008968:	f64c 63e0 	movw	r3, #52960	; 0xcee0
 800896c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008970:	110f      	asrs	r7, r1, #4
 8008972:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008976:	06fa      	lsls	r2, r7, #27
 8008978:	e9d3 4500 	ldrd	r4, r5, [r3]
 800897c:	f140 818b 	bpl.w	8008c96 <_dtoa_r+0x9d6>
 8008980:	f64c 73d0 	movw	r3, #53200	; 0xcfd0
 8008984:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8008988:	f6c0 0300 	movt	r3, #2048	; 0x800
 800898c:	f007 070f 	and.w	r7, r7, #15
 8008990:	f04f 0803 	mov.w	r8, #3
 8008994:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8008998:	f003 fc3a 	bl	800c210 <__aeabi_ddiv>
 800899c:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 80089a0:	b19f      	cbz	r7, 80089ca <_dtoa_r+0x70a>
 80089a2:	f64c 79d0 	movw	r9, #53200	; 0xcfd0
 80089a6:	f6c0 0900 	movt	r9, #2048	; 0x800
 80089aa:	07fb      	lsls	r3, r7, #31
 80089ac:	4620      	mov	r0, r4
 80089ae:	4629      	mov	r1, r5
 80089b0:	d507      	bpl.n	80089c2 <_dtoa_r+0x702>
 80089b2:	e9d9 2300 	ldrd	r2, r3, [r9]
 80089b6:	f108 0801 	add.w	r8, r8, #1
 80089ba:	f003 faff 	bl	800bfbc <__aeabi_dmul>
 80089be:	4604      	mov	r4, r0
 80089c0:	460d      	mov	r5, r1
 80089c2:	107f      	asrs	r7, r7, #1
 80089c4:	f109 0908 	add.w	r9, r9, #8
 80089c8:	d1ef      	bne.n	80089aa <_dtoa_r+0x6ea>
 80089ca:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80089ce:	4622      	mov	r2, r4
 80089d0:	462b      	mov	r3, r5
 80089d2:	f003 fc1d 	bl	800c210 <__aeabi_ddiv>
 80089d6:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 80089da:	9914      	ldr	r1, [sp, #80]	; 0x50
 80089dc:	b151      	cbz	r1, 80089f4 <_dtoa_r+0x734>
 80089de:	2300      	movs	r3, #0
 80089e0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80089e4:	2200      	movs	r2, #0
 80089e6:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 80089ea:	f003 fd59 	bl	800c4a0 <__aeabi_dcmplt>
 80089ee:	2800      	cmp	r0, #0
 80089f0:	f040 82dc 	bne.w	8008fac <_dtoa_r+0xcec>
 80089f4:	4640      	mov	r0, r8
 80089f6:	f003 fa7b 	bl	800bef0 <__aeabi_i2d>
 80089fa:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 80089fe:	f003 fadd 	bl	800bfbc <__aeabi_dmul>
 8008a02:	2300      	movs	r3, #0
 8008a04:	2200      	movs	r2, #0
 8008a06:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8008a0a:	f003 f925 	bl	800bc58 <__adddf3>
 8008a0e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008a10:	4604      	mov	r4, r0
 8008a12:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8008a16:	2a00      	cmp	r2, #0
 8008a18:	f000 80cc 	beq.w	8008bb4 <_dtoa_r+0x8f4>
 8008a1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008a1e:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
 8008a22:	931b      	str	r3, [sp, #108]	; 0x6c
 8008a24:	9812      	ldr	r0, [sp, #72]	; 0x48
 8008a26:	2800      	cmp	r0, #0
 8008a28:	f000 817a 	beq.w	8008d20 <_dtoa_r+0xa60>
 8008a2c:	f64c 63e0 	movw	r3, #52960	; 0xcee0
 8008a30:	2100      	movs	r1, #0
 8008a32:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008a36:	2000      	movs	r0, #0
 8008a38:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 8008a3c:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 8008a40:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008a42:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8008a46:	f003 fbe3 	bl	800c210 <__aeabi_ddiv>
 8008a4a:	4622      	mov	r2, r4
 8008a4c:	462b      	mov	r3, r5
 8008a4e:	f003 f901 	bl	800bc54 <__aeabi_dsub>
 8008a52:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
 8008a56:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008a5a:	f003 fd49 	bl	800c4f0 <__aeabi_d2iz>
 8008a5e:	4680      	mov	r8, r0
 8008a60:	f003 fa46 	bl	800bef0 <__aeabi_i2d>
 8008a64:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8008a68:	fa5f fa88 	uxtb.w	sl, r8
 8008a6c:	4602      	mov	r2, r0
 8008a6e:	460b      	mov	r3, r1
 8008a70:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008a74:	f003 f8ee 	bl	800bc54 <__aeabi_dsub>
 8008a78:	f807 ab01 	strb.w	sl, [r7], #1
 8008a7c:	4604      	mov	r4, r0
 8008a7e:	460d      	mov	r5, r1
 8008a80:	4622      	mov	r2, r4
 8008a82:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8008a86:	462b      	mov	r3, r5
 8008a88:	f003 fd28 	bl	800c4dc <__aeabi_dcmpgt>
 8008a8c:	2800      	cmp	r0, #0
 8008a8e:	f040 839e 	bne.w	80091ce <_dtoa_r+0xf0e>
 8008a92:	2100      	movs	r1, #0
 8008a94:	4622      	mov	r2, r4
 8008a96:	462b      	mov	r3, r5
 8008a98:	2000      	movs	r0, #0
 8008a9a:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8008a9e:	f003 f8d9 	bl	800bc54 <__aeabi_dsub>
 8008aa2:	4602      	mov	r2, r0
 8008aa4:	460b      	mov	r3, r1
 8008aa6:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8008aaa:	f003 fd17 	bl	800c4dc <__aeabi_dcmpgt>
 8008aae:	2800      	cmp	r0, #0
 8008ab0:	f040 838a 	bne.w	80091c8 <_dtoa_r+0xf08>
 8008ab4:	f1b9 0f01 	cmp.w	r9, #1
 8008ab8:	f77f ad33 	ble.w	8008522 <_dtoa_r+0x262>
 8008abc:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008abe:	46b8      	mov	r8, r7
 8008ac0:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 8008ac4:	4489      	add	r9, r1
 8008ac6:	9618      	str	r6, [sp, #96]	; 0x60
 8008ac8:	46cb      	mov	fp, r9
 8008aca:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58
 8008ace:	e00f      	b.n	8008af0 <_dtoa_r+0x830>
 8008ad0:	2100      	movs	r1, #0
 8008ad2:	2000      	movs	r0, #0
 8008ad4:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 8008ad8:	f003 f8bc 	bl	800bc54 <__aeabi_dsub>
 8008adc:	4632      	mov	r2, r6
 8008ade:	463b      	mov	r3, r7
 8008ae0:	f003 fcde 	bl	800c4a0 <__aeabi_dcmplt>
 8008ae4:	2800      	cmp	r0, #0
 8008ae6:	f040 82e5 	bne.w	80090b4 <_dtoa_r+0xdf4>
 8008aea:	45d8      	cmp	r8, fp
 8008aec:	f000 82e9 	beq.w	80090c2 <_dtoa_r+0xe02>
 8008af0:	2300      	movs	r3, #0
 8008af2:	2200      	movs	r2, #0
 8008af4:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008af8:	4630      	mov	r0, r6
 8008afa:	4639      	mov	r1, r7
 8008afc:	f003 fa5e 	bl	800bfbc <__aeabi_dmul>
 8008b00:	2300      	movs	r3, #0
 8008b02:	2200      	movs	r2, #0
 8008b04:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008b08:	4606      	mov	r6, r0
 8008b0a:	460f      	mov	r7, r1
 8008b0c:	4620      	mov	r0, r4
 8008b0e:	4629      	mov	r1, r5
 8008b10:	f003 fa54 	bl	800bfbc <__aeabi_dmul>
 8008b14:	460d      	mov	r5, r1
 8008b16:	4604      	mov	r4, r0
 8008b18:	f003 fcea 	bl	800c4f0 <__aeabi_d2iz>
 8008b1c:	4681      	mov	r9, r0
 8008b1e:	f003 f9e7 	bl	800bef0 <__aeabi_i2d>
 8008b22:	f109 0930 	add.w	r9, r9, #48	; 0x30
 8008b26:	fa5f fa89 	uxtb.w	sl, r9
 8008b2a:	4602      	mov	r2, r0
 8008b2c:	460b      	mov	r3, r1
 8008b2e:	4620      	mov	r0, r4
 8008b30:	4629      	mov	r1, r5
 8008b32:	f003 f88f 	bl	800bc54 <__aeabi_dsub>
 8008b36:	4632      	mov	r2, r6
 8008b38:	463b      	mov	r3, r7
 8008b3a:	f808 ab01 	strb.w	sl, [r8], #1
 8008b3e:	46c1      	mov	r9, r8
 8008b40:	4604      	mov	r4, r0
 8008b42:	460d      	mov	r5, r1
 8008b44:	f003 fcac 	bl	800c4a0 <__aeabi_dcmplt>
 8008b48:	4622      	mov	r2, r4
 8008b4a:	462b      	mov	r3, r5
 8008b4c:	2800      	cmp	r0, #0
 8008b4e:	d0bf      	beq.n	8008ad0 <_dtoa_r+0x810>
 8008b50:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8008b52:	4647      	mov	r7, r8
 8008b54:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8008b58:	9e18      	ldr	r6, [sp, #96]	; 0x60
 8008b5a:	9009      	str	r0, [sp, #36]	; 0x24
 8008b5c:	e653      	b.n	8008806 <_dtoa_r+0x546>
 8008b5e:	2201      	movs	r2, #1
 8008b60:	9212      	str	r2, [sp, #72]	; 0x48
 8008b62:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 8008b64:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008b66:	189a      	adds	r2, r3, r2
 8008b68:	9215      	str	r2, [sp, #84]	; 0x54
 8008b6a:	f102 0a01 	add.w	sl, r2, #1
 8008b6e:	f1ba 0f00 	cmp.w	sl, #0
 8008b72:	f340 8202 	ble.w	8008f7a <_dtoa_r+0xcba>
 8008b76:	f1ba 0f0e 	cmp.w	sl, #14
 8008b7a:	bf8c      	ite	hi
 8008b7c:	2400      	movhi	r4, #0
 8008b7e:	f004 0401 	andls.w	r4, r4, #1
 8008b82:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8008b86:	e6ce      	b.n	8008926 <_dtoa_r+0x666>
 8008b88:	2100      	movs	r1, #0
 8008b8a:	9112      	str	r1, [sp, #72]	; 0x48
 8008b8c:	e7e9      	b.n	8008b62 <_dtoa_r+0x8a2>
 8008b8e:	2300      	movs	r3, #0
 8008b90:	9312      	str	r3, [sp, #72]	; 0x48
 8008b92:	e6bc      	b.n	800890e <_dtoa_r+0x64e>
 8008b94:	4640      	mov	r0, r8
 8008b96:	f003 f9ab 	bl	800bef0 <__aeabi_i2d>
 8008b9a:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8008b9e:	f003 fa0d 	bl	800bfbc <__aeabi_dmul>
 8008ba2:	2300      	movs	r3, #0
 8008ba4:	2200      	movs	r2, #0
 8008ba6:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8008baa:	f003 f855 	bl	800bc58 <__adddf3>
 8008bae:	4604      	mov	r4, r0
 8008bb0:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8008bb4:	2300      	movs	r3, #0
 8008bb6:	2200      	movs	r2, #0
 8008bb8:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8008bbc:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008bc0:	f003 f848 	bl	800bc54 <__aeabi_dsub>
 8008bc4:	4622      	mov	r2, r4
 8008bc6:	462b      	mov	r3, r5
 8008bc8:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8008bcc:	f003 fc86 	bl	800c4dc <__aeabi_dcmpgt>
 8008bd0:	4680      	mov	r8, r0
 8008bd2:	2800      	cmp	r0, #0
 8008bd4:	f040 80a0 	bne.w	8008d18 <_dtoa_r+0xa58>
 8008bd8:	4622      	mov	r2, r4
 8008bda:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008bde:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 8008be2:	f003 fc5d 	bl	800c4a0 <__aeabi_dcmplt>
 8008be6:	2800      	cmp	r0, #0
 8008be8:	f43f ac9b 	beq.w	8008522 <_dtoa_r+0x262>
 8008bec:	46c2      	mov	sl, r8
 8008bee:	9829      	ldr	r0, [sp, #164]	; 0xa4
 8008bf0:	2500      	movs	r5, #0
 8008bf2:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008bf4:	43c0      	mvns	r0, r0
 8008bf6:	9009      	str	r0, [sp, #36]	; 0x24
 8008bf8:	e5f5      	b.n	80087e6 <_dtoa_r+0x526>
 8008bfa:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008bfc:	2a00      	cmp	r2, #0
 8008bfe:	f040 813e 	bne.w	8008e7e <_dtoa_r+0xbbe>
 8008c02:	2400      	movs	r4, #0
 8008c04:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8008c06:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008c08:	e002      	b.n	8008c10 <_dtoa_r+0x950>
 8008c0a:	f001 f891 	bl	8009d30 <__multadd>
 8008c0e:	4683      	mov	fp, r0
 8008c10:	4641      	mov	r1, r8
 8008c12:	4658      	mov	r0, fp
 8008c14:	f7ff fab8 	bl	8008188 <quorem>
 8008c18:	220a      	movs	r2, #10
 8008c1a:	2300      	movs	r3, #0
 8008c1c:	4659      	mov	r1, fp
 8008c1e:	f100 0c30 	add.w	ip, r0, #48	; 0x30
 8008c22:	f807 c004 	strb.w	ip, [r7, r4]
 8008c26:	3401      	adds	r4, #1
 8008c28:	4630      	mov	r0, r6
 8008c2a:	42ac      	cmp	r4, r5
 8008c2c:	dbed      	blt.n	8008c0a <_dtoa_r+0x94a>
 8008c2e:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008c30:	2500      	movs	r5, #0
 8008c32:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008c34:	2801      	cmp	r0, #1
 8008c36:	bfac      	ite	ge
 8008c38:	183f      	addge	r7, r7, r0
 8008c3a:	3701      	addlt	r7, #1
 8008c3c:	4659      	mov	r1, fp
 8008c3e:	2201      	movs	r2, #1
 8008c40:	4630      	mov	r0, r6
 8008c42:	f8cd c00c 	str.w	ip, [sp, #12]
 8008c46:	f001 fa49 	bl	800a0dc <__lshift>
 8008c4a:	4641      	mov	r1, r8
 8008c4c:	4683      	mov	fp, r0
 8008c4e:	f001 fa9f 	bl	800a190 <__mcmp>
 8008c52:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008c56:	2800      	cmp	r0, #0
 8008c58:	f340 823f 	ble.w	80090da <_dtoa_r+0xe1a>
 8008c5c:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8008c60:	990d      	ldr	r1, [sp, #52]	; 0x34
 8008c62:	e002      	b.n	8008c6a <_dtoa_r+0x9aa>
 8008c64:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 8008c68:	461f      	mov	r7, r3
 8008c6a:	1e7b      	subs	r3, r7, #1
 8008c6c:	2a39      	cmp	r2, #57	; 0x39
 8008c6e:	f040 826f 	bne.w	8009150 <_dtoa_r+0xe90>
 8008c72:	428b      	cmp	r3, r1
 8008c74:	d1f6      	bne.n	8008c64 <_dtoa_r+0x9a4>
 8008c76:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008c78:	2331      	movs	r3, #49	; 0x31
 8008c7a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008c7c:	7013      	strb	r3, [r2, #0]
 8008c7e:	3101      	adds	r1, #1
 8008c80:	9109      	str	r1, [sp, #36]	; 0x24
 8008c82:	e5b0      	b.n	80087e6 <_dtoa_r+0x526>
 8008c84:	231c      	movs	r3, #28
 8008c86:	9810      	ldr	r0, [sp, #64]	; 0x40
 8008c88:	18e4      	adds	r4, r4, r3
 8008c8a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008c8c:	18c0      	adds	r0, r0, r3
 8008c8e:	9010      	str	r0, [sp, #64]	; 0x40
 8008c90:	18c9      	adds	r1, r1, r3
 8008c92:	910b      	str	r1, [sp, #44]	; 0x2c
 8008c94:	e56d      	b.n	8008772 <_dtoa_r+0x4b2>
 8008c96:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008c9a:	f04f 0802 	mov.w	r8, #2
 8008c9e:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 8008ca2:	e67d      	b.n	80089a0 <_dtoa_r+0x6e0>
 8008ca4:	4630      	mov	r0, r6
 8008ca6:	4629      	mov	r1, r5
 8008ca8:	f001 f826 	bl	8009cf8 <_Bfree>
 8008cac:	e5a7      	b.n	80087fe <_dtoa_r+0x53e>
 8008cae:	980d      	ldr	r0, [sp, #52]	; 0x34
 8008cb0:	f7ff bb45 	b.w	800833e <_dtoa_r+0x7e>
 8008cb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008cb6:	425c      	negs	r4, r3
 8008cb8:	2c00      	cmp	r4, #0
 8008cba:	f000 81a2 	beq.w	8009002 <_dtoa_r+0xd42>
 8008cbe:	f004 020f 	and.w	r2, r4, #15
 8008cc2:	f64c 63e0 	movw	r3, #52960	; 0xcee0
 8008cc6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008cca:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8008cce:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008cd2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008cd6:	f003 f971 	bl	800bfbc <__aeabi_dmul>
 8008cda:	1124      	asrs	r4, r4, #4
 8008cdc:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8008ce0:	f000 8268 	beq.w	80091b4 <_dtoa_r+0xef4>
 8008ce4:	f64c 75d0 	movw	r5, #53200	; 0xcfd0
 8008ce8:	f04f 0802 	mov.w	r8, #2
 8008cec:	f6c0 0500 	movt	r5, #2048	; 0x800
 8008cf0:	4602      	mov	r2, r0
 8008cf2:	460b      	mov	r3, r1
 8008cf4:	07e7      	lsls	r7, r4, #31
 8008cf6:	4610      	mov	r0, r2
 8008cf8:	4619      	mov	r1, r3
 8008cfa:	d507      	bpl.n	8008d0c <_dtoa_r+0xa4c>
 8008cfc:	e9d5 2300 	ldrd	r2, r3, [r5]
 8008d00:	f108 0801 	add.w	r8, r8, #1
 8008d04:	f003 f95a 	bl	800bfbc <__aeabi_dmul>
 8008d08:	4602      	mov	r2, r0
 8008d0a:	460b      	mov	r3, r1
 8008d0c:	3508      	adds	r5, #8
 8008d0e:	1064      	asrs	r4, r4, #1
 8008d10:	d1f0      	bne.n	8008cf4 <_dtoa_r+0xa34>
 8008d12:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 8008d16:	e660      	b.n	80089da <_dtoa_r+0x71a>
 8008d18:	f04f 0800 	mov.w	r8, #0
 8008d1c:	46c2      	mov	sl, r8
 8008d1e:	e55a      	b.n	80087d6 <_dtoa_r+0x516>
 8008d20:	f109 32ff 	add.w	r2, r9, #4294967295
 8008d24:	9216      	str	r2, [sp, #88]	; 0x58
 8008d26:	9816      	ldr	r0, [sp, #88]	; 0x58
 8008d28:	f64c 61e0 	movw	r1, #52960	; 0xcee0
 8008d2c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8008d30:	4622      	mov	r2, r4
 8008d32:	462b      	mov	r3, r5
 8008d34:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8008d36:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 8008d3a:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008d3e:	f003 f93d 	bl	800bfbc <__aeabi_dmul>
 8008d42:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 8008d46:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008d4a:	f003 fbd1 	bl	800c4f0 <__aeabi_d2iz>
 8008d4e:	4680      	mov	r8, r0
 8008d50:	f003 f8ce 	bl	800bef0 <__aeabi_i2d>
 8008d54:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8008d58:	4602      	mov	r2, r0
 8008d5a:	460b      	mov	r3, r1
 8008d5c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008d60:	f002 ff78 	bl	800bc54 <__aeabi_dsub>
 8008d64:	f1b9 0f01 	cmp.w	r9, #1
 8008d68:	f807 8b01 	strb.w	r8, [r7], #1
 8008d6c:	4604      	mov	r4, r0
 8008d6e:	460d      	mov	r5, r1
 8008d70:	d020      	beq.n	8008db4 <_dtoa_r+0xaf4>
 8008d72:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008d74:	1e53      	subs	r3, r2, #1
 8008d76:	4690      	mov	r8, r2
 8008d78:	4499      	add	r9, r3
 8008d7a:	2300      	movs	r3, #0
 8008d7c:	2200      	movs	r2, #0
 8008d7e:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008d82:	f003 f91b 	bl	800bfbc <__aeabi_dmul>
 8008d86:	460d      	mov	r5, r1
 8008d88:	4604      	mov	r4, r0
 8008d8a:	f003 fbb1 	bl	800c4f0 <__aeabi_d2iz>
 8008d8e:	4682      	mov	sl, r0
 8008d90:	f003 f8ae 	bl	800bef0 <__aeabi_i2d>
 8008d94:	f10a 0a30 	add.w	sl, sl, #48	; 0x30
 8008d98:	4602      	mov	r2, r0
 8008d9a:	460b      	mov	r3, r1
 8008d9c:	4620      	mov	r0, r4
 8008d9e:	4629      	mov	r1, r5
 8008da0:	f002 ff58 	bl	800bc54 <__aeabi_dsub>
 8008da4:	f808 af01 	strb.w	sl, [r8, #1]!
 8008da8:	45c8      	cmp	r8, r9
 8008daa:	d1e6      	bne.n	8008d7a <_dtoa_r+0xaba>
 8008dac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8008dae:	4604      	mov	r4, r0
 8008db0:	460d      	mov	r5, r1
 8008db2:	18ff      	adds	r7, r7, r3
 8008db4:	2300      	movs	r3, #0
 8008db6:	2200      	movs	r2, #0
 8008db8:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
 8008dbc:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 8008dc0:	f002 ff4a 	bl	800bc58 <__adddf3>
 8008dc4:	4622      	mov	r2, r4
 8008dc6:	462b      	mov	r3, r5
 8008dc8:	f003 fb6a 	bl	800c4a0 <__aeabi_dcmplt>
 8008dcc:	2800      	cmp	r0, #0
 8008dce:	f000 8126 	beq.w	800901e <_dtoa_r+0xd5e>
 8008dd2:	f817 ac01 	ldrb.w	sl, [r7, #-1]
 8008dd6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008dd8:	e459      	b.n	800868e <_dtoa_r+0x3ce>
 8008dda:	4658      	mov	r0, fp
 8008ddc:	4641      	mov	r1, r8
 8008dde:	f001 f9d7 	bl	800a190 <__mcmp>
 8008de2:	2800      	cmp	r0, #0
 8008de4:	f6bf acda 	bge.w	800879c <_dtoa_r+0x4dc>
 8008de8:	4659      	mov	r1, fp
 8008dea:	220a      	movs	r2, #10
 8008dec:	4630      	mov	r0, r6
 8008dee:	2300      	movs	r3, #0
 8008df0:	f000 ff9e 	bl	8009d30 <__multadd>
 8008df4:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008df6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8008df8:	3901      	subs	r1, #1
 8008dfa:	9109      	str	r1, [sp, #36]	; 0x24
 8008dfc:	4683      	mov	fp, r0
 8008dfe:	bb52      	cbnz	r2, 8008e56 <_dtoa_r+0xb96>
 8008e00:	9815      	ldr	r0, [sp, #84]	; 0x54
 8008e02:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8008e04:	2800      	cmp	r0, #0
 8008e06:	dc03      	bgt.n	8008e10 <_dtoa_r+0xb50>
 8008e08:	9928      	ldr	r1, [sp, #160]	; 0xa0
 8008e0a:	2902      	cmp	r1, #2
 8008e0c:	f300 81ec 	bgt.w	80091e8 <_dtoa_r+0xf28>
 8008e10:	920c      	str	r2, [sp, #48]	; 0x30
 8008e12:	e6f6      	b.n	8008c02 <_dtoa_r+0x942>
 8008e14:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8008e18:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8008e1c:	6918      	ldr	r0, [r3, #16]
 8008e1e:	f001 f817 	bl	8009e50 <__hi0bits>
 8008e22:	f1c0 0020 	rsb	r0, r0, #32
 8008e26:	e491      	b.n	800874c <_dtoa_r+0x48c>
 8008e28:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	f040 8163 	bne.w	80090f6 <_dtoa_r+0xe36>
 8008e30:	2300      	movs	r3, #0
 8008e32:	2200      	movs	r2, #0
 8008e34:	f2c4 0314 	movt	r3, #16404	; 0x4014
 8008e38:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008e3c:	f003 f8be 	bl	800bfbc <__aeabi_dmul>
 8008e40:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008e44:	f003 fb40 	bl	800c4c8 <__aeabi_dcmpge>
 8008e48:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8008e4c:	46c2      	mov	sl, r8
 8008e4e:	2800      	cmp	r0, #0
 8008e50:	f47f aecd 	bne.w	8008bee <_dtoa_r+0x92e>
 8008e54:	e4bf      	b.n	80087d6 <_dtoa_r+0x516>
 8008e56:	2300      	movs	r3, #0
 8008e58:	4651      	mov	r1, sl
 8008e5a:	220a      	movs	r2, #10
 8008e5c:	4630      	mov	r0, r6
 8008e5e:	f000 ff67 	bl	8009d30 <__multadd>
 8008e62:	9915      	ldr	r1, [sp, #84]	; 0x54
 8008e64:	2900      	cmp	r1, #0
 8008e66:	bfcc      	ite	gt
 8008e68:	2300      	movgt	r3, #0
 8008e6a:	2301      	movle	r3, #1
 8008e6c:	4682      	mov	sl, r0
 8008e6e:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8008e70:	2802      	cmp	r0, #2
 8008e72:	bfd8      	it	le
 8008e74:	2300      	movle	r3, #0
 8008e76:	2b00      	cmp	r3, #0
 8008e78:	f040 81ad 	bne.w	80091d6 <_dtoa_r+0xf16>
 8008e7c:	910c      	str	r1, [sp, #48]	; 0x30
 8008e7e:	2c00      	cmp	r4, #0
 8008e80:	dd05      	ble.n	8008e8e <_dtoa_r+0xbce>
 8008e82:	4651      	mov	r1, sl
 8008e84:	4630      	mov	r0, r6
 8008e86:	4622      	mov	r2, r4
 8008e88:	f001 f928 	bl	800a0dc <__lshift>
 8008e8c:	4682      	mov	sl, r0
 8008e8e:	46d1      	mov	r9, sl
 8008e90:	2d00      	cmp	r5, #0
 8008e92:	f040 8147 	bne.w	8009124 <_dtoa_r+0xe64>
 8008e96:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008e98:	4655      	mov	r5, sl
 8008e9a:	980c      	ldr	r0, [sp, #48]	; 0x30
 8008e9c:	9904      	ldr	r1, [sp, #16]
 8008e9e:	1c5c      	adds	r4, r3, #1
 8008ea0:	1818      	adds	r0, r3, r0
 8008ea2:	900c      	str	r0, [sp, #48]	; 0x30
 8008ea4:	f001 0101 	and.w	r1, r1, #1
 8008ea8:	910a      	str	r1, [sp, #40]	; 0x28
 8008eaa:	4641      	mov	r1, r8
 8008eac:	4658      	mov	r0, fp
 8008eae:	f7ff f96b 	bl	8008188 <quorem>
 8008eb2:	4629      	mov	r1, r5
 8008eb4:	4607      	mov	r7, r0
 8008eb6:	4658      	mov	r0, fp
 8008eb8:	f001 f96a 	bl	800a190 <__mcmp>
 8008ebc:	464a      	mov	r2, r9
 8008ebe:	4641      	mov	r1, r8
 8008ec0:	4682      	mov	sl, r0
 8008ec2:	4630      	mov	r0, r6
 8008ec4:	f001 f982 	bl	800a1cc <__mdiff>
 8008ec8:	1e63      	subs	r3, r4, #1
 8008eca:	930b      	str	r3, [sp, #44]	; 0x2c
 8008ecc:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008ed0:	9304      	str	r3, [sp, #16]
 8008ed2:	68c3      	ldr	r3, [r0, #12]
 8008ed4:	4602      	mov	r2, r0
 8008ed6:	2b00      	cmp	r3, #0
 8008ed8:	d03d      	beq.n	8008f56 <_dtoa_r+0xc96>
 8008eda:	2301      	movs	r3, #1
 8008edc:	4630      	mov	r0, r6
 8008ede:	4611      	mov	r1, r2
 8008ee0:	9303      	str	r3, [sp, #12]
 8008ee2:	f000 ff09 	bl	8009cf8 <_Bfree>
 8008ee6:	9b03      	ldr	r3, [sp, #12]
 8008ee8:	9828      	ldr	r0, [sp, #160]	; 0xa0
 8008eea:	4318      	orrs	r0, r3
 8008eec:	d103      	bne.n	8008ef6 <_dtoa_r+0xc36>
 8008eee:	990a      	ldr	r1, [sp, #40]	; 0x28
 8008ef0:	2900      	cmp	r1, #0
 8008ef2:	f000 8154 	beq.w	800919e <_dtoa_r+0xede>
 8008ef6:	f1ba 0f00 	cmp.w	sl, #0
 8008efa:	f2c0 80b8 	blt.w	800906e <_dtoa_r+0xdae>
 8008efe:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8008f00:	ea5a 0202 	orrs.w	r2, sl, r2
 8008f04:	d103      	bne.n	8008f0e <_dtoa_r+0xc4e>
 8008f06:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008f08:	2800      	cmp	r0, #0
 8008f0a:	f000 80b0 	beq.w	800906e <_dtoa_r+0xdae>
 8008f0e:	2b00      	cmp	r3, #0
 8008f10:	f300 812c 	bgt.w	800916c <_dtoa_r+0xeac>
 8008f14:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008f16:	4627      	mov	r7, r4
 8008f18:	9a04      	ldr	r2, [sp, #16]
 8008f1a:	429c      	cmp	r4, r3
 8008f1c:	f804 2c01 	strb.w	r2, [r4, #-1]
 8008f20:	f000 8131 	beq.w	8009186 <_dtoa_r+0xec6>
 8008f24:	4659      	mov	r1, fp
 8008f26:	220a      	movs	r2, #10
 8008f28:	2300      	movs	r3, #0
 8008f2a:	4630      	mov	r0, r6
 8008f2c:	f000 ff00 	bl	8009d30 <__multadd>
 8008f30:	454d      	cmp	r5, r9
 8008f32:	4683      	mov	fp, r0
 8008f34:	d017      	beq.n	8008f66 <_dtoa_r+0xca6>
 8008f36:	4629      	mov	r1, r5
 8008f38:	220a      	movs	r2, #10
 8008f3a:	2300      	movs	r3, #0
 8008f3c:	4630      	mov	r0, r6
 8008f3e:	f000 fef7 	bl	8009d30 <__multadd>
 8008f42:	4649      	mov	r1, r9
 8008f44:	220a      	movs	r2, #10
 8008f46:	2300      	movs	r3, #0
 8008f48:	3401      	adds	r4, #1
 8008f4a:	4605      	mov	r5, r0
 8008f4c:	4630      	mov	r0, r6
 8008f4e:	f000 feef 	bl	8009d30 <__multadd>
 8008f52:	4681      	mov	r9, r0
 8008f54:	e7a9      	b.n	8008eaa <_dtoa_r+0xbea>
 8008f56:	4611      	mov	r1, r2
 8008f58:	4658      	mov	r0, fp
 8008f5a:	9203      	str	r2, [sp, #12]
 8008f5c:	f001 f918 	bl	800a190 <__mcmp>
 8008f60:	9a03      	ldr	r2, [sp, #12]
 8008f62:	4603      	mov	r3, r0
 8008f64:	e7ba      	b.n	8008edc <_dtoa_r+0xc1c>
 8008f66:	4629      	mov	r1, r5
 8008f68:	4630      	mov	r0, r6
 8008f6a:	220a      	movs	r2, #10
 8008f6c:	2300      	movs	r3, #0
 8008f6e:	f000 fedf 	bl	8009d30 <__multadd>
 8008f72:	3401      	adds	r4, #1
 8008f74:	4605      	mov	r5, r0
 8008f76:	4681      	mov	r9, r0
 8008f78:	e797      	b.n	8008eaa <_dtoa_r+0xbea>
 8008f7a:	f1ba 0f0e 	cmp.w	sl, #14
 8008f7e:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8008f82:	bf8c      	ite	hi
 8008f84:	2300      	movhi	r3, #0
 8008f86:	2301      	movls	r3, #1
 8008f88:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8008f8a:	401c      	ands	r4, r3
 8008f8c:	2300      	movs	r3, #0
 8008f8e:	606b      	str	r3, [r5, #4]
 8008f90:	e4d9      	b.n	8008946 <_dtoa_r+0x686>
 8008f92:	2301      	movs	r3, #1
 8008f94:	9315      	str	r3, [sp, #84]	; 0x54
 8008f96:	930c      	str	r3, [sp, #48]	; 0x30
 8008f98:	9329      	str	r3, [sp, #164]	; 0xa4
 8008f9a:	e7f5      	b.n	8008f88 <_dtoa_r+0xcc8>
 8008f9c:	4659      	mov	r1, fp
 8008f9e:	4630      	mov	r0, r6
 8008fa0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8008fa2:	f001 f849 	bl	800a038 <__pow5mult>
 8008fa6:	4683      	mov	fp, r0
 8008fa8:	f7ff bbb8 	b.w	800871c <_dtoa_r+0x45c>
 8008fac:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008fae:	2a00      	cmp	r2, #0
 8008fb0:	f43f adf0 	beq.w	8008b94 <_dtoa_r+0x8d4>
 8008fb4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8008fb6:	2b00      	cmp	r3, #0
 8008fb8:	f77f aab3 	ble.w	8008522 <_dtoa_r+0x262>
 8008fbc:	2300      	movs	r3, #0
 8008fbe:	2200      	movs	r2, #0
 8008fc0:	f2c4 0324 	movt	r3, #16420	; 0x4024
 8008fc4:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008fc8:	f002 fff8 	bl	800bfbc <__aeabi_dmul>
 8008fcc:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8008fd0:	f108 0001 	add.w	r0, r8, #1
 8008fd4:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008fd6:	3901      	subs	r1, #1
 8008fd8:	911b      	str	r1, [sp, #108]	; 0x6c
 8008fda:	f002 ff89 	bl	800bef0 <__aeabi_i2d>
 8008fde:	4602      	mov	r2, r0
 8008fe0:	460b      	mov	r3, r1
 8008fe2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8008fe6:	f002 ffe9 	bl	800bfbc <__aeabi_dmul>
 8008fea:	2300      	movs	r3, #0
 8008fec:	2200      	movs	r2, #0
 8008fee:	f2c4 031c 	movt	r3, #16412	; 0x401c
 8008ff2:	f002 fe31 	bl	800bc58 <__adddf3>
 8008ff6:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
 8008ffa:	4604      	mov	r4, r0
 8008ffc:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8009000:	e510      	b.n	8008a24 <_dtoa_r+0x764>
 8009002:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8009006:	f04f 0802 	mov.w	r8, #2
 800900a:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 800900e:	e4e4      	b.n	80089da <_dtoa_r+0x71a>
 8009010:	4659      	mov	r1, fp
 8009012:	4630      	mov	r0, r6
 8009014:	f001 f810 	bl	800a038 <__pow5mult>
 8009018:	4683      	mov	fp, r0
 800901a:	f7ff bb7f 	b.w	800871c <_dtoa_r+0x45c>
 800901e:	2100      	movs	r1, #0
 8009020:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
 8009024:	2000      	movs	r0, #0
 8009026:	f6c3 71e0 	movt	r1, #16352	; 0x3fe0
 800902a:	f002 fe13 	bl	800bc54 <__aeabi_dsub>
 800902e:	4622      	mov	r2, r4
 8009030:	462b      	mov	r3, r5
 8009032:	f003 fa53 	bl	800c4dc <__aeabi_dcmpgt>
 8009036:	2800      	cmp	r0, #0
 8009038:	f43f aa73 	beq.w	8008522 <_dtoa_r+0x262>
 800903c:	463b      	mov	r3, r7
 800903e:	461f      	mov	r7, r3
 8009040:	3b01      	subs	r3, #1
 8009042:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8009046:	2a30      	cmp	r2, #48	; 0x30
 8009048:	d0f9      	beq.n	800903e <_dtoa_r+0xd7e>
 800904a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 800904c:	9109      	str	r1, [sp, #36]	; 0x24
 800904e:	f7ff bbda 	b.w	8008806 <_dtoa_r+0x546>
 8009052:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8009054:	2a00      	cmp	r2, #0
 8009056:	d07f      	beq.n	8009158 <_dtoa_r+0xe98>
 8009058:	f203 4333 	addw	r3, r3, #1075	; 0x433
 800905c:	9d11      	ldr	r5, [sp, #68]	; 0x44
 800905e:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8009060:	e42e      	b.n	80088c0 <_dtoa_r+0x600>
 8009062:	465f      	mov	r7, fp
 8009064:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8009066:	f8dd b010 	ldr.w	fp, [sp, #16]
 800906a:	f7ff bbcc 	b.w	8008806 <_dtoa_r+0x546>
 800906e:	f8dd c010 	ldr.w	ip, [sp, #16]
 8009072:	2b00      	cmp	r3, #0
 8009074:	4664      	mov	r4, ip
 8009076:	dd13      	ble.n	80090a0 <_dtoa_r+0xde0>
 8009078:	4659      	mov	r1, fp
 800907a:	2201      	movs	r2, #1
 800907c:	4630      	mov	r0, r6
 800907e:	f8cd c00c 	str.w	ip, [sp, #12]
 8009082:	f001 f82b 	bl	800a0dc <__lshift>
 8009086:	4641      	mov	r1, r8
 8009088:	4683      	mov	fp, r0
 800908a:	f001 f881 	bl	800a190 <__mcmp>
 800908e:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8009092:	2800      	cmp	r0, #0
 8009094:	f340 8091 	ble.w	80091ba <_dtoa_r+0xefa>
 8009098:	2c39      	cmp	r4, #57	; 0x39
 800909a:	f107 0c31 	add.w	ip, r7, #49	; 0x31
 800909e:	d076      	beq.n	800918e <_dtoa_r+0xece>
 80090a0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80090a2:	46ca      	mov	sl, r9
 80090a4:	f807 cb01 	strb.w	ip, [r7], #1
 80090a8:	f7ff bb9d 	b.w	80087e6 <_dtoa_r+0x526>
 80090ac:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80090ae:	1a9c      	subs	r4, r3, r2
 80090b0:	2300      	movs	r3, #0
 80090b2:	e405      	b.n	80088c0 <_dtoa_r+0x600>
 80090b4:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 80090b8:	464f      	mov	r7, r9
 80090ba:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80090bc:	9e18      	ldr	r6, [sp, #96]	; 0x60
 80090be:	f7ff bae6 	b.w	800868e <_dtoa_r+0x3ce>
 80090c2:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 80090c6:	9e18      	ldr	r6, [sp, #96]	; 0x60
 80090c8:	f7ff ba2b 	b.w	8008522 <_dtoa_r+0x262>
 80090cc:	920d      	str	r2, [sp, #52]	; 0x34
 80090ce:	f10a 0a01 	add.w	sl, sl, #1
 80090d2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80090d4:	9209      	str	r2, [sp, #36]	; 0x24
 80090d6:	f7ff baea 	b.w	80086ae <_dtoa_r+0x3ee>
 80090da:	d103      	bne.n	80090e4 <_dtoa_r+0xe24>
 80090dc:	f01c 0f01 	tst.w	ip, #1
 80090e0:	f47f adbc 	bne.w	8008c5c <_dtoa_r+0x99c>
 80090e4:	463b      	mov	r3, r7
 80090e6:	461f      	mov	r7, r3
 80090e8:	3b01      	subs	r3, #1
 80090ea:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 80090ee:	2a30      	cmp	r2, #48	; 0x30
 80090f0:	d0f9      	beq.n	80090e6 <_dtoa_r+0xe26>
 80090f2:	f7ff bb78 	b.w	80087e6 <_dtoa_r+0x526>
 80090f6:	f04f 0800 	mov.w	r8, #0
 80090fa:	e577      	b.n	8008bec <_dtoa_r+0x92c>
 80090fc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8009100:	4622      	mov	r2, r4
 8009102:	462b      	mov	r3, r5
 8009104:	f003 f9c2 	bl	800c48c <__aeabi_dcmpeq>
 8009108:	2800      	cmp	r0, #0
 800910a:	f43f ab7c 	beq.w	8008806 <_dtoa_r+0x546>
 800910e:	f018 0f01 	tst.w	r8, #1
 8009112:	f43f ab78 	beq.w	8008806 <_dtoa_r+0x546>
 8009116:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009118:	f817 ac01 	ldrb.w	sl, [r7, #-1]
 800911c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800911e:	931b      	str	r3, [sp, #108]	; 0x6c
 8009120:	f7ff bab5 	b.w	800868e <_dtoa_r+0x3ce>
 8009124:	f8da 1004 	ldr.w	r1, [sl, #4]
 8009128:	4630      	mov	r0, r6
 800912a:	f000 fdaf 	bl	8009c8c <_Balloc>
 800912e:	f8da 3010 	ldr.w	r3, [sl, #16]
 8009132:	f10a 010c 	add.w	r1, sl, #12
 8009136:	1c9a      	adds	r2, r3, #2
 8009138:	0092      	lsls	r2, r2, #2
 800913a:	4604      	mov	r4, r0
 800913c:	300c      	adds	r0, #12
 800913e:	f000 fce7 	bl	8009b10 <memcpy>
 8009142:	4630      	mov	r0, r6
 8009144:	4621      	mov	r1, r4
 8009146:	2201      	movs	r2, #1
 8009148:	f000 ffc8 	bl	800a0dc <__lshift>
 800914c:	4681      	mov	r9, r0
 800914e:	e6a2      	b.n	8008e96 <_dtoa_r+0xbd6>
 8009150:	3201      	adds	r2, #1
 8009152:	701a      	strb	r2, [r3, #0]
 8009154:	f7ff bb47 	b.w	80087e6 <_dtoa_r+0x526>
 8009158:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800915a:	9d11      	ldr	r5, [sp, #68]	; 0x44
 800915c:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800915e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 8009162:	f7ff bbad 	b.w	80088c0 <_dtoa_r+0x600>
 8009166:	9d04      	ldr	r5, [sp, #16]
 8009168:	f7ff baeb 	b.w	8008742 <_dtoa_r+0x482>
 800916c:	f8dd c010 	ldr.w	ip, [sp, #16]
 8009170:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 8009174:	d00b      	beq.n	800918e <_dtoa_r+0xece>
 8009176:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8009178:	f10c 0c01 	add.w	ip, ip, #1
 800917c:	46ca      	mov	sl, r9
 800917e:	f807 cb01 	strb.w	ip, [r7], #1
 8009182:	f7ff bb30 	b.w	80087e6 <_dtoa_r+0x526>
 8009186:	f8dd c010 	ldr.w	ip, [sp, #16]
 800918a:	46ca      	mov	sl, r9
 800918c:	e556      	b.n	8008c3c <_dtoa_r+0x97c>
 800918e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8009190:	2339      	movs	r3, #57	; 0x39
 8009192:	46ca      	mov	sl, r9
 8009194:	461a      	mov	r2, r3
 8009196:	990d      	ldr	r1, [sp, #52]	; 0x34
 8009198:	f807 3b01 	strb.w	r3, [r7], #1
 800919c:	e565      	b.n	8008c6a <_dtoa_r+0x9aa>
 800919e:	f8dd c010 	ldr.w	ip, [sp, #16]
 80091a2:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 80091a6:	d0f2      	beq.n	800918e <_dtoa_r+0xece>
 80091a8:	f1ba 0f00 	cmp.w	sl, #0
 80091ac:	bfc8      	it	gt
 80091ae:	f107 0c31 	addgt.w	ip, r7, #49	; 0x31
 80091b2:	e775      	b.n	80090a0 <_dtoa_r+0xde0>
 80091b4:	f04f 0802 	mov.w	r8, #2
 80091b8:	e40f      	b.n	80089da <_dtoa_r+0x71a>
 80091ba:	f47f af71 	bne.w	80090a0 <_dtoa_r+0xde0>
 80091be:	f01c 0f01 	tst.w	ip, #1
 80091c2:	f43f af6d 	beq.w	80090a0 <_dtoa_r+0xde0>
 80091c6:	e767      	b.n	8009098 <_dtoa_r+0xdd8>
 80091c8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80091ca:	f7ff ba60 	b.w	800868e <_dtoa_r+0x3ce>
 80091ce:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80091d0:	9309      	str	r3, [sp, #36]	; 0x24
 80091d2:	f7ff bb18 	b.w	8008806 <_dtoa_r+0x546>
 80091d6:	9915      	ldr	r1, [sp, #84]	; 0x54
 80091d8:	910c      	str	r1, [sp, #48]	; 0x30
 80091da:	f7ff baeb 	b.w	80087b4 <_dtoa_r+0x4f4>
 80091de:	f43f aac8 	beq.w	8008772 <_dtoa_r+0x4b2>
 80091e2:	f1c3 033c 	rsb	r3, r3, #60	; 0x3c
 80091e6:	e54e      	b.n	8008c86 <_dtoa_r+0x9c6>
 80091e8:	920c      	str	r2, [sp, #48]	; 0x30
 80091ea:	f7ff bae3 	b.w	80087b4 <_dtoa_r+0x4f4>
 80091ee:	bf00      	nop

080091f0 <_malloc_trim_r>:
 80091f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80091f2:	f240 2430 	movw	r4, #560	; 0x230
 80091f6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80091fa:	460f      	mov	r7, r1
 80091fc:	4605      	mov	r5, r0
 80091fe:	f000 fd41 	bl	8009c84 <__malloc_lock>
 8009202:	68a3      	ldr	r3, [r4, #8]
 8009204:	685e      	ldr	r6, [r3, #4]
 8009206:	f026 0603 	bic.w	r6, r6, #3
 800920a:	f606 73ef 	addw	r3, r6, #4079	; 0xfef
 800920e:	1bdf      	subs	r7, r3, r7
 8009210:	0b3f      	lsrs	r7, r7, #12
 8009212:	3f01      	subs	r7, #1
 8009214:	033f      	lsls	r7, r7, #12
 8009216:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 800921a:	db07      	blt.n	800922c <_malloc_trim_r+0x3c>
 800921c:	2100      	movs	r1, #0
 800921e:	4628      	mov	r0, r5
 8009220:	f001 f9e4 	bl	800a5ec <_sbrk_r>
 8009224:	68a3      	ldr	r3, [r4, #8]
 8009226:	199b      	adds	r3, r3, r6
 8009228:	4298      	cmp	r0, r3
 800922a:	d004      	beq.n	8009236 <_malloc_trim_r+0x46>
 800922c:	4628      	mov	r0, r5
 800922e:	f000 fd2b 	bl	8009c88 <__malloc_unlock>
 8009232:	2000      	movs	r0, #0
 8009234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009236:	4279      	negs	r1, r7
 8009238:	4628      	mov	r0, r5
 800923a:	f001 f9d7 	bl	800a5ec <_sbrk_r>
 800923e:	3001      	adds	r0, #1
 8009240:	d010      	beq.n	8009264 <_malloc_trim_r+0x74>
 8009242:	f240 635c 	movw	r3, #1628	; 0x65c
 8009246:	68a1      	ldr	r1, [r4, #8]
 8009248:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800924c:	1bf6      	subs	r6, r6, r7
 800924e:	4628      	mov	r0, r5
 8009250:	f046 0601 	orr.w	r6, r6, #1
 8009254:	681a      	ldr	r2, [r3, #0]
 8009256:	604e      	str	r6, [r1, #4]
 8009258:	1bd7      	subs	r7, r2, r7
 800925a:	601f      	str	r7, [r3, #0]
 800925c:	f000 fd14 	bl	8009c88 <__malloc_unlock>
 8009260:	2001      	movs	r0, #1
 8009262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009264:	2100      	movs	r1, #0
 8009266:	4628      	mov	r0, r5
 8009268:	f001 f9c0 	bl	800a5ec <_sbrk_r>
 800926c:	68a3      	ldr	r3, [r4, #8]
 800926e:	1ac2      	subs	r2, r0, r3
 8009270:	2a0f      	cmp	r2, #15
 8009272:	dddb      	ble.n	800922c <_malloc_trim_r+0x3c>
 8009274:	f240 6438 	movw	r4, #1592	; 0x638
 8009278:	f240 615c 	movw	r1, #1628	; 0x65c
 800927c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8009280:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8009284:	f042 0201 	orr.w	r2, r2, #1
 8009288:	605a      	str	r2, [r3, #4]
 800928a:	6823      	ldr	r3, [r4, #0]
 800928c:	1ac0      	subs	r0, r0, r3
 800928e:	6008      	str	r0, [r1, #0]
 8009290:	e7cc      	b.n	800922c <_malloc_trim_r+0x3c>
 8009292:	bf00      	nop

08009294 <_free_r>:
 8009294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009298:	460e      	mov	r6, r1
 800929a:	4680      	mov	r8, r0
 800929c:	2900      	cmp	r1, #0
 800929e:	d05c      	beq.n	800935a <_free_r+0xc6>
 80092a0:	f000 fcf0 	bl	8009c84 <__malloc_lock>
 80092a4:	f240 2530 	movw	r5, #560	; 0x230
 80092a8:	f856 1c04 	ldr.w	r1, [r6, #-4]
 80092ac:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80092b0:	f1a6 0408 	sub.w	r4, r6, #8
 80092b4:	f021 0301 	bic.w	r3, r1, #1
 80092b8:	68af      	ldr	r7, [r5, #8]
 80092ba:	18e2      	adds	r2, r4, r3
 80092bc:	4297      	cmp	r7, r2
 80092be:	6850      	ldr	r0, [r2, #4]
 80092c0:	f020 0003 	bic.w	r0, r0, #3
 80092c4:	d067      	beq.n	8009396 <_free_r+0x102>
 80092c6:	f011 0101 	ands.w	r1, r1, #1
 80092ca:	6050      	str	r0, [r2, #4]
 80092cc:	d035      	beq.n	800933a <_free_r+0xa6>
 80092ce:	2100      	movs	r1, #0
 80092d0:	1816      	adds	r6, r2, r0
 80092d2:	6876      	ldr	r6, [r6, #4]
 80092d4:	f016 0f01 	tst.w	r6, #1
 80092d8:	d106      	bne.n	80092e8 <_free_r+0x54>
 80092da:	181b      	adds	r3, r3, r0
 80092dc:	6890      	ldr	r0, [r2, #8]
 80092de:	2900      	cmp	r1, #0
 80092e0:	d04d      	beq.n	800937e <_free_r+0xea>
 80092e2:	68d2      	ldr	r2, [r2, #12]
 80092e4:	60c2      	str	r2, [r0, #12]
 80092e6:	6090      	str	r0, [r2, #8]
 80092e8:	f043 0201 	orr.w	r2, r3, #1
 80092ec:	50e3      	str	r3, [r4, r3]
 80092ee:	6062      	str	r2, [r4, #4]
 80092f0:	b9f1      	cbnz	r1, 8009330 <_free_r+0x9c>
 80092f2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80092f6:	d332      	bcc.n	800935e <_free_r+0xca>
 80092f8:	0a5a      	lsrs	r2, r3, #9
 80092fa:	2a04      	cmp	r2, #4
 80092fc:	d86c      	bhi.n	80093d8 <_free_r+0x144>
 80092fe:	0998      	lsrs	r0, r3, #6
 8009300:	3038      	adds	r0, #56	; 0x38
 8009302:	0041      	lsls	r1, r0, #1
 8009304:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 8009308:	f240 2130 	movw	r1, #560	; 0x230
 800930c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8009310:	68aa      	ldr	r2, [r5, #8]
 8009312:	42aa      	cmp	r2, r5
 8009314:	d06b      	beq.n	80093ee <_free_r+0x15a>
 8009316:	6851      	ldr	r1, [r2, #4]
 8009318:	f021 0103 	bic.w	r1, r1, #3
 800931c:	428b      	cmp	r3, r1
 800931e:	d202      	bcs.n	8009326 <_free_r+0x92>
 8009320:	6892      	ldr	r2, [r2, #8]
 8009322:	4295      	cmp	r5, r2
 8009324:	d1f7      	bne.n	8009316 <_free_r+0x82>
 8009326:	68d3      	ldr	r3, [r2, #12]
 8009328:	60e3      	str	r3, [r4, #12]
 800932a:	60a2      	str	r2, [r4, #8]
 800932c:	60d4      	str	r4, [r2, #12]
 800932e:	609c      	str	r4, [r3, #8]
 8009330:	4640      	mov	r0, r8
 8009332:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009336:	f000 bca7 	b.w	8009c88 <__malloc_unlock>
 800933a:	f856 6c08 	ldr.w	r6, [r6, #-8]
 800933e:	f105 0c08 	add.w	ip, r5, #8
 8009342:	1ba4      	subs	r4, r4, r6
 8009344:	199b      	adds	r3, r3, r6
 8009346:	68a6      	ldr	r6, [r4, #8]
 8009348:	4566      	cmp	r6, ip
 800934a:	d043      	beq.n	80093d4 <_free_r+0x140>
 800934c:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8009350:	f8c6 c00c 	str.w	ip, [r6, #12]
 8009354:	f8cc 6008 	str.w	r6, [ip, #8]
 8009358:	e7ba      	b.n	80092d0 <_free_r+0x3c>
 800935a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800935e:	08db      	lsrs	r3, r3, #3
 8009360:	2101      	movs	r1, #1
 8009362:	6868      	ldr	r0, [r5, #4]
 8009364:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
 8009368:	109b      	asrs	r3, r3, #2
 800936a:	fa01 f303 	lsl.w	r3, r1, r3
 800936e:	60e2      	str	r2, [r4, #12]
 8009370:	6891      	ldr	r1, [r2, #8]
 8009372:	4318      	orrs	r0, r3
 8009374:	6068      	str	r0, [r5, #4]
 8009376:	60a1      	str	r1, [r4, #8]
 8009378:	60cc      	str	r4, [r1, #12]
 800937a:	6094      	str	r4, [r2, #8]
 800937c:	e7d8      	b.n	8009330 <_free_r+0x9c>
 800937e:	4e29      	ldr	r6, [pc, #164]	; (8009424 <_free_r+0x190>)
 8009380:	42b0      	cmp	r0, r6
 8009382:	d1ae      	bne.n	80092e2 <_free_r+0x4e>
 8009384:	616c      	str	r4, [r5, #20]
 8009386:	f043 0201 	orr.w	r2, r3, #1
 800938a:	612c      	str	r4, [r5, #16]
 800938c:	60e0      	str	r0, [r4, #12]
 800938e:	60a0      	str	r0, [r4, #8]
 8009390:	6062      	str	r2, [r4, #4]
 8009392:	50e3      	str	r3, [r4, r3]
 8009394:	e7cc      	b.n	8009330 <_free_r+0x9c>
 8009396:	18c0      	adds	r0, r0, r3
 8009398:	07cb      	lsls	r3, r1, #31
 800939a:	d407      	bmi.n	80093ac <_free_r+0x118>
 800939c:	f856 3c08 	ldr.w	r3, [r6, #-8]
 80093a0:	1ae4      	subs	r4, r4, r3
 80093a2:	18c0      	adds	r0, r0, r3
 80093a4:	68a2      	ldr	r2, [r4, #8]
 80093a6:	68e3      	ldr	r3, [r4, #12]
 80093a8:	60d3      	str	r3, [r2, #12]
 80093aa:	609a      	str	r2, [r3, #8]
 80093ac:	f240 623c 	movw	r2, #1596	; 0x63c
 80093b0:	f040 0301 	orr.w	r3, r0, #1
 80093b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80093b8:	6063      	str	r3, [r4, #4]
 80093ba:	60ac      	str	r4, [r5, #8]
 80093bc:	6813      	ldr	r3, [r2, #0]
 80093be:	4298      	cmp	r0, r3
 80093c0:	d3b6      	bcc.n	8009330 <_free_r+0x9c>
 80093c2:	f240 6358 	movw	r3, #1624	; 0x658
 80093c6:	4640      	mov	r0, r8
 80093c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80093cc:	6819      	ldr	r1, [r3, #0]
 80093ce:	f7ff ff0f 	bl	80091f0 <_malloc_trim_r>
 80093d2:	e7ad      	b.n	8009330 <_free_r+0x9c>
 80093d4:	2101      	movs	r1, #1
 80093d6:	e77b      	b.n	80092d0 <_free_r+0x3c>
 80093d8:	f102 005b 	add.w	r0, r2, #91	; 0x5b
 80093dc:	0041      	lsls	r1, r0, #1
 80093de:	2a14      	cmp	r2, #20
 80093e0:	d990      	bls.n	8009304 <_free_r+0x70>
 80093e2:	2a54      	cmp	r2, #84	; 0x54
 80093e4:	d80c      	bhi.n	8009400 <_free_r+0x16c>
 80093e6:	0b18      	lsrs	r0, r3, #12
 80093e8:	306e      	adds	r0, #110	; 0x6e
 80093ea:	0041      	lsls	r1, r0, #1
 80093ec:	e78a      	b.n	8009304 <_free_r+0x70>
 80093ee:	2601      	movs	r6, #1
 80093f0:	684d      	ldr	r5, [r1, #4]
 80093f2:	1080      	asrs	r0, r0, #2
 80093f4:	4613      	mov	r3, r2
 80093f6:	fa06 f000 	lsl.w	r0, r6, r0
 80093fa:	4305      	orrs	r5, r0
 80093fc:	604d      	str	r5, [r1, #4]
 80093fe:	e793      	b.n	8009328 <_free_r+0x94>
 8009400:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8009404:	d803      	bhi.n	800940e <_free_r+0x17a>
 8009406:	0bd8      	lsrs	r0, r3, #15
 8009408:	3077      	adds	r0, #119	; 0x77
 800940a:	0041      	lsls	r1, r0, #1
 800940c:	e77a      	b.n	8009304 <_free_r+0x70>
 800940e:	f240 5154 	movw	r1, #1364	; 0x554
 8009412:	428a      	cmp	r2, r1
 8009414:	d803      	bhi.n	800941e <_free_r+0x18a>
 8009416:	0c98      	lsrs	r0, r3, #18
 8009418:	307c      	adds	r0, #124	; 0x7c
 800941a:	0041      	lsls	r1, r0, #1
 800941c:	e772      	b.n	8009304 <_free_r+0x70>
 800941e:	21fc      	movs	r1, #252	; 0xfc
 8009420:	207e      	movs	r0, #126	; 0x7e
 8009422:	e76f      	b.n	8009304 <_free_r+0x70>
 8009424:	20000238 	.word	0x20000238

08009428 <_setlocale_r>:
 8009428:	b510      	push	{r4, lr}
 800942a:	4614      	mov	r4, r2
 800942c:	b13a      	cbz	r2, 800943e <_setlocale_r+0x16>
 800942e:	f24d 11b0 	movw	r1, #53680	; 0xd1b0
 8009432:	4610      	mov	r0, r2
 8009434:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009438:	f001 f8ec 	bl	800a614 <strcmp>
 800943c:	b920      	cbnz	r0, 8009448 <_setlocale_r+0x20>
 800943e:	f24d 10ac 	movw	r0, #53676	; 0xd1ac
 8009442:	f6c0 0000 	movt	r0, #2048	; 0x800
 8009446:	bd10      	pop	{r4, pc}
 8009448:	f24d 11ac 	movw	r1, #53676	; 0xd1ac
 800944c:	4620      	mov	r0, r4
 800944e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009452:	f001 f8df 	bl	800a614 <strcmp>
 8009456:	2800      	cmp	r0, #0
 8009458:	d0f1      	beq.n	800943e <_setlocale_r+0x16>
 800945a:	f24d 1178 	movw	r1, #53624	; 0xd178
 800945e:	4620      	mov	r0, r4
 8009460:	f6c0 0100 	movt	r1, #2048	; 0x800
 8009464:	f001 f8d6 	bl	800a614 <strcmp>
 8009468:	f24d 13ac 	movw	r3, #53676	; 0xd1ac
 800946c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8009470:	2800      	cmp	r0, #0
 8009472:	bf0c      	ite	eq
 8009474:	4618      	moveq	r0, r3
 8009476:	2000      	movne	r0, #0
 8009478:	bd10      	pop	{r4, pc}
 800947a:	bf00      	nop

0800947c <__locale_charset>:
 800947c:	f240 10b4 	movw	r0, #436	; 0x1b4
 8009480:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8009484:	4770      	bx	lr
 8009486:	bf00      	nop

08009488 <__locale_mb_cur_max>:
 8009488:	f240 13b4 	movw	r3, #436	; 0x1b4
 800948c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009490:	6a18      	ldr	r0, [r3, #32]
 8009492:	4770      	bx	lr

08009494 <__locale_msgcharset>:
 8009494:	4800      	ldr	r0, [pc, #0]	; (8009498 <__locale_msgcharset+0x4>)
 8009496:	4770      	bx	lr
 8009498:	200001d8 	.word	0x200001d8

0800949c <__locale_cjk_lang>:
 800949c:	2000      	movs	r0, #0
 800949e:	4770      	bx	lr

080094a0 <_localeconv_r>:
 80094a0:	4800      	ldr	r0, [pc, #0]	; (80094a4 <_localeconv_r+0x4>)
 80094a2:	4770      	bx	lr
 80094a4:	200001f8 	.word	0x200001f8

080094a8 <setlocale>:
 80094a8:	f240 03c0 	movw	r3, #192	; 0xc0
 80094ac:	460a      	mov	r2, r1
 80094ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80094b2:	4601      	mov	r1, r0
 80094b4:	6818      	ldr	r0, [r3, #0]
 80094b6:	f7ff bfb7 	b.w	8009428 <_setlocale_r>
 80094ba:	bf00      	nop

080094bc <localeconv>:
 80094bc:	4800      	ldr	r0, [pc, #0]	; (80094c0 <localeconv+0x4>)
 80094be:	4770      	bx	lr
 80094c0:	200001f8 	.word	0x200001f8

080094c4 <malloc>:
 80094c4:	f240 03c0 	movw	r3, #192	; 0xc0
 80094c8:	4601      	mov	r1, r0
 80094ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80094ce:	6818      	ldr	r0, [r3, #0]
 80094d0:	f000 b808 	b.w	80094e4 <_malloc_r>

080094d4 <free>:
 80094d4:	f240 03c0 	movw	r3, #192	; 0xc0
 80094d8:	4601      	mov	r1, r0
 80094da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80094de:	6818      	ldr	r0, [r3, #0]
 80094e0:	f7ff bed8 	b.w	8009294 <_free_r>

080094e4 <_malloc_r>:
 80094e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80094e8:	f101 040b 	add.w	r4, r1, #11
 80094ec:	2c16      	cmp	r4, #22
 80094ee:	b083      	sub	sp, #12
 80094f0:	4607      	mov	r7, r0
 80094f2:	d930      	bls.n	8009556 <_malloc_r+0x72>
 80094f4:	f024 0407 	bic.w	r4, r4, #7
 80094f8:	0fe3      	lsrs	r3, r4, #31
 80094fa:	428c      	cmp	r4, r1
 80094fc:	bf2c      	ite	cs
 80094fe:	4619      	movcs	r1, r3
 8009500:	f043 0101 	orrcc.w	r1, r3, #1
 8009504:	2900      	cmp	r1, #0
 8009506:	d12f      	bne.n	8009568 <_malloc_r+0x84>
 8009508:	4638      	mov	r0, r7
 800950a:	f000 fbbb 	bl	8009c84 <__malloc_lock>
 800950e:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8009512:	d22e      	bcs.n	8009572 <_malloc_r+0x8e>
 8009514:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 8009518:	f240 2630 	movw	r6, #560	; 0x230
 800951c:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8009520:	eb06 02cc 	add.w	r2, r6, ip, lsl #3
 8009524:	68d3      	ldr	r3, [r2, #12]
 8009526:	4293      	cmp	r3, r2
 8009528:	f000 8211 	beq.w	800994e <_malloc_r+0x46a>
 800952c:	6859      	ldr	r1, [r3, #4]
 800952e:	f103 0808 	add.w	r8, r3, #8
 8009532:	68da      	ldr	r2, [r3, #12]
 8009534:	4638      	mov	r0, r7
 8009536:	f021 0403 	bic.w	r4, r1, #3
 800953a:	6899      	ldr	r1, [r3, #8]
 800953c:	191b      	adds	r3, r3, r4
 800953e:	685c      	ldr	r4, [r3, #4]
 8009540:	60ca      	str	r2, [r1, #12]
 8009542:	f044 0401 	orr.w	r4, r4, #1
 8009546:	6091      	str	r1, [r2, #8]
 8009548:	605c      	str	r4, [r3, #4]
 800954a:	f000 fb9d 	bl	8009c88 <__malloc_unlock>
 800954e:	4640      	mov	r0, r8
 8009550:	b003      	add	sp, #12
 8009552:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009556:	2300      	movs	r3, #0
 8009558:	2410      	movs	r4, #16
 800955a:	428c      	cmp	r4, r1
 800955c:	bf2c      	ite	cs
 800955e:	4619      	movcs	r1, r3
 8009560:	f043 0101 	orrcc.w	r1, r3, #1
 8009564:	2900      	cmp	r1, #0
 8009566:	d0cf      	beq.n	8009508 <_malloc_r+0x24>
 8009568:	230c      	movs	r3, #12
 800956a:	f04f 0800 	mov.w	r8, #0
 800956e:	603b      	str	r3, [r7, #0]
 8009570:	e7ed      	b.n	800954e <_malloc_r+0x6a>
 8009572:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8009576:	bf04      	itt	eq
 8009578:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 800957c:	ea4f 054c 	moveq.w	r5, ip, lsl #1
 8009580:	f040 808f 	bne.w	80096a2 <_malloc_r+0x1be>
 8009584:	f240 2630 	movw	r6, #560	; 0x230
 8009588:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800958c:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 8009590:	68eb      	ldr	r3, [r5, #12]
 8009592:	429d      	cmp	r5, r3
 8009594:	d106      	bne.n	80095a4 <_malloc_r+0xc0>
 8009596:	e00d      	b.n	80095b4 <_malloc_r+0xd0>
 8009598:	2a00      	cmp	r2, #0
 800959a:	f280 8155 	bge.w	8009848 <_malloc_r+0x364>
 800959e:	68db      	ldr	r3, [r3, #12]
 80095a0:	429d      	cmp	r5, r3
 80095a2:	d007      	beq.n	80095b4 <_malloc_r+0xd0>
 80095a4:	6859      	ldr	r1, [r3, #4]
 80095a6:	f021 0103 	bic.w	r1, r1, #3
 80095aa:	1b0a      	subs	r2, r1, r4
 80095ac:	2a0f      	cmp	r2, #15
 80095ae:	ddf3      	ble.n	8009598 <_malloc_r+0xb4>
 80095b0:	f10c 3cff 	add.w	ip, ip, #4294967295
 80095b4:	f10c 0c01 	add.w	ip, ip, #1
 80095b8:	f240 2230 	movw	r2, #560	; 0x230
 80095bc:	6933      	ldr	r3, [r6, #16]
 80095be:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80095c2:	f102 0e08 	add.w	lr, r2, #8
 80095c6:	4573      	cmp	r3, lr
 80095c8:	bf08      	it	eq
 80095ca:	f8d2 9004 	ldreq.w	r9, [r2, #4]
 80095ce:	d022      	beq.n	8009616 <_malloc_r+0x132>
 80095d0:	6858      	ldr	r0, [r3, #4]
 80095d2:	f020 0003 	bic.w	r0, r0, #3
 80095d6:	1b01      	subs	r1, r0, r4
 80095d8:	290f      	cmp	r1, #15
 80095da:	f300 8184 	bgt.w	80098e6 <_malloc_r+0x402>
 80095de:	2900      	cmp	r1, #0
 80095e0:	f8c2 e014 	str.w	lr, [r2, #20]
 80095e4:	f8c2 e010 	str.w	lr, [r2, #16]
 80095e8:	da66      	bge.n	80096b8 <_malloc_r+0x1d4>
 80095ea:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80095ee:	f080 814e 	bcs.w	800988e <_malloc_r+0x3aa>
 80095f2:	08c1      	lsrs	r1, r0, #3
 80095f4:	f04f 0801 	mov.w	r8, #1
 80095f8:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
 80095fc:	1089      	asrs	r1, r1, #2
 80095fe:	fa08 f801 	lsl.w	r8, r8, r1
 8009602:	6851      	ldr	r1, [r2, #4]
 8009604:	6885      	ldr	r5, [r0, #8]
 8009606:	60d8      	str	r0, [r3, #12]
 8009608:	ea48 0901 	orr.w	r9, r8, r1
 800960c:	f8c2 9004 	str.w	r9, [r2, #4]
 8009610:	609d      	str	r5, [r3, #8]
 8009612:	60eb      	str	r3, [r5, #12]
 8009614:	6083      	str	r3, [r0, #8]
 8009616:	2201      	movs	r2, #1
 8009618:	ea4f 03ac 	mov.w	r3, ip, asr #2
 800961c:	fa02 f303 	lsl.w	r3, r2, r3
 8009620:	454b      	cmp	r3, r9
 8009622:	d854      	bhi.n	80096ce <_malloc_r+0x1ea>
 8009624:	ea19 0f03 	tst.w	r9, r3
 8009628:	d10d      	bne.n	8009646 <_malloc_r+0x162>
 800962a:	4093      	lsls	r3, r2
 800962c:	f02c 0c03 	bic.w	ip, ip, #3
 8009630:	ea19 0f03 	tst.w	r9, r3
 8009634:	f10c 0c04 	add.w	ip, ip, #4
 8009638:	d105      	bne.n	8009646 <_malloc_r+0x162>
 800963a:	005b      	lsls	r3, r3, #1
 800963c:	f10c 0c04 	add.w	ip, ip, #4
 8009640:	ea19 0f03 	tst.w	r9, r3
 8009644:	d0f9      	beq.n	800963a <_malloc_r+0x156>
 8009646:	eb06 09cc 	add.w	r9, r6, ip, lsl #3
 800964a:	46e0      	mov	r8, ip
 800964c:	4648      	mov	r0, r9
 800964e:	68c2      	ldr	r2, [r0, #12]
 8009650:	4290      	cmp	r0, r2
 8009652:	d107      	bne.n	8009664 <_malloc_r+0x180>
 8009654:	e15b      	b.n	800990e <_malloc_r+0x42a>
 8009656:	2900      	cmp	r1, #0
 8009658:	f280 8183 	bge.w	8009962 <_malloc_r+0x47e>
 800965c:	68d2      	ldr	r2, [r2, #12]
 800965e:	4290      	cmp	r0, r2
 8009660:	f000 8155 	beq.w	800990e <_malloc_r+0x42a>
 8009664:	6855      	ldr	r5, [r2, #4]
 8009666:	f025 0503 	bic.w	r5, r5, #3
 800966a:	1b29      	subs	r1, r5, r4
 800966c:	290f      	cmp	r1, #15
 800966e:	ddf2      	ble.n	8009656 <_malloc_r+0x172>
 8009670:	4690      	mov	r8, r2
 8009672:	1913      	adds	r3, r2, r4
 8009674:	68d5      	ldr	r5, [r2, #12]
 8009676:	f044 0001 	orr.w	r0, r4, #1
 800967a:	f858 4f08 	ldr.w	r4, [r8, #8]!
 800967e:	f041 0c01 	orr.w	ip, r1, #1
 8009682:	6050      	str	r0, [r2, #4]
 8009684:	4638      	mov	r0, r7
 8009686:	f8c3 c004 	str.w	ip, [r3, #4]
 800968a:	60e5      	str	r5, [r4, #12]
 800968c:	60ac      	str	r4, [r5, #8]
 800968e:	6173      	str	r3, [r6, #20]
 8009690:	6133      	str	r3, [r6, #16]
 8009692:	f8c3 e00c 	str.w	lr, [r3, #12]
 8009696:	f8c3 e008 	str.w	lr, [r3, #8]
 800969a:	5059      	str	r1, [r3, r1]
 800969c:	f000 faf4 	bl	8009c88 <__malloc_unlock>
 80096a0:	e755      	b.n	800954e <_malloc_r+0x6a>
 80096a2:	f1bc 0f04 	cmp.w	ip, #4
 80096a6:	f200 80de 	bhi.w	8009866 <_malloc_r+0x382>
 80096aa:	ea4f 1c94 	mov.w	ip, r4, lsr #6
 80096ae:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 80096b2:	ea4f 054c 	mov.w	r5, ip, lsl #1
 80096b6:	e765      	b.n	8009584 <_malloc_r+0xa0>
 80096b8:	181a      	adds	r2, r3, r0
 80096ba:	f103 0808 	add.w	r8, r3, #8
 80096be:	4638      	mov	r0, r7
 80096c0:	6853      	ldr	r3, [r2, #4]
 80096c2:	f043 0301 	orr.w	r3, r3, #1
 80096c6:	6053      	str	r3, [r2, #4]
 80096c8:	f000 fade 	bl	8009c88 <__malloc_unlock>
 80096cc:	e73f      	b.n	800954e <_malloc_r+0x6a>
 80096ce:	68b5      	ldr	r5, [r6, #8]
 80096d0:	686b      	ldr	r3, [r5, #4]
 80096d2:	f023 0a03 	bic.w	sl, r3, #3
 80096d6:	4554      	cmp	r4, sl
 80096d8:	d804      	bhi.n	80096e4 <_malloc_r+0x200>
 80096da:	ebc4 030a 	rsb	r3, r4, sl
 80096de:	2b0f      	cmp	r3, #15
 80096e0:	f300 80a4 	bgt.w	800982c <_malloc_r+0x348>
 80096e4:	f240 6958 	movw	r9, #1624	; 0x658
 80096e8:	f8d6 1408 	ldr.w	r1, [r6, #1032]	; 0x408
 80096ec:	f2c2 0900 	movt	r9, #8192	; 0x2000
 80096f0:	eb05 020a 	add.w	r2, r5, sl
 80096f4:	3101      	adds	r1, #1
 80096f6:	f8d9 3000 	ldr.w	r3, [r9]
 80096fa:	4423      	add	r3, r4
 80096fc:	bf08      	it	eq
 80096fe:	f103 0b10 	addeq.w	fp, r3, #16
 8009702:	d006      	beq.n	8009712 <_malloc_r+0x22e>
 8009704:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8009708:	330f      	adds	r3, #15
 800970a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800970e:	f023 0b0f 	bic.w	fp, r3, #15
 8009712:	4638      	mov	r0, r7
 8009714:	4659      	mov	r1, fp
 8009716:	9201      	str	r2, [sp, #4]
 8009718:	f000 ff68 	bl	800a5ec <_sbrk_r>
 800971c:	9a01      	ldr	r2, [sp, #4]
 800971e:	1c41      	adds	r1, r0, #1
 8009720:	4680      	mov	r8, r0
 8009722:	f000 8168 	beq.w	80099f6 <_malloc_r+0x512>
 8009726:	4282      	cmp	r2, r0
 8009728:	f200 8131 	bhi.w	800998e <_malloc_r+0x4aa>
 800972c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8009730:	4542      	cmp	r2, r8
 8009732:	445b      	add	r3, fp
 8009734:	f8c9 3004 	str.w	r3, [r9, #4]
 8009738:	f000 8166 	beq.w	8009a08 <_malloc_r+0x524>
 800973c:	f8d6 1408 	ldr.w	r1, [r6, #1032]	; 0x408
 8009740:	f240 2030 	movw	r0, #560	; 0x230
 8009744:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8009748:	3101      	adds	r1, #1
 800974a:	bf17      	itett	ne
 800974c:	ebc2 0208 	rsbne	r2, r2, r8
 8009750:	f8c0 8408 	streq.w	r8, [r0, #1032]	; 0x408
 8009754:	189b      	addne	r3, r3, r2
 8009756:	f8c9 3004 	strne.w	r3, [r9, #4]
 800975a:	f018 0307 	ands.w	r3, r8, #7
 800975e:	4638      	mov	r0, r7
 8009760:	bf1f      	itttt	ne
 8009762:	f1c3 0208 	rsbne	r2, r3, #8
 8009766:	f5c3 5380 	rsbne	r3, r3, #4096	; 0x1000
 800976a:	4490      	addne	r8, r2
 800976c:	f103 0208 	addne.w	r2, r3, #8
 8009770:	eb08 030b 	add.w	r3, r8, fp
 8009774:	bf08      	it	eq
 8009776:	f44f 5280 	moveq.w	r2, #4096	; 0x1000
 800977a:	051b      	lsls	r3, r3, #20
 800977c:	0d1b      	lsrs	r3, r3, #20
 800977e:	ebc3 0b02 	rsb	fp, r3, r2
 8009782:	4659      	mov	r1, fp
 8009784:	f000 ff32 	bl	800a5ec <_sbrk_r>
 8009788:	1c43      	adds	r3, r0, #1
 800978a:	f000 8149 	beq.w	8009a20 <_malloc_r+0x53c>
 800978e:	ebc8 0100 	rsb	r1, r8, r0
 8009792:	4459      	add	r1, fp
 8009794:	f041 0101 	orr.w	r1, r1, #1
 8009798:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800979c:	42b5      	cmp	r5, r6
 800979e:	f240 6258 	movw	r2, #1624	; 0x658
 80097a2:	f8c6 8008 	str.w	r8, [r6, #8]
 80097a6:	445b      	add	r3, fp
 80097a8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80097ac:	f8c8 1004 	str.w	r1, [r8, #4]
 80097b0:	f8c9 3004 	str.w	r3, [r9, #4]
 80097b4:	d018      	beq.n	80097e8 <_malloc_r+0x304>
 80097b6:	f1ba 0f0f 	cmp.w	sl, #15
 80097ba:	f240 810b 	bls.w	80099d4 <_malloc_r+0x4f0>
 80097be:	f1aa 000c 	sub.w	r0, sl, #12
 80097c2:	6869      	ldr	r1, [r5, #4]
 80097c4:	f020 0007 	bic.w	r0, r0, #7
 80097c8:	f04f 0c05 	mov.w	ip, #5
 80097cc:	eb05 0e00 	add.w	lr, r5, r0
 80097d0:	280f      	cmp	r0, #15
 80097d2:	f001 0101 	and.w	r1, r1, #1
 80097d6:	ea40 0101 	orr.w	r1, r0, r1
 80097da:	6069      	str	r1, [r5, #4]
 80097dc:	f8ce c004 	str.w	ip, [lr, #4]
 80097e0:	f8ce c008 	str.w	ip, [lr, #8]
 80097e4:	f200 8120 	bhi.w	8009a28 <_malloc_r+0x544>
 80097e8:	f240 6258 	movw	r2, #1624	; 0x658
 80097ec:	f8d9 102c 	ldr.w	r1, [r9, #44]	; 0x2c
 80097f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80097f4:	68b5      	ldr	r5, [r6, #8]
 80097f6:	428b      	cmp	r3, r1
 80097f8:	f8d9 1030 	ldr.w	r1, [r9, #48]	; 0x30
 80097fc:	bf88      	it	hi
 80097fe:	62d3      	strhi	r3, [r2, #44]	; 0x2c
 8009800:	f240 6258 	movw	r2, #1624	; 0x658
 8009804:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8009808:	428b      	cmp	r3, r1
 800980a:	bf88      	it	hi
 800980c:	6313      	strhi	r3, [r2, #48]	; 0x30
 800980e:	686a      	ldr	r2, [r5, #4]
 8009810:	f022 0203 	bic.w	r2, r2, #3
 8009814:	4294      	cmp	r4, r2
 8009816:	ebc4 0302 	rsb	r3, r4, r2
 800981a:	d801      	bhi.n	8009820 <_malloc_r+0x33c>
 800981c:	2b0f      	cmp	r3, #15
 800981e:	dc05      	bgt.n	800982c <_malloc_r+0x348>
 8009820:	4638      	mov	r0, r7
 8009822:	f04f 0800 	mov.w	r8, #0
 8009826:	f000 fa2f 	bl	8009c88 <__malloc_unlock>
 800982a:	e690      	b.n	800954e <_malloc_r+0x6a>
 800982c:	192a      	adds	r2, r5, r4
 800982e:	f043 0301 	orr.w	r3, r3, #1
 8009832:	f044 0401 	orr.w	r4, r4, #1
 8009836:	4638      	mov	r0, r7
 8009838:	606c      	str	r4, [r5, #4]
 800983a:	f105 0808 	add.w	r8, r5, #8
 800983e:	6053      	str	r3, [r2, #4]
 8009840:	60b2      	str	r2, [r6, #8]
 8009842:	f000 fa21 	bl	8009c88 <__malloc_unlock>
 8009846:	e682      	b.n	800954e <_malloc_r+0x6a>
 8009848:	1859      	adds	r1, r3, r1
 800984a:	68da      	ldr	r2, [r3, #12]
 800984c:	689c      	ldr	r4, [r3, #8]
 800984e:	4638      	mov	r0, r7
 8009850:	684d      	ldr	r5, [r1, #4]
 8009852:	f103 0808 	add.w	r8, r3, #8
 8009856:	f045 0501 	orr.w	r5, r5, #1
 800985a:	60e2      	str	r2, [r4, #12]
 800985c:	6094      	str	r4, [r2, #8]
 800985e:	604d      	str	r5, [r1, #4]
 8009860:	f000 fa12 	bl	8009c88 <__malloc_unlock>
 8009864:	e673      	b.n	800954e <_malloc_r+0x6a>
 8009866:	f1bc 0f14 	cmp.w	ip, #20
 800986a:	bf9c      	itt	ls
 800986c:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 8009870:	ea4f 054c 	movls.w	r5, ip, lsl #1
 8009874:	f67f ae86 	bls.w	8009584 <_malloc_r+0xa0>
 8009878:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 800987c:	f200 8093 	bhi.w	80099a6 <_malloc_r+0x4c2>
 8009880:	ea4f 3c14 	mov.w	ip, r4, lsr #12
 8009884:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
 8009888:	ea4f 054c 	mov.w	r5, ip, lsl #1
 800988c:	e67a      	b.n	8009584 <_malloc_r+0xa0>
 800988e:	0a42      	lsrs	r2, r0, #9
 8009890:	2a04      	cmp	r2, #4
 8009892:	d975      	bls.n	8009980 <_malloc_r+0x49c>
 8009894:	2a14      	cmp	r2, #20
 8009896:	bf9c      	itt	ls
 8009898:	f102 095b 	addls.w	r9, r2, #91	; 0x5b
 800989c:	ea4f 0549 	movls.w	r5, r9, lsl #1
 80098a0:	d908      	bls.n	80098b4 <_malloc_r+0x3d0>
 80098a2:	2a54      	cmp	r2, #84	; 0x54
 80098a4:	f200 80c9 	bhi.w	8009a3a <_malloc_r+0x556>
 80098a8:	ea4f 3910 	mov.w	r9, r0, lsr #12
 80098ac:	f109 096e 	add.w	r9, r9, #110	; 0x6e
 80098b0:	ea4f 0549 	mov.w	r5, r9, lsl #1
 80098b4:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 80098b8:	f240 2830 	movw	r8, #560	; 0x230
 80098bc:	f2c2 0800 	movt	r8, #8192	; 0x2000
 80098c0:	68aa      	ldr	r2, [r5, #8]
 80098c2:	42aa      	cmp	r2, r5
 80098c4:	d079      	beq.n	80099ba <_malloc_r+0x4d6>
 80098c6:	6851      	ldr	r1, [r2, #4]
 80098c8:	f021 0103 	bic.w	r1, r1, #3
 80098cc:	4288      	cmp	r0, r1
 80098ce:	d202      	bcs.n	80098d6 <_malloc_r+0x3f2>
 80098d0:	6892      	ldr	r2, [r2, #8]
 80098d2:	4295      	cmp	r5, r2
 80098d4:	d1f7      	bne.n	80098c6 <_malloc_r+0x3e2>
 80098d6:	68d0      	ldr	r0, [r2, #12]
 80098d8:	f8d6 9004 	ldr.w	r9, [r6, #4]
 80098dc:	60d8      	str	r0, [r3, #12]
 80098de:	609a      	str	r2, [r3, #8]
 80098e0:	60d3      	str	r3, [r2, #12]
 80098e2:	6083      	str	r3, [r0, #8]
 80098e4:	e697      	b.n	8009616 <_malloc_r+0x132>
 80098e6:	191d      	adds	r5, r3, r4
 80098e8:	f041 0601 	orr.w	r6, r1, #1
 80098ec:	6155      	str	r5, [r2, #20]
 80098ee:	f044 0401 	orr.w	r4, r4, #1
 80098f2:	6115      	str	r5, [r2, #16]
 80098f4:	4638      	mov	r0, r7
 80098f6:	605c      	str	r4, [r3, #4]
 80098f8:	f103 0808 	add.w	r8, r3, #8
 80098fc:	f8c5 e00c 	str.w	lr, [r5, #12]
 8009900:	f8c5 e008 	str.w	lr, [r5, #8]
 8009904:	606e      	str	r6, [r5, #4]
 8009906:	5069      	str	r1, [r5, r1]
 8009908:	f000 f9be 	bl	8009c88 <__malloc_unlock>
 800990c:	e61f      	b.n	800954e <_malloc_r+0x6a>
 800990e:	f108 0801 	add.w	r8, r8, #1
 8009912:	3008      	adds	r0, #8
 8009914:	f018 0f03 	tst.w	r8, #3
 8009918:	f47f ae99 	bne.w	800964e <_malloc_r+0x16a>
 800991c:	464a      	mov	r2, r9
 800991e:	f01c 0f03 	tst.w	ip, #3
 8009922:	f1a2 0108 	sub.w	r1, r2, #8
 8009926:	f10c 3cff 	add.w	ip, ip, #4294967295
 800992a:	f000 809e 	beq.w	8009a6a <_malloc_r+0x586>
 800992e:	6812      	ldr	r2, [r2, #0]
 8009930:	428a      	cmp	r2, r1
 8009932:	d0f4      	beq.n	800991e <_malloc_r+0x43a>
 8009934:	6872      	ldr	r2, [r6, #4]
 8009936:	005b      	lsls	r3, r3, #1
 8009938:	4293      	cmp	r3, r2
 800993a:	f63f aec8 	bhi.w	80096ce <_malloc_r+0x1ea>
 800993e:	2b00      	cmp	r3, #0
 8009940:	f43f aec5 	beq.w	80096ce <_malloc_r+0x1ea>
 8009944:	421a      	tst	r2, r3
 8009946:	f000 8095 	beq.w	8009a74 <_malloc_r+0x590>
 800994a:	46c4      	mov	ip, r8
 800994c:	e67b      	b.n	8009646 <_malloc_r+0x162>
 800994e:	f103 0208 	add.w	r2, r3, #8
 8009952:	695b      	ldr	r3, [r3, #20]
 8009954:	429a      	cmp	r2, r3
 8009956:	bf08      	it	eq
 8009958:	f10c 0c02 	addeq.w	ip, ip, #2
 800995c:	f43f ae2c 	beq.w	80095b8 <_malloc_r+0xd4>
 8009960:	e5e4      	b.n	800952c <_malloc_r+0x48>
 8009962:	4690      	mov	r8, r2
 8009964:	1955      	adds	r5, r2, r5
 8009966:	68d3      	ldr	r3, [r2, #12]
 8009968:	4638      	mov	r0, r7
 800996a:	f858 2f08 	ldr.w	r2, [r8, #8]!
 800996e:	6869      	ldr	r1, [r5, #4]
 8009970:	60d3      	str	r3, [r2, #12]
 8009972:	f041 0101 	orr.w	r1, r1, #1
 8009976:	609a      	str	r2, [r3, #8]
 8009978:	6069      	str	r1, [r5, #4]
 800997a:	f000 f985 	bl	8009c88 <__malloc_unlock>
 800997e:	e5e6      	b.n	800954e <_malloc_r+0x6a>
 8009980:	ea4f 1990 	mov.w	r9, r0, lsr #6
 8009984:	f109 0938 	add.w	r9, r9, #56	; 0x38
 8009988:	ea4f 0549 	mov.w	r5, r9, lsl #1
 800998c:	e792      	b.n	80098b4 <_malloc_r+0x3d0>
 800998e:	42b5      	cmp	r5, r6
 8009990:	f240 2330 	movw	r3, #560	; 0x230
 8009994:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009998:	f43f aec8 	beq.w	800972c <_malloc_r+0x248>
 800999c:	689d      	ldr	r5, [r3, #8]
 800999e:	686a      	ldr	r2, [r5, #4]
 80099a0:	f022 0203 	bic.w	r2, r2, #3
 80099a4:	e736      	b.n	8009814 <_malloc_r+0x330>
 80099a6:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 80099aa:	d819      	bhi.n	80099e0 <_malloc_r+0x4fc>
 80099ac:	ea4f 3cd4 	mov.w	ip, r4, lsr #15
 80099b0:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
 80099b4:	ea4f 054c 	mov.w	r5, ip, lsl #1
 80099b8:	e5e4      	b.n	8009584 <_malloc_r+0xa0>
 80099ba:	2501      	movs	r5, #1
 80099bc:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80099c0:	ea4f 09a9 	mov.w	r9, r9, asr #2
 80099c4:	4610      	mov	r0, r2
 80099c6:	fa05 f509 	lsl.w	r5, r5, r9
 80099ca:	ea45 0901 	orr.w	r9, r5, r1
 80099ce:	f8c8 9004 	str.w	r9, [r8, #4]
 80099d2:	e783      	b.n	80098dc <_malloc_r+0x3f8>
 80099d4:	2301      	movs	r3, #1
 80099d6:	4645      	mov	r5, r8
 80099d8:	f8c8 3004 	str.w	r3, [r8, #4]
 80099dc:	2200      	movs	r2, #0
 80099de:	e719      	b.n	8009814 <_malloc_r+0x330>
 80099e0:	f240 5354 	movw	r3, #1364	; 0x554
 80099e4:	459c      	cmp	ip, r3
 80099e6:	d80b      	bhi.n	8009a00 <_malloc_r+0x51c>
 80099e8:	ea4f 4c94 	mov.w	ip, r4, lsr #18
 80099ec:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
 80099f0:	ea4f 054c 	mov.w	r5, ip, lsl #1
 80099f4:	e5c6      	b.n	8009584 <_malloc_r+0xa0>
 80099f6:	68b5      	ldr	r5, [r6, #8]
 80099f8:	686a      	ldr	r2, [r5, #4]
 80099fa:	f022 0203 	bic.w	r2, r2, #3
 80099fe:	e709      	b.n	8009814 <_malloc_r+0x330>
 8009a00:	25fc      	movs	r5, #252	; 0xfc
 8009a02:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 8009a06:	e5bd      	b.n	8009584 <_malloc_r+0xa0>
 8009a08:	0511      	lsls	r1, r2, #20
 8009a0a:	0d09      	lsrs	r1, r1, #20
 8009a0c:	2900      	cmp	r1, #0
 8009a0e:	f47f ae95 	bne.w	800973c <_malloc_r+0x258>
 8009a12:	68b2      	ldr	r2, [r6, #8]
 8009a14:	eb0b 010a 	add.w	r1, fp, sl
 8009a18:	f041 0101 	orr.w	r1, r1, #1
 8009a1c:	6051      	str	r1, [r2, #4]
 8009a1e:	e6e3      	b.n	80097e8 <_malloc_r+0x304>
 8009a20:	2101      	movs	r1, #1
 8009a22:	f04f 0b00 	mov.w	fp, #0
 8009a26:	e6b7      	b.n	8009798 <_malloc_r+0x2b4>
 8009a28:	4638      	mov	r0, r7
 8009a2a:	f105 0108 	add.w	r1, r5, #8
 8009a2e:	9201      	str	r2, [sp, #4]
 8009a30:	f7ff fc30 	bl	8009294 <_free_r>
 8009a34:	9a01      	ldr	r2, [sp, #4]
 8009a36:	6853      	ldr	r3, [r2, #4]
 8009a38:	e6d6      	b.n	80097e8 <_malloc_r+0x304>
 8009a3a:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8009a3e:	d806      	bhi.n	8009a4e <_malloc_r+0x56a>
 8009a40:	ea4f 39d0 	mov.w	r9, r0, lsr #15
 8009a44:	f109 0977 	add.w	r9, r9, #119	; 0x77
 8009a48:	ea4f 0549 	mov.w	r5, r9, lsl #1
 8009a4c:	e732      	b.n	80098b4 <_malloc_r+0x3d0>
 8009a4e:	f240 5154 	movw	r1, #1364	; 0x554
 8009a52:	25fc      	movs	r5, #252	; 0xfc
 8009a54:	428a      	cmp	r2, r1
 8009a56:	f04f 097e 	mov.w	r9, #126	; 0x7e
 8009a5a:	bf9e      	ittt	ls
 8009a5c:	ea4f 4990 	movls.w	r9, r0, lsr #18
 8009a60:	f109 097c 	addls.w	r9, r9, #124	; 0x7c
 8009a64:	ea4f 0549 	movls.w	r5, r9, lsl #1
 8009a68:	e724      	b.n	80098b4 <_malloc_r+0x3d0>
 8009a6a:	6872      	ldr	r2, [r6, #4]
 8009a6c:	ea22 0203 	bic.w	r2, r2, r3
 8009a70:	6072      	str	r2, [r6, #4]
 8009a72:	e760      	b.n	8009936 <_malloc_r+0x452>
 8009a74:	005b      	lsls	r3, r3, #1
 8009a76:	f108 0804 	add.w	r8, r8, #4
 8009a7a:	e763      	b.n	8009944 <_malloc_r+0x460>

08009a7c <memchr>:
 8009a7c:	0783      	lsls	r3, r0, #30
 8009a7e:	b2c9      	uxtb	r1, r1
 8009a80:	b470      	push	{r4, r5, r6}
 8009a82:	d040      	beq.n	8009b06 <memchr+0x8a>
 8009a84:	1e54      	subs	r4, r2, #1
 8009a86:	2a00      	cmp	r2, #0
 8009a88:	d03f      	beq.n	8009b0a <memchr+0x8e>
 8009a8a:	7803      	ldrb	r3, [r0, #0]
 8009a8c:	428b      	cmp	r3, r1
 8009a8e:	d021      	beq.n	8009ad4 <memchr+0x58>
 8009a90:	1c43      	adds	r3, r0, #1
 8009a92:	e004      	b.n	8009a9e <memchr+0x22>
 8009a94:	b304      	cbz	r4, 8009ad8 <memchr+0x5c>
 8009a96:	7802      	ldrb	r2, [r0, #0]
 8009a98:	3c01      	subs	r4, #1
 8009a9a:	428a      	cmp	r2, r1
 8009a9c:	d01a      	beq.n	8009ad4 <memchr+0x58>
 8009a9e:	f013 0f03 	tst.w	r3, #3
 8009aa2:	4618      	mov	r0, r3
 8009aa4:	f103 0301 	add.w	r3, r3, #1
 8009aa8:	d1f4      	bne.n	8009a94 <memchr+0x18>
 8009aaa:	2c03      	cmp	r4, #3
 8009aac:	d816      	bhi.n	8009adc <memchr+0x60>
 8009aae:	1e65      	subs	r5, r4, #1
 8009ab0:	b194      	cbz	r4, 8009ad8 <memchr+0x5c>
 8009ab2:	7803      	ldrb	r3, [r0, #0]
 8009ab4:	428b      	cmp	r3, r1
 8009ab6:	d00d      	beq.n	8009ad4 <memchr+0x58>
 8009ab8:	1c42      	adds	r2, r0, #1
 8009aba:	2300      	movs	r3, #0
 8009abc:	e002      	b.n	8009ac4 <memchr+0x48>
 8009abe:	7804      	ldrb	r4, [r0, #0]
 8009ac0:	428c      	cmp	r4, r1
 8009ac2:	d007      	beq.n	8009ad4 <memchr+0x58>
 8009ac4:	429d      	cmp	r5, r3
 8009ac6:	4610      	mov	r0, r2
 8009ac8:	f103 0301 	add.w	r3, r3, #1
 8009acc:	f102 0201 	add.w	r2, r2, #1
 8009ad0:	d1f5      	bne.n	8009abe <memchr+0x42>
 8009ad2:	2000      	movs	r0, #0
 8009ad4:	bc70      	pop	{r4, r5, r6}
 8009ad6:	4770      	bx	lr
 8009ad8:	4620      	mov	r0, r4
 8009ada:	e7fb      	b.n	8009ad4 <memchr+0x58>
 8009adc:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8009ae0:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8009ae4:	4602      	mov	r2, r0
 8009ae6:	3004      	adds	r0, #4
 8009ae8:	6813      	ldr	r3, [r2, #0]
 8009aea:	4073      	eors	r3, r6
 8009aec:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 8009af0:	ea25 0303 	bic.w	r3, r5, r3
 8009af4:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8009af8:	d103      	bne.n	8009b02 <memchr+0x86>
 8009afa:	3c04      	subs	r4, #4
 8009afc:	2c03      	cmp	r4, #3
 8009afe:	d8f1      	bhi.n	8009ae4 <memchr+0x68>
 8009b00:	e7d5      	b.n	8009aae <memchr+0x32>
 8009b02:	4610      	mov	r0, r2
 8009b04:	e7d3      	b.n	8009aae <memchr+0x32>
 8009b06:	4614      	mov	r4, r2
 8009b08:	e7cf      	b.n	8009aaa <memchr+0x2e>
 8009b0a:	4610      	mov	r0, r2
 8009b0c:	e7e2      	b.n	8009ad4 <memchr+0x58>
 8009b0e:	bf00      	nop

08009b10 <memcpy>:
 8009b10:	2a03      	cmp	r2, #3
 8009b12:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8009b16:	d809      	bhi.n	8009b2c <memcpy+0x1c>
 8009b18:	b12a      	cbz	r2, 8009b26 <memcpy+0x16>
 8009b1a:	2300      	movs	r3, #0
 8009b1c:	5ccc      	ldrb	r4, [r1, r3]
 8009b1e:	54c4      	strb	r4, [r0, r3]
 8009b20:	3301      	adds	r3, #1
 8009b22:	4293      	cmp	r3, r2
 8009b24:	d1fa      	bne.n	8009b1c <memcpy+0xc>
 8009b26:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8009b2a:	4770      	bx	lr
 8009b2c:	0783      	lsls	r3, r0, #30
 8009b2e:	4402      	add	r2, r0
 8009b30:	d00e      	beq.n	8009b50 <memcpy+0x40>
 8009b32:	1c44      	adds	r4, r0, #1
 8009b34:	1c4d      	adds	r5, r1, #1
 8009b36:	f815 7c01 	ldrb.w	r7, [r5, #-1]
 8009b3a:	f004 0603 	and.w	r6, r4, #3
 8009b3e:	4623      	mov	r3, r4
 8009b40:	3401      	adds	r4, #1
 8009b42:	4629      	mov	r1, r5
 8009b44:	3501      	adds	r5, #1
 8009b46:	f804 7c02 	strb.w	r7, [r4, #-2]
 8009b4a:	2e00      	cmp	r6, #0
 8009b4c:	d1f3      	bne.n	8009b36 <memcpy+0x26>
 8009b4e:	e000      	b.n	8009b52 <memcpy+0x42>
 8009b50:	4603      	mov	r3, r0
 8009b52:	f011 0403 	ands.w	r4, r1, #3
 8009b56:	d06d      	beq.n	8009c34 <memcpy+0x124>
 8009b58:	1ad7      	subs	r7, r2, r3
 8009b5a:	1b0d      	subs	r5, r1, r4
 8009b5c:	2f03      	cmp	r7, #3
 8009b5e:	682e      	ldr	r6, [r5, #0]
 8009b60:	dd19      	ble.n	8009b96 <memcpy+0x86>
 8009b62:	f1c4 0c04 	rsb	ip, r4, #4
 8009b66:	ea4f 08c4 	mov.w	r8, r4, lsl #3
 8009b6a:	1d1c      	adds	r4, r3, #4
 8009b6c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8009b70:	f855 7f04 	ldr.w	r7, [r5, #4]!
 8009b74:	ebc4 0902 	rsb	r9, r4, r2
 8009b78:	4623      	mov	r3, r4
 8009b7a:	3104      	adds	r1, #4
 8009b7c:	3404      	adds	r4, #4
 8009b7e:	f1b9 0f03 	cmp.w	r9, #3
 8009b82:	fa26 fa08 	lsr.w	sl, r6, r8
 8009b86:	fa07 fb0c 	lsl.w	fp, r7, ip
 8009b8a:	463e      	mov	r6, r7
 8009b8c:	ea4b 070a 	orr.w	r7, fp, sl
 8009b90:	f844 7c08 	str.w	r7, [r4, #-8]
 8009b94:	dcec      	bgt.n	8009b70 <memcpy+0x60>
 8009b96:	429a      	cmp	r2, r3
 8009b98:	d9c5      	bls.n	8009b26 <memcpy+0x16>
 8009b9a:	3301      	adds	r3, #1
 8009b9c:	3101      	adds	r1, #1
 8009b9e:	3201      	adds	r2, #1
 8009ba0:	f811 4c01 	ldrb.w	r4, [r1, #-1]
 8009ba4:	3301      	adds	r3, #1
 8009ba6:	3101      	adds	r1, #1
 8009ba8:	4293      	cmp	r3, r2
 8009baa:	f803 4c02 	strb.w	r4, [r3, #-2]
 8009bae:	d1f7      	bne.n	8009ba0 <memcpy+0x90>
 8009bb0:	e7b9      	b.n	8009b26 <memcpy+0x16>
 8009bb2:	680c      	ldr	r4, [r1, #0]
 8009bb4:	3340      	adds	r3, #64	; 0x40
 8009bb6:	3140      	adds	r1, #64	; 0x40
 8009bb8:	f843 4c40 	str.w	r4, [r3, #-64]
 8009bbc:	f851 4c3c 	ldr.w	r4, [r1, #-60]
 8009bc0:	f843 4c3c 	str.w	r4, [r3, #-60]
 8009bc4:	f851 4c38 	ldr.w	r4, [r1, #-56]
 8009bc8:	f843 4c38 	str.w	r4, [r3, #-56]
 8009bcc:	f851 4c34 	ldr.w	r4, [r1, #-52]
 8009bd0:	f843 4c34 	str.w	r4, [r3, #-52]
 8009bd4:	f851 4c30 	ldr.w	r4, [r1, #-48]
 8009bd8:	f843 4c30 	str.w	r4, [r3, #-48]
 8009bdc:	f851 4c2c 	ldr.w	r4, [r1, #-44]
 8009be0:	f843 4c2c 	str.w	r4, [r3, #-44]
 8009be4:	f851 4c28 	ldr.w	r4, [r1, #-40]
 8009be8:	f843 4c28 	str.w	r4, [r3, #-40]
 8009bec:	f851 4c24 	ldr.w	r4, [r1, #-36]
 8009bf0:	f843 4c24 	str.w	r4, [r3, #-36]
 8009bf4:	f851 4c20 	ldr.w	r4, [r1, #-32]
 8009bf8:	f843 4c20 	str.w	r4, [r3, #-32]
 8009bfc:	f851 4c1c 	ldr.w	r4, [r1, #-28]
 8009c00:	f843 4c1c 	str.w	r4, [r3, #-28]
 8009c04:	f851 4c18 	ldr.w	r4, [r1, #-24]
 8009c08:	f843 4c18 	str.w	r4, [r3, #-24]
 8009c0c:	f851 4c14 	ldr.w	r4, [r1, #-20]
 8009c10:	f843 4c14 	str.w	r4, [r3, #-20]
 8009c14:	f851 4c10 	ldr.w	r4, [r1, #-16]
 8009c18:	f843 4c10 	str.w	r4, [r3, #-16]
 8009c1c:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 8009c20:	f843 4c0c 	str.w	r4, [r3, #-12]
 8009c24:	f851 4c08 	ldr.w	r4, [r1, #-8]
 8009c28:	f843 4c08 	str.w	r4, [r3, #-8]
 8009c2c:	f851 4c04 	ldr.w	r4, [r1, #-4]
 8009c30:	f843 4c04 	str.w	r4, [r3, #-4]
 8009c34:	1ad4      	subs	r4, r2, r3
 8009c36:	2c3f      	cmp	r4, #63	; 0x3f
 8009c38:	dcbb      	bgt.n	8009bb2 <memcpy+0xa2>
 8009c3a:	e011      	b.n	8009c60 <memcpy+0x150>
 8009c3c:	680c      	ldr	r4, [r1, #0]
 8009c3e:	3310      	adds	r3, #16
 8009c40:	3110      	adds	r1, #16
 8009c42:	f843 4c10 	str.w	r4, [r3, #-16]
 8009c46:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 8009c4a:	f843 4c0c 	str.w	r4, [r3, #-12]
 8009c4e:	f851 4c08 	ldr.w	r4, [r1, #-8]
 8009c52:	f843 4c08 	str.w	r4, [r3, #-8]
 8009c56:	f851 4c04 	ldr.w	r4, [r1, #-4]
 8009c5a:	f843 4c04 	str.w	r4, [r3, #-4]
 8009c5e:	1ad4      	subs	r4, r2, r3
 8009c60:	2c0f      	cmp	r4, #15
 8009c62:	dceb      	bgt.n	8009c3c <memcpy+0x12c>
 8009c64:	2c03      	cmp	r4, #3
 8009c66:	dd96      	ble.n	8009b96 <memcpy+0x86>
 8009c68:	1d1c      	adds	r4, r3, #4
 8009c6a:	1d0d      	adds	r5, r1, #4
 8009c6c:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8009c70:	1b16      	subs	r6, r2, r4
 8009c72:	4623      	mov	r3, r4
 8009c74:	4629      	mov	r1, r5
 8009c76:	3404      	adds	r4, #4
 8009c78:	3504      	adds	r5, #4
 8009c7a:	2e03      	cmp	r6, #3
 8009c7c:	f844 7c08 	str.w	r7, [r4, #-8]
 8009c80:	dcf4      	bgt.n	8009c6c <memcpy+0x15c>
 8009c82:	e788      	b.n	8009b96 <memcpy+0x86>

08009c84 <__malloc_lock>:
 8009c84:	4770      	bx	lr
 8009c86:	bf00      	nop

08009c88 <__malloc_unlock>:
 8009c88:	4770      	bx	lr
 8009c8a:	bf00      	nop

08009c8c <_Balloc>:
 8009c8c:	b570      	push	{r4, r5, r6, lr}
 8009c8e:	4606      	mov	r6, r0
 8009c90:	6a44      	ldr	r4, [r0, #36]	; 0x24
 8009c92:	460d      	mov	r5, r1
 8009c94:	b15c      	cbz	r4, 8009cae <_Balloc+0x22>
 8009c96:	68e2      	ldr	r2, [r4, #12]
 8009c98:	b19a      	cbz	r2, 8009cc2 <_Balloc+0x36>
 8009c9a:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8009c9e:	b1e0      	cbz	r0, 8009cda <_Balloc+0x4e>
 8009ca0:	6801      	ldr	r1, [r0, #0]
 8009ca2:	f842 1025 	str.w	r1, [r2, r5, lsl #2]
 8009ca6:	2200      	movs	r2, #0
 8009ca8:	6102      	str	r2, [r0, #16]
 8009caa:	60c2      	str	r2, [r0, #12]
 8009cac:	bd70      	pop	{r4, r5, r6, pc}
 8009cae:	2010      	movs	r0, #16
 8009cb0:	f7ff fc08 	bl	80094c4 <malloc>
 8009cb4:	2300      	movs	r3, #0
 8009cb6:	4604      	mov	r4, r0
 8009cb8:	6270      	str	r0, [r6, #36]	; 0x24
 8009cba:	6043      	str	r3, [r0, #4]
 8009cbc:	6083      	str	r3, [r0, #8]
 8009cbe:	6003      	str	r3, [r0, #0]
 8009cc0:	60c3      	str	r3, [r0, #12]
 8009cc2:	2221      	movs	r2, #33	; 0x21
 8009cc4:	4630      	mov	r0, r6
 8009cc6:	2104      	movs	r1, #4
 8009cc8:	f001 fba0 	bl	800b40c <_calloc_r>
 8009ccc:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8009cce:	60e0      	str	r0, [r4, #12]
 8009cd0:	68da      	ldr	r2, [r3, #12]
 8009cd2:	2a00      	cmp	r2, #0
 8009cd4:	d1e1      	bne.n	8009c9a <_Balloc+0xe>
 8009cd6:	2000      	movs	r0, #0
 8009cd8:	bd70      	pop	{r4, r5, r6, pc}
 8009cda:	2301      	movs	r3, #1
 8009cdc:	4630      	mov	r0, r6
 8009cde:	4619      	mov	r1, r3
 8009ce0:	fa03 f405 	lsl.w	r4, r3, r5
 8009ce4:	1d62      	adds	r2, r4, #5
 8009ce6:	0092      	lsls	r2, r2, #2
 8009ce8:	f001 fb90 	bl	800b40c <_calloc_r>
 8009cec:	2800      	cmp	r0, #0
 8009cee:	d0f2      	beq.n	8009cd6 <_Balloc+0x4a>
 8009cf0:	6045      	str	r5, [r0, #4]
 8009cf2:	6084      	str	r4, [r0, #8]
 8009cf4:	e7d7      	b.n	8009ca6 <_Balloc+0x1a>
 8009cf6:	bf00      	nop

08009cf8 <_Bfree>:
 8009cf8:	b530      	push	{r4, r5, lr}
 8009cfa:	4604      	mov	r4, r0
 8009cfc:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8009cfe:	b083      	sub	sp, #12
 8009d00:	b155      	cbz	r5, 8009d18 <_Bfree+0x20>
 8009d02:	b139      	cbz	r1, 8009d14 <_Bfree+0x1c>
 8009d04:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009d06:	684a      	ldr	r2, [r1, #4]
 8009d08:	68db      	ldr	r3, [r3, #12]
 8009d0a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8009d0e:	6008      	str	r0, [r1, #0]
 8009d10:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8009d14:	b003      	add	sp, #12
 8009d16:	bd30      	pop	{r4, r5, pc}
 8009d18:	2010      	movs	r0, #16
 8009d1a:	9101      	str	r1, [sp, #4]
 8009d1c:	f7ff fbd2 	bl	80094c4 <malloc>
 8009d20:	9901      	ldr	r1, [sp, #4]
 8009d22:	6260      	str	r0, [r4, #36]	; 0x24
 8009d24:	6045      	str	r5, [r0, #4]
 8009d26:	6085      	str	r5, [r0, #8]
 8009d28:	6005      	str	r5, [r0, #0]
 8009d2a:	60c5      	str	r5, [r0, #12]
 8009d2c:	e7e9      	b.n	8009d02 <_Bfree+0xa>
 8009d2e:	bf00      	nop

08009d30 <__multadd>:
 8009d30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009d34:	4688      	mov	r8, r1
 8009d36:	f8d1 a010 	ldr.w	sl, [r1, #16]
 8009d3a:	b082      	sub	sp, #8
 8009d3c:	4681      	mov	r9, r0
 8009d3e:	f101 0514 	add.w	r5, r1, #20
 8009d42:	2400      	movs	r4, #0
 8009d44:	682f      	ldr	r7, [r5, #0]
 8009d46:	3401      	adds	r4, #1
 8009d48:	b2be      	uxth	r6, r7
 8009d4a:	0c3f      	lsrs	r7, r7, #16
 8009d4c:	fb02 3606 	mla	r6, r2, r6, r3
 8009d50:	fb02 f307 	mul.w	r3, r2, r7
 8009d54:	eb03 4316 	add.w	r3, r3, r6, lsr #16
 8009d58:	b2b6      	uxth	r6, r6
 8009d5a:	eb06 4603 	add.w	r6, r6, r3, lsl #16
 8009d5e:	0c1b      	lsrs	r3, r3, #16
 8009d60:	45a2      	cmp	sl, r4
 8009d62:	f845 6b04 	str.w	r6, [r5], #4
 8009d66:	dced      	bgt.n	8009d44 <__multadd+0x14>
 8009d68:	b153      	cbz	r3, 8009d80 <__multadd+0x50>
 8009d6a:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8009d6e:	4592      	cmp	sl, r2
 8009d70:	da0a      	bge.n	8009d88 <__multadd+0x58>
 8009d72:	eb08 028a 	add.w	r2, r8, sl, lsl #2
 8009d76:	f10a 0101 	add.w	r1, sl, #1
 8009d7a:	f8c8 1010 	str.w	r1, [r8, #16]
 8009d7e:	6153      	str	r3, [r2, #20]
 8009d80:	4640      	mov	r0, r8
 8009d82:	b002      	add	sp, #8
 8009d84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009d88:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8009d8c:	4648      	mov	r0, r9
 8009d8e:	9301      	str	r3, [sp, #4]
 8009d90:	3101      	adds	r1, #1
 8009d92:	f7ff ff7b 	bl	8009c8c <_Balloc>
 8009d96:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8009d9a:	f108 010c 	add.w	r1, r8, #12
 8009d9e:	3202      	adds	r2, #2
 8009da0:	0092      	lsls	r2, r2, #2
 8009da2:	4604      	mov	r4, r0
 8009da4:	300c      	adds	r0, #12
 8009da6:	f7ff feb3 	bl	8009b10 <memcpy>
 8009daa:	4641      	mov	r1, r8
 8009dac:	4648      	mov	r0, r9
 8009dae:	46a0      	mov	r8, r4
 8009db0:	f7ff ffa2 	bl	8009cf8 <_Bfree>
 8009db4:	9b01      	ldr	r3, [sp, #4]
 8009db6:	e7dc      	b.n	8009d72 <__multadd+0x42>

08009db8 <__s2b>:
 8009db8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009dbc:	f648 6539 	movw	r5, #36409	; 0x8e39
 8009dc0:	461f      	mov	r7, r3
 8009dc2:	f6c3 05e3 	movt	r5, #14563	; 0x38e3
 8009dc6:	3308      	adds	r3, #8
 8009dc8:	4606      	mov	r6, r0
 8009dca:	460c      	mov	r4, r1
 8009dcc:	4690      	mov	r8, r2
 8009dce:	fb85 1003 	smull	r1, r0, r5, r3
 8009dd2:	17db      	asrs	r3, r3, #31
 8009dd4:	ebc3 0060 	rsb	r0, r3, r0, asr #1
 8009dd8:	2801      	cmp	r0, #1
 8009dda:	dd37      	ble.n	8009e4c <__s2b+0x94>
 8009ddc:	2501      	movs	r5, #1
 8009dde:	2100      	movs	r1, #0
 8009de0:	006d      	lsls	r5, r5, #1
 8009de2:	3101      	adds	r1, #1
 8009de4:	42a8      	cmp	r0, r5
 8009de6:	dcfb      	bgt.n	8009de0 <__s2b+0x28>
 8009de8:	4630      	mov	r0, r6
 8009dea:	f7ff ff4f 	bl	8009c8c <_Balloc>
 8009dee:	9b08      	ldr	r3, [sp, #32]
 8009df0:	6143      	str	r3, [r0, #20]
 8009df2:	2301      	movs	r3, #1
 8009df4:	f1b8 0f09 	cmp.w	r8, #9
 8009df8:	4601      	mov	r1, r0
 8009dfa:	6103      	str	r3, [r0, #16]
 8009dfc:	dd22      	ble.n	8009e44 <__s2b+0x8c>
 8009dfe:	f104 0909 	add.w	r9, r4, #9
 8009e02:	4444      	add	r4, r8
 8009e04:	464d      	mov	r5, r9
 8009e06:	f815 3b01 	ldrb.w	r3, [r5], #1
 8009e0a:	220a      	movs	r2, #10
 8009e0c:	4630      	mov	r0, r6
 8009e0e:	3b30      	subs	r3, #48	; 0x30
 8009e10:	f7ff ff8e 	bl	8009d30 <__multadd>
 8009e14:	42a5      	cmp	r5, r4
 8009e16:	4601      	mov	r1, r0
 8009e18:	d1f5      	bne.n	8009e06 <__s2b+0x4e>
 8009e1a:	eb09 0408 	add.w	r4, r9, r8
 8009e1e:	3c08      	subs	r4, #8
 8009e20:	4547      	cmp	r7, r8
 8009e22:	dd0c      	ble.n	8009e3e <__s2b+0x86>
 8009e24:	ebc8 0707 	rsb	r7, r8, r7
 8009e28:	19e7      	adds	r7, r4, r7
 8009e2a:	f814 3b01 	ldrb.w	r3, [r4], #1
 8009e2e:	220a      	movs	r2, #10
 8009e30:	4630      	mov	r0, r6
 8009e32:	3b30      	subs	r3, #48	; 0x30
 8009e34:	f7ff ff7c 	bl	8009d30 <__multadd>
 8009e38:	42bc      	cmp	r4, r7
 8009e3a:	4601      	mov	r1, r0
 8009e3c:	d1f5      	bne.n	8009e2a <__s2b+0x72>
 8009e3e:	4608      	mov	r0, r1
 8009e40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009e44:	340a      	adds	r4, #10
 8009e46:	f04f 0809 	mov.w	r8, #9
 8009e4a:	e7e9      	b.n	8009e20 <__s2b+0x68>
 8009e4c:	2100      	movs	r1, #0
 8009e4e:	e7cb      	b.n	8009de8 <__s2b+0x30>

08009e50 <__hi0bits>:
 8009e50:	4603      	mov	r3, r0
 8009e52:	2000      	movs	r0, #0
 8009e54:	0c1a      	lsrs	r2, r3, #16
 8009e56:	d101      	bne.n	8009e5c <__hi0bits+0xc>
 8009e58:	041b      	lsls	r3, r3, #16
 8009e5a:	2010      	movs	r0, #16
 8009e5c:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 8009e60:	d101      	bne.n	8009e66 <__hi0bits+0x16>
 8009e62:	3008      	adds	r0, #8
 8009e64:	021b      	lsls	r3, r3, #8
 8009e66:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 8009e6a:	d101      	bne.n	8009e70 <__hi0bits+0x20>
 8009e6c:	3004      	adds	r0, #4
 8009e6e:	011b      	lsls	r3, r3, #4
 8009e70:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 8009e74:	d101      	bne.n	8009e7a <__hi0bits+0x2a>
 8009e76:	3002      	adds	r0, #2
 8009e78:	009b      	lsls	r3, r3, #2
 8009e7a:	2b00      	cmp	r3, #0
 8009e7c:	db02      	blt.n	8009e84 <__hi0bits+0x34>
 8009e7e:	005b      	lsls	r3, r3, #1
 8009e80:	d401      	bmi.n	8009e86 <__hi0bits+0x36>
 8009e82:	2020      	movs	r0, #32
 8009e84:	4770      	bx	lr
 8009e86:	3001      	adds	r0, #1
 8009e88:	4770      	bx	lr
 8009e8a:	bf00      	nop

08009e8c <__lo0bits>:
 8009e8c:	6803      	ldr	r3, [r0, #0]
 8009e8e:	4602      	mov	r2, r0
 8009e90:	f013 0007 	ands.w	r0, r3, #7
 8009e94:	d007      	beq.n	8009ea6 <__lo0bits+0x1a>
 8009e96:	07d9      	lsls	r1, r3, #31
 8009e98:	d41f      	bmi.n	8009eda <__lo0bits+0x4e>
 8009e9a:	0798      	lsls	r0, r3, #30
 8009e9c:	d41f      	bmi.n	8009ede <__lo0bits+0x52>
 8009e9e:	089b      	lsrs	r3, r3, #2
 8009ea0:	2002      	movs	r0, #2
 8009ea2:	6013      	str	r3, [r2, #0]
 8009ea4:	4770      	bx	lr
 8009ea6:	b299      	uxth	r1, r3
 8009ea8:	b909      	cbnz	r1, 8009eae <__lo0bits+0x22>
 8009eaa:	0c1b      	lsrs	r3, r3, #16
 8009eac:	2010      	movs	r0, #16
 8009eae:	f013 0fff 	tst.w	r3, #255	; 0xff
 8009eb2:	d101      	bne.n	8009eb8 <__lo0bits+0x2c>
 8009eb4:	3008      	adds	r0, #8
 8009eb6:	0a1b      	lsrs	r3, r3, #8
 8009eb8:	0719      	lsls	r1, r3, #28
 8009eba:	d101      	bne.n	8009ec0 <__lo0bits+0x34>
 8009ebc:	3004      	adds	r0, #4
 8009ebe:	091b      	lsrs	r3, r3, #4
 8009ec0:	0799      	lsls	r1, r3, #30
 8009ec2:	d101      	bne.n	8009ec8 <__lo0bits+0x3c>
 8009ec4:	3002      	adds	r0, #2
 8009ec6:	089b      	lsrs	r3, r3, #2
 8009ec8:	07d9      	lsls	r1, r3, #31
 8009eca:	d404      	bmi.n	8009ed6 <__lo0bits+0x4a>
 8009ecc:	085b      	lsrs	r3, r3, #1
 8009ece:	d101      	bne.n	8009ed4 <__lo0bits+0x48>
 8009ed0:	2020      	movs	r0, #32
 8009ed2:	4770      	bx	lr
 8009ed4:	3001      	adds	r0, #1
 8009ed6:	6013      	str	r3, [r2, #0]
 8009ed8:	4770      	bx	lr
 8009eda:	2000      	movs	r0, #0
 8009edc:	4770      	bx	lr
 8009ede:	085b      	lsrs	r3, r3, #1
 8009ee0:	2001      	movs	r0, #1
 8009ee2:	6013      	str	r3, [r2, #0]
 8009ee4:	4770      	bx	lr
 8009ee6:	bf00      	nop

08009ee8 <__i2b>:
 8009ee8:	b510      	push	{r4, lr}
 8009eea:	460c      	mov	r4, r1
 8009eec:	2101      	movs	r1, #1
 8009eee:	f7ff fecd 	bl	8009c8c <_Balloc>
 8009ef2:	2201      	movs	r2, #1
 8009ef4:	6144      	str	r4, [r0, #20]
 8009ef6:	6102      	str	r2, [r0, #16]
 8009ef8:	bd10      	pop	{r4, pc}
 8009efa:	bf00      	nop

08009efc <__multiply>:
 8009efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009f00:	460c      	mov	r4, r1
 8009f02:	690e      	ldr	r6, [r1, #16]
 8009f04:	b085      	sub	sp, #20
 8009f06:	6915      	ldr	r5, [r2, #16]
 8009f08:	4617      	mov	r7, r2
 8009f0a:	42ae      	cmp	r6, r5
 8009f0c:	da04      	bge.n	8009f18 <__multiply+0x1c>
 8009f0e:	4632      	mov	r2, r6
 8009f10:	463c      	mov	r4, r7
 8009f12:	462e      	mov	r6, r5
 8009f14:	460f      	mov	r7, r1
 8009f16:	4615      	mov	r5, r2
 8009f18:	68a3      	ldr	r3, [r4, #8]
 8009f1a:	eb06 0805 	add.w	r8, r6, r5
 8009f1e:	6861      	ldr	r1, [r4, #4]
 8009f20:	4598      	cmp	r8, r3
 8009f22:	bfc8      	it	gt
 8009f24:	3101      	addgt	r1, #1
 8009f26:	f7ff feb1 	bl	8009c8c <_Balloc>
 8009f2a:	eb00 0988 	add.w	r9, r0, r8, lsl #2
 8009f2e:	f100 0314 	add.w	r3, r0, #20
 8009f32:	f109 0914 	add.w	r9, r9, #20
 8009f36:	9001      	str	r0, [sp, #4]
 8009f38:	2000      	movs	r0, #0
 8009f3a:	454b      	cmp	r3, r9
 8009f3c:	d203      	bcs.n	8009f46 <__multiply+0x4a>
 8009f3e:	f843 0b04 	str.w	r0, [r3], #4
 8009f42:	4599      	cmp	r9, r3
 8009f44:	d8fb      	bhi.n	8009f3e <__multiply+0x42>
 8009f46:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8009f4a:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8009f4e:	3714      	adds	r7, #20
 8009f50:	3514      	adds	r5, #20
 8009f52:	3414      	adds	r4, #20
 8009f54:	3614      	adds	r6, #20
 8009f56:	42af      	cmp	r7, r5
 8009f58:	d257      	bcs.n	800a00a <__multiply+0x10e>
 8009f5a:	9a01      	ldr	r2, [sp, #4]
 8009f5c:	f8cd 9008 	str.w	r9, [sp, #8]
 8009f60:	46a9      	mov	r9, r5
 8009f62:	f8cd 800c 	str.w	r8, [sp, #12]
 8009f66:	f102 0c18 	add.w	ip, r2, #24
 8009f6a:	46a0      	mov	r8, r4
 8009f6c:	f857 4b04 	ldr.w	r4, [r7], #4
 8009f70:	b2a0      	uxth	r0, r4
 8009f72:	b1f0      	cbz	r0, 8009fb2 <__multiply+0xb6>
 8009f74:	4642      	mov	r2, r8
 8009f76:	f1ac 0304 	sub.w	r3, ip, #4
 8009f7a:	2400      	movs	r4, #0
 8009f7c:	f852 1b04 	ldr.w	r1, [r2], #4
 8009f80:	681d      	ldr	r5, [r3, #0]
 8009f82:	fa1f fa81 	uxth.w	sl, r1
 8009f86:	0c09      	lsrs	r1, r1, #16
 8009f88:	fa1f fb85 	uxth.w	fp, r5
 8009f8c:	0c2d      	lsrs	r5, r5, #16
 8009f8e:	fb00 ba0a 	mla	sl, r0, sl, fp
 8009f92:	fb00 5101 	mla	r1, r0, r1, r5
 8009f96:	4454      	add	r4, sl
 8009f98:	eb01 4114 	add.w	r1, r1, r4, lsr #16
 8009f9c:	b2a4      	uxth	r4, r4
 8009f9e:	ea44 4501 	orr.w	r5, r4, r1, lsl #16
 8009fa2:	0c0c      	lsrs	r4, r1, #16
 8009fa4:	4296      	cmp	r6, r2
 8009fa6:	f843 5b04 	str.w	r5, [r3], #4
 8009faa:	d8e7      	bhi.n	8009f7c <__multiply+0x80>
 8009fac:	601c      	str	r4, [r3, #0]
 8009fae:	f857 4c04 	ldr.w	r4, [r7, #-4]
 8009fb2:	0c24      	lsrs	r4, r4, #16
 8009fb4:	d021      	beq.n	8009ffa <__multiply+0xfe>
 8009fb6:	f85c 1c04 	ldr.w	r1, [ip, #-4]
 8009fba:	4642      	mov	r2, r8
 8009fbc:	4663      	mov	r3, ip
 8009fbe:	2500      	movs	r5, #0
 8009fc0:	4608      	mov	r0, r1
 8009fc2:	f8b2 a000 	ldrh.w	sl, [r2]
 8009fc6:	0c00      	lsrs	r0, r0, #16
 8009fc8:	b289      	uxth	r1, r1
 8009fca:	469b      	mov	fp, r3
 8009fcc:	fb04 000a 	mla	r0, r4, sl, r0
 8009fd0:	1945      	adds	r5, r0, r5
 8009fd2:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8009fd6:	f843 1c04 	str.w	r1, [r3, #-4]
 8009fda:	f853 0b04 	ldr.w	r0, [r3], #4
 8009fde:	f852 1b04 	ldr.w	r1, [r2], #4
 8009fe2:	fa1f fa80 	uxth.w	sl, r0
 8009fe6:	0c09      	lsrs	r1, r1, #16
 8009fe8:	fb04 a101 	mla	r1, r4, r1, sl
 8009fec:	eb01 4115 	add.w	r1, r1, r5, lsr #16
 8009ff0:	0c0d      	lsrs	r5, r1, #16
 8009ff2:	4296      	cmp	r6, r2
 8009ff4:	d8e5      	bhi.n	8009fc2 <__multiply+0xc6>
 8009ff6:	f8cb 1000 	str.w	r1, [fp]
 8009ffa:	45b9      	cmp	r9, r7
 8009ffc:	f10c 0c04 	add.w	ip, ip, #4
 800a000:	d8b4      	bhi.n	8009f6c <__multiply+0x70>
 800a002:	f8dd 9008 	ldr.w	r9, [sp, #8]
 800a006:	f8dd 800c 	ldr.w	r8, [sp, #12]
 800a00a:	f1b8 0f00 	cmp.w	r8, #0
 800a00e:	dd0b      	ble.n	800a028 <__multiply+0x12c>
 800a010:	f859 3c04 	ldr.w	r3, [r9, #-4]
 800a014:	f1a9 0904 	sub.w	r9, r9, #4
 800a018:	b11b      	cbz	r3, 800a022 <__multiply+0x126>
 800a01a:	e005      	b.n	800a028 <__multiply+0x12c>
 800a01c:	f859 3d04 	ldr.w	r3, [r9, #-4]!
 800a020:	b913      	cbnz	r3, 800a028 <__multiply+0x12c>
 800a022:	f1b8 0801 	subs.w	r8, r8, #1
 800a026:	d1f9      	bne.n	800a01c <__multiply+0x120>
 800a028:	9b01      	ldr	r3, [sp, #4]
 800a02a:	4618      	mov	r0, r3
 800a02c:	f8c3 8010 	str.w	r8, [r3, #16]
 800a030:	b005      	add	sp, #20
 800a032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a036:	bf00      	nop

0800a038 <__pow5mult>:
 800a038:	f012 0303 	ands.w	r3, r2, #3
 800a03c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a040:	4614      	mov	r4, r2
 800a042:	4680      	mov	r8, r0
 800a044:	460f      	mov	r7, r1
 800a046:	d128      	bne.n	800a09a <__pow5mult+0x62>
 800a048:	10a4      	asrs	r4, r4, #2
 800a04a:	d01a      	beq.n	800a082 <__pow5mult+0x4a>
 800a04c:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 800a050:	2d00      	cmp	r5, #0
 800a052:	d02e      	beq.n	800a0b2 <__pow5mult+0x7a>
 800a054:	68ae      	ldr	r6, [r5, #8]
 800a056:	b92e      	cbnz	r6, 800a064 <__pow5mult+0x2c>
 800a058:	e036      	b.n	800a0c8 <__pow5mult+0x90>
 800a05a:	1064      	asrs	r4, r4, #1
 800a05c:	d011      	beq.n	800a082 <__pow5mult+0x4a>
 800a05e:	6835      	ldr	r5, [r6, #0]
 800a060:	b195      	cbz	r5, 800a088 <__pow5mult+0x50>
 800a062:	462e      	mov	r6, r5
 800a064:	07e0      	lsls	r0, r4, #31
 800a066:	d5f8      	bpl.n	800a05a <__pow5mult+0x22>
 800a068:	4639      	mov	r1, r7
 800a06a:	4632      	mov	r2, r6
 800a06c:	4640      	mov	r0, r8
 800a06e:	f7ff ff45 	bl	8009efc <__multiply>
 800a072:	4639      	mov	r1, r7
 800a074:	4605      	mov	r5, r0
 800a076:	4640      	mov	r0, r8
 800a078:	f7ff fe3e 	bl	8009cf8 <_Bfree>
 800a07c:	1064      	asrs	r4, r4, #1
 800a07e:	462f      	mov	r7, r5
 800a080:	d1ed      	bne.n	800a05e <__pow5mult+0x26>
 800a082:	4638      	mov	r0, r7
 800a084:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a088:	4631      	mov	r1, r6
 800a08a:	4632      	mov	r2, r6
 800a08c:	4640      	mov	r0, r8
 800a08e:	f7ff ff35 	bl	8009efc <__multiply>
 800a092:	6030      	str	r0, [r6, #0]
 800a094:	4606      	mov	r6, r0
 800a096:	6005      	str	r5, [r0, #0]
 800a098:	e7e4      	b.n	800a064 <__pow5mult+0x2c>
 800a09a:	f64c 62d0 	movw	r2, #52944	; 0xced0
 800a09e:	1e5d      	subs	r5, r3, #1
 800a0a0:	f6c0 0200 	movt	r2, #2048	; 0x800
 800a0a4:	2300      	movs	r3, #0
 800a0a6:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
 800a0aa:	f7ff fe41 	bl	8009d30 <__multadd>
 800a0ae:	4607      	mov	r7, r0
 800a0b0:	e7ca      	b.n	800a048 <__pow5mult+0x10>
 800a0b2:	2010      	movs	r0, #16
 800a0b4:	f7ff fa06 	bl	80094c4 <malloc>
 800a0b8:	2300      	movs	r3, #0
 800a0ba:	4605      	mov	r5, r0
 800a0bc:	f8c8 0024 	str.w	r0, [r8, #36]	; 0x24
 800a0c0:	6043      	str	r3, [r0, #4]
 800a0c2:	6083      	str	r3, [r0, #8]
 800a0c4:	6003      	str	r3, [r0, #0]
 800a0c6:	60c3      	str	r3, [r0, #12]
 800a0c8:	4640      	mov	r0, r8
 800a0ca:	f240 2171 	movw	r1, #625	; 0x271
 800a0ce:	f7ff ff0b 	bl	8009ee8 <__i2b>
 800a0d2:	2300      	movs	r3, #0
 800a0d4:	60a8      	str	r0, [r5, #8]
 800a0d6:	4606      	mov	r6, r0
 800a0d8:	6003      	str	r3, [r0, #0]
 800a0da:	e7c3      	b.n	800a064 <__pow5mult+0x2c>

0800a0dc <__lshift>:
 800a0dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a0e0:	4693      	mov	fp, r2
 800a0e2:	690a      	ldr	r2, [r1, #16]
 800a0e4:	460f      	mov	r7, r1
 800a0e6:	ea4f 156b 	mov.w	r5, fp, asr #5
 800a0ea:	688b      	ldr	r3, [r1, #8]
 800a0ec:	eb05 0a02 	add.w	sl, r5, r2
 800a0f0:	4681      	mov	r9, r0
 800a0f2:	f10a 0601 	add.w	r6, sl, #1
 800a0f6:	6849      	ldr	r1, [r1, #4]
 800a0f8:	429e      	cmp	r6, r3
 800a0fa:	dd03      	ble.n	800a104 <__lshift+0x28>
 800a0fc:	005b      	lsls	r3, r3, #1
 800a0fe:	3101      	adds	r1, #1
 800a100:	429e      	cmp	r6, r3
 800a102:	dcfb      	bgt.n	800a0fc <__lshift+0x20>
 800a104:	4648      	mov	r0, r9
 800a106:	f7ff fdc1 	bl	8009c8c <_Balloc>
 800a10a:	2d00      	cmp	r5, #0
 800a10c:	4680      	mov	r8, r0
 800a10e:	f100 0414 	add.w	r4, r0, #20
 800a112:	dd0a      	ble.n	800a12a <__lshift+0x4e>
 800a114:	2300      	movs	r3, #0
 800a116:	461a      	mov	r2, r3
 800a118:	3301      	adds	r3, #1
 800a11a:	f844 2b04 	str.w	r2, [r4], #4
 800a11e:	42ab      	cmp	r3, r5
 800a120:	d1fa      	bne.n	800a118 <__lshift+0x3c>
 800a122:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800a126:	f103 0414 	add.w	r4, r3, #20
 800a12a:	6938      	ldr	r0, [r7, #16]
 800a12c:	f107 0514 	add.w	r5, r7, #20
 800a130:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a134:	3014      	adds	r0, #20
 800a136:	f01b 0b1f 	ands.w	fp, fp, #31
 800a13a:	d01c      	beq.n	800a176 <__lshift+0x9a>
 800a13c:	f1cb 0320 	rsb	r3, fp, #32
 800a140:	2200      	movs	r2, #0
 800a142:	6829      	ldr	r1, [r5, #0]
 800a144:	fa01 f10b 	lsl.w	r1, r1, fp
 800a148:	430a      	orrs	r2, r1
 800a14a:	f844 2b04 	str.w	r2, [r4], #4
 800a14e:	f855 2b04 	ldr.w	r2, [r5], #4
 800a152:	42a8      	cmp	r0, r5
 800a154:	fa22 f203 	lsr.w	r2, r2, r3
 800a158:	d8f3      	bhi.n	800a142 <__lshift+0x66>
 800a15a:	6022      	str	r2, [r4, #0]
 800a15c:	b10a      	cbz	r2, 800a162 <__lshift+0x86>
 800a15e:	f10a 0602 	add.w	r6, sl, #2
 800a162:	4648      	mov	r0, r9
 800a164:	3e01      	subs	r6, #1
 800a166:	4639      	mov	r1, r7
 800a168:	f8c8 6010 	str.w	r6, [r8, #16]
 800a16c:	f7ff fdc4 	bl	8009cf8 <_Bfree>
 800a170:	4640      	mov	r0, r8
 800a172:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a176:	f855 3b04 	ldr.w	r3, [r5], #4
 800a17a:	42a8      	cmp	r0, r5
 800a17c:	f844 3b04 	str.w	r3, [r4], #4
 800a180:	d9ef      	bls.n	800a162 <__lshift+0x86>
 800a182:	f855 3b04 	ldr.w	r3, [r5], #4
 800a186:	42a8      	cmp	r0, r5
 800a188:	f844 3b04 	str.w	r3, [r4], #4
 800a18c:	d8f3      	bhi.n	800a176 <__lshift+0x9a>
 800a18e:	e7e8      	b.n	800a162 <__lshift+0x86>

0800a190 <__mcmp>:
 800a190:	4603      	mov	r3, r0
 800a192:	690a      	ldr	r2, [r1, #16]
 800a194:	6900      	ldr	r0, [r0, #16]
 800a196:	b430      	push	{r4, r5}
 800a198:	1a80      	subs	r0, r0, r2
 800a19a:	d10f      	bne.n	800a1bc <__mcmp+0x2c>
 800a19c:	3204      	adds	r2, #4
 800a19e:	f103 0514 	add.w	r5, r3, #20
 800a1a2:	0092      	lsls	r2, r2, #2
 800a1a4:	189b      	adds	r3, r3, r2
 800a1a6:	1889      	adds	r1, r1, r2
 800a1a8:	3304      	adds	r3, #4
 800a1aa:	3104      	adds	r1, #4
 800a1ac:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800a1b0:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 800a1b4:	42a2      	cmp	r2, r4
 800a1b6:	d103      	bne.n	800a1c0 <__mcmp+0x30>
 800a1b8:	429d      	cmp	r5, r3
 800a1ba:	d3f7      	bcc.n	800a1ac <__mcmp+0x1c>
 800a1bc:	bc30      	pop	{r4, r5}
 800a1be:	4770      	bx	lr
 800a1c0:	4294      	cmp	r4, r2
 800a1c2:	bf94      	ite	ls
 800a1c4:	2001      	movls	r0, #1
 800a1c6:	f04f 30ff 	movhi.w	r0, #4294967295
 800a1ca:	e7f7      	b.n	800a1bc <__mcmp+0x2c>

0800a1cc <__mdiff>:
 800a1cc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a1d0:	468b      	mov	fp, r1
 800a1d2:	4604      	mov	r4, r0
 800a1d4:	4611      	mov	r1, r2
 800a1d6:	4658      	mov	r0, fp
 800a1d8:	4691      	mov	r9, r2
 800a1da:	f7ff ffd9 	bl	800a190 <__mcmp>
 800a1de:	1e05      	subs	r5, r0, #0
 800a1e0:	d061      	beq.n	800a2a6 <__mdiff+0xda>
 800a1e2:	bfbc      	itt	lt
 800a1e4:	465b      	movlt	r3, fp
 800a1e6:	46cb      	movlt	fp, r9
 800a1e8:	4620      	mov	r0, r4
 800a1ea:	bfb8      	it	lt
 800a1ec:	4699      	movlt	r9, r3
 800a1ee:	f8db 1004 	ldr.w	r1, [fp, #4]
 800a1f2:	bfac      	ite	ge
 800a1f4:	f04f 0800 	movge.w	r8, #0
 800a1f8:	f04f 0801 	movlt.w	r8, #1
 800a1fc:	f7ff fd46 	bl	8009c8c <_Balloc>
 800a200:	f8db 7010 	ldr.w	r7, [fp, #16]
 800a204:	f109 0514 	add.w	r5, r9, #20
 800a208:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800a20c:	f10b 0614 	add.w	r6, fp, #20
 800a210:	2400      	movs	r4, #0
 800a212:	eb0b 0c87 	add.w	ip, fp, r7, lsl #2
 800a216:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 800a21a:	f10c 0c14 	add.w	ip, ip, #20
 800a21e:	f109 0914 	add.w	r9, r9, #20
 800a222:	f100 0a14 	add.w	sl, r0, #20
 800a226:	f8c0 800c 	str.w	r8, [r0, #12]
 800a22a:	f856 8b04 	ldr.w	r8, [r6], #4
 800a22e:	4653      	mov	r3, sl
 800a230:	f855 ab04 	ldr.w	sl, [r5], #4
 800a234:	4632      	mov	r2, r6
 800a236:	fa1f f188 	uxth.w	r1, r8
 800a23a:	1909      	adds	r1, r1, r4
 800a23c:	fa1f fb8a 	uxth.w	fp, sl
 800a240:	ebcb 0101 	rsb	r1, fp, r1
 800a244:	ea4f 441a 	mov.w	r4, sl, lsr #16
 800a248:	ebc4 4418 	rsb	r4, r4, r8, lsr #16
 800a24c:	eb04 4421 	add.w	r4, r4, r1, asr #16
 800a250:	b289      	uxth	r1, r1
 800a252:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 800a256:	1424      	asrs	r4, r4, #16
 800a258:	45a9      	cmp	r9, r5
 800a25a:	f843 1b04 	str.w	r1, [r3], #4
 800a25e:	469a      	mov	sl, r3
 800a260:	d8e3      	bhi.n	800a22a <__mdiff+0x5e>
 800a262:	45b4      	cmp	ip, r6
 800a264:	4698      	mov	r8, r3
 800a266:	d914      	bls.n	800a292 <__mdiff+0xc6>
 800a268:	f852 5b04 	ldr.w	r5, [r2], #4
 800a26c:	b2a9      	uxth	r1, r5
 800a26e:	0c2d      	lsrs	r5, r5, #16
 800a270:	190c      	adds	r4, r1, r4
 800a272:	eb05 4524 	add.w	r5, r5, r4, asr #16
 800a276:	b2a4      	uxth	r4, r4
 800a278:	ea44 4105 	orr.w	r1, r4, r5, lsl #16
 800a27c:	142c      	asrs	r4, r5, #16
 800a27e:	4594      	cmp	ip, r2
 800a280:	f843 1b04 	str.w	r1, [r3], #4
 800a284:	d8f0      	bhi.n	800a268 <__mdiff+0x9c>
 800a286:	43f3      	mvns	r3, r6
 800a288:	4463      	add	r3, ip
 800a28a:	f023 0303 	bic.w	r3, r3, #3
 800a28e:	3304      	adds	r3, #4
 800a290:	4443      	add	r3, r8
 800a292:	3b04      	subs	r3, #4
 800a294:	b921      	cbnz	r1, 800a2a0 <__mdiff+0xd4>
 800a296:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800a29a:	3f01      	subs	r7, #1
 800a29c:	2a00      	cmp	r2, #0
 800a29e:	d0fa      	beq.n	800a296 <__mdiff+0xca>
 800a2a0:	6107      	str	r7, [r0, #16]
 800a2a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a2a6:	4620      	mov	r0, r4
 800a2a8:	4629      	mov	r1, r5
 800a2aa:	f7ff fcef 	bl	8009c8c <_Balloc>
 800a2ae:	2301      	movs	r3, #1
 800a2b0:	6145      	str	r5, [r0, #20]
 800a2b2:	6103      	str	r3, [r0, #16]
 800a2b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800a2b8 <__ulp>:
 800a2b8:	2300      	movs	r3, #0
 800a2ba:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 800a2be:	400b      	ands	r3, r1
 800a2c0:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
 800a2c4:	2b00      	cmp	r3, #0
 800a2c6:	dd02      	ble.n	800a2ce <__ulp+0x16>
 800a2c8:	4619      	mov	r1, r3
 800a2ca:	2000      	movs	r0, #0
 800a2cc:	4770      	bx	lr
 800a2ce:	425b      	negs	r3, r3
 800a2d0:	2100      	movs	r1, #0
 800a2d2:	151b      	asrs	r3, r3, #20
 800a2d4:	2b13      	cmp	r3, #19
 800a2d6:	dd0b      	ble.n	800a2f0 <__ulp+0x38>
 800a2d8:	2b32      	cmp	r3, #50	; 0x32
 800a2da:	dd02      	ble.n	800a2e2 <__ulp+0x2a>
 800a2dc:	2301      	movs	r3, #1
 800a2de:	4618      	mov	r0, r3
 800a2e0:	4770      	bx	lr
 800a2e2:	2201      	movs	r2, #1
 800a2e4:	f1c3 0333 	rsb	r3, r3, #51	; 0x33
 800a2e8:	fa02 f303 	lsl.w	r3, r2, r3
 800a2ec:	4618      	mov	r0, r3
 800a2ee:	4770      	bx	lr
 800a2f0:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800a2f4:	2000      	movs	r0, #0
 800a2f6:	fa42 f103 	asr.w	r1, r2, r3
 800a2fa:	4770      	bx	lr

0800a2fc <__b2d>:
 800a2fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a300:	f100 0814 	add.w	r8, r0, #20
 800a304:	6906      	ldr	r6, [r0, #16]
 800a306:	4689      	mov	r9, r1
 800a308:	3604      	adds	r6, #4
 800a30a:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800a30e:	4634      	mov	r4, r6
 800a310:	4637      	mov	r7, r6
 800a312:	f854 5b04 	ldr.w	r5, [r4], #4
 800a316:	4628      	mov	r0, r5
 800a318:	f7ff fd9a 	bl	8009e50 <__hi0bits>
 800a31c:	280a      	cmp	r0, #10
 800a31e:	f1c0 0320 	rsb	r3, r0, #32
 800a322:	f8c9 3000 	str.w	r3, [r9]
 800a326:	dc18      	bgt.n	800a35a <__b2d+0x5e>
 800a328:	45b0      	cmp	r8, r6
 800a32a:	f1c0 010b 	rsb	r1, r0, #11
 800a32e:	fa25 f701 	lsr.w	r7, r5, r1
 800a332:	bf38      	it	cc
 800a334:	f854 4c08 	ldrcc.w	r4, [r4, #-8]
 800a338:	f047 577f 	orr.w	r7, r7, #1069547520	; 0x3fc00000
 800a33c:	f447 1340 	orr.w	r3, r7, #3145728	; 0x300000
 800a340:	bf34      	ite	cc
 800a342:	fa24 f101 	lsrcc.w	r1, r4, r1
 800a346:	2100      	movcs	r1, #0
 800a348:	3015      	adds	r0, #21
 800a34a:	fa05 f500 	lsl.w	r5, r5, r0
 800a34e:	ea41 0205 	orr.w	r2, r1, r5
 800a352:	4610      	mov	r0, r2
 800a354:	4619      	mov	r1, r3
 800a356:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800a35a:	2100      	movs	r1, #0
 800a35c:	45b0      	cmp	r8, r6
 800a35e:	d202      	bcs.n	800a366 <__b2d+0x6a>
 800a360:	f854 1c08 	ldr.w	r1, [r4, #-8]
 800a364:	1f37      	subs	r7, r6, #4
 800a366:	f1b0 040b 	subs.w	r4, r0, #11
 800a36a:	d018      	beq.n	800a39e <__b2d+0xa2>
 800a36c:	fa05 f504 	lsl.w	r5, r5, r4
 800a370:	f1c0 002b 	rsb	r0, r0, #43	; 0x2b
 800a374:	4547      	cmp	r7, r8
 800a376:	f045 557f 	orr.w	r5, r5, #1069547520	; 0x3fc00000
 800a37a:	fa21 f600 	lsr.w	r6, r1, r0
 800a37e:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
 800a382:	ea45 0306 	orr.w	r3, r5, r6
 800a386:	bf88      	it	hi
 800a388:	f857 5c04 	ldrhi.w	r5, [r7, #-4]
 800a38c:	fa01 f104 	lsl.w	r1, r1, r4
 800a390:	bf8c      	ite	hi
 800a392:	fa25 f000 	lsrhi.w	r0, r5, r0
 800a396:	2000      	movls	r0, #0
 800a398:	ea40 0201 	orr.w	r2, r0, r1
 800a39c:	e7d9      	b.n	800a352 <__b2d+0x56>
 800a39e:	f045 557f 	orr.w	r5, r5, #1069547520	; 0x3fc00000
 800a3a2:	460a      	mov	r2, r1
 800a3a4:	f445 1340 	orr.w	r3, r5, #3145728	; 0x300000
 800a3a8:	e7d3      	b.n	800a352 <__b2d+0x56>
 800a3aa:	bf00      	nop

0800a3ac <__d2b>:
 800a3ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a3b0:	b083      	sub	sp, #12
 800a3b2:	2101      	movs	r1, #1
 800a3b4:	461d      	mov	r5, r3
 800a3b6:	4614      	mov	r4, r2
 800a3b8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800a3ba:	f7ff fc67 	bl	8009c8c <_Balloc>
 800a3be:	f3c5 560a 	ubfx	r6, r5, #20, #11
 800a3c2:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
 800a3c6:	46a9      	mov	r9, r5
 800a3c8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800a3cc:	4680      	mov	r8, r0
 800a3ce:	b10e      	cbz	r6, 800a3d4 <__d2b+0x28>
 800a3d0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800a3d4:	9301      	str	r3, [sp, #4]
 800a3d6:	2c00      	cmp	r4, #0
 800a3d8:	d024      	beq.n	800a424 <__d2b+0x78>
 800a3da:	a802      	add	r0, sp, #8
 800a3dc:	f840 4d08 	str.w	r4, [r0, #-8]!
 800a3e0:	4668      	mov	r0, sp
 800a3e2:	f7ff fd53 	bl	8009e8c <__lo0bits>
 800a3e6:	9b01      	ldr	r3, [sp, #4]
 800a3e8:	2800      	cmp	r0, #0
 800a3ea:	d131      	bne.n	800a450 <__d2b+0xa4>
 800a3ec:	9a00      	ldr	r2, [sp, #0]
 800a3ee:	f8c8 2014 	str.w	r2, [r8, #20]
 800a3f2:	2b00      	cmp	r3, #0
 800a3f4:	bf0c      	ite	eq
 800a3f6:	2401      	moveq	r4, #1
 800a3f8:	2402      	movne	r4, #2
 800a3fa:	f8c8 3018 	str.w	r3, [r8, #24]
 800a3fe:	f8c8 4010 	str.w	r4, [r8, #16]
 800a402:	b9e6      	cbnz	r6, 800a43e <__d2b+0x92>
 800a404:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 800a408:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 800a40c:	6038      	str	r0, [r7, #0]
 800a40e:	6918      	ldr	r0, [r3, #16]
 800a410:	f7ff fd1e 	bl	8009e50 <__hi0bits>
 800a414:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a416:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 800a41a:	6018      	str	r0, [r3, #0]
 800a41c:	4640      	mov	r0, r8
 800a41e:	b003      	add	sp, #12
 800a420:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a424:	a801      	add	r0, sp, #4
 800a426:	f7ff fd31 	bl	8009e8c <__lo0bits>
 800a42a:	2301      	movs	r3, #1
 800a42c:	461c      	mov	r4, r3
 800a42e:	f8c8 3010 	str.w	r3, [r8, #16]
 800a432:	9b01      	ldr	r3, [sp, #4]
 800a434:	f8c8 3014 	str.w	r3, [r8, #20]
 800a438:	3020      	adds	r0, #32
 800a43a:	2e00      	cmp	r6, #0
 800a43c:	d0e2      	beq.n	800a404 <__d2b+0x58>
 800a43e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800a440:	f2a6 4933 	subw	r9, r6, #1075	; 0x433
 800a444:	f1c0 0335 	rsb	r3, r0, #53	; 0x35
 800a448:	4448      	add	r0, r9
 800a44a:	6038      	str	r0, [r7, #0]
 800a44c:	6013      	str	r3, [r2, #0]
 800a44e:	e7e5      	b.n	800a41c <__d2b+0x70>
 800a450:	f1c0 0120 	rsb	r1, r0, #32
 800a454:	9a00      	ldr	r2, [sp, #0]
 800a456:	fa03 f101 	lsl.w	r1, r3, r1
 800a45a:	fa23 f300 	lsr.w	r3, r3, r0
 800a45e:	430a      	orrs	r2, r1
 800a460:	9301      	str	r3, [sp, #4]
 800a462:	f8c8 2014 	str.w	r2, [r8, #20]
 800a466:	e7c4      	b.n	800a3f2 <__d2b+0x46>

0800a468 <__ratio>:
 800a468:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a46c:	b083      	sub	sp, #12
 800a46e:	4688      	mov	r8, r1
 800a470:	4669      	mov	r1, sp
 800a472:	4606      	mov	r6, r0
 800a474:	f7ff ff42 	bl	800a2fc <__b2d>
 800a478:	460d      	mov	r5, r1
 800a47a:	4604      	mov	r4, r0
 800a47c:	a901      	add	r1, sp, #4
 800a47e:	4640      	mov	r0, r8
 800a480:	f7ff ff3c 	bl	800a2fc <__b2d>
 800a484:	462f      	mov	r7, r5
 800a486:	460b      	mov	r3, r1
 800a488:	4602      	mov	r2, r0
 800a48a:	f8d8 1010 	ldr.w	r1, [r8, #16]
 800a48e:	4699      	mov	r9, r3
 800a490:	6930      	ldr	r0, [r6, #16]
 800a492:	4626      	mov	r6, r4
 800a494:	4690      	mov	r8, r2
 800a496:	ebc1 0e00 	rsb	lr, r1, r0
 800a49a:	e89d 0003 	ldmia.w	sp, {r0, r1}
 800a49e:	1a40      	subs	r0, r0, r1
 800a4a0:	eb00 114e 	add.w	r1, r0, lr, lsl #5
 800a4a4:	2900      	cmp	r1, #0
 800a4a6:	bfc9      	itett	gt
 800a4a8:	eb05 5701 	addgt.w	r7, r5, r1, lsl #20
 800a4ac:	eba3 5901 	suble.w	r9, r3, r1, lsl #20
 800a4b0:	4624      	movgt	r4, r4
 800a4b2:	463d      	movgt	r5, r7
 800a4b4:	bfdc      	itt	le
 800a4b6:	4612      	movle	r2, r2
 800a4b8:	464b      	movle	r3, r9
 800a4ba:	4620      	mov	r0, r4
 800a4bc:	4629      	mov	r1, r5
 800a4be:	f001 fea7 	bl	800c210 <__aeabi_ddiv>
 800a4c2:	b003      	add	sp, #12
 800a4c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800a4c8 <_mprec_log10>:
 800a4c8:	2817      	cmp	r0, #23
 800a4ca:	b510      	push	{r4, lr}
 800a4cc:	4604      	mov	r4, r0
 800a4ce:	dd0c      	ble.n	800a4ea <_mprec_log10+0x22>
 800a4d0:	2100      	movs	r1, #0
 800a4d2:	2000      	movs	r0, #0
 800a4d4:	f6c3 71f0 	movt	r1, #16368	; 0x3ff0
 800a4d8:	2300      	movs	r3, #0
 800a4da:	2200      	movs	r2, #0
 800a4dc:	f2c4 0324 	movt	r3, #16420	; 0x4024
 800a4e0:	f001 fd6c 	bl	800bfbc <__aeabi_dmul>
 800a4e4:	3c01      	subs	r4, #1
 800a4e6:	d1f7      	bne.n	800a4d8 <_mprec_log10+0x10>
 800a4e8:	bd10      	pop	{r4, pc}
 800a4ea:	f64c 63d0 	movw	r3, #52944	; 0xced0
 800a4ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a4f2:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a4f6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800a4fa:	bd10      	pop	{r4, pc}

0800a4fc <__copybits>:
 800a4fc:	b470      	push	{r4, r5, r6}
 800a4fe:	3901      	subs	r1, #1
 800a500:	6915      	ldr	r5, [r2, #16]
 800a502:	f102 0314 	add.w	r3, r2, #20
 800a506:	114e      	asrs	r6, r1, #5
 800a508:	3601      	adds	r6, #1
 800a50a:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 800a50e:	3514      	adds	r5, #20
 800a510:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800a514:	42ab      	cmp	r3, r5
 800a516:	d20c      	bcs.n	800a532 <__copybits+0x36>
 800a518:	4601      	mov	r1, r0
 800a51a:	f853 4b04 	ldr.w	r4, [r3], #4
 800a51e:	429d      	cmp	r5, r3
 800a520:	f841 4b04 	str.w	r4, [r1], #4
 800a524:	d8f9      	bhi.n	800a51a <__copybits+0x1e>
 800a526:	1aab      	subs	r3, r5, r2
 800a528:	3b15      	subs	r3, #21
 800a52a:	f023 0303 	bic.w	r3, r3, #3
 800a52e:	3304      	adds	r3, #4
 800a530:	18c0      	adds	r0, r0, r3
 800a532:	4286      	cmp	r6, r0
 800a534:	d904      	bls.n	800a540 <__copybits+0x44>
 800a536:	2300      	movs	r3, #0
 800a538:	f840 3b04 	str.w	r3, [r0], #4
 800a53c:	4286      	cmp	r6, r0
 800a53e:	d8fb      	bhi.n	800a538 <__copybits+0x3c>
 800a540:	bc70      	pop	{r4, r5, r6}
 800a542:	4770      	bx	lr

0800a544 <__any_on>:
 800a544:	b430      	push	{r4, r5}
 800a546:	114b      	asrs	r3, r1, #5
 800a548:	6904      	ldr	r4, [r0, #16]
 800a54a:	f100 0214 	add.w	r2, r0, #20
 800a54e:	429c      	cmp	r4, r3
 800a550:	bfb8      	it	lt
 800a552:	4623      	movlt	r3, r4
 800a554:	db00      	blt.n	800a558 <__any_on+0x14>
 800a556:	dc11      	bgt.n	800a57c <__any_on+0x38>
 800a558:	3304      	adds	r3, #4
 800a55a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800a55e:	1d03      	adds	r3, r0, #4
 800a560:	429a      	cmp	r2, r3
 800a562:	d218      	bcs.n	800a596 <__any_on+0x52>
 800a564:	f853 3c04 	ldr.w	r3, [r3, #-4]
 800a568:	b92b      	cbnz	r3, 800a576 <__any_on+0x32>
 800a56a:	4282      	cmp	r2, r0
 800a56c:	d213      	bcs.n	800a596 <__any_on+0x52>
 800a56e:	f850 3d04 	ldr.w	r3, [r0, #-4]!
 800a572:	2b00      	cmp	r3, #0
 800a574:	d0f9      	beq.n	800a56a <__any_on+0x26>
 800a576:	2001      	movs	r0, #1
 800a578:	bc30      	pop	{r4, r5}
 800a57a:	4770      	bx	lr
 800a57c:	f011 011f 	ands.w	r1, r1, #31
 800a580:	d0ea      	beq.n	800a558 <__any_on+0x14>
 800a582:	eb00 0483 	add.w	r4, r0, r3, lsl #2
 800a586:	6964      	ldr	r4, [r4, #20]
 800a588:	fa24 f501 	lsr.w	r5, r4, r1
 800a58c:	fa05 f101 	lsl.w	r1, r5, r1
 800a590:	42a1      	cmp	r1, r4
 800a592:	d1f0      	bne.n	800a576 <__any_on+0x32>
 800a594:	e7e0      	b.n	800a558 <__any_on+0x14>
 800a596:	2000      	movs	r0, #0
 800a598:	e7ee      	b.n	800a578 <__any_on+0x34>
 800a59a:	bf00      	nop

0800a59c <__fpclassifyd>:
 800a59c:	ea50 0201 	orrs.w	r2, r0, r1
 800a5a0:	d101      	bne.n	800a5a6 <__fpclassifyd+0xa>
 800a5a2:	2002      	movs	r0, #2
 800a5a4:	4770      	bx	lr
 800a5a6:	f1d0 0201 	rsbs	r2, r0, #1
 800a5aa:	bf38      	it	cc
 800a5ac:	2200      	movcc	r2, #0
 800a5ae:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800a5b2:	bf08      	it	eq
 800a5b4:	2800      	cmpeq	r0, #0
 800a5b6:	d0f4      	beq.n	800a5a2 <__fpclassifyd+0x6>
 800a5b8:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 800a5bc:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800a5c0:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 800a5c4:	f6c7 71df 	movt	r1, #32735	; 0x7fdf
 800a5c8:	4288      	cmp	r0, r1
 800a5ca:	d801      	bhi.n	800a5d0 <__fpclassifyd+0x34>
 800a5cc:	2004      	movs	r0, #4
 800a5ce:	4770      	bx	lr
 800a5d0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800a5d4:	d201      	bcs.n	800a5da <__fpclassifyd+0x3e>
 800a5d6:	2003      	movs	r0, #3
 800a5d8:	4770      	bx	lr
 800a5da:	2000      	movs	r0, #0
 800a5dc:	f6c7 70f0 	movt	r0, #32752	; 0x7ff0
 800a5e0:	4283      	cmp	r3, r0
 800a5e2:	bf14      	ite	ne
 800a5e4:	2000      	movne	r0, #0
 800a5e6:	f002 0001 	andeq.w	r0, r2, #1
 800a5ea:	4770      	bx	lr

0800a5ec <_sbrk_r>:
 800a5ec:	b538      	push	{r3, r4, r5, lr}
 800a5ee:	f241 24e0 	movw	r4, #4832	; 0x12e0
 800a5f2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800a5f6:	4605      	mov	r5, r0
 800a5f8:	4608      	mov	r0, r1
 800a5fa:	2300      	movs	r3, #0
 800a5fc:	6023      	str	r3, [r4, #0]
 800a5fe:	f7fc f961 	bl	80068c4 <_sbrk>
 800a602:	1c43      	adds	r3, r0, #1
 800a604:	d000      	beq.n	800a608 <_sbrk_r+0x1c>
 800a606:	bd38      	pop	{r3, r4, r5, pc}
 800a608:	6823      	ldr	r3, [r4, #0]
 800a60a:	2b00      	cmp	r3, #0
 800a60c:	d0fb      	beq.n	800a606 <_sbrk_r+0x1a>
 800a60e:	602b      	str	r3, [r5, #0]
 800a610:	bd38      	pop	{r3, r4, r5, pc}
 800a612:	bf00      	nop

0800a614 <strcmp>:
 800a614:	ea80 0201 	eor.w	r2, r0, r1
 800a618:	f012 0f03 	tst.w	r2, #3
 800a61c:	f040 803a 	bne.w	800a694 <strcmp_unaligned>
 800a620:	f010 0203 	ands.w	r2, r0, #3
 800a624:	f020 0003 	bic.w	r0, r0, #3
 800a628:	f021 0103 	bic.w	r1, r1, #3
 800a62c:	f850 cb04 	ldr.w	ip, [r0], #4
 800a630:	bf08      	it	eq
 800a632:	f851 3b04 	ldreq.w	r3, [r1], #4
 800a636:	d00d      	beq.n	800a654 <strcmp+0x40>
 800a638:	f082 0203 	eor.w	r2, r2, #3
 800a63c:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a640:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 800a644:	fa23 f202 	lsr.w	r2, r3, r2
 800a648:	f851 3b04 	ldr.w	r3, [r1], #4
 800a64c:	ea4c 0c02 	orr.w	ip, ip, r2
 800a650:	ea43 0302 	orr.w	r3, r3, r2
 800a654:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 800a658:	459c      	cmp	ip, r3
 800a65a:	bf01      	itttt	eq
 800a65c:	ea22 020c 	biceq.w	r2, r2, ip
 800a660:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 800a664:	f850 cb04 	ldreq.w	ip, [r0], #4
 800a668:	f851 3b04 	ldreq.w	r3, [r1], #4
 800a66c:	d0f2      	beq.n	800a654 <strcmp+0x40>
 800a66e:	ea4f 600c 	mov.w	r0, ip, lsl #24
 800a672:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 800a676:	2801      	cmp	r0, #1
 800a678:	bf28      	it	cs
 800a67a:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 800a67e:	bf08      	it	eq
 800a680:	0a1b      	lsreq	r3, r3, #8
 800a682:	d0f4      	beq.n	800a66e <strcmp+0x5a>
 800a684:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 800a688:	ea4f 6010 	mov.w	r0, r0, lsr #24
 800a68c:	eba0 0003 	sub.w	r0, r0, r3
 800a690:	4770      	bx	lr
 800a692:	bf00      	nop

0800a694 <strcmp_unaligned>:
 800a694:	f010 0f03 	tst.w	r0, #3
 800a698:	d00a      	beq.n	800a6b0 <strcmp_unaligned+0x1c>
 800a69a:	f810 2b01 	ldrb.w	r2, [r0], #1
 800a69e:	f811 3b01 	ldrb.w	r3, [r1], #1
 800a6a2:	2a01      	cmp	r2, #1
 800a6a4:	bf28      	it	cs
 800a6a6:	429a      	cmpcs	r2, r3
 800a6a8:	d0f4      	beq.n	800a694 <strcmp_unaligned>
 800a6aa:	eba2 0003 	sub.w	r0, r2, r3
 800a6ae:	4770      	bx	lr
 800a6b0:	f84d 5d04 	str.w	r5, [sp, #-4]!
 800a6b4:	f84d 4d04 	str.w	r4, [sp, #-4]!
 800a6b8:	f04f 0201 	mov.w	r2, #1
 800a6bc:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 800a6c0:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 800a6c4:	f001 0c03 	and.w	ip, r1, #3
 800a6c8:	f021 0103 	bic.w	r1, r1, #3
 800a6cc:	f850 4b04 	ldr.w	r4, [r0], #4
 800a6d0:	f851 5b04 	ldr.w	r5, [r1], #4
 800a6d4:	f1bc 0f02 	cmp.w	ip, #2
 800a6d8:	d026      	beq.n	800a728 <strcmp_unaligned+0x94>
 800a6da:	d84b      	bhi.n	800a774 <strcmp_unaligned+0xe0>
 800a6dc:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 800a6e0:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 800a6e4:	eba4 0302 	sub.w	r3, r4, r2
 800a6e8:	ea23 0304 	bic.w	r3, r3, r4
 800a6ec:	d10d      	bne.n	800a70a <strcmp_unaligned+0x76>
 800a6ee:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 800a6f2:	bf08      	it	eq
 800a6f4:	f851 5b04 	ldreq.w	r5, [r1], #4
 800a6f8:	d10a      	bne.n	800a710 <strcmp_unaligned+0x7c>
 800a6fa:	ea8c 0c04 	eor.w	ip, ip, r4
 800a6fe:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 800a702:	d10c      	bne.n	800a71e <strcmp_unaligned+0x8a>
 800a704:	f850 4b04 	ldr.w	r4, [r0], #4
 800a708:	e7e8      	b.n	800a6dc <strcmp_unaligned+0x48>
 800a70a:	ea4f 2515 	mov.w	r5, r5, lsr #8
 800a70e:	e05c      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a710:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 800a714:	d152      	bne.n	800a7bc <strcmp_unaligned+0x128>
 800a716:	780d      	ldrb	r5, [r1, #0]
 800a718:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 800a71c:	e055      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a71e:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 800a722:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 800a726:	e050      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a728:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 800a72c:	eba4 0302 	sub.w	r3, r4, r2
 800a730:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800a734:	ea23 0304 	bic.w	r3, r3, r4
 800a738:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 800a73c:	d117      	bne.n	800a76e <strcmp_unaligned+0xda>
 800a73e:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 800a742:	bf08      	it	eq
 800a744:	f851 5b04 	ldreq.w	r5, [r1], #4
 800a748:	d107      	bne.n	800a75a <strcmp_unaligned+0xc6>
 800a74a:	ea8c 0c04 	eor.w	ip, ip, r4
 800a74e:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 800a752:	d108      	bne.n	800a766 <strcmp_unaligned+0xd2>
 800a754:	f850 4b04 	ldr.w	r4, [r0], #4
 800a758:	e7e6      	b.n	800a728 <strcmp_unaligned+0x94>
 800a75a:	041b      	lsls	r3, r3, #16
 800a75c:	d12e      	bne.n	800a7bc <strcmp_unaligned+0x128>
 800a75e:	880d      	ldrh	r5, [r1, #0]
 800a760:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 800a764:	e031      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a766:	ea4f 4505 	mov.w	r5, r5, lsl #16
 800a76a:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 800a76e:	ea4f 4515 	mov.w	r5, r5, lsr #16
 800a772:	e02a      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a774:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 800a778:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 800a77c:	eba4 0302 	sub.w	r3, r4, r2
 800a780:	ea23 0304 	bic.w	r3, r3, r4
 800a784:	d10d      	bne.n	800a7a2 <strcmp_unaligned+0x10e>
 800a786:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 800a78a:	bf08      	it	eq
 800a78c:	f851 5b04 	ldreq.w	r5, [r1], #4
 800a790:	d10a      	bne.n	800a7a8 <strcmp_unaligned+0x114>
 800a792:	ea8c 0c04 	eor.w	ip, ip, r4
 800a796:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 800a79a:	d10a      	bne.n	800a7b2 <strcmp_unaligned+0x11e>
 800a79c:	f850 4b04 	ldr.w	r4, [r0], #4
 800a7a0:	e7e8      	b.n	800a774 <strcmp_unaligned+0xe0>
 800a7a2:	ea4f 6515 	mov.w	r5, r5, lsr #24
 800a7a6:	e010      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a7a8:	f014 0fff 	tst.w	r4, #255	; 0xff
 800a7ac:	d006      	beq.n	800a7bc <strcmp_unaligned+0x128>
 800a7ae:	f851 5b04 	ldr.w	r5, [r1], #4
 800a7b2:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 800a7b6:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 800a7ba:	e006      	b.n	800a7ca <strcmp_unaligned+0x136>
 800a7bc:	f04f 0000 	mov.w	r0, #0
 800a7c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a7c4:	f85d 5b04 	ldr.w	r5, [sp], #4
 800a7c8:	4770      	bx	lr
 800a7ca:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 800a7ce:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 800a7d2:	2801      	cmp	r0, #1
 800a7d4:	bf28      	it	cs
 800a7d6:	4290      	cmpcs	r0, r2
 800a7d8:	bf04      	itt	eq
 800a7da:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 800a7de:	0a2d      	lsreq	r5, r5, #8
 800a7e0:	d0f3      	beq.n	800a7ca <strcmp_unaligned+0x136>
 800a7e2:	eba2 0000 	sub.w	r0, r2, r0
 800a7e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a7ea:	f85d 5b04 	ldr.w	r5, [sp], #4
 800a7ee:	4770      	bx	lr

0800a7f0 <strlen>:
 800a7f0:	f020 0103 	bic.w	r1, r0, #3
 800a7f4:	f010 0003 	ands.w	r0, r0, #3
 800a7f8:	f1c0 0000 	rsb	r0, r0, #0
 800a7fc:	f851 3b04 	ldr.w	r3, [r1], #4
 800a800:	f100 0c04 	add.w	ip, r0, #4
 800a804:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800a808:	f06f 0200 	mvn.w	r2, #0
 800a80c:	bf1c      	itt	ne
 800a80e:	fa22 f20c 	lsrne.w	r2, r2, ip
 800a812:	4313      	orrne	r3, r2
 800a814:	f04f 0c01 	mov.w	ip, #1
 800a818:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800a81c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800a820:	eba3 020c 	sub.w	r2, r3, ip
 800a824:	ea22 0203 	bic.w	r2, r2, r3
 800a828:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800a82c:	bf04      	itt	eq
 800a82e:	f851 3b04 	ldreq.w	r3, [r1], #4
 800a832:	3004      	addeq	r0, #4
 800a834:	d0f4      	beq.n	800a820 <strlen+0x30>
 800a836:	f013 0fff 	tst.w	r3, #255	; 0xff
 800a83a:	bf1f      	itttt	ne
 800a83c:	3001      	addne	r0, #1
 800a83e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800a842:	3001      	addne	r0, #1
 800a844:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 800a848:	bf18      	it	ne
 800a84a:	3001      	addne	r0, #1
 800a84c:	4770      	bx	lr
 800a84e:	bf00      	nop

0800a850 <__ssprint_r>:
 800a850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a854:	b083      	sub	sp, #12
 800a856:	6894      	ldr	r4, [r2, #8]
 800a858:	4692      	mov	sl, r2
 800a85a:	9001      	str	r0, [sp, #4]
 800a85c:	460d      	mov	r5, r1
 800a85e:	6817      	ldr	r7, [r2, #0]
 800a860:	2c00      	cmp	r4, #0
 800a862:	d075      	beq.n	800a950 <__ssprint_r+0x100>
 800a864:	f04f 0b00 	mov.w	fp, #0
 800a868:	6808      	ldr	r0, [r1, #0]
 800a86a:	688b      	ldr	r3, [r1, #8]
 800a86c:	465c      	mov	r4, fp
 800a86e:	2c00      	cmp	r4, #0
 800a870:	d04c      	beq.n	800a90c <__ssprint_r+0xbc>
 800a872:	429c      	cmp	r4, r3
 800a874:	461e      	mov	r6, r3
 800a876:	4698      	mov	r8, r3
 800a878:	d34e      	bcc.n	800a918 <__ssprint_r+0xc8>
 800a87a:	f8b5 e00c 	ldrh.w	lr, [r5, #12]
 800a87e:	f41e 6f90 	tst.w	lr, #1152	; 0x480
 800a882:	d033      	beq.n	800a8ec <__ssprint_r+0x9c>
 800a884:	696b      	ldr	r3, [r5, #20]
 800a886:	1c62      	adds	r2, r4, #1
 800a888:	6929      	ldr	r1, [r5, #16]
 800a88a:	f40e 6e80 	and.w	lr, lr, #1024	; 0x400
 800a88e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800a892:	1a46      	subs	r6, r0, r1
 800a894:	1990      	adds	r0, r2, r6
 800a896:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800a89a:	ea4f 0963 	mov.w	r9, r3, asr #1
 800a89e:	4581      	cmp	r9, r0
 800a8a0:	464a      	mov	r2, r9
 800a8a2:	bf38      	it	cc
 800a8a4:	4681      	movcc	r9, r0
 800a8a6:	fa0f f08e 	sxth.w	r0, lr
 800a8aa:	bf38      	it	cc
 800a8ac:	464a      	movcc	r2, r9
 800a8ae:	2800      	cmp	r0, #0
 800a8b0:	d035      	beq.n	800a91e <__ssprint_r+0xce>
 800a8b2:	9801      	ldr	r0, [sp, #4]
 800a8b4:	4611      	mov	r1, r2
 800a8b6:	f7fe fe15 	bl	80094e4 <_malloc_r>
 800a8ba:	4680      	mov	r8, r0
 800a8bc:	2800      	cmp	r0, #0
 800a8be:	d038      	beq.n	800a932 <__ssprint_r+0xe2>
 800a8c0:	4632      	mov	r2, r6
 800a8c2:	6929      	ldr	r1, [r5, #16]
 800a8c4:	f7ff f924 	bl	8009b10 <memcpy>
 800a8c8:	89aa      	ldrh	r2, [r5, #12]
 800a8ca:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 800a8ce:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a8d2:	81aa      	strh	r2, [r5, #12]
 800a8d4:	eb08 0006 	add.w	r0, r8, r6
 800a8d8:	ebc6 0209 	rsb	r2, r6, r9
 800a8dc:	f8c5 8010 	str.w	r8, [r5, #16]
 800a8e0:	4626      	mov	r6, r4
 800a8e2:	46a0      	mov	r8, r4
 800a8e4:	6028      	str	r0, [r5, #0]
 800a8e6:	f8c5 9014 	str.w	r9, [r5, #20]
 800a8ea:	60aa      	str	r2, [r5, #8]
 800a8ec:	4642      	mov	r2, r8
 800a8ee:	4659      	mov	r1, fp
 800a8f0:	f000 fdbc 	bl	800b46c <memmove>
 800a8f4:	f8da 2008 	ldr.w	r2, [sl, #8]
 800a8f8:	68ab      	ldr	r3, [r5, #8]
 800a8fa:	6828      	ldr	r0, [r5, #0]
 800a8fc:	1b14      	subs	r4, r2, r4
 800a8fe:	1b9b      	subs	r3, r3, r6
 800a900:	60ab      	str	r3, [r5, #8]
 800a902:	4440      	add	r0, r8
 800a904:	6028      	str	r0, [r5, #0]
 800a906:	f8ca 4008 	str.w	r4, [sl, #8]
 800a90a:	b30c      	cbz	r4, 800a950 <__ssprint_r+0x100>
 800a90c:	f8d7 b000 	ldr.w	fp, [r7]
 800a910:	3708      	adds	r7, #8
 800a912:	f857 4c04 	ldr.w	r4, [r7, #-4]
 800a916:	e7aa      	b.n	800a86e <__ssprint_r+0x1e>
 800a918:	4626      	mov	r6, r4
 800a91a:	46a0      	mov	r8, r4
 800a91c:	e7e6      	b.n	800a8ec <__ssprint_r+0x9c>
 800a91e:	9801      	ldr	r0, [sp, #4]
 800a920:	f000 fe70 	bl	800b604 <_realloc_r>
 800a924:	4680      	mov	r8, r0
 800a926:	2800      	cmp	r0, #0
 800a928:	d1d4      	bne.n	800a8d4 <__ssprint_r+0x84>
 800a92a:	9801      	ldr	r0, [sp, #4]
 800a92c:	6929      	ldr	r1, [r5, #16]
 800a92e:	f7fe fcb1 	bl	8009294 <_free_r>
 800a932:	9a01      	ldr	r2, [sp, #4]
 800a934:	230c      	movs	r3, #12
 800a936:	f04f 30ff 	mov.w	r0, #4294967295
 800a93a:	6013      	str	r3, [r2, #0]
 800a93c:	2300      	movs	r3, #0
 800a93e:	89aa      	ldrh	r2, [r5, #12]
 800a940:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a944:	81aa      	strh	r2, [r5, #12]
 800a946:	f8ca 3008 	str.w	r3, [sl, #8]
 800a94a:	f8ca 3004 	str.w	r3, [sl, #4]
 800a94e:	e002      	b.n	800a956 <__ssprint_r+0x106>
 800a950:	4620      	mov	r0, r4
 800a952:	f8ca 4004 	str.w	r4, [sl, #4]
 800a956:	b003      	add	sp, #12
 800a958:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800a95c <_svfiprintf_r>:
 800a95c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a960:	b0b3      	sub	sp, #204	; 0xcc
 800a962:	930b      	str	r3, [sp, #44]	; 0x2c
 800a964:	898b      	ldrh	r3, [r1, #12]
 800a966:	9104      	str	r1, [sp, #16]
 800a968:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a96c:	900a      	str	r0, [sp, #40]	; 0x28
 800a96e:	b21b      	sxth	r3, r3
 800a970:	b11b      	cbz	r3, 800a97a <_svfiprintf_r+0x1e>
 800a972:	690b      	ldr	r3, [r1, #16]
 800a974:	2b00      	cmp	r3, #0
 800a976:	f000 8510 	beq.w	800b39a <_svfiprintf_r+0xa3e>
 800a97a:	f10d 0687 	add.w	r6, sp, #135	; 0x87
 800a97e:	9602      	str	r6, [sp, #8]
 800a980:	9e02      	ldr	r6, [sp, #8]
 800a982:	af22      	add	r7, sp, #136	; 0x88
 800a984:	4615      	mov	r5, r2
 800a986:	46b8      	mov	r8, r7
 800a988:	9703      	str	r7, [sp, #12]
 800a98a:	1bbf      	subs	r7, r7, r6
 800a98c:	f64c 76f8 	movw	r6, #53240	; 0xcff8
 800a990:	2300      	movs	r3, #0
 800a992:	f6c0 0600 	movt	r6, #2048	; 0x800
 800a996:	930e      	str	r3, [sp, #56]	; 0x38
 800a998:	9306      	str	r3, [sp, #24]
 800a99a:	9711      	str	r7, [sp, #68]	; 0x44
 800a99c:	960d      	str	r6, [sp, #52]	; 0x34
 800a99e:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
 800a9a2:	9317      	str	r3, [sp, #92]	; 0x5c
 800a9a4:	9316      	str	r3, [sp, #88]	; 0x58
 800a9a6:	782b      	ldrb	r3, [r5, #0]
 800a9a8:	2b00      	cmp	r3, #0
 800a9aa:	bf18      	it	ne
 800a9ac:	2b25      	cmpne	r3, #37	; 0x25
 800a9ae:	f000 834d 	beq.w	800b04c <_svfiprintf_r+0x6f0>
 800a9b2:	1c6a      	adds	r2, r5, #1
 800a9b4:	4614      	mov	r4, r2
 800a9b6:	3201      	adds	r2, #1
 800a9b8:	7823      	ldrb	r3, [r4, #0]
 800a9ba:	2b25      	cmp	r3, #37	; 0x25
 800a9bc:	bf18      	it	ne
 800a9be:	2b00      	cmpne	r3, #0
 800a9c0:	d1f8      	bne.n	800a9b4 <_svfiprintf_r+0x58>
 800a9c2:	1b66      	subs	r6, r4, r5
 800a9c4:	d010      	beq.n	800a9e8 <_svfiprintf_r+0x8c>
 800a9c6:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800a9c8:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800a9ca:	3201      	adds	r2, #1
 800a9cc:	e888 0060 	stmia.w	r8, {r5, r6}
 800a9d0:	2a07      	cmp	r2, #7
 800a9d2:	4431      	add	r1, r6
 800a9d4:	9216      	str	r2, [sp, #88]	; 0x58
 800a9d6:	bfd8      	it	le
 800a9d8:	f108 0808 	addle.w	r8, r8, #8
 800a9dc:	9117      	str	r1, [sp, #92]	; 0x5c
 800a9de:	f300 83c3 	bgt.w	800b168 <_svfiprintf_r+0x80c>
 800a9e2:	9f06      	ldr	r7, [sp, #24]
 800a9e4:	19bf      	adds	r7, r7, r6
 800a9e6:	9706      	str	r7, [sp, #24]
 800a9e8:	7823      	ldrb	r3, [r4, #0]
 800a9ea:	2b00      	cmp	r3, #0
 800a9ec:	f000 8341 	beq.w	800b072 <_svfiprintf_r+0x716>
 800a9f0:	2300      	movs	r3, #0
 800a9f2:	1c65      	adds	r5, r4, #1
 800a9f4:	461a      	mov	r2, r3
 800a9f6:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 800a9fa:	f04f 37ff 	mov.w	r7, #4294967295
 800a9fe:	7863      	ldrb	r3, [r4, #1]
 800aa00:	4614      	mov	r4, r2
 800aa02:	9209      	str	r2, [sp, #36]	; 0x24
 800aa04:	3501      	adds	r5, #1
 800aa06:	f1a3 0120 	sub.w	r1, r3, #32
 800aa0a:	2958      	cmp	r1, #88	; 0x58
 800aa0c:	f200 8235 	bhi.w	800ae7a <_svfiprintf_r+0x51e>
 800aa10:	e8df f011 	tbh	[pc, r1, lsl #1]
 800aa14:	02330179 	.word	0x02330179
 800aa18:	01750233 	.word	0x01750233
 800aa1c:	02330233 	.word	0x02330233
 800aa20:	02330233 	.word	0x02330233
 800aa24:	02330233 	.word	0x02330233
 800aa28:	019400d7 	.word	0x019400d7
 800aa2c:	00e40233 	.word	0x00e40233
 800aa30:	02330197 	.word	0x02330197
 800aa34:	017f0190 	.word	0x017f0190
 800aa38:	017f017f 	.word	0x017f017f
 800aa3c:	017f017f 	.word	0x017f017f
 800aa40:	017f017f 	.word	0x017f017f
 800aa44:	017f017f 	.word	0x017f017f
 800aa48:	02330233 	.word	0x02330233
 800aa4c:	02330233 	.word	0x02330233
 800aa50:	02330233 	.word	0x02330233
 800aa54:	02330233 	.word	0x02330233
 800aa58:	02330233 	.word	0x02330233
 800aa5c:	02330059 	.word	0x02330059
 800aa60:	02330233 	.word	0x02330233
 800aa64:	02330233 	.word	0x02330233
 800aa68:	02330233 	.word	0x02330233
 800aa6c:	02330233 	.word	0x02330233
 800aa70:	00cd0233 	.word	0x00cd0233
 800aa74:	02330233 	.word	0x02330233
 800aa78:	02330233 	.word	0x02330233
 800aa7c:	00b40233 	.word	0x00b40233
 800aa80:	02330233 	.word	0x02330233
 800aa84:	02330157 	.word	0x02330157
 800aa88:	02330233 	.word	0x02330233
 800aa8c:	02330233 	.word	0x02330233
 800aa90:	02330233 	.word	0x02330233
 800aa94:	02330233 	.word	0x02330233
 800aa98:	00e80233 	.word	0x00e80233
 800aa9c:	0233005b 	.word	0x0233005b
 800aaa0:	02330233 	.word	0x02330233
 800aaa4:	005b0204 	.word	0x005b0204
 800aaa8:	02330233 	.word	0x02330233
 800aaac:	023301f7 	.word	0x023301f7
 800aab0:	00cf0208 	.word	0x00cf0208
 800aab4:	01b301b7 	.word	0x01b301b7
 800aab8:	01d10233 	.word	0x01d10233
 800aabc:	00b60233 	.word	0x00b60233
 800aac0:	02330233 	.word	0x02330233
 800aac4:	021b      	.short	0x021b
 800aac6:	f044 0410 	orr.w	r4, r4, #16
 800aaca:	06a1      	lsls	r1, r4, #26
 800aacc:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800aad0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800aad2:	f140 83ca 	bpl.w	800b26a <_svfiprintf_r+0x90e>
 800aad6:	1df3      	adds	r3, r6, #7
 800aad8:	f023 0307 	bic.w	r3, r3, #7
 800aadc:	f103 0608 	add.w	r6, r3, #8
 800aae0:	960b      	str	r6, [sp, #44]	; 0x2c
 800aae2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aae6:	4692      	mov	sl, r2
 800aae8:	469b      	mov	fp, r3
 800aaea:	2a00      	cmp	r2, #0
 800aaec:	f173 0000 	sbcs.w	r0, r3, #0
 800aaf0:	f2c0 8424 	blt.w	800b33c <_svfiprintf_r+0x9e0>
 800aaf4:	ea5a 010b 	orrs.w	r1, sl, fp
 800aaf8:	f89d 904f 	ldrb.w	r9, [sp, #79]	; 0x4f
 800aafc:	bf0c      	ite	eq
 800aafe:	2600      	moveq	r6, #0
 800ab00:	2601      	movne	r6, #1
 800ab02:	2301      	movs	r3, #1
 800ab04:	2f00      	cmp	r7, #0
 800ab06:	bfa8      	it	ge
 800ab08:	f024 0480 	bicge.w	r4, r4, #128	; 0x80
 800ab0c:	2f00      	cmp	r7, #0
 800ab0e:	bf18      	it	ne
 800ab10:	f046 0601 	orrne.w	r6, r6, #1
 800ab14:	2e00      	cmp	r6, #0
 800ab16:	f000 829b 	beq.w	800b050 <_svfiprintf_r+0x6f4>
 800ab1a:	2b01      	cmp	r3, #1
 800ab1c:	f000 8348 	beq.w	800b1b0 <_svfiprintf_r+0x854>
 800ab20:	2b02      	cmp	r3, #2
 800ab22:	f000 836c 	beq.w	800b1fe <_svfiprintf_r+0x8a2>
 800ab26:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 800ab2a:	46bc      	mov	ip, r7
 800ab2c:	ea4f 01da 	mov.w	r1, sl, lsr #3
 800ab30:	2607      	movs	r6, #7
 800ab32:	ea41 714b 	orr.w	r1, r1, fp, lsl #29
 800ab36:	ea4f 03db 	mov.w	r3, fp, lsr #3
 800ab3a:	ea0a 0206 	and.w	r2, sl, r6
 800ab3e:	469b      	mov	fp, r3
 800ab40:	468a      	mov	sl, r1
 800ab42:	4606      	mov	r6, r0
 800ab44:	3230      	adds	r2, #48	; 0x30
 800ab46:	3801      	subs	r0, #1
 800ab48:	ea5a 070b 	orrs.w	r7, sl, fp
 800ab4c:	b2d2      	uxtb	r2, r2
 800ab4e:	7032      	strb	r2, [r6, #0]
 800ab50:	d1ec      	bne.n	800ab2c <_svfiprintf_r+0x1d0>
 800ab52:	07e1      	lsls	r1, r4, #31
 800ab54:	4667      	mov	r7, ip
 800ab56:	4633      	mov	r3, r6
 800ab58:	f100 83af 	bmi.w	800b2ba <_svfiprintf_r+0x95e>
 800ab5c:	9b03      	ldr	r3, [sp, #12]
 800ab5e:	1b9b      	subs	r3, r3, r6
 800ab60:	9305      	str	r3, [sp, #20]
 800ab62:	9707      	str	r7, [sp, #28]
 800ab64:	f8dd b014 	ldr.w	fp, [sp, #20]
 800ab68:	9f07      	ldr	r7, [sp, #28]
 800ab6a:	45bb      	cmp	fp, r7
 800ab6c:	bfb8      	it	lt
 800ab6e:	46bb      	movlt	fp, r7
 800ab70:	f1b9 0f00 	cmp.w	r9, #0
 800ab74:	d047      	beq.n	800ac06 <_svfiprintf_r+0x2aa>
 800ab76:	f10b 0b01 	add.w	fp, fp, #1
 800ab7a:	e044      	b.n	800ac06 <_svfiprintf_r+0x2aa>
 800ab7c:	f044 0410 	orr.w	r4, r4, #16
 800ab80:	06a2      	lsls	r2, r4, #26
 800ab82:	f140 8360 	bpl.w	800b246 <_svfiprintf_r+0x8ea>
 800ab86:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800ab88:	2301      	movs	r3, #1
 800ab8a:	1df2      	adds	r2, r6, #7
 800ab8c:	f022 0207 	bic.w	r2, r2, #7
 800ab90:	f102 0608 	add.w	r6, r2, #8
 800ab94:	960b      	str	r6, [sp, #44]	; 0x2c
 800ab96:	e9d2 ab00 	ldrd	sl, fp, [r2]
 800ab9a:	ea5a 000b 	orrs.w	r0, sl, fp
 800ab9e:	bf0c      	ite	eq
 800aba0:	2600      	moveq	r6, #0
 800aba2:	2601      	movne	r6, #1
 800aba4:	f04f 0900 	mov.w	r9, #0
 800aba8:	f88d 904f 	strb.w	r9, [sp, #79]	; 0x4f
 800abac:	e7aa      	b.n	800ab04 <_svfiprintf_r+0x1a8>
 800abae:	f044 0410 	orr.w	r4, r4, #16
 800abb2:	f014 0320 	ands.w	r3, r4, #32
 800abb6:	f000 833b 	beq.w	800b230 <_svfiprintf_r+0x8d4>
 800abba:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800abbc:	2300      	movs	r3, #0
 800abbe:	1df2      	adds	r2, r6, #7
 800abc0:	e7e4      	b.n	800ab8c <_svfiprintf_r+0x230>
 800abc2:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800abc4:	6836      	ldr	r6, [r6, #0]
 800abc6:	9609      	str	r6, [sp, #36]	; 0x24
 800abc8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800abca:	1d31      	adds	r1, r6, #4
 800abcc:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800abce:	2e00      	cmp	r6, #0
 800abd0:	f280 8365 	bge.w	800b29e <_svfiprintf_r+0x942>
 800abd4:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800abd6:	910b      	str	r1, [sp, #44]	; 0x2c
 800abd8:	4276      	negs	r6, r6
 800abda:	9609      	str	r6, [sp, #36]	; 0x24
 800abdc:	f044 0404 	orr.w	r4, r4, #4
 800abe0:	782b      	ldrb	r3, [r5, #0]
 800abe2:	e70f      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800abe4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800abe6:	ae18      	add	r6, sp, #96	; 0x60
 800abe8:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800abea:	f04f 0b01 	mov.w	fp, #1
 800abee:	2200      	movs	r2, #0
 800abf0:	f8cd b014 	str.w	fp, [sp, #20]
 800abf4:	681b      	ldr	r3, [r3, #0]
 800abf6:	3704      	adds	r7, #4
 800abf8:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800abfc:	970b      	str	r7, [sp, #44]	; 0x2c
 800abfe:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 800ac02:	2300      	movs	r3, #0
 800ac04:	9307      	str	r3, [sp, #28]
 800ac06:	f014 0302 	ands.w	r3, r4, #2
 800ac0a:	9308      	str	r3, [sp, #32]
 800ac0c:	bf18      	it	ne
 800ac0e:	f10b 0b02 	addne.w	fp, fp, #2
 800ac12:	f014 0784 	ands.w	r7, r4, #132	; 0x84
 800ac16:	970c      	str	r7, [sp, #48]	; 0x30
 800ac18:	f040 813f 	bne.w	800ae9a <_svfiprintf_r+0x53e>
 800ac1c:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800ac1e:	ebcb 0a07 	rsb	sl, fp, r7
 800ac22:	f1ba 0f00 	cmp.w	sl, #0
 800ac26:	f340 8138 	ble.w	800ae9a <_svfiprintf_r+0x53e>
 800ac2a:	f1ba 0f10 	cmp.w	sl, #16
 800ac2e:	f64c 79f8 	movw	r9, #53240	; 0xcff8
 800ac32:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800ac34:	f6c0 0900 	movt	r9, #2048	; 0x800
 800ac38:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800ac3a:	dd29      	ble.n	800ac90 <_svfiprintf_r+0x334>
 800ac3c:	950f      	str	r5, [sp, #60]	; 0x3c
 800ac3e:	2710      	movs	r7, #16
 800ac40:	9410      	str	r4, [sp, #64]	; 0x40
 800ac42:	4655      	mov	r5, sl
 800ac44:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800ac46:	46ca      	mov	sl, r9
 800ac48:	46b1      	mov	r9, r6
 800ac4a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800ac4c:	e002      	b.n	800ac54 <_svfiprintf_r+0x2f8>
 800ac4e:	3d10      	subs	r5, #16
 800ac50:	2d10      	cmp	r5, #16
 800ac52:	dd18      	ble.n	800ac86 <_svfiprintf_r+0x32a>
 800ac54:	3201      	adds	r2, #1
 800ac56:	3110      	adds	r1, #16
 800ac58:	2a07      	cmp	r2, #7
 800ac5a:	e888 00c0 	stmia.w	r8, {r6, r7}
 800ac5e:	9216      	str	r2, [sp, #88]	; 0x58
 800ac60:	f108 0808 	add.w	r8, r8, #8
 800ac64:	9117      	str	r1, [sp, #92]	; 0x5c
 800ac66:	ddf2      	ble.n	800ac4e <_svfiprintf_r+0x2f2>
 800ac68:	4620      	mov	r0, r4
 800ac6a:	9904      	ldr	r1, [sp, #16]
 800ac6c:	aa15      	add	r2, sp, #84	; 0x54
 800ac6e:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800ac72:	f7ff fded 	bl	800a850 <__ssprint_r>
 800ac76:	2800      	cmp	r0, #0
 800ac78:	f040 8202 	bne.w	800b080 <_svfiprintf_r+0x724>
 800ac7c:	3d10      	subs	r5, #16
 800ac7e:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800ac80:	2d10      	cmp	r5, #16
 800ac82:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800ac84:	dce6      	bgt.n	800ac54 <_svfiprintf_r+0x2f8>
 800ac86:	464e      	mov	r6, r9
 800ac88:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800ac8a:	46d1      	mov	r9, sl
 800ac8c:	46aa      	mov	sl, r5
 800ac8e:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 800ac90:	3201      	adds	r2, #1
 800ac92:	e888 0600 	stmia.w	r8, {r9, sl}
 800ac96:	2a07      	cmp	r2, #7
 800ac98:	4451      	add	r1, sl
 800ac9a:	9216      	str	r2, [sp, #88]	; 0x58
 800ac9c:	bfd8      	it	le
 800ac9e:	f108 0808 	addle.w	r8, r8, #8
 800aca2:	9117      	str	r1, [sp, #92]	; 0x5c
 800aca4:	f340 80fb 	ble.w	800ae9e <_svfiprintf_r+0x542>
 800aca8:	980a      	ldr	r0, [sp, #40]	; 0x28
 800acaa:	aa15      	add	r2, sp, #84	; 0x54
 800acac:	9904      	ldr	r1, [sp, #16]
 800acae:	f7ff fdcf 	bl	800a850 <__ssprint_r>
 800acb2:	2800      	cmp	r0, #0
 800acb4:	f040 81e4 	bne.w	800b080 <_svfiprintf_r+0x724>
 800acb8:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800acba:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800acbe:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800acc0:	e0ed      	b.n	800ae9e <_svfiprintf_r+0x542>
 800acc2:	06a0      	lsls	r0, r4, #26
 800acc4:	f24d 1668 	movw	r6, #53608	; 0xd168
 800acc8:	f6c0 0600 	movt	r6, #2048	; 0x800
 800accc:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800acd0:	960e      	str	r6, [sp, #56]	; 0x38
 800acd2:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800acd4:	f140 80c4 	bpl.w	800ae60 <_svfiprintf_r+0x504>
 800acd8:	1df2      	adds	r2, r6, #7
 800acda:	f022 0207 	bic.w	r2, r2, #7
 800acde:	f102 0608 	add.w	r6, r2, #8
 800ace2:	960b      	str	r6, [sp, #44]	; 0x2c
 800ace4:	e9d2 ab00 	ldrd	sl, fp, [r2]
 800ace8:	07e0      	lsls	r0, r4, #31
 800acea:	f100 82cb 	bmi.w	800b284 <_svfiprintf_r+0x928>
 800acee:	ea5a 000b 	orrs.w	r0, sl, fp
 800acf2:	f04f 0302 	mov.w	r3, #2
 800acf6:	bf0c      	ite	eq
 800acf8:	2600      	moveq	r6, #0
 800acfa:	2601      	movne	r6, #1
 800acfc:	e752      	b.n	800aba4 <_svfiprintf_r+0x248>
 800acfe:	f044 0401 	orr.w	r4, r4, #1
 800ad02:	782b      	ldrb	r3, [r5, #0]
 800ad04:	e67e      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ad06:	782b      	ldrb	r3, [r5, #0]
 800ad08:	2a00      	cmp	r2, #0
 800ad0a:	f47f ae7b 	bne.w	800aa04 <_svfiprintf_r+0xa8>
 800ad0e:	2220      	movs	r2, #32
 800ad10:	e678      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ad12:	4628      	mov	r0, r5
 800ad14:	2100      	movs	r1, #0
 800ad16:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
 800ad1a:	f810 3b01 	ldrb.w	r3, [r0], #1
 800ad1e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800ad22:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 800ad26:	4605      	mov	r5, r0
 800ad28:	2e09      	cmp	r6, #9
 800ad2a:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
 800ad2e:	d9f2      	bls.n	800ad16 <_svfiprintf_r+0x3ba>
 800ad30:	9109      	str	r1, [sp, #36]	; 0x24
 800ad32:	e668      	b.n	800aa06 <_svfiprintf_r+0xaa>
 800ad34:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 800ad38:	782b      	ldrb	r3, [r5, #0]
 800ad3a:	e663      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ad3c:	782b      	ldrb	r3, [r5, #0]
 800ad3e:	222b      	movs	r2, #43	; 0x2b
 800ad40:	e660      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ad42:	4628      	mov	r0, r5
 800ad44:	f810 3b01 	ldrb.w	r3, [r0], #1
 800ad48:	2b2a      	cmp	r3, #42	; 0x2a
 800ad4a:	f000 8349 	beq.w	800b3e0 <_svfiprintf_r+0xa84>
 800ad4e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 800ad52:	2700      	movs	r7, #0
 800ad54:	2909      	cmp	r1, #9
 800ad56:	4605      	mov	r5, r0
 800ad58:	f63f ae55 	bhi.w	800aa06 <_svfiprintf_r+0xaa>
 800ad5c:	2700      	movs	r7, #0
 800ad5e:	f810 3b01 	ldrb.w	r3, [r0], #1
 800ad62:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 800ad66:	eb01 0747 	add.w	r7, r1, r7, lsl #1
 800ad6a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 800ad6e:	2909      	cmp	r1, #9
 800ad70:	4605      	mov	r5, r0
 800ad72:	d9f4      	bls.n	800ad5e <_svfiprintf_r+0x402>
 800ad74:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 800ad78:	e645      	b.n	800aa06 <_svfiprintf_r+0xaa>
 800ad7a:	f044 0420 	orr.w	r4, r4, #32
 800ad7e:	782b      	ldrb	r3, [r5, #0]
 800ad80:	e640      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ad82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ad84:	f04f 0b00 	mov.w	fp, #0
 800ad88:	f24d 117c 	movw	r1, #53628	; 0xd17c
 800ad8c:	f044 0402 	orr.w	r4, r4, #2
 800ad90:	1d18      	adds	r0, r3, #4
 800ad92:	f6c0 0100 	movt	r1, #2048	; 0x800
 800ad96:	681e      	ldr	r6, [r3, #0]
 800ad98:	2330      	movs	r3, #48	; 0x30
 800ad9a:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 800ad9e:	2378      	movs	r3, #120	; 0x78
 800ada0:	46b2      	mov	sl, r6
 800ada2:	ebb6 060b 	subs.w	r6, r6, fp
 800ada6:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
 800adaa:	bf18      	it	ne
 800adac:	2601      	movne	r6, #1
 800adae:	900b      	str	r0, [sp, #44]	; 0x2c
 800adb0:	2302      	movs	r3, #2
 800adb2:	910e      	str	r1, [sp, #56]	; 0x38
 800adb4:	e6f6      	b.n	800aba4 <_svfiprintf_r+0x248>
 800adb6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800adb8:	f04f 0b00 	mov.w	fp, #0
 800adbc:	f88d b04f 	strb.w	fp, [sp, #79]	; 0x4f
 800adc0:	f102 0a04 	add.w	sl, r2, #4
 800adc4:	6816      	ldr	r6, [r2, #0]
 800adc6:	2e00      	cmp	r6, #0
 800adc8:	f000 82f5 	beq.w	800b3b6 <_svfiprintf_r+0xa5a>
 800adcc:	2f00      	cmp	r7, #0
 800adce:	4630      	mov	r0, r6
 800add0:	f2c0 82d2 	blt.w	800b378 <_svfiprintf_r+0xa1c>
 800add4:	4659      	mov	r1, fp
 800add6:	463a      	mov	r2, r7
 800add8:	f7fe fe50 	bl	8009a7c <memchr>
 800addc:	2800      	cmp	r0, #0
 800adde:	f000 82f7 	beq.w	800b3d0 <_svfiprintf_r+0xa74>
 800ade2:	1b80      	subs	r0, r0, r6
 800ade4:	f89d 904f 	ldrb.w	r9, [sp, #79]	; 0x4f
 800ade8:	42b8      	cmp	r0, r7
 800adea:	9005      	str	r0, [sp, #20]
 800adec:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800adf0:	bfc4      	itt	gt
 800adf2:	9705      	strgt	r7, [sp, #20]
 800adf4:	f8cd b01c 	strgt.w	fp, [sp, #28]
 800adf8:	f73f aeb4 	bgt.w	800ab64 <_svfiprintf_r+0x208>
 800adfc:	f8cd b01c 	str.w	fp, [sp, #28]
 800ae00:	e6b0      	b.n	800ab64 <_svfiprintf_r+0x208>
 800ae02:	782b      	ldrb	r3, [r5, #0]
 800ae04:	4629      	mov	r1, r5
 800ae06:	2b6c      	cmp	r3, #108	; 0x6c
 800ae08:	bf18      	it	ne
 800ae0a:	f044 0410 	orrne.w	r4, r4, #16
 800ae0e:	f47f adf9 	bne.w	800aa04 <_svfiprintf_r+0xa8>
 800ae12:	3501      	adds	r5, #1
 800ae14:	f044 0420 	orr.w	r4, r4, #32
 800ae18:	784b      	ldrb	r3, [r1, #1]
 800ae1a:	e5f3      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ae1c:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 800ae20:	782b      	ldrb	r3, [r5, #0]
 800ae22:	e5ef      	b.n	800aa04 <_svfiprintf_r+0xa8>
 800ae24:	06a6      	lsls	r6, r4, #26
 800ae26:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800ae2a:	f100 829a 	bmi.w	800b362 <_svfiprintf_r+0xa06>
 800ae2e:	06e0      	lsls	r0, r4, #27
 800ae30:	f100 82aa 	bmi.w	800b388 <_svfiprintf_r+0xa2c>
 800ae34:	0661      	lsls	r1, r4, #25
 800ae36:	f140 82a7 	bpl.w	800b388 <_svfiprintf_r+0xa2c>
 800ae3a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800ae3c:	9e06      	ldr	r6, [sp, #24]
 800ae3e:	3704      	adds	r7, #4
 800ae40:	f857 3c04 	ldr.w	r3, [r7, #-4]
 800ae44:	970b      	str	r7, [sp, #44]	; 0x2c
 800ae46:	801e      	strh	r6, [r3, #0]
 800ae48:	e5ad      	b.n	800a9a6 <_svfiprintf_r+0x4a>
 800ae4a:	06a0      	lsls	r0, r4, #26
 800ae4c:	f24d 167c 	movw	r6, #53628	; 0xd17c
 800ae50:	f6c0 0600 	movt	r6, #2048	; 0x800
 800ae54:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800ae58:	960e      	str	r6, [sp, #56]	; 0x38
 800ae5a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800ae5c:	f53f af3c 	bmi.w	800acd8 <_svfiprintf_r+0x37c>
 800ae60:	06e1      	lsls	r1, r4, #27
 800ae62:	f100 8257 	bmi.w	800b314 <_svfiprintf_r+0x9b8>
 800ae66:	0662      	lsls	r2, r4, #25
 800ae68:	f140 8254 	bpl.w	800b314 <_svfiprintf_r+0x9b8>
 800ae6c:	f8b6 a000 	ldrh.w	sl, [r6]
 800ae70:	f04f 0b00 	mov.w	fp, #0
 800ae74:	3604      	adds	r6, #4
 800ae76:	960b      	str	r6, [sp, #44]	; 0x2c
 800ae78:	e736      	b.n	800ace8 <_svfiprintf_r+0x38c>
 800ae7a:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
 800ae7e:	2b00      	cmp	r3, #0
 800ae80:	f000 80f7 	beq.w	800b072 <_svfiprintf_r+0x716>
 800ae84:	f04f 0b01 	mov.w	fp, #1
 800ae88:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 800ae8c:	f8cd b014 	str.w	fp, [sp, #20]
 800ae90:	2300      	movs	r3, #0
 800ae92:	ae18      	add	r6, sp, #96	; 0x60
 800ae94:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
 800ae98:	e6b3      	b.n	800ac02 <_svfiprintf_r+0x2a6>
 800ae9a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800ae9c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800ae9e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 800aea2:	b183      	cbz	r3, 800aec6 <_svfiprintf_r+0x56a>
 800aea4:	3201      	adds	r2, #1
 800aea6:	f10d 034f 	add.w	r3, sp, #79	; 0x4f
 800aeaa:	f8c8 3000 	str.w	r3, [r8]
 800aeae:	2301      	movs	r3, #1
 800aeb0:	2a07      	cmp	r2, #7
 800aeb2:	f8c8 3004 	str.w	r3, [r8, #4]
 800aeb6:	4419      	add	r1, r3
 800aeb8:	9216      	str	r2, [sp, #88]	; 0x58
 800aeba:	9117      	str	r1, [sp, #92]	; 0x5c
 800aebc:	bfd8      	it	le
 800aebe:	f108 0808 	addle.w	r8, r8, #8
 800aec2:	f300 815b 	bgt.w	800b17c <_svfiprintf_r+0x820>
 800aec6:	9b08      	ldr	r3, [sp, #32]
 800aec8:	b17b      	cbz	r3, 800aeea <_svfiprintf_r+0x58e>
 800aeca:	3201      	adds	r2, #1
 800aecc:	ab14      	add	r3, sp, #80	; 0x50
 800aece:	f8c8 3000 	str.w	r3, [r8]
 800aed2:	2302      	movs	r3, #2
 800aed4:	2a07      	cmp	r2, #7
 800aed6:	f8c8 3004 	str.w	r3, [r8, #4]
 800aeda:	4419      	add	r1, r3
 800aedc:	9216      	str	r2, [sp, #88]	; 0x58
 800aede:	9117      	str	r1, [sp, #92]	; 0x5c
 800aee0:	bfd8      	it	le
 800aee2:	f108 0808 	addle.w	r8, r8, #8
 800aee6:	f300 8156 	bgt.w	800b196 <_svfiprintf_r+0x83a>
 800aeea:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 800aeec:	2f80      	cmp	r7, #128	; 0x80
 800aeee:	f000 80d6 	beq.w	800b09e <_svfiprintf_r+0x742>
 800aef2:	9807      	ldr	r0, [sp, #28]
 800aef4:	9b05      	ldr	r3, [sp, #20]
 800aef6:	1ac7      	subs	r7, r0, r3
 800aef8:	2f00      	cmp	r7, #0
 800aefa:	dd48      	ble.n	800af8e <_svfiprintf_r+0x632>
 800aefc:	2f10      	cmp	r7, #16
 800aefe:	f8df 9508 	ldr.w	r9, [pc, #1288]	; 800b408 <_svfiprintf_r+0xaac>
 800af02:	dd2c      	ble.n	800af5e <_svfiprintf_r+0x602>
 800af04:	464b      	mov	r3, r9
 800af06:	9507      	str	r5, [sp, #28]
 800af08:	9408      	str	r4, [sp, #32]
 800af0a:	46b1      	mov	r9, r6
 800af0c:	f04f 0a10 	mov.w	sl, #16
 800af10:	463e      	mov	r6, r7
 800af12:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800af14:	461f      	mov	r7, r3
 800af16:	9d04      	ldr	r5, [sp, #16]
 800af18:	e002      	b.n	800af20 <_svfiprintf_r+0x5c4>
 800af1a:	3e10      	subs	r6, #16
 800af1c:	2e10      	cmp	r6, #16
 800af1e:	dd18      	ble.n	800af52 <_svfiprintf_r+0x5f6>
 800af20:	3201      	adds	r2, #1
 800af22:	3110      	adds	r1, #16
 800af24:	2a07      	cmp	r2, #7
 800af26:	e888 0480 	stmia.w	r8, {r7, sl}
 800af2a:	9216      	str	r2, [sp, #88]	; 0x58
 800af2c:	f108 0808 	add.w	r8, r8, #8
 800af30:	9117      	str	r1, [sp, #92]	; 0x5c
 800af32:	ddf2      	ble.n	800af1a <_svfiprintf_r+0x5be>
 800af34:	4620      	mov	r0, r4
 800af36:	4629      	mov	r1, r5
 800af38:	aa15      	add	r2, sp, #84	; 0x54
 800af3a:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800af3e:	f7ff fc87 	bl	800a850 <__ssprint_r>
 800af42:	2800      	cmp	r0, #0
 800af44:	f040 809c 	bne.w	800b080 <_svfiprintf_r+0x724>
 800af48:	3e10      	subs	r6, #16
 800af4a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800af4c:	2e10      	cmp	r6, #16
 800af4e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800af50:	dce6      	bgt.n	800af20 <_svfiprintf_r+0x5c4>
 800af52:	463b      	mov	r3, r7
 800af54:	9d07      	ldr	r5, [sp, #28]
 800af56:	9c08      	ldr	r4, [sp, #32]
 800af58:	4637      	mov	r7, r6
 800af5a:	464e      	mov	r6, r9
 800af5c:	4699      	mov	r9, r3
 800af5e:	3201      	adds	r2, #1
 800af60:	f8c8 9000 	str.w	r9, [r8]
 800af64:	2a07      	cmp	r2, #7
 800af66:	f8c8 7004 	str.w	r7, [r8, #4]
 800af6a:	4439      	add	r1, r7
 800af6c:	9216      	str	r2, [sp, #88]	; 0x58
 800af6e:	9117      	str	r1, [sp, #92]	; 0x5c
 800af70:	bfd8      	it	le
 800af72:	f108 0808 	addle.w	r8, r8, #8
 800af76:	dd0a      	ble.n	800af8e <_svfiprintf_r+0x632>
 800af78:	980a      	ldr	r0, [sp, #40]	; 0x28
 800af7a:	aa15      	add	r2, sp, #84	; 0x54
 800af7c:	9904      	ldr	r1, [sp, #16]
 800af7e:	f7ff fc67 	bl	800a850 <__ssprint_r>
 800af82:	2800      	cmp	r0, #0
 800af84:	d17c      	bne.n	800b080 <_svfiprintf_r+0x724>
 800af86:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800af88:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800af8c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800af8e:	3201      	adds	r2, #1
 800af90:	9b05      	ldr	r3, [sp, #20]
 800af92:	2a07      	cmp	r2, #7
 800af94:	f8c8 6000 	str.w	r6, [r8]
 800af98:	4419      	add	r1, r3
 800af9a:	9216      	str	r2, [sp, #88]	; 0x58
 800af9c:	f8c8 3004 	str.w	r3, [r8, #4]
 800afa0:	bfd8      	it	le
 800afa2:	f108 0808 	addle.w	r8, r8, #8
 800afa6:	9117      	str	r1, [sp, #92]	; 0x5c
 800afa8:	f300 80c7 	bgt.w	800b13a <_svfiprintf_r+0x7de>
 800afac:	0763      	lsls	r3, r4, #29
 800afae:	d539      	bpl.n	800b024 <_svfiprintf_r+0x6c8>
 800afb0:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800afb2:	ebcb 0406 	rsb	r4, fp, r6
 800afb6:	2c00      	cmp	r4, #0
 800afb8:	dd34      	ble.n	800b024 <_svfiprintf_r+0x6c8>
 800afba:	2c10      	cmp	r4, #16
 800afbc:	f64c 79f8 	movw	r9, #53240	; 0xcff8
 800afc0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800afc2:	f6c0 0900 	movt	r9, #2048	; 0x800
 800afc6:	dd22      	ble.n	800b00e <_svfiprintf_r+0x6b2>
 800afc8:	9505      	str	r5, [sp, #20]
 800afca:	2610      	movs	r6, #16
 800afcc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800afce:	f8dd a010 	ldr.w	sl, [sp, #16]
 800afd2:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800afd4:	e002      	b.n	800afdc <_svfiprintf_r+0x680>
 800afd6:	3c10      	subs	r4, #16
 800afd8:	2c10      	cmp	r4, #16
 800afda:	dd17      	ble.n	800b00c <_svfiprintf_r+0x6b0>
 800afdc:	3201      	adds	r2, #1
 800afde:	3110      	adds	r1, #16
 800afe0:	2a07      	cmp	r2, #7
 800afe2:	e888 0060 	stmia.w	r8, {r5, r6}
 800afe6:	9216      	str	r2, [sp, #88]	; 0x58
 800afe8:	f108 0808 	add.w	r8, r8, #8
 800afec:	9117      	str	r1, [sp, #92]	; 0x5c
 800afee:	ddf2      	ble.n	800afd6 <_svfiprintf_r+0x67a>
 800aff0:	4638      	mov	r0, r7
 800aff2:	4651      	mov	r1, sl
 800aff4:	aa15      	add	r2, sp, #84	; 0x54
 800aff6:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800affa:	f7ff fc29 	bl	800a850 <__ssprint_r>
 800affe:	2800      	cmp	r0, #0
 800b000:	d13e      	bne.n	800b080 <_svfiprintf_r+0x724>
 800b002:	3c10      	subs	r4, #16
 800b004:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b006:	2c10      	cmp	r4, #16
 800b008:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b00a:	dce7      	bgt.n	800afdc <_svfiprintf_r+0x680>
 800b00c:	9d05      	ldr	r5, [sp, #20]
 800b00e:	3201      	adds	r2, #1
 800b010:	1861      	adds	r1, r4, r1
 800b012:	2a07      	cmp	r2, #7
 800b014:	f8c8 9000 	str.w	r9, [r8]
 800b018:	f8c8 4004 	str.w	r4, [r8, #4]
 800b01c:	9216      	str	r2, [sp, #88]	; 0x58
 800b01e:	9117      	str	r1, [sp, #92]	; 0x5c
 800b020:	f300 8141 	bgt.w	800b2a6 <_svfiprintf_r+0x94a>
 800b024:	9f06      	ldr	r7, [sp, #24]
 800b026:	9e09      	ldr	r6, [sp, #36]	; 0x24
 800b028:	45b3      	cmp	fp, r6
 800b02a:	bfac      	ite	ge
 800b02c:	445f      	addge	r7, fp
 800b02e:	19bf      	addlt	r7, r7, r6
 800b030:	9706      	str	r7, [sp, #24]
 800b032:	2900      	cmp	r1, #0
 800b034:	f040 808c 	bne.w	800b150 <_svfiprintf_r+0x7f4>
 800b038:	2300      	movs	r3, #0
 800b03a:	9316      	str	r3, [sp, #88]	; 0x58
 800b03c:	782b      	ldrb	r3, [r5, #0]
 800b03e:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b042:	2b00      	cmp	r3, #0
 800b044:	bf18      	it	ne
 800b046:	2b25      	cmpne	r3, #37	; 0x25
 800b048:	f47f acb3 	bne.w	800a9b2 <_svfiprintf_r+0x56>
 800b04c:	462c      	mov	r4, r5
 800b04e:	e4cb      	b.n	800a9e8 <_svfiprintf_r+0x8c>
 800b050:	2b00      	cmp	r3, #0
 800b052:	f040 8086 	bne.w	800b162 <_svfiprintf_r+0x806>
 800b056:	07e2      	lsls	r2, r4, #31
 800b058:	bf5c      	itt	pl
 800b05a:	9305      	strpl	r3, [sp, #20]
 800b05c:	ae22      	addpl	r6, sp, #136	; 0x88
 800b05e:	f57f ad80 	bpl.w	800ab62 <_svfiprintf_r+0x206>
 800b062:	9e11      	ldr	r6, [sp, #68]	; 0x44
 800b064:	2330      	movs	r3, #48	; 0x30
 800b066:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
 800b06a:	9605      	str	r6, [sp, #20]
 800b06c:	f10d 0687 	add.w	r6, sp, #135	; 0x87
 800b070:	e577      	b.n	800ab62 <_svfiprintf_r+0x206>
 800b072:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800b074:	b123      	cbz	r3, 800b080 <_svfiprintf_r+0x724>
 800b076:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b078:	aa15      	add	r2, sp, #84	; 0x54
 800b07a:	9904      	ldr	r1, [sp, #16]
 800b07c:	f7ff fbe8 	bl	800a850 <__ssprint_r>
 800b080:	9e04      	ldr	r6, [sp, #16]
 800b082:	9f06      	ldr	r7, [sp, #24]
 800b084:	89b3      	ldrh	r3, [r6, #12]
 800b086:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b08a:	b21b      	sxth	r3, r3
 800b08c:	2b00      	cmp	r3, #0
 800b08e:	bf18      	it	ne
 800b090:	f04f 37ff 	movne.w	r7, #4294967295
 800b094:	9706      	str	r7, [sp, #24]
 800b096:	9806      	ldr	r0, [sp, #24]
 800b098:	b033      	add	sp, #204	; 0xcc
 800b09a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b09e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800b0a0:	ebcb 0a07 	rsb	sl, fp, r7
 800b0a4:	f1ba 0f00 	cmp.w	sl, #0
 800b0a8:	f77f af23 	ble.w	800aef2 <_svfiprintf_r+0x596>
 800b0ac:	f1ba 0f10 	cmp.w	sl, #16
 800b0b0:	f8df 9354 	ldr.w	r9, [pc, #852]	; 800b408 <_svfiprintf_r+0xaac>
 800b0b4:	dd29      	ble.n	800b10a <_svfiprintf_r+0x7ae>
 800b0b6:	4653      	mov	r3, sl
 800b0b8:	9508      	str	r5, [sp, #32]
 800b0ba:	46b2      	mov	sl, r6
 800b0bc:	464d      	mov	r5, r9
 800b0be:	2710      	movs	r7, #16
 800b0c0:	46a1      	mov	r9, r4
 800b0c2:	461e      	mov	r6, r3
 800b0c4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800b0c6:	e002      	b.n	800b0ce <_svfiprintf_r+0x772>
 800b0c8:	3e10      	subs	r6, #16
 800b0ca:	2e10      	cmp	r6, #16
 800b0cc:	dd17      	ble.n	800b0fe <_svfiprintf_r+0x7a2>
 800b0ce:	3201      	adds	r2, #1
 800b0d0:	3110      	adds	r1, #16
 800b0d2:	2a07      	cmp	r2, #7
 800b0d4:	e888 00a0 	stmia.w	r8, {r5, r7}
 800b0d8:	9216      	str	r2, [sp, #88]	; 0x58
 800b0da:	f108 0808 	add.w	r8, r8, #8
 800b0de:	9117      	str	r1, [sp, #92]	; 0x5c
 800b0e0:	ddf2      	ble.n	800b0c8 <_svfiprintf_r+0x76c>
 800b0e2:	4620      	mov	r0, r4
 800b0e4:	9904      	ldr	r1, [sp, #16]
 800b0e6:	aa15      	add	r2, sp, #84	; 0x54
 800b0e8:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b0ec:	f7ff fbb0 	bl	800a850 <__ssprint_r>
 800b0f0:	2800      	cmp	r0, #0
 800b0f2:	d1c5      	bne.n	800b080 <_svfiprintf_r+0x724>
 800b0f4:	3e10      	subs	r6, #16
 800b0f6:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b0f8:	2e10      	cmp	r6, #16
 800b0fa:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b0fc:	dce7      	bgt.n	800b0ce <_svfiprintf_r+0x772>
 800b0fe:	4633      	mov	r3, r6
 800b100:	464c      	mov	r4, r9
 800b102:	46a9      	mov	r9, r5
 800b104:	9d08      	ldr	r5, [sp, #32]
 800b106:	4656      	mov	r6, sl
 800b108:	469a      	mov	sl, r3
 800b10a:	3201      	adds	r2, #1
 800b10c:	e888 0600 	stmia.w	r8, {r9, sl}
 800b110:	2a07      	cmp	r2, #7
 800b112:	4451      	add	r1, sl
 800b114:	9216      	str	r2, [sp, #88]	; 0x58
 800b116:	bfd8      	it	le
 800b118:	f108 0808 	addle.w	r8, r8, #8
 800b11c:	9117      	str	r1, [sp, #92]	; 0x5c
 800b11e:	f77f aee8 	ble.w	800aef2 <_svfiprintf_r+0x596>
 800b122:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b124:	aa15      	add	r2, sp, #84	; 0x54
 800b126:	9904      	ldr	r1, [sp, #16]
 800b128:	f7ff fb92 	bl	800a850 <__ssprint_r>
 800b12c:	2800      	cmp	r0, #0
 800b12e:	d1a7      	bne.n	800b080 <_svfiprintf_r+0x724>
 800b130:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b132:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b136:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b138:	e6db      	b.n	800aef2 <_svfiprintf_r+0x596>
 800b13a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b13c:	aa15      	add	r2, sp, #84	; 0x54
 800b13e:	9904      	ldr	r1, [sp, #16]
 800b140:	f7ff fb86 	bl	800a850 <__ssprint_r>
 800b144:	2800      	cmp	r0, #0
 800b146:	d19b      	bne.n	800b080 <_svfiprintf_r+0x724>
 800b148:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b14a:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b14e:	e72d      	b.n	800afac <_svfiprintf_r+0x650>
 800b150:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b152:	aa15      	add	r2, sp, #84	; 0x54
 800b154:	9904      	ldr	r1, [sp, #16]
 800b156:	f7ff fb7b 	bl	800a850 <__ssprint_r>
 800b15a:	2800      	cmp	r0, #0
 800b15c:	f43f af6c 	beq.w	800b038 <_svfiprintf_r+0x6dc>
 800b160:	e78e      	b.n	800b080 <_svfiprintf_r+0x724>
 800b162:	9605      	str	r6, [sp, #20]
 800b164:	ae22      	add	r6, sp, #136	; 0x88
 800b166:	e4fc      	b.n	800ab62 <_svfiprintf_r+0x206>
 800b168:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b16a:	aa15      	add	r2, sp, #84	; 0x54
 800b16c:	9904      	ldr	r1, [sp, #16]
 800b16e:	f7ff fb6f 	bl	800a850 <__ssprint_r>
 800b172:	2800      	cmp	r0, #0
 800b174:	d184      	bne.n	800b080 <_svfiprintf_r+0x724>
 800b176:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b17a:	e432      	b.n	800a9e2 <_svfiprintf_r+0x86>
 800b17c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b17e:	aa15      	add	r2, sp, #84	; 0x54
 800b180:	9904      	ldr	r1, [sp, #16]
 800b182:	f7ff fb65 	bl	800a850 <__ssprint_r>
 800b186:	2800      	cmp	r0, #0
 800b188:	f47f af7a 	bne.w	800b080 <_svfiprintf_r+0x724>
 800b18c:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b18e:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b192:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b194:	e697      	b.n	800aec6 <_svfiprintf_r+0x56a>
 800b196:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b198:	aa15      	add	r2, sp, #84	; 0x54
 800b19a:	9904      	ldr	r1, [sp, #16]
 800b19c:	f7ff fb58 	bl	800a850 <__ssprint_r>
 800b1a0:	2800      	cmp	r0, #0
 800b1a2:	f47f af6d 	bne.w	800b080 <_svfiprintf_r+0x724>
 800b1a6:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b1a8:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 800b1ac:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800b1ae:	e69c      	b.n	800aeea <_svfiprintf_r+0x58e>
 800b1b0:	f1bb 0f00 	cmp.w	fp, #0
 800b1b4:	bf08      	it	eq
 800b1b6:	f1ba 0f0a 	cmpeq.w	sl, #10
 800b1ba:	f0c0 8089 	bcc.w	800b2d0 <_svfiprintf_r+0x974>
 800b1be:	f10d 0687 	add.w	r6, sp, #135	; 0x87
 800b1c2:	9405      	str	r4, [sp, #20]
 800b1c4:	4650      	mov	r0, sl
 800b1c6:	4659      	mov	r1, fp
 800b1c8:	220a      	movs	r2, #10
 800b1ca:	2300      	movs	r3, #0
 800b1cc:	f001 f9b8 	bl	800c540 <__aeabi_uldivmod>
 800b1d0:	4634      	mov	r4, r6
 800b1d2:	4650      	mov	r0, sl
 800b1d4:	4659      	mov	r1, fp
 800b1d6:	2300      	movs	r3, #0
 800b1d8:	3e01      	subs	r6, #1
 800b1da:	f102 0e30 	add.w	lr, r2, #48	; 0x30
 800b1de:	220a      	movs	r2, #10
 800b1e0:	f884 e000 	strb.w	lr, [r4]
 800b1e4:	f001 f9ac 	bl	800c540 <__aeabi_uldivmod>
 800b1e8:	4682      	mov	sl, r0
 800b1ea:	468b      	mov	fp, r1
 800b1ec:	ea5a 000b 	orrs.w	r0, sl, fp
 800b1f0:	d1e8      	bne.n	800b1c4 <_svfiprintf_r+0x868>
 800b1f2:	9b03      	ldr	r3, [sp, #12]
 800b1f4:	4626      	mov	r6, r4
 800b1f6:	9c05      	ldr	r4, [sp, #20]
 800b1f8:	1b9b      	subs	r3, r3, r6
 800b1fa:	9305      	str	r3, [sp, #20]
 800b1fc:	e4b1      	b.n	800ab62 <_svfiprintf_r+0x206>
 800b1fe:	980e      	ldr	r0, [sp, #56]	; 0x38
 800b200:	f10d 0187 	add.w	r1, sp, #135	; 0x87
 800b204:	9705      	str	r7, [sp, #20]
 800b206:	260f      	movs	r6, #15
 800b208:	ea4f 131a 	mov.w	r3, sl, lsr #4
 800b20c:	ea0a 0206 	and.w	r2, sl, r6
 800b210:	ea43 730b 	orr.w	r3, r3, fp, lsl #28
 800b214:	1882      	adds	r2, r0, r2
 800b216:	ea4f 1c1b 	mov.w	ip, fp, lsr #4
 800b21a:	469a      	mov	sl, r3
 800b21c:	46e3      	mov	fp, ip
 800b21e:	7812      	ldrb	r2, [r2, #0]
 800b220:	460e      	mov	r6, r1
 800b222:	3901      	subs	r1, #1
 800b224:	ea5a 070b 	orrs.w	r7, sl, fp
 800b228:	7032      	strb	r2, [r6, #0]
 800b22a:	d1ec      	bne.n	800b206 <_svfiprintf_r+0x8aa>
 800b22c:	9f05      	ldr	r7, [sp, #20]
 800b22e:	e495      	b.n	800ab5c <_svfiprintf_r+0x200>
 800b230:	f014 0210 	ands.w	r2, r4, #16
 800b234:	d155      	bne.n	800b2e2 <_svfiprintf_r+0x986>
 800b236:	f014 0340 	ands.w	r3, r4, #64	; 0x40
 800b23a:	d052      	beq.n	800b2e2 <_svfiprintf_r+0x986>
 800b23c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b23e:	4613      	mov	r3, r2
 800b240:	f8b6 a000 	ldrh.w	sl, [r6]
 800b244:	e007      	b.n	800b256 <_svfiprintf_r+0x8fa>
 800b246:	06e3      	lsls	r3, r4, #27
 800b248:	d457      	bmi.n	800b2fa <_svfiprintf_r+0x99e>
 800b24a:	0666      	lsls	r6, r4, #25
 800b24c:	d555      	bpl.n	800b2fa <_svfiprintf_r+0x99e>
 800b24e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b250:	2301      	movs	r3, #1
 800b252:	f8b6 a000 	ldrh.w	sl, [r6]
 800b256:	f04f 0b00 	mov.w	fp, #0
 800b25a:	3604      	adds	r6, #4
 800b25c:	ea5a 000b 	orrs.w	r0, sl, fp
 800b260:	960b      	str	r6, [sp, #44]	; 0x2c
 800b262:	bf0c      	ite	eq
 800b264:	2600      	moveq	r6, #0
 800b266:	2601      	movne	r6, #1
 800b268:	e49c      	b.n	800aba4 <_svfiprintf_r+0x248>
 800b26a:	06e2      	lsls	r2, r4, #27
 800b26c:	d459      	bmi.n	800b322 <_svfiprintf_r+0x9c6>
 800b26e:	0663      	lsls	r3, r4, #25
 800b270:	d557      	bpl.n	800b322 <_svfiprintf_r+0x9c6>
 800b272:	f9b6 a000 	ldrsh.w	sl, [r6]
 800b276:	3604      	adds	r6, #4
 800b278:	960b      	str	r6, [sp, #44]	; 0x2c
 800b27a:	4652      	mov	r2, sl
 800b27c:	ea4f 7bea 	mov.w	fp, sl, asr #31
 800b280:	465b      	mov	r3, fp
 800b282:	e432      	b.n	800aaea <_svfiprintf_r+0x18e>
 800b284:	ea5a 010b 	orrs.w	r1, sl, fp
 800b288:	d068      	beq.n	800b35c <_svfiprintf_r+0xa00>
 800b28a:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
 800b28e:	f044 0402 	orr.w	r4, r4, #2
 800b292:	2330      	movs	r3, #48	; 0x30
 800b294:	2601      	movs	r6, #1
 800b296:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 800b29a:	2302      	movs	r3, #2
 800b29c:	e482      	b.n	800aba4 <_svfiprintf_r+0x248>
 800b29e:	782b      	ldrb	r3, [r5, #0]
 800b2a0:	910b      	str	r1, [sp, #44]	; 0x2c
 800b2a2:	f7ff bbaf 	b.w	800aa04 <_svfiprintf_r+0xa8>
 800b2a6:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b2a8:	aa15      	add	r2, sp, #84	; 0x54
 800b2aa:	9904      	ldr	r1, [sp, #16]
 800b2ac:	f7ff fad0 	bl	800a850 <__ssprint_r>
 800b2b0:	2800      	cmp	r0, #0
 800b2b2:	f47f aee5 	bne.w	800b080 <_svfiprintf_r+0x724>
 800b2b6:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800b2b8:	e6b4      	b.n	800b024 <_svfiprintf_r+0x6c8>
 800b2ba:	2a30      	cmp	r2, #48	; 0x30
 800b2bc:	f43f ac4e 	beq.w	800ab5c <_svfiprintf_r+0x200>
 800b2c0:	4606      	mov	r6, r0
 800b2c2:	9803      	ldr	r0, [sp, #12]
 800b2c4:	2230      	movs	r2, #48	; 0x30
 800b2c6:	f803 2c01 	strb.w	r2, [r3, #-1]
 800b2ca:	1b80      	subs	r0, r0, r6
 800b2cc:	9005      	str	r0, [sp, #20]
 800b2ce:	e448      	b.n	800ab62 <_svfiprintf_r+0x206>
 800b2d0:	9e11      	ldr	r6, [sp, #68]	; 0x44
 800b2d2:	f10a 0a30 	add.w	sl, sl, #48	; 0x30
 800b2d6:	f88d a087 	strb.w	sl, [sp, #135]	; 0x87
 800b2da:	9605      	str	r6, [sp, #20]
 800b2dc:	f10d 0687 	add.w	r6, sp, #135	; 0x87
 800b2e0:	e43f      	b.n	800ab62 <_svfiprintf_r+0x206>
 800b2e2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800b2e4:	f04f 0b00 	mov.w	fp, #0
 800b2e8:	3104      	adds	r1, #4
 800b2ea:	f851 6c04 	ldr.w	r6, [r1, #-4]
 800b2ee:	910b      	str	r1, [sp, #44]	; 0x2c
 800b2f0:	46b2      	mov	sl, r6
 800b2f2:	3600      	adds	r6, #0
 800b2f4:	bf18      	it	ne
 800b2f6:	2601      	movne	r6, #1
 800b2f8:	e454      	b.n	800aba4 <_svfiprintf_r+0x248>
 800b2fa:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800b2fc:	2301      	movs	r3, #1
 800b2fe:	f04f 0b00 	mov.w	fp, #0
 800b302:	3104      	adds	r1, #4
 800b304:	f851 6c04 	ldr.w	r6, [r1, #-4]
 800b308:	910b      	str	r1, [sp, #44]	; 0x2c
 800b30a:	46b2      	mov	sl, r6
 800b30c:	3600      	adds	r6, #0
 800b30e:	bf18      	it	ne
 800b310:	2601      	movne	r6, #1
 800b312:	e447      	b.n	800aba4 <_svfiprintf_r+0x248>
 800b314:	6832      	ldr	r2, [r6, #0]
 800b316:	f04f 0b00 	mov.w	fp, #0
 800b31a:	3604      	adds	r6, #4
 800b31c:	960b      	str	r6, [sp, #44]	; 0x2c
 800b31e:	4692      	mov	sl, r2
 800b320:	e4e2      	b.n	800ace8 <_svfiprintf_r+0x38c>
 800b322:	6833      	ldr	r3, [r6, #0]
 800b324:	3604      	adds	r6, #4
 800b326:	960b      	str	r6, [sp, #44]	; 0x2c
 800b328:	461a      	mov	r2, r3
 800b32a:	469a      	mov	sl, r3
 800b32c:	ea4f 7be3 	mov.w	fp, r3, asr #31
 800b330:	465b      	mov	r3, fp
 800b332:	2a00      	cmp	r2, #0
 800b334:	f173 0000 	sbcs.w	r0, r3, #0
 800b338:	f6bf abdc 	bge.w	800aaf4 <_svfiprintf_r+0x198>
 800b33c:	f1da 0a00 	rsbs	sl, sl, #0
 800b340:	eb6b 0b4b 	sbc.w	fp, fp, fp, lsl #1
 800b344:	f04f 092d 	mov.w	r9, #45	; 0x2d
 800b348:	ea5a 020b 	orrs.w	r2, sl, fp
 800b34c:	f88d 904f 	strb.w	r9, [sp, #79]	; 0x4f
 800b350:	bf0c      	ite	eq
 800b352:	2600      	moveq	r6, #0
 800b354:	2601      	movne	r6, #1
 800b356:	2301      	movs	r3, #1
 800b358:	f7ff bbd4 	b.w	800ab04 <_svfiprintf_r+0x1a8>
 800b35c:	2600      	movs	r6, #0
 800b35e:	2302      	movs	r3, #2
 800b360:	e420      	b.n	800aba4 <_svfiprintf_r+0x248>
 800b362:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b364:	9a06      	ldr	r2, [sp, #24]
 800b366:	3604      	adds	r6, #4
 800b368:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800b36c:	17d1      	asrs	r1, r2, #31
 800b36e:	960b      	str	r6, [sp, #44]	; 0x2c
 800b370:	601a      	str	r2, [r3, #0]
 800b372:	6059      	str	r1, [r3, #4]
 800b374:	f7ff bb17 	b.w	800a9a6 <_svfiprintf_r+0x4a>
 800b378:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800b37c:	f7ff fa38 	bl	800a7f0 <strlen>
 800b380:	f89d 904f 	ldrb.w	r9, [sp, #79]	; 0x4f
 800b384:	9005      	str	r0, [sp, #20]
 800b386:	e539      	b.n	800adfc <_svfiprintf_r+0x4a0>
 800b388:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800b38a:	9e06      	ldr	r6, [sp, #24]
 800b38c:	3704      	adds	r7, #4
 800b38e:	f857 3c04 	ldr.w	r3, [r7, #-4]
 800b392:	970b      	str	r7, [sp, #44]	; 0x2c
 800b394:	601e      	str	r6, [r3, #0]
 800b396:	f7ff bb06 	b.w	800a9a6 <_svfiprintf_r+0x4a>
 800b39a:	2140      	movs	r1, #64	; 0x40
 800b39c:	9201      	str	r2, [sp, #4]
 800b39e:	f7fe f8a1 	bl	80094e4 <_malloc_r>
 800b3a2:	9e04      	ldr	r6, [sp, #16]
 800b3a4:	9a01      	ldr	r2, [sp, #4]
 800b3a6:	6030      	str	r0, [r6, #0]
 800b3a8:	6130      	str	r0, [r6, #16]
 800b3aa:	b328      	cbz	r0, 800b3f8 <_svfiprintf_r+0xa9c>
 800b3ac:	9e04      	ldr	r6, [sp, #16]
 800b3ae:	2340      	movs	r3, #64	; 0x40
 800b3b0:	6173      	str	r3, [r6, #20]
 800b3b2:	f7ff bae2 	b.w	800a97a <_svfiprintf_r+0x1e>
 800b3b6:	2f06      	cmp	r7, #6
 800b3b8:	bf28      	it	cs
 800b3ba:	2706      	movcs	r7, #6
 800b3bc:	f24d 1690 	movw	r6, #53648	; 0xd190
 800b3c0:	9705      	str	r7, [sp, #20]
 800b3c2:	ea27 7be7 	bic.w	fp, r7, r7, asr #31
 800b3c6:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800b3ca:	f6c0 0600 	movt	r6, #2048	; 0x800
 800b3ce:	e418      	b.n	800ac02 <_svfiprintf_r+0x2a6>
 800b3d0:	f89d 904f 	ldrb.w	r9, [sp, #79]	; 0x4f
 800b3d4:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800b3d8:	9705      	str	r7, [sp, #20]
 800b3da:	9007      	str	r0, [sp, #28]
 800b3dc:	f7ff bbc2 	b.w	800ab64 <_svfiprintf_r+0x208>
 800b3e0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800b3e2:	786b      	ldrb	r3, [r5, #1]
 800b3e4:	4605      	mov	r5, r0
 800b3e6:	1d31      	adds	r1, r6, #4
 800b3e8:	910b      	str	r1, [sp, #44]	; 0x2c
 800b3ea:	6837      	ldr	r7, [r6, #0]
 800b3ec:	2f00      	cmp	r7, #0
 800b3ee:	bfb8      	it	lt
 800b3f0:	f04f 37ff 	movlt.w	r7, #4294967295
 800b3f4:	f7ff bb06 	b.w	800aa04 <_svfiprintf_r+0xa8>
 800b3f8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800b3fa:	f04f 37ff 	mov.w	r7, #4294967295
 800b3fe:	230c      	movs	r3, #12
 800b400:	9706      	str	r7, [sp, #24]
 800b402:	6033      	str	r3, [r6, #0]
 800b404:	e647      	b.n	800b096 <_svfiprintf_r+0x73a>
 800b406:	bf00      	nop
 800b408:	0800d008 	.word	0x0800d008

0800b40c <_calloc_r>:
 800b40c:	b510      	push	{r4, lr}
 800b40e:	fb01 f102 	mul.w	r1, r1, r2
 800b412:	f7fe f867 	bl	80094e4 <_malloc_r>
 800b416:	4604      	mov	r4, r0
 800b418:	b170      	cbz	r0, 800b438 <_calloc_r+0x2c>
 800b41a:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800b41e:	f022 0203 	bic.w	r2, r2, #3
 800b422:	3a04      	subs	r2, #4
 800b424:	2a24      	cmp	r2, #36	; 0x24
 800b426:	d81c      	bhi.n	800b462 <_calloc_r+0x56>
 800b428:	2a13      	cmp	r2, #19
 800b42a:	bf98      	it	ls
 800b42c:	4603      	movls	r3, r0
 800b42e:	d805      	bhi.n	800b43c <_calloc_r+0x30>
 800b430:	2200      	movs	r2, #0
 800b432:	601a      	str	r2, [r3, #0]
 800b434:	605a      	str	r2, [r3, #4]
 800b436:	609a      	str	r2, [r3, #8]
 800b438:	4620      	mov	r0, r4
 800b43a:	bd10      	pop	{r4, pc}
 800b43c:	2100      	movs	r1, #0
 800b43e:	2a1b      	cmp	r2, #27
 800b440:	6001      	str	r1, [r0, #0]
 800b442:	bf98      	it	ls
 800b444:	f100 0308 	addls.w	r3, r0, #8
 800b448:	6041      	str	r1, [r0, #4]
 800b44a:	d9f1      	bls.n	800b430 <_calloc_r+0x24>
 800b44c:	2a24      	cmp	r2, #36	; 0x24
 800b44e:	6081      	str	r1, [r0, #8]
 800b450:	60c1      	str	r1, [r0, #12]
 800b452:	bf11      	iteee	ne
 800b454:	f100 0310 	addne.w	r3, r0, #16
 800b458:	6101      	streq	r1, [r0, #16]
 800b45a:	f100 0318 	addeq.w	r3, r0, #24
 800b45e:	6141      	streq	r1, [r0, #20]
 800b460:	e7e6      	b.n	800b430 <_calloc_r+0x24>
 800b462:	2100      	movs	r1, #0
 800b464:	f000 f868 	bl	800b538 <memset>
 800b468:	4620      	mov	r0, r4
 800b46a:	bd10      	pop	{r4, pc}

0800b46c <memmove>:
 800b46c:	4288      	cmp	r0, r1
 800b46e:	b4f0      	push	{r4, r5, r6, r7}
 800b470:	d911      	bls.n	800b496 <memmove+0x2a>
 800b472:	188c      	adds	r4, r1, r2
 800b474:	42a0      	cmp	r0, r4
 800b476:	d20e      	bcs.n	800b496 <memmove+0x2a>
 800b478:	1885      	adds	r5, r0, r2
 800b47a:	1e53      	subs	r3, r2, #1
 800b47c:	b14a      	cbz	r2, 800b492 <memmove+0x26>
 800b47e:	4621      	mov	r1, r4
 800b480:	462a      	mov	r2, r5
 800b482:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 800b486:	3b01      	subs	r3, #1
 800b488:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b48c:	f802 4d01 	strb.w	r4, [r2, #-1]!
 800b490:	d1f7      	bne.n	800b482 <memmove+0x16>
 800b492:	bcf0      	pop	{r4, r5, r6, r7}
 800b494:	4770      	bx	lr
 800b496:	2a0f      	cmp	r2, #15
 800b498:	d947      	bls.n	800b52a <memmove+0xbe>
 800b49a:	ea41 0300 	orr.w	r3, r1, r0
 800b49e:	079b      	lsls	r3, r3, #30
 800b4a0:	d145      	bne.n	800b52e <memmove+0xc2>
 800b4a2:	460c      	mov	r4, r1
 800b4a4:	4603      	mov	r3, r0
 800b4a6:	4615      	mov	r5, r2
 800b4a8:	6826      	ldr	r6, [r4, #0]
 800b4aa:	3310      	adds	r3, #16
 800b4ac:	3410      	adds	r4, #16
 800b4ae:	3d10      	subs	r5, #16
 800b4b0:	2d0f      	cmp	r5, #15
 800b4b2:	f843 6c10 	str.w	r6, [r3, #-16]
 800b4b6:	f854 6c0c 	ldr.w	r6, [r4, #-12]
 800b4ba:	f843 6c0c 	str.w	r6, [r3, #-12]
 800b4be:	f854 6c08 	ldr.w	r6, [r4, #-8]
 800b4c2:	f843 6c08 	str.w	r6, [r3, #-8]
 800b4c6:	f854 6c04 	ldr.w	r6, [r4, #-4]
 800b4ca:	f843 6c04 	str.w	r6, [r3, #-4]
 800b4ce:	d8eb      	bhi.n	800b4a8 <memmove+0x3c>
 800b4d0:	f1a2 0510 	sub.w	r5, r2, #16
 800b4d4:	f002 040f 	and.w	r4, r2, #15
 800b4d8:	f025 050f 	bic.w	r5, r5, #15
 800b4dc:	3510      	adds	r5, #16
 800b4de:	2c03      	cmp	r4, #3
 800b4e0:	eb00 0305 	add.w	r3, r0, r5
 800b4e4:	4429      	add	r1, r5
 800b4e6:	d924      	bls.n	800b532 <memmove+0xc6>
 800b4e8:	f1a4 0c04 	sub.w	ip, r4, #4
 800b4ec:	461d      	mov	r5, r3
 800b4ee:	460c      	mov	r4, r1
 800b4f0:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
 800b4f4:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 800b4f8:	3704      	adds	r7, #4
 800b4fa:	f854 6b04 	ldr.w	r6, [r4], #4
 800b4fe:	42bc      	cmp	r4, r7
 800b500:	f845 6b04 	str.w	r6, [r5], #4
 800b504:	d1f9      	bne.n	800b4fa <memmove+0x8e>
 800b506:	f10c 0401 	add.w	r4, ip, #1
 800b50a:	f002 0203 	and.w	r2, r2, #3
 800b50e:	00a4      	lsls	r4, r4, #2
 800b510:	1909      	adds	r1, r1, r4
 800b512:	191b      	adds	r3, r3, r4
 800b514:	2a00      	cmp	r2, #0
 800b516:	d0bc      	beq.n	800b492 <memmove+0x26>
 800b518:	3901      	subs	r1, #1
 800b51a:	189a      	adds	r2, r3, r2
 800b51c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800b520:	f803 4b01 	strb.w	r4, [r3], #1
 800b524:	4293      	cmp	r3, r2
 800b526:	d1f9      	bne.n	800b51c <memmove+0xb0>
 800b528:	e7b3      	b.n	800b492 <memmove+0x26>
 800b52a:	4603      	mov	r3, r0
 800b52c:	e7f2      	b.n	800b514 <memmove+0xa8>
 800b52e:	4603      	mov	r3, r0
 800b530:	e7f2      	b.n	800b518 <memmove+0xac>
 800b532:	4622      	mov	r2, r4
 800b534:	e7ee      	b.n	800b514 <memmove+0xa8>
 800b536:	bf00      	nop

0800b538 <memset>:
 800b538:	2a03      	cmp	r2, #3
 800b53a:	b2c9      	uxtb	r1, r1
 800b53c:	b470      	push	{r4, r5, r6}
 800b53e:	d808      	bhi.n	800b552 <memset+0x1a>
 800b540:	b12a      	cbz	r2, 800b54e <memset+0x16>
 800b542:	4603      	mov	r3, r0
 800b544:	1812      	adds	r2, r2, r0
 800b546:	f803 1b01 	strb.w	r1, [r3], #1
 800b54a:	4293      	cmp	r3, r2
 800b54c:	d1fb      	bne.n	800b546 <memset+0xe>
 800b54e:	bc70      	pop	{r4, r5, r6}
 800b550:	4770      	bx	lr
 800b552:	0783      	lsls	r3, r0, #30
 800b554:	4402      	add	r2, r0
 800b556:	d009      	beq.n	800b56c <memset+0x34>
 800b558:	1c44      	adds	r4, r0, #1
 800b55a:	f004 0503 	and.w	r5, r4, #3
 800b55e:	4623      	mov	r3, r4
 800b560:	f804 1c01 	strb.w	r1, [r4, #-1]
 800b564:	3401      	adds	r4, #1
 800b566:	2d00      	cmp	r5, #0
 800b568:	d1f7      	bne.n	800b55a <memset+0x22>
 800b56a:	e000      	b.n	800b56e <memset+0x36>
 800b56c:	4603      	mov	r3, r0
 800b56e:	1ad5      	subs	r5, r2, r3
 800b570:	eb01 2401 	add.w	r4, r1, r1, lsl #8
 800b574:	2d3f      	cmp	r5, #63	; 0x3f
 800b576:	eb04 4404 	add.w	r4, r4, r4, lsl #16
 800b57a:	dd2c      	ble.n	800b5d6 <memset+0x9e>
 800b57c:	601c      	str	r4, [r3, #0]
 800b57e:	3340      	adds	r3, #64	; 0x40
 800b580:	1ad5      	subs	r5, r2, r3
 800b582:	f843 4c3c 	str.w	r4, [r3, #-60]
 800b586:	2d3f      	cmp	r5, #63	; 0x3f
 800b588:	f843 4c38 	str.w	r4, [r3, #-56]
 800b58c:	f843 4c34 	str.w	r4, [r3, #-52]
 800b590:	f843 4c30 	str.w	r4, [r3, #-48]
 800b594:	f843 4c2c 	str.w	r4, [r3, #-44]
 800b598:	f843 4c28 	str.w	r4, [r3, #-40]
 800b59c:	f843 4c24 	str.w	r4, [r3, #-36]
 800b5a0:	f843 4c20 	str.w	r4, [r3, #-32]
 800b5a4:	f843 4c1c 	str.w	r4, [r3, #-28]
 800b5a8:	f843 4c18 	str.w	r4, [r3, #-24]
 800b5ac:	f843 4c14 	str.w	r4, [r3, #-20]
 800b5b0:	f843 4c10 	str.w	r4, [r3, #-16]
 800b5b4:	f843 4c0c 	str.w	r4, [r3, #-12]
 800b5b8:	f843 4c08 	str.w	r4, [r3, #-8]
 800b5bc:	f843 4c04 	str.w	r4, [r3, #-4]
 800b5c0:	dcdc      	bgt.n	800b57c <memset+0x44>
 800b5c2:	e008      	b.n	800b5d6 <memset+0x9e>
 800b5c4:	601c      	str	r4, [r3, #0]
 800b5c6:	3310      	adds	r3, #16
 800b5c8:	1ad5      	subs	r5, r2, r3
 800b5ca:	f843 4c0c 	str.w	r4, [r3, #-12]
 800b5ce:	f843 4c08 	str.w	r4, [r3, #-8]
 800b5d2:	f843 4c04 	str.w	r4, [r3, #-4]
 800b5d6:	2d0f      	cmp	r5, #15
 800b5d8:	dcf4      	bgt.n	800b5c4 <memset+0x8c>
 800b5da:	2d03      	cmp	r5, #3
 800b5dc:	dd08      	ble.n	800b5f0 <memset+0xb8>
 800b5de:	1d1d      	adds	r5, r3, #4
 800b5e0:	1b56      	subs	r6, r2, r5
 800b5e2:	f845 4c04 	str.w	r4, [r5, #-4]
 800b5e6:	2e03      	cmp	r6, #3
 800b5e8:	462b      	mov	r3, r5
 800b5ea:	f105 0504 	add.w	r5, r5, #4
 800b5ee:	dcf7      	bgt.n	800b5e0 <memset+0xa8>
 800b5f0:	429a      	cmp	r2, r3
 800b5f2:	d9ac      	bls.n	800b54e <memset+0x16>
 800b5f4:	3301      	adds	r3, #1
 800b5f6:	3201      	adds	r2, #1
 800b5f8:	f803 1c01 	strb.w	r1, [r3, #-1]
 800b5fc:	3301      	adds	r3, #1
 800b5fe:	4293      	cmp	r3, r2
 800b600:	d1fa      	bne.n	800b5f8 <memset+0xc0>
 800b602:	e7a4      	b.n	800b54e <memset+0x16>

0800b604 <_realloc_r>:
 800b604:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b608:	460c      	mov	r4, r1
 800b60a:	b083      	sub	sp, #12
 800b60c:	4681      	mov	r9, r0
 800b60e:	4617      	mov	r7, r2
 800b610:	2900      	cmp	r1, #0
 800b612:	f000 811c 	beq.w	800b84e <_realloc_r+0x24a>
 800b616:	f107 050b 	add.w	r5, r7, #11
 800b61a:	f7fe fb33 	bl	8009c84 <__malloc_lock>
 800b61e:	f854 2c04 	ldr.w	r2, [r4, #-4]
 800b622:	2d16      	cmp	r5, #22
 800b624:	f1a4 0a08 	sub.w	sl, r4, #8
 800b628:	f022 0603 	bic.w	r6, r2, #3
 800b62c:	d875      	bhi.n	800b71a <_realloc_r+0x116>
 800b62e:	2110      	movs	r1, #16
 800b630:	2300      	movs	r3, #0
 800b632:	460d      	mov	r5, r1
 800b634:	42bd      	cmp	r5, r7
 800b636:	bf38      	it	cc
 800b638:	f043 0301 	orrcc.w	r3, r3, #1
 800b63c:	2b00      	cmp	r3, #0
 800b63e:	f040 810c 	bne.w	800b85a <_realloc_r+0x256>
 800b642:	428e      	cmp	r6, r1
 800b644:	da6e      	bge.n	800b724 <_realloc_r+0x120>
 800b646:	f240 2b30 	movw	fp, #560	; 0x230
 800b64a:	eb0a 0006 	add.w	r0, sl, r6
 800b64e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 800b652:	f8db e008 	ldr.w	lr, [fp, #8]
 800b656:	4586      	cmp	lr, r0
 800b658:	f000 8104 	beq.w	800b864 <_realloc_r+0x260>
 800b65c:	f8d0 c004 	ldr.w	ip, [r0, #4]
 800b660:	f02c 0801 	bic.w	r8, ip, #1
 800b664:	4480      	add	r8, r0
 800b666:	f8d8 8004 	ldr.w	r8, [r8, #4]
 800b66a:	f018 0f01 	tst.w	r8, #1
 800b66e:	bf1c      	itt	ne
 800b670:	469c      	movne	ip, r3
 800b672:	4660      	movne	r0, ip
 800b674:	d06f      	beq.n	800b756 <_realloc_r+0x152>
 800b676:	07d3      	lsls	r3, r2, #31
 800b678:	f100 80c3 	bmi.w	800b802 <_realloc_r+0x1fe>
 800b67c:	f854 3c08 	ldr.w	r3, [r4, #-8]
 800b680:	ebc3 030a 	rsb	r3, r3, sl
 800b684:	685a      	ldr	r2, [r3, #4]
 800b686:	f022 0203 	bic.w	r2, r2, #3
 800b68a:	1992      	adds	r2, r2, r6
 800b68c:	9201      	str	r2, [sp, #4]
 800b68e:	2800      	cmp	r0, #0
 800b690:	d06c      	beq.n	800b76c <_realloc_r+0x168>
 800b692:	4570      	cmp	r0, lr
 800b694:	f000 8137 	beq.w	800b906 <_realloc_r+0x302>
 800b698:	eb0c 0802 	add.w	r8, ip, r2
 800b69c:	4588      	cmp	r8, r1
 800b69e:	db65      	blt.n	800b76c <_realloc_r+0x168>
 800b6a0:	68c1      	ldr	r1, [r0, #12]
 800b6a2:	461f      	mov	r7, r3
 800b6a4:	6880      	ldr	r0, [r0, #8]
 800b6a6:	1f32      	subs	r2, r6, #4
 800b6a8:	2a24      	cmp	r2, #36	; 0x24
 800b6aa:	6088      	str	r0, [r1, #8]
 800b6ac:	60c1      	str	r1, [r0, #12]
 800b6ae:	f857 0f08 	ldr.w	r0, [r7, #8]!
 800b6b2:	68d9      	ldr	r1, [r3, #12]
 800b6b4:	60c1      	str	r1, [r0, #12]
 800b6b6:	6088      	str	r0, [r1, #8]
 800b6b8:	f200 8178 	bhi.w	800b9ac <_realloc_r+0x3a8>
 800b6bc:	2a13      	cmp	r2, #19
 800b6be:	bf9c      	itt	ls
 800b6c0:	4639      	movls	r1, r7
 800b6c2:	4620      	movls	r0, r4
 800b6c4:	d91f      	bls.n	800b706 <_realloc_r+0x102>
 800b6c6:	6821      	ldr	r1, [r4, #0]
 800b6c8:	2a1b      	cmp	r2, #27
 800b6ca:	bf98      	it	ls
 800b6cc:	f104 0008 	addls.w	r0, r4, #8
 800b6d0:	6099      	str	r1, [r3, #8]
 800b6d2:	6861      	ldr	r1, [r4, #4]
 800b6d4:	60d9      	str	r1, [r3, #12]
 800b6d6:	bf98      	it	ls
 800b6d8:	f103 0110 	addls.w	r1, r3, #16
 800b6dc:	d913      	bls.n	800b706 <_realloc_r+0x102>
 800b6de:	68a1      	ldr	r1, [r4, #8]
 800b6e0:	2a24      	cmp	r2, #36	; 0x24
 800b6e2:	bf14      	ite	ne
 800b6e4:	f104 0010 	addne.w	r0, r4, #16
 800b6e8:	f104 0018 	addeq.w	r0, r4, #24
 800b6ec:	6119      	str	r1, [r3, #16]
 800b6ee:	68e1      	ldr	r1, [r4, #12]
 800b6f0:	6159      	str	r1, [r3, #20]
 800b6f2:	bf11      	iteee	ne
 800b6f4:	f103 0118 	addne.w	r1, r3, #24
 800b6f8:	6922      	ldreq	r2, [r4, #16]
 800b6fa:	f103 0120 	addeq.w	r1, r3, #32
 800b6fe:	619a      	streq	r2, [r3, #24]
 800b700:	bf04      	itt	eq
 800b702:	6962      	ldreq	r2, [r4, #20]
 800b704:	61da      	streq	r2, [r3, #28]
 800b706:	6802      	ldr	r2, [r0, #0]
 800b708:	463c      	mov	r4, r7
 800b70a:	600a      	str	r2, [r1, #0]
 800b70c:	469a      	mov	sl, r3
 800b70e:	6842      	ldr	r2, [r0, #4]
 800b710:	604a      	str	r2, [r1, #4]
 800b712:	6882      	ldr	r2, [r0, #8]
 800b714:	608a      	str	r2, [r1, #8]
 800b716:	685a      	ldr	r2, [r3, #4]
 800b718:	e005      	b.n	800b726 <_realloc_r+0x122>
 800b71a:	f025 0507 	bic.w	r5, r5, #7
 800b71e:	4629      	mov	r1, r5
 800b720:	0feb      	lsrs	r3, r5, #31
 800b722:	e787      	b.n	800b634 <_realloc_r+0x30>
 800b724:	46b0      	mov	r8, r6
 800b726:	ebc5 0308 	rsb	r3, r5, r8
 800b72a:	2b0f      	cmp	r3, #15
 800b72c:	d855      	bhi.n	800b7da <_realloc_r+0x1d6>
 800b72e:	eb0a 0308 	add.w	r3, sl, r8
 800b732:	f002 0201 	and.w	r2, r2, #1
 800b736:	ea42 0208 	orr.w	r2, r2, r8
 800b73a:	f8ca 2004 	str.w	r2, [sl, #4]
 800b73e:	685a      	ldr	r2, [r3, #4]
 800b740:	f042 0201 	orr.w	r2, r2, #1
 800b744:	605a      	str	r2, [r3, #4]
 800b746:	4648      	mov	r0, r9
 800b748:	4627      	mov	r7, r4
 800b74a:	f7fe fa9d 	bl	8009c88 <__malloc_unlock>
 800b74e:	4638      	mov	r0, r7
 800b750:	b003      	add	sp, #12
 800b752:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b756:	f02c 0c03 	bic.w	ip, ip, #3
 800b75a:	eb0c 0806 	add.w	r8, ip, r6
 800b75e:	4588      	cmp	r8, r1
 800b760:	db89      	blt.n	800b676 <_realloc_r+0x72>
 800b762:	68c3      	ldr	r3, [r0, #12]
 800b764:	6881      	ldr	r1, [r0, #8]
 800b766:	60cb      	str	r3, [r1, #12]
 800b768:	6099      	str	r1, [r3, #8]
 800b76a:	e7dc      	b.n	800b726 <_realloc_r+0x122>
 800b76c:	9a01      	ldr	r2, [sp, #4]
 800b76e:	428a      	cmp	r2, r1
 800b770:	db47      	blt.n	800b802 <_realloc_r+0x1fe>
 800b772:	461f      	mov	r7, r3
 800b774:	68d9      	ldr	r1, [r3, #12]
 800b776:	1f32      	subs	r2, r6, #4
 800b778:	f857 0f08 	ldr.w	r0, [r7, #8]!
 800b77c:	2a24      	cmp	r2, #36	; 0x24
 800b77e:	60c1      	str	r1, [r0, #12]
 800b780:	6088      	str	r0, [r1, #8]
 800b782:	f200 80b1 	bhi.w	800b8e8 <_realloc_r+0x2e4>
 800b786:	2a13      	cmp	r2, #19
 800b788:	bf9c      	itt	ls
 800b78a:	4639      	movls	r1, r7
 800b78c:	4620      	movls	r0, r4
 800b78e:	d91f      	bls.n	800b7d0 <_realloc_r+0x1cc>
 800b790:	6821      	ldr	r1, [r4, #0]
 800b792:	2a1b      	cmp	r2, #27
 800b794:	bf98      	it	ls
 800b796:	f104 0008 	addls.w	r0, r4, #8
 800b79a:	6099      	str	r1, [r3, #8]
 800b79c:	6861      	ldr	r1, [r4, #4]
 800b79e:	60d9      	str	r1, [r3, #12]
 800b7a0:	bf98      	it	ls
 800b7a2:	f103 0110 	addls.w	r1, r3, #16
 800b7a6:	d913      	bls.n	800b7d0 <_realloc_r+0x1cc>
 800b7a8:	68a1      	ldr	r1, [r4, #8]
 800b7aa:	2a24      	cmp	r2, #36	; 0x24
 800b7ac:	bf14      	ite	ne
 800b7ae:	f104 0010 	addne.w	r0, r4, #16
 800b7b2:	f104 0018 	addeq.w	r0, r4, #24
 800b7b6:	6119      	str	r1, [r3, #16]
 800b7b8:	68e1      	ldr	r1, [r4, #12]
 800b7ba:	6159      	str	r1, [r3, #20]
 800b7bc:	bf11      	iteee	ne
 800b7be:	f103 0118 	addne.w	r1, r3, #24
 800b7c2:	6922      	ldreq	r2, [r4, #16]
 800b7c4:	f103 0120 	addeq.w	r1, r3, #32
 800b7c8:	619a      	streq	r2, [r3, #24]
 800b7ca:	bf04      	itt	eq
 800b7cc:	6962      	ldreq	r2, [r4, #20]
 800b7ce:	61da      	streq	r2, [r3, #28]
 800b7d0:	6802      	ldr	r2, [r0, #0]
 800b7d2:	463c      	mov	r4, r7
 800b7d4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800b7d8:	e797      	b.n	800b70a <_realloc_r+0x106>
 800b7da:	eb0a 0105 	add.w	r1, sl, r5
 800b7de:	f002 0201 	and.w	r2, r2, #1
 800b7e2:	18ce      	adds	r6, r1, r3
 800b7e4:	4315      	orrs	r5, r2
 800b7e6:	f043 0301 	orr.w	r3, r3, #1
 800b7ea:	f8ca 5004 	str.w	r5, [sl, #4]
 800b7ee:	604b      	str	r3, [r1, #4]
 800b7f0:	4648      	mov	r0, r9
 800b7f2:	6873      	ldr	r3, [r6, #4]
 800b7f4:	3108      	adds	r1, #8
 800b7f6:	f043 0301 	orr.w	r3, r3, #1
 800b7fa:	6073      	str	r3, [r6, #4]
 800b7fc:	f7fd fd4a 	bl	8009294 <_free_r>
 800b800:	e7a1      	b.n	800b746 <_realloc_r+0x142>
 800b802:	4639      	mov	r1, r7
 800b804:	4648      	mov	r0, r9
 800b806:	f7fd fe6d 	bl	80094e4 <_malloc_r>
 800b80a:	4607      	mov	r7, r0
 800b80c:	b1d8      	cbz	r0, 800b846 <_realloc_r+0x242>
 800b80e:	f854 2c04 	ldr.w	r2, [r4, #-4]
 800b812:	f1a0 0108 	sub.w	r1, r0, #8
 800b816:	f022 0301 	bic.w	r3, r2, #1
 800b81a:	4453      	add	r3, sl
 800b81c:	4299      	cmp	r1, r3
 800b81e:	f000 80bf 	beq.w	800b9a0 <_realloc_r+0x39c>
 800b822:	1f32      	subs	r2, r6, #4
 800b824:	2a24      	cmp	r2, #36	; 0x24
 800b826:	d86a      	bhi.n	800b8fe <_realloc_r+0x2fa>
 800b828:	2a13      	cmp	r2, #19
 800b82a:	bf9c      	itt	ls
 800b82c:	4603      	movls	r3, r0
 800b82e:	4622      	movls	r2, r4
 800b830:	d839      	bhi.n	800b8a6 <_realloc_r+0x2a2>
 800b832:	6811      	ldr	r1, [r2, #0]
 800b834:	6019      	str	r1, [r3, #0]
 800b836:	6851      	ldr	r1, [r2, #4]
 800b838:	6059      	str	r1, [r3, #4]
 800b83a:	6892      	ldr	r2, [r2, #8]
 800b83c:	609a      	str	r2, [r3, #8]
 800b83e:	4648      	mov	r0, r9
 800b840:	4621      	mov	r1, r4
 800b842:	f7fd fd27 	bl	8009294 <_free_r>
 800b846:	4648      	mov	r0, r9
 800b848:	f7fe fa1e 	bl	8009c88 <__malloc_unlock>
 800b84c:	e77f      	b.n	800b74e <_realloc_r+0x14a>
 800b84e:	4611      	mov	r1, r2
 800b850:	b003      	add	sp, #12
 800b852:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b856:	f7fd be45 	b.w	80094e4 <_malloc_r>
 800b85a:	230c      	movs	r3, #12
 800b85c:	2700      	movs	r7, #0
 800b85e:	f8c9 3000 	str.w	r3, [r9]
 800b862:	e774      	b.n	800b74e <_realloc_r+0x14a>
 800b864:	f8de 3004 	ldr.w	r3, [lr, #4]
 800b868:	f105 0010 	add.w	r0, r5, #16
 800b86c:	f023 0c03 	bic.w	ip, r3, #3
 800b870:	eb0c 0306 	add.w	r3, ip, r6
 800b874:	4283      	cmp	r3, r0
 800b876:	bfb8      	it	lt
 800b878:	4670      	movlt	r0, lr
 800b87a:	f6ff aefc 	blt.w	800b676 <_realloc_r+0x72>
 800b87e:	eb0a 0205 	add.w	r2, sl, r5
 800b882:	1b5b      	subs	r3, r3, r5
 800b884:	f043 0301 	orr.w	r3, r3, #1
 800b888:	4648      	mov	r0, r9
 800b88a:	6053      	str	r3, [r2, #4]
 800b88c:	4627      	mov	r7, r4
 800b88e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800b892:	f8cb 2008 	str.w	r2, [fp, #8]
 800b896:	f003 0301 	and.w	r3, r3, #1
 800b89a:	431d      	orrs	r5, r3
 800b89c:	f844 5c04 	str.w	r5, [r4, #-4]
 800b8a0:	f7fe f9f2 	bl	8009c88 <__malloc_unlock>
 800b8a4:	e753      	b.n	800b74e <_realloc_r+0x14a>
 800b8a6:	6823      	ldr	r3, [r4, #0]
 800b8a8:	2a1b      	cmp	r2, #27
 800b8aa:	bf98      	it	ls
 800b8ac:	f104 0208 	addls.w	r2, r4, #8
 800b8b0:	6003      	str	r3, [r0, #0]
 800b8b2:	6863      	ldr	r3, [r4, #4]
 800b8b4:	6043      	str	r3, [r0, #4]
 800b8b6:	bf98      	it	ls
 800b8b8:	f100 0308 	addls.w	r3, r0, #8
 800b8bc:	d9b9      	bls.n	800b832 <_realloc_r+0x22e>
 800b8be:	68a3      	ldr	r3, [r4, #8]
 800b8c0:	2a24      	cmp	r2, #36	; 0x24
 800b8c2:	bf14      	ite	ne
 800b8c4:	f104 0210 	addne.w	r2, r4, #16
 800b8c8:	f104 0218 	addeq.w	r2, r4, #24
 800b8cc:	6083      	str	r3, [r0, #8]
 800b8ce:	68e3      	ldr	r3, [r4, #12]
 800b8d0:	60c3      	str	r3, [r0, #12]
 800b8d2:	bf11      	iteee	ne
 800b8d4:	f100 0310 	addne.w	r3, r0, #16
 800b8d8:	6921      	ldreq	r1, [r4, #16]
 800b8da:	f100 0318 	addeq.w	r3, r0, #24
 800b8de:	6101      	streq	r1, [r0, #16]
 800b8e0:	bf04      	itt	eq
 800b8e2:	6961      	ldreq	r1, [r4, #20]
 800b8e4:	6141      	streq	r1, [r0, #20]
 800b8e6:	e7a4      	b.n	800b832 <_realloc_r+0x22e>
 800b8e8:	4621      	mov	r1, r4
 800b8ea:	4638      	mov	r0, r7
 800b8ec:	9300      	str	r3, [sp, #0]
 800b8ee:	f7ff fdbd 	bl	800b46c <memmove>
 800b8f2:	e89d 0108 	ldmia.w	sp, {r3, r8}
 800b8f6:	463c      	mov	r4, r7
 800b8f8:	469a      	mov	sl, r3
 800b8fa:	685a      	ldr	r2, [r3, #4]
 800b8fc:	e713      	b.n	800b726 <_realloc_r+0x122>
 800b8fe:	4621      	mov	r1, r4
 800b900:	f7ff fdb4 	bl	800b46c <memmove>
 800b904:	e79b      	b.n	800b83e <_realloc_r+0x23a>
 800b906:	9801      	ldr	r0, [sp, #4]
 800b908:	f105 0210 	add.w	r2, r5, #16
 800b90c:	eb0c 0800 	add.w	r8, ip, r0
 800b910:	4590      	cmp	r8, r2
 800b912:	f6ff af2b 	blt.w	800b76c <_realloc_r+0x168>
 800b916:	461f      	mov	r7, r3
 800b918:	68d9      	ldr	r1, [r3, #12]
 800b91a:	1f32      	subs	r2, r6, #4
 800b91c:	f857 0f08 	ldr.w	r0, [r7, #8]!
 800b920:	2a24      	cmp	r2, #36	; 0x24
 800b922:	60c1      	str	r1, [r0, #12]
 800b924:	6088      	str	r0, [r1, #8]
 800b926:	d84b      	bhi.n	800b9c0 <_realloc_r+0x3bc>
 800b928:	2a13      	cmp	r2, #19
 800b92a:	bf9c      	itt	ls
 800b92c:	463a      	movls	r2, r7
 800b92e:	4621      	movls	r1, r4
 800b930:	d91f      	bls.n	800b972 <_realloc_r+0x36e>
 800b932:	6821      	ldr	r1, [r4, #0]
 800b934:	2a1b      	cmp	r2, #27
 800b936:	bf98      	it	ls
 800b938:	f103 0210 	addls.w	r2, r3, #16
 800b93c:	6099      	str	r1, [r3, #8]
 800b93e:	6861      	ldr	r1, [r4, #4]
 800b940:	60d9      	str	r1, [r3, #12]
 800b942:	bf98      	it	ls
 800b944:	f104 0108 	addls.w	r1, r4, #8
 800b948:	d913      	bls.n	800b972 <_realloc_r+0x36e>
 800b94a:	68a1      	ldr	r1, [r4, #8]
 800b94c:	2a24      	cmp	r2, #36	; 0x24
 800b94e:	bf14      	ite	ne
 800b950:	f103 0218 	addne.w	r2, r3, #24
 800b954:	f103 0220 	addeq.w	r2, r3, #32
 800b958:	6119      	str	r1, [r3, #16]
 800b95a:	68e1      	ldr	r1, [r4, #12]
 800b95c:	6159      	str	r1, [r3, #20]
 800b95e:	bf11      	iteee	ne
 800b960:	f104 0110 	addne.w	r1, r4, #16
 800b964:	6920      	ldreq	r0, [r4, #16]
 800b966:	f104 0118 	addeq.w	r1, r4, #24
 800b96a:	6198      	streq	r0, [r3, #24]
 800b96c:	bf04      	itt	eq
 800b96e:	6960      	ldreq	r0, [r4, #20]
 800b970:	61d8      	streq	r0, [r3, #28]
 800b972:	6808      	ldr	r0, [r1, #0]
 800b974:	6010      	str	r0, [r2, #0]
 800b976:	6848      	ldr	r0, [r1, #4]
 800b978:	6050      	str	r0, [r2, #4]
 800b97a:	6889      	ldr	r1, [r1, #8]
 800b97c:	6091      	str	r1, [r2, #8]
 800b97e:	195a      	adds	r2, r3, r5
 800b980:	ebc5 0108 	rsb	r1, r5, r8
 800b984:	f041 0101 	orr.w	r1, r1, #1
 800b988:	4648      	mov	r0, r9
 800b98a:	6051      	str	r1, [r2, #4]
 800b98c:	6859      	ldr	r1, [r3, #4]
 800b98e:	f8cb 2008 	str.w	r2, [fp, #8]
 800b992:	f001 0101 	and.w	r1, r1, #1
 800b996:	430d      	orrs	r5, r1
 800b998:	605d      	str	r5, [r3, #4]
 800b99a:	f7fe f975 	bl	8009c88 <__malloc_unlock>
 800b99e:	e6d6      	b.n	800b74e <_realloc_r+0x14a>
 800b9a0:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800b9a4:	f023 0803 	bic.w	r8, r3, #3
 800b9a8:	44b0      	add	r8, r6
 800b9aa:	e6bc      	b.n	800b726 <_realloc_r+0x122>
 800b9ac:	4621      	mov	r1, r4
 800b9ae:	4638      	mov	r0, r7
 800b9b0:	9300      	str	r3, [sp, #0]
 800b9b2:	f7ff fd5b 	bl	800b46c <memmove>
 800b9b6:	9b00      	ldr	r3, [sp, #0]
 800b9b8:	463c      	mov	r4, r7
 800b9ba:	469a      	mov	sl, r3
 800b9bc:	685a      	ldr	r2, [r3, #4]
 800b9be:	e6b2      	b.n	800b726 <_realloc_r+0x122>
 800b9c0:	4638      	mov	r0, r7
 800b9c2:	4621      	mov	r1, r4
 800b9c4:	9300      	str	r3, [sp, #0]
 800b9c6:	f7ff fd51 	bl	800b46c <memmove>
 800b9ca:	9b00      	ldr	r3, [sp, #0]
 800b9cc:	e7d7      	b.n	800b97e <_realloc_r+0x37a>
 800b9ce:	bf00      	nop

0800b9d0 <__aeabi_uidiv>:
 800b9d0:	1e4a      	subs	r2, r1, #1
 800b9d2:	bf08      	it	eq
 800b9d4:	4770      	bxeq	lr
 800b9d6:	f0c0 8124 	bcc.w	800bc22 <__aeabi_uidiv+0x252>
 800b9da:	4288      	cmp	r0, r1
 800b9dc:	f240 8116 	bls.w	800bc0c <__aeabi_uidiv+0x23c>
 800b9e0:	4211      	tst	r1, r2
 800b9e2:	f000 8117 	beq.w	800bc14 <__aeabi_uidiv+0x244>
 800b9e6:	fab0 f380 	clz	r3, r0
 800b9ea:	fab1 f281 	clz	r2, r1
 800b9ee:	eba2 0303 	sub.w	r3, r2, r3
 800b9f2:	f1c3 031f 	rsb	r3, r3, #31
 800b9f6:	a204      	add	r2, pc, #16	; (adr r2, 800ba08 <__aeabi_uidiv+0x38>)
 800b9f8:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800b9fc:	f04f 0200 	mov.w	r2, #0
 800ba00:	469f      	mov	pc, r3
 800ba02:	bf00      	nop
 800ba04:	f3af 8000 	nop.w
 800ba08:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 800ba0c:	bf00      	nop
 800ba0e:	eb42 0202 	adc.w	r2, r2, r2
 800ba12:	bf28      	it	cs
 800ba14:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 800ba18:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 800ba1c:	bf00      	nop
 800ba1e:	eb42 0202 	adc.w	r2, r2, r2
 800ba22:	bf28      	it	cs
 800ba24:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 800ba28:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 800ba2c:	bf00      	nop
 800ba2e:	eb42 0202 	adc.w	r2, r2, r2
 800ba32:	bf28      	it	cs
 800ba34:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 800ba38:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 800ba3c:	bf00      	nop
 800ba3e:	eb42 0202 	adc.w	r2, r2, r2
 800ba42:	bf28      	it	cs
 800ba44:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 800ba48:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 800ba4c:	bf00      	nop
 800ba4e:	eb42 0202 	adc.w	r2, r2, r2
 800ba52:	bf28      	it	cs
 800ba54:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 800ba58:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 800ba5c:	bf00      	nop
 800ba5e:	eb42 0202 	adc.w	r2, r2, r2
 800ba62:	bf28      	it	cs
 800ba64:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 800ba68:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 800ba6c:	bf00      	nop
 800ba6e:	eb42 0202 	adc.w	r2, r2, r2
 800ba72:	bf28      	it	cs
 800ba74:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 800ba78:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 800ba7c:	bf00      	nop
 800ba7e:	eb42 0202 	adc.w	r2, r2, r2
 800ba82:	bf28      	it	cs
 800ba84:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 800ba88:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 800ba8c:	bf00      	nop
 800ba8e:	eb42 0202 	adc.w	r2, r2, r2
 800ba92:	bf28      	it	cs
 800ba94:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 800ba98:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 800ba9c:	bf00      	nop
 800ba9e:	eb42 0202 	adc.w	r2, r2, r2
 800baa2:	bf28      	it	cs
 800baa4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 800baa8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 800baac:	bf00      	nop
 800baae:	eb42 0202 	adc.w	r2, r2, r2
 800bab2:	bf28      	it	cs
 800bab4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 800bab8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 800babc:	bf00      	nop
 800babe:	eb42 0202 	adc.w	r2, r2, r2
 800bac2:	bf28      	it	cs
 800bac4:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 800bac8:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 800bacc:	bf00      	nop
 800bace:	eb42 0202 	adc.w	r2, r2, r2
 800bad2:	bf28      	it	cs
 800bad4:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 800bad8:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 800badc:	bf00      	nop
 800bade:	eb42 0202 	adc.w	r2, r2, r2
 800bae2:	bf28      	it	cs
 800bae4:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 800bae8:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 800baec:	bf00      	nop
 800baee:	eb42 0202 	adc.w	r2, r2, r2
 800baf2:	bf28      	it	cs
 800baf4:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 800baf8:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 800bafc:	bf00      	nop
 800bafe:	eb42 0202 	adc.w	r2, r2, r2
 800bb02:	bf28      	it	cs
 800bb04:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 800bb08:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 800bb0c:	bf00      	nop
 800bb0e:	eb42 0202 	adc.w	r2, r2, r2
 800bb12:	bf28      	it	cs
 800bb14:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 800bb18:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 800bb1c:	bf00      	nop
 800bb1e:	eb42 0202 	adc.w	r2, r2, r2
 800bb22:	bf28      	it	cs
 800bb24:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 800bb28:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 800bb2c:	bf00      	nop
 800bb2e:	eb42 0202 	adc.w	r2, r2, r2
 800bb32:	bf28      	it	cs
 800bb34:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 800bb38:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 800bb3c:	bf00      	nop
 800bb3e:	eb42 0202 	adc.w	r2, r2, r2
 800bb42:	bf28      	it	cs
 800bb44:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 800bb48:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 800bb4c:	bf00      	nop
 800bb4e:	eb42 0202 	adc.w	r2, r2, r2
 800bb52:	bf28      	it	cs
 800bb54:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 800bb58:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 800bb5c:	bf00      	nop
 800bb5e:	eb42 0202 	adc.w	r2, r2, r2
 800bb62:	bf28      	it	cs
 800bb64:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 800bb68:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 800bb6c:	bf00      	nop
 800bb6e:	eb42 0202 	adc.w	r2, r2, r2
 800bb72:	bf28      	it	cs
 800bb74:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 800bb78:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 800bb7c:	bf00      	nop
 800bb7e:	eb42 0202 	adc.w	r2, r2, r2
 800bb82:	bf28      	it	cs
 800bb84:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 800bb88:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 800bb8c:	bf00      	nop
 800bb8e:	eb42 0202 	adc.w	r2, r2, r2
 800bb92:	bf28      	it	cs
 800bb94:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 800bb98:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 800bb9c:	bf00      	nop
 800bb9e:	eb42 0202 	adc.w	r2, r2, r2
 800bba2:	bf28      	it	cs
 800bba4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 800bba8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 800bbac:	bf00      	nop
 800bbae:	eb42 0202 	adc.w	r2, r2, r2
 800bbb2:	bf28      	it	cs
 800bbb4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 800bbb8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 800bbbc:	bf00      	nop
 800bbbe:	eb42 0202 	adc.w	r2, r2, r2
 800bbc2:	bf28      	it	cs
 800bbc4:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 800bbc8:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 800bbcc:	bf00      	nop
 800bbce:	eb42 0202 	adc.w	r2, r2, r2
 800bbd2:	bf28      	it	cs
 800bbd4:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 800bbd8:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 800bbdc:	bf00      	nop
 800bbde:	eb42 0202 	adc.w	r2, r2, r2
 800bbe2:	bf28      	it	cs
 800bbe4:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 800bbe8:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 800bbec:	bf00      	nop
 800bbee:	eb42 0202 	adc.w	r2, r2, r2
 800bbf2:	bf28      	it	cs
 800bbf4:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 800bbf8:	ebb0 0f01 	cmp.w	r0, r1
 800bbfc:	bf00      	nop
 800bbfe:	eb42 0202 	adc.w	r2, r2, r2
 800bc02:	bf28      	it	cs
 800bc04:	eba0 0001 	subcs.w	r0, r0, r1
 800bc08:	4610      	mov	r0, r2
 800bc0a:	4770      	bx	lr
 800bc0c:	bf0c      	ite	eq
 800bc0e:	2001      	moveq	r0, #1
 800bc10:	2000      	movne	r0, #0
 800bc12:	4770      	bx	lr
 800bc14:	fab1 f281 	clz	r2, r1
 800bc18:	f1c2 021f 	rsb	r2, r2, #31
 800bc1c:	fa20 f002 	lsr.w	r0, r0, r2
 800bc20:	4770      	bx	lr
 800bc22:	b108      	cbz	r0, 800bc28 <__aeabi_uidiv+0x258>
 800bc24:	f04f 30ff 	mov.w	r0, #4294967295
 800bc28:	f000 b80e 	b.w	800bc48 <__aeabi_idiv0>

0800bc2c <__aeabi_uidivmod>:
 800bc2c:	2900      	cmp	r1, #0
 800bc2e:	d0f8      	beq.n	800bc22 <__aeabi_uidiv+0x252>
 800bc30:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 800bc34:	f7ff fecc 	bl	800b9d0 <__aeabi_uidiv>
 800bc38:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 800bc3c:	fb02 f300 	mul.w	r3, r2, r0
 800bc40:	eba1 0103 	sub.w	r1, r1, r3
 800bc44:	4770      	bx	lr
 800bc46:	bf00      	nop

0800bc48 <__aeabi_idiv0>:
 800bc48:	4770      	bx	lr
 800bc4a:	bf00      	nop

0800bc4c <__aeabi_drsub>:
 800bc4c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800bc50:	e002      	b.n	800bc58 <__adddf3>
 800bc52:	bf00      	nop

0800bc54 <__aeabi_dsub>:
 800bc54:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800bc58 <__adddf3>:
 800bc58:	b530      	push	{r4, r5, lr}
 800bc5a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800bc5e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800bc62:	ea94 0f05 	teq	r4, r5
 800bc66:	bf08      	it	eq
 800bc68:	ea90 0f02 	teqeq	r0, r2
 800bc6c:	bf1f      	itttt	ne
 800bc6e:	ea54 0c00 	orrsne.w	ip, r4, r0
 800bc72:	ea55 0c02 	orrsne.w	ip, r5, r2
 800bc76:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800bc7a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800bc7e:	f000 80e2 	beq.w	800be46 <__adddf3+0x1ee>
 800bc82:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800bc86:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800bc8a:	bfb8      	it	lt
 800bc8c:	426d      	neglt	r5, r5
 800bc8e:	dd0c      	ble.n	800bcaa <__adddf3+0x52>
 800bc90:	442c      	add	r4, r5
 800bc92:	ea80 0202 	eor.w	r2, r0, r2
 800bc96:	ea81 0303 	eor.w	r3, r1, r3
 800bc9a:	ea82 0000 	eor.w	r0, r2, r0
 800bc9e:	ea83 0101 	eor.w	r1, r3, r1
 800bca2:	ea80 0202 	eor.w	r2, r0, r2
 800bca6:	ea81 0303 	eor.w	r3, r1, r3
 800bcaa:	2d36      	cmp	r5, #54	; 0x36
 800bcac:	bf88      	it	hi
 800bcae:	bd30      	pophi	{r4, r5, pc}
 800bcb0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800bcb4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800bcb8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800bcbc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800bcc0:	d002      	beq.n	800bcc8 <__adddf3+0x70>
 800bcc2:	4240      	negs	r0, r0
 800bcc4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800bcc8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800bccc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800bcd0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800bcd4:	d002      	beq.n	800bcdc <__adddf3+0x84>
 800bcd6:	4252      	negs	r2, r2
 800bcd8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800bcdc:	ea94 0f05 	teq	r4, r5
 800bce0:	f000 80a7 	beq.w	800be32 <__adddf3+0x1da>
 800bce4:	f1a4 0401 	sub.w	r4, r4, #1
 800bce8:	f1d5 0e20 	rsbs	lr, r5, #32
 800bcec:	db0d      	blt.n	800bd0a <__adddf3+0xb2>
 800bcee:	fa02 fc0e 	lsl.w	ip, r2, lr
 800bcf2:	fa22 f205 	lsr.w	r2, r2, r5
 800bcf6:	1880      	adds	r0, r0, r2
 800bcf8:	f141 0100 	adc.w	r1, r1, #0
 800bcfc:	fa03 f20e 	lsl.w	r2, r3, lr
 800bd00:	1880      	adds	r0, r0, r2
 800bd02:	fa43 f305 	asr.w	r3, r3, r5
 800bd06:	4159      	adcs	r1, r3
 800bd08:	e00e      	b.n	800bd28 <__adddf3+0xd0>
 800bd0a:	f1a5 0520 	sub.w	r5, r5, #32
 800bd0e:	f10e 0e20 	add.w	lr, lr, #32
 800bd12:	2a01      	cmp	r2, #1
 800bd14:	fa03 fc0e 	lsl.w	ip, r3, lr
 800bd18:	bf28      	it	cs
 800bd1a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800bd1e:	fa43 f305 	asr.w	r3, r3, r5
 800bd22:	18c0      	adds	r0, r0, r3
 800bd24:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800bd28:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800bd2c:	d507      	bpl.n	800bd3e <__adddf3+0xe6>
 800bd2e:	f04f 0e00 	mov.w	lr, #0
 800bd32:	f1dc 0c00 	rsbs	ip, ip, #0
 800bd36:	eb7e 0000 	sbcs.w	r0, lr, r0
 800bd3a:	eb6e 0101 	sbc.w	r1, lr, r1
 800bd3e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800bd42:	d31b      	bcc.n	800bd7c <__adddf3+0x124>
 800bd44:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800bd48:	d30c      	bcc.n	800bd64 <__adddf3+0x10c>
 800bd4a:	0849      	lsrs	r1, r1, #1
 800bd4c:	ea5f 0030 	movs.w	r0, r0, rrx
 800bd50:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800bd54:	f104 0401 	add.w	r4, r4, #1
 800bd58:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800bd5c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800bd60:	f080 809a 	bcs.w	800be98 <__adddf3+0x240>
 800bd64:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800bd68:	bf08      	it	eq
 800bd6a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800bd6e:	f150 0000 	adcs.w	r0, r0, #0
 800bd72:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800bd76:	ea41 0105 	orr.w	r1, r1, r5
 800bd7a:	bd30      	pop	{r4, r5, pc}
 800bd7c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800bd80:	4140      	adcs	r0, r0
 800bd82:	eb41 0101 	adc.w	r1, r1, r1
 800bd86:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800bd8a:	f1a4 0401 	sub.w	r4, r4, #1
 800bd8e:	d1e9      	bne.n	800bd64 <__adddf3+0x10c>
 800bd90:	f091 0f00 	teq	r1, #0
 800bd94:	bf04      	itt	eq
 800bd96:	4601      	moveq	r1, r0
 800bd98:	2000      	moveq	r0, #0
 800bd9a:	fab1 f381 	clz	r3, r1
 800bd9e:	bf08      	it	eq
 800bda0:	3320      	addeq	r3, #32
 800bda2:	f1a3 030b 	sub.w	r3, r3, #11
 800bda6:	f1b3 0220 	subs.w	r2, r3, #32
 800bdaa:	da0c      	bge.n	800bdc6 <__adddf3+0x16e>
 800bdac:	320c      	adds	r2, #12
 800bdae:	dd08      	ble.n	800bdc2 <__adddf3+0x16a>
 800bdb0:	f102 0c14 	add.w	ip, r2, #20
 800bdb4:	f1c2 020c 	rsb	r2, r2, #12
 800bdb8:	fa01 f00c 	lsl.w	r0, r1, ip
 800bdbc:	fa21 f102 	lsr.w	r1, r1, r2
 800bdc0:	e00c      	b.n	800bddc <__adddf3+0x184>
 800bdc2:	f102 0214 	add.w	r2, r2, #20
 800bdc6:	bfd8      	it	le
 800bdc8:	f1c2 0c20 	rsble	ip, r2, #32
 800bdcc:	fa01 f102 	lsl.w	r1, r1, r2
 800bdd0:	fa20 fc0c 	lsr.w	ip, r0, ip
 800bdd4:	bfdc      	itt	le
 800bdd6:	ea41 010c 	orrle.w	r1, r1, ip
 800bdda:	4090      	lslle	r0, r2
 800bddc:	1ae4      	subs	r4, r4, r3
 800bdde:	bfa2      	ittt	ge
 800bde0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800bde4:	4329      	orrge	r1, r5
 800bde6:	bd30      	popge	{r4, r5, pc}
 800bde8:	ea6f 0404 	mvn.w	r4, r4
 800bdec:	3c1f      	subs	r4, #31
 800bdee:	da1c      	bge.n	800be2a <__adddf3+0x1d2>
 800bdf0:	340c      	adds	r4, #12
 800bdf2:	dc0e      	bgt.n	800be12 <__adddf3+0x1ba>
 800bdf4:	f104 0414 	add.w	r4, r4, #20
 800bdf8:	f1c4 0220 	rsb	r2, r4, #32
 800bdfc:	fa20 f004 	lsr.w	r0, r0, r4
 800be00:	fa01 f302 	lsl.w	r3, r1, r2
 800be04:	ea40 0003 	orr.w	r0, r0, r3
 800be08:	fa21 f304 	lsr.w	r3, r1, r4
 800be0c:	ea45 0103 	orr.w	r1, r5, r3
 800be10:	bd30      	pop	{r4, r5, pc}
 800be12:	f1c4 040c 	rsb	r4, r4, #12
 800be16:	f1c4 0220 	rsb	r2, r4, #32
 800be1a:	fa20 f002 	lsr.w	r0, r0, r2
 800be1e:	fa01 f304 	lsl.w	r3, r1, r4
 800be22:	ea40 0003 	orr.w	r0, r0, r3
 800be26:	4629      	mov	r1, r5
 800be28:	bd30      	pop	{r4, r5, pc}
 800be2a:	fa21 f004 	lsr.w	r0, r1, r4
 800be2e:	4629      	mov	r1, r5
 800be30:	bd30      	pop	{r4, r5, pc}
 800be32:	f094 0f00 	teq	r4, #0
 800be36:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800be3a:	bf06      	itte	eq
 800be3c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800be40:	3401      	addeq	r4, #1
 800be42:	3d01      	subne	r5, #1
 800be44:	e74e      	b.n	800bce4 <__adddf3+0x8c>
 800be46:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800be4a:	bf18      	it	ne
 800be4c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800be50:	d029      	beq.n	800bea6 <__adddf3+0x24e>
 800be52:	ea94 0f05 	teq	r4, r5
 800be56:	bf08      	it	eq
 800be58:	ea90 0f02 	teqeq	r0, r2
 800be5c:	d005      	beq.n	800be6a <__adddf3+0x212>
 800be5e:	ea54 0c00 	orrs.w	ip, r4, r0
 800be62:	bf04      	itt	eq
 800be64:	4619      	moveq	r1, r3
 800be66:	4610      	moveq	r0, r2
 800be68:	bd30      	pop	{r4, r5, pc}
 800be6a:	ea91 0f03 	teq	r1, r3
 800be6e:	bf1e      	ittt	ne
 800be70:	2100      	movne	r1, #0
 800be72:	2000      	movne	r0, #0
 800be74:	bd30      	popne	{r4, r5, pc}
 800be76:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800be7a:	d105      	bne.n	800be88 <__adddf3+0x230>
 800be7c:	0040      	lsls	r0, r0, #1
 800be7e:	4149      	adcs	r1, r1
 800be80:	bf28      	it	cs
 800be82:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800be86:	bd30      	pop	{r4, r5, pc}
 800be88:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800be8c:	bf3c      	itt	cc
 800be8e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800be92:	bd30      	popcc	{r4, r5, pc}
 800be94:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800be98:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800be9c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800bea0:	f04f 0000 	mov.w	r0, #0
 800bea4:	bd30      	pop	{r4, r5, pc}
 800bea6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800beaa:	bf1a      	itte	ne
 800beac:	4619      	movne	r1, r3
 800beae:	4610      	movne	r0, r2
 800beb0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800beb4:	bf1c      	itt	ne
 800beb6:	460b      	movne	r3, r1
 800beb8:	4602      	movne	r2, r0
 800beba:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800bebe:	bf06      	itte	eq
 800bec0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800bec4:	ea91 0f03 	teqeq	r1, r3
 800bec8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800becc:	bd30      	pop	{r4, r5, pc}
 800bece:	bf00      	nop

0800bed0 <__aeabi_ui2d>:
 800bed0:	f090 0f00 	teq	r0, #0
 800bed4:	bf04      	itt	eq
 800bed6:	2100      	moveq	r1, #0
 800bed8:	4770      	bxeq	lr
 800beda:	b530      	push	{r4, r5, lr}
 800bedc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800bee0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800bee4:	f04f 0500 	mov.w	r5, #0
 800bee8:	f04f 0100 	mov.w	r1, #0
 800beec:	e750      	b.n	800bd90 <__adddf3+0x138>
 800beee:	bf00      	nop

0800bef0 <__aeabi_i2d>:
 800bef0:	f090 0f00 	teq	r0, #0
 800bef4:	bf04      	itt	eq
 800bef6:	2100      	moveq	r1, #0
 800bef8:	4770      	bxeq	lr
 800befa:	b530      	push	{r4, r5, lr}
 800befc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800bf00:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800bf04:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800bf08:	bf48      	it	mi
 800bf0a:	4240      	negmi	r0, r0
 800bf0c:	f04f 0100 	mov.w	r1, #0
 800bf10:	e73e      	b.n	800bd90 <__adddf3+0x138>
 800bf12:	bf00      	nop

0800bf14 <__aeabi_f2d>:
 800bf14:	0042      	lsls	r2, r0, #1
 800bf16:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800bf1a:	ea4f 0131 	mov.w	r1, r1, rrx
 800bf1e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800bf22:	bf1f      	itttt	ne
 800bf24:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800bf28:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800bf2c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800bf30:	4770      	bxne	lr
 800bf32:	f092 0f00 	teq	r2, #0
 800bf36:	bf14      	ite	ne
 800bf38:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800bf3c:	4770      	bxeq	lr
 800bf3e:	b530      	push	{r4, r5, lr}
 800bf40:	f44f 7460 	mov.w	r4, #896	; 0x380
 800bf44:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800bf48:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800bf4c:	e720      	b.n	800bd90 <__adddf3+0x138>
 800bf4e:	bf00      	nop

0800bf50 <__aeabi_ul2d>:
 800bf50:	ea50 0201 	orrs.w	r2, r0, r1
 800bf54:	bf08      	it	eq
 800bf56:	4770      	bxeq	lr
 800bf58:	b530      	push	{r4, r5, lr}
 800bf5a:	f04f 0500 	mov.w	r5, #0
 800bf5e:	e00a      	b.n	800bf76 <__aeabi_l2d+0x16>

0800bf60 <__aeabi_l2d>:
 800bf60:	ea50 0201 	orrs.w	r2, r0, r1
 800bf64:	bf08      	it	eq
 800bf66:	4770      	bxeq	lr
 800bf68:	b530      	push	{r4, r5, lr}
 800bf6a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800bf6e:	d502      	bpl.n	800bf76 <__aeabi_l2d+0x16>
 800bf70:	4240      	negs	r0, r0
 800bf72:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800bf76:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800bf7a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800bf7e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800bf82:	f43f aedc 	beq.w	800bd3e <__adddf3+0xe6>
 800bf86:	f04f 0203 	mov.w	r2, #3
 800bf8a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800bf8e:	bf18      	it	ne
 800bf90:	3203      	addne	r2, #3
 800bf92:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800bf96:	bf18      	it	ne
 800bf98:	3203      	addne	r2, #3
 800bf9a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800bf9e:	f1c2 0320 	rsb	r3, r2, #32
 800bfa2:	fa00 fc03 	lsl.w	ip, r0, r3
 800bfa6:	fa20 f002 	lsr.w	r0, r0, r2
 800bfaa:	fa01 fe03 	lsl.w	lr, r1, r3
 800bfae:	ea40 000e 	orr.w	r0, r0, lr
 800bfb2:	fa21 f102 	lsr.w	r1, r1, r2
 800bfb6:	4414      	add	r4, r2
 800bfb8:	e6c1      	b.n	800bd3e <__adddf3+0xe6>
 800bfba:	bf00      	nop

0800bfbc <__aeabi_dmul>:
 800bfbc:	b570      	push	{r4, r5, r6, lr}
 800bfbe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800bfc2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800bfc6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800bfca:	bf1d      	ittte	ne
 800bfcc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800bfd0:	ea94 0f0c 	teqne	r4, ip
 800bfd4:	ea95 0f0c 	teqne	r5, ip
 800bfd8:	f000 f8de 	bleq	800c198 <__aeabi_dmul+0x1dc>
 800bfdc:	442c      	add	r4, r5
 800bfde:	ea81 0603 	eor.w	r6, r1, r3
 800bfe2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800bfe6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800bfea:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800bfee:	bf18      	it	ne
 800bff0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800bff4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800bff8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800bffc:	d038      	beq.n	800c070 <__aeabi_dmul+0xb4>
 800bffe:	fba0 ce02 	umull	ip, lr, r0, r2
 800c002:	f04f 0500 	mov.w	r5, #0
 800c006:	fbe1 e502 	umlal	lr, r5, r1, r2
 800c00a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800c00e:	fbe0 e503 	umlal	lr, r5, r0, r3
 800c012:	f04f 0600 	mov.w	r6, #0
 800c016:	fbe1 5603 	umlal	r5, r6, r1, r3
 800c01a:	f09c 0f00 	teq	ip, #0
 800c01e:	bf18      	it	ne
 800c020:	f04e 0e01 	orrne.w	lr, lr, #1
 800c024:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800c028:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800c02c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800c030:	d204      	bcs.n	800c03c <__aeabi_dmul+0x80>
 800c032:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800c036:	416d      	adcs	r5, r5
 800c038:	eb46 0606 	adc.w	r6, r6, r6
 800c03c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800c040:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800c044:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800c048:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800c04c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800c050:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c054:	bf88      	it	hi
 800c056:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c05a:	d81e      	bhi.n	800c09a <__aeabi_dmul+0xde>
 800c05c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800c060:	bf08      	it	eq
 800c062:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800c066:	f150 0000 	adcs.w	r0, r0, #0
 800c06a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c06e:	bd70      	pop	{r4, r5, r6, pc}
 800c070:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800c074:	ea46 0101 	orr.w	r1, r6, r1
 800c078:	ea40 0002 	orr.w	r0, r0, r2
 800c07c:	ea81 0103 	eor.w	r1, r1, r3
 800c080:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800c084:	bfc2      	ittt	gt
 800c086:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c08a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c08e:	bd70      	popgt	{r4, r5, r6, pc}
 800c090:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c094:	f04f 0e00 	mov.w	lr, #0
 800c098:	3c01      	subs	r4, #1
 800c09a:	f300 80ab 	bgt.w	800c1f4 <__aeabi_dmul+0x238>
 800c09e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800c0a2:	bfde      	ittt	le
 800c0a4:	2000      	movle	r0, #0
 800c0a6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800c0aa:	bd70      	pople	{r4, r5, r6, pc}
 800c0ac:	f1c4 0400 	rsb	r4, r4, #0
 800c0b0:	3c20      	subs	r4, #32
 800c0b2:	da35      	bge.n	800c120 <__aeabi_dmul+0x164>
 800c0b4:	340c      	adds	r4, #12
 800c0b6:	dc1b      	bgt.n	800c0f0 <__aeabi_dmul+0x134>
 800c0b8:	f104 0414 	add.w	r4, r4, #20
 800c0bc:	f1c4 0520 	rsb	r5, r4, #32
 800c0c0:	fa00 f305 	lsl.w	r3, r0, r5
 800c0c4:	fa20 f004 	lsr.w	r0, r0, r4
 800c0c8:	fa01 f205 	lsl.w	r2, r1, r5
 800c0cc:	ea40 0002 	orr.w	r0, r0, r2
 800c0d0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800c0d4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c0d8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c0dc:	fa21 f604 	lsr.w	r6, r1, r4
 800c0e0:	eb42 0106 	adc.w	r1, r2, r6
 800c0e4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c0e8:	bf08      	it	eq
 800c0ea:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c0ee:	bd70      	pop	{r4, r5, r6, pc}
 800c0f0:	f1c4 040c 	rsb	r4, r4, #12
 800c0f4:	f1c4 0520 	rsb	r5, r4, #32
 800c0f8:	fa00 f304 	lsl.w	r3, r0, r4
 800c0fc:	fa20 f005 	lsr.w	r0, r0, r5
 800c100:	fa01 f204 	lsl.w	r2, r1, r4
 800c104:	ea40 0002 	orr.w	r0, r0, r2
 800c108:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c10c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c110:	f141 0100 	adc.w	r1, r1, #0
 800c114:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c118:	bf08      	it	eq
 800c11a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c11e:	bd70      	pop	{r4, r5, r6, pc}
 800c120:	f1c4 0520 	rsb	r5, r4, #32
 800c124:	fa00 f205 	lsl.w	r2, r0, r5
 800c128:	ea4e 0e02 	orr.w	lr, lr, r2
 800c12c:	fa20 f304 	lsr.w	r3, r0, r4
 800c130:	fa01 f205 	lsl.w	r2, r1, r5
 800c134:	ea43 0302 	orr.w	r3, r3, r2
 800c138:	fa21 f004 	lsr.w	r0, r1, r4
 800c13c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c140:	fa21 f204 	lsr.w	r2, r1, r4
 800c144:	ea20 0002 	bic.w	r0, r0, r2
 800c148:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800c14c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c150:	bf08      	it	eq
 800c152:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c156:	bd70      	pop	{r4, r5, r6, pc}
 800c158:	f094 0f00 	teq	r4, #0
 800c15c:	d10f      	bne.n	800c17e <__aeabi_dmul+0x1c2>
 800c15e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800c162:	0040      	lsls	r0, r0, #1
 800c164:	eb41 0101 	adc.w	r1, r1, r1
 800c168:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c16c:	bf08      	it	eq
 800c16e:	3c01      	subeq	r4, #1
 800c170:	d0f7      	beq.n	800c162 <__aeabi_dmul+0x1a6>
 800c172:	ea41 0106 	orr.w	r1, r1, r6
 800c176:	f095 0f00 	teq	r5, #0
 800c17a:	bf18      	it	ne
 800c17c:	4770      	bxne	lr
 800c17e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800c182:	0052      	lsls	r2, r2, #1
 800c184:	eb43 0303 	adc.w	r3, r3, r3
 800c188:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800c18c:	bf08      	it	eq
 800c18e:	3d01      	subeq	r5, #1
 800c190:	d0f7      	beq.n	800c182 <__aeabi_dmul+0x1c6>
 800c192:	ea43 0306 	orr.w	r3, r3, r6
 800c196:	4770      	bx	lr
 800c198:	ea94 0f0c 	teq	r4, ip
 800c19c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c1a0:	bf18      	it	ne
 800c1a2:	ea95 0f0c 	teqne	r5, ip
 800c1a6:	d00c      	beq.n	800c1c2 <__aeabi_dmul+0x206>
 800c1a8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c1ac:	bf18      	it	ne
 800c1ae:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c1b2:	d1d1      	bne.n	800c158 <__aeabi_dmul+0x19c>
 800c1b4:	ea81 0103 	eor.w	r1, r1, r3
 800c1b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c1bc:	f04f 0000 	mov.w	r0, #0
 800c1c0:	bd70      	pop	{r4, r5, r6, pc}
 800c1c2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c1c6:	bf06      	itte	eq
 800c1c8:	4610      	moveq	r0, r2
 800c1ca:	4619      	moveq	r1, r3
 800c1cc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c1d0:	d019      	beq.n	800c206 <__aeabi_dmul+0x24a>
 800c1d2:	ea94 0f0c 	teq	r4, ip
 800c1d6:	d102      	bne.n	800c1de <__aeabi_dmul+0x222>
 800c1d8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800c1dc:	d113      	bne.n	800c206 <__aeabi_dmul+0x24a>
 800c1de:	ea95 0f0c 	teq	r5, ip
 800c1e2:	d105      	bne.n	800c1f0 <__aeabi_dmul+0x234>
 800c1e4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800c1e8:	bf1c      	itt	ne
 800c1ea:	4610      	movne	r0, r2
 800c1ec:	4619      	movne	r1, r3
 800c1ee:	d10a      	bne.n	800c206 <__aeabi_dmul+0x24a>
 800c1f0:	ea81 0103 	eor.w	r1, r1, r3
 800c1f4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c1f8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c1fc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c200:	f04f 0000 	mov.w	r0, #0
 800c204:	bd70      	pop	{r4, r5, r6, pc}
 800c206:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c20a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800c20e:	bd70      	pop	{r4, r5, r6, pc}

0800c210 <__aeabi_ddiv>:
 800c210:	b570      	push	{r4, r5, r6, lr}
 800c212:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c216:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c21a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c21e:	bf1d      	ittte	ne
 800c220:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c224:	ea94 0f0c 	teqne	r4, ip
 800c228:	ea95 0f0c 	teqne	r5, ip
 800c22c:	f000 f8a7 	bleq	800c37e <__aeabi_ddiv+0x16e>
 800c230:	eba4 0405 	sub.w	r4, r4, r5
 800c234:	ea81 0e03 	eor.w	lr, r1, r3
 800c238:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c23c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c240:	f000 8088 	beq.w	800c354 <__aeabi_ddiv+0x144>
 800c244:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c248:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c24c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800c250:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c254:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c258:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800c25c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800c260:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800c264:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800c268:	429d      	cmp	r5, r3
 800c26a:	bf08      	it	eq
 800c26c:	4296      	cmpeq	r6, r2
 800c26e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800c272:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800c276:	d202      	bcs.n	800c27e <__aeabi_ddiv+0x6e>
 800c278:	085b      	lsrs	r3, r3, #1
 800c27a:	ea4f 0232 	mov.w	r2, r2, rrx
 800c27e:	1ab6      	subs	r6, r6, r2
 800c280:	eb65 0503 	sbc.w	r5, r5, r3
 800c284:	085b      	lsrs	r3, r3, #1
 800c286:	ea4f 0232 	mov.w	r2, r2, rrx
 800c28a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800c28e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800c292:	ebb6 0e02 	subs.w	lr, r6, r2
 800c296:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c29a:	bf22      	ittt	cs
 800c29c:	1ab6      	subcs	r6, r6, r2
 800c29e:	4675      	movcs	r5, lr
 800c2a0:	ea40 000c 	orrcs.w	r0, r0, ip
 800c2a4:	085b      	lsrs	r3, r3, #1
 800c2a6:	ea4f 0232 	mov.w	r2, r2, rrx
 800c2aa:	ebb6 0e02 	subs.w	lr, r6, r2
 800c2ae:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c2b2:	bf22      	ittt	cs
 800c2b4:	1ab6      	subcs	r6, r6, r2
 800c2b6:	4675      	movcs	r5, lr
 800c2b8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800c2bc:	085b      	lsrs	r3, r3, #1
 800c2be:	ea4f 0232 	mov.w	r2, r2, rrx
 800c2c2:	ebb6 0e02 	subs.w	lr, r6, r2
 800c2c6:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c2ca:	bf22      	ittt	cs
 800c2cc:	1ab6      	subcs	r6, r6, r2
 800c2ce:	4675      	movcs	r5, lr
 800c2d0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800c2d4:	085b      	lsrs	r3, r3, #1
 800c2d6:	ea4f 0232 	mov.w	r2, r2, rrx
 800c2da:	ebb6 0e02 	subs.w	lr, r6, r2
 800c2de:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c2e2:	bf22      	ittt	cs
 800c2e4:	1ab6      	subcs	r6, r6, r2
 800c2e6:	4675      	movcs	r5, lr
 800c2e8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800c2ec:	ea55 0e06 	orrs.w	lr, r5, r6
 800c2f0:	d018      	beq.n	800c324 <__aeabi_ddiv+0x114>
 800c2f2:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800c2f6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800c2fa:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800c2fe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800c302:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800c306:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800c30a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800c30e:	d1c0      	bne.n	800c292 <__aeabi_ddiv+0x82>
 800c310:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c314:	d10b      	bne.n	800c32e <__aeabi_ddiv+0x11e>
 800c316:	ea41 0100 	orr.w	r1, r1, r0
 800c31a:	f04f 0000 	mov.w	r0, #0
 800c31e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c322:	e7b6      	b.n	800c292 <__aeabi_ddiv+0x82>
 800c324:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c328:	bf04      	itt	eq
 800c32a:	4301      	orreq	r1, r0
 800c32c:	2000      	moveq	r0, #0
 800c32e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c332:	bf88      	it	hi
 800c334:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c338:	f63f aeaf 	bhi.w	800c09a <__aeabi_dmul+0xde>
 800c33c:	ebb5 0c03 	subs.w	ip, r5, r3
 800c340:	bf04      	itt	eq
 800c342:	ebb6 0c02 	subseq.w	ip, r6, r2
 800c346:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c34a:	f150 0000 	adcs.w	r0, r0, #0
 800c34e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c352:	bd70      	pop	{r4, r5, r6, pc}
 800c354:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800c358:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800c35c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800c360:	bfc2      	ittt	gt
 800c362:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c366:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c36a:	bd70      	popgt	{r4, r5, r6, pc}
 800c36c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c370:	f04f 0e00 	mov.w	lr, #0
 800c374:	3c01      	subs	r4, #1
 800c376:	e690      	b.n	800c09a <__aeabi_dmul+0xde>
 800c378:	ea45 0e06 	orr.w	lr, r5, r6
 800c37c:	e68d      	b.n	800c09a <__aeabi_dmul+0xde>
 800c37e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c382:	ea94 0f0c 	teq	r4, ip
 800c386:	bf08      	it	eq
 800c388:	ea95 0f0c 	teqeq	r5, ip
 800c38c:	f43f af3b 	beq.w	800c206 <__aeabi_dmul+0x24a>
 800c390:	ea94 0f0c 	teq	r4, ip
 800c394:	d10a      	bne.n	800c3ac <__aeabi_ddiv+0x19c>
 800c396:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c39a:	f47f af34 	bne.w	800c206 <__aeabi_dmul+0x24a>
 800c39e:	ea95 0f0c 	teq	r5, ip
 800c3a2:	f47f af25 	bne.w	800c1f0 <__aeabi_dmul+0x234>
 800c3a6:	4610      	mov	r0, r2
 800c3a8:	4619      	mov	r1, r3
 800c3aa:	e72c      	b.n	800c206 <__aeabi_dmul+0x24a>
 800c3ac:	ea95 0f0c 	teq	r5, ip
 800c3b0:	d106      	bne.n	800c3c0 <__aeabi_ddiv+0x1b0>
 800c3b2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c3b6:	f43f aefd 	beq.w	800c1b4 <__aeabi_dmul+0x1f8>
 800c3ba:	4610      	mov	r0, r2
 800c3bc:	4619      	mov	r1, r3
 800c3be:	e722      	b.n	800c206 <__aeabi_dmul+0x24a>
 800c3c0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c3c4:	bf18      	it	ne
 800c3c6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c3ca:	f47f aec5 	bne.w	800c158 <__aeabi_dmul+0x19c>
 800c3ce:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800c3d2:	f47f af0d 	bne.w	800c1f0 <__aeabi_dmul+0x234>
 800c3d6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800c3da:	f47f aeeb 	bne.w	800c1b4 <__aeabi_dmul+0x1f8>
 800c3de:	e712      	b.n	800c206 <__aeabi_dmul+0x24a>

0800c3e0 <__gedf2>:
 800c3e0:	f04f 3cff 	mov.w	ip, #4294967295
 800c3e4:	e006      	b.n	800c3f4 <__cmpdf2+0x4>
 800c3e6:	bf00      	nop

0800c3e8 <__ledf2>:
 800c3e8:	f04f 0c01 	mov.w	ip, #1
 800c3ec:	e002      	b.n	800c3f4 <__cmpdf2+0x4>
 800c3ee:	bf00      	nop

0800c3f0 <__cmpdf2>:
 800c3f0:	f04f 0c01 	mov.w	ip, #1
 800c3f4:	f84d cd04 	str.w	ip, [sp, #-4]!
 800c3f8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c3fc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c400:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c404:	bf18      	it	ne
 800c406:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800c40a:	d01b      	beq.n	800c444 <__cmpdf2+0x54>
 800c40c:	b001      	add	sp, #4
 800c40e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800c412:	bf0c      	ite	eq
 800c414:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800c418:	ea91 0f03 	teqne	r1, r3
 800c41c:	bf02      	ittt	eq
 800c41e:	ea90 0f02 	teqeq	r0, r2
 800c422:	2000      	moveq	r0, #0
 800c424:	4770      	bxeq	lr
 800c426:	f110 0f00 	cmn.w	r0, #0
 800c42a:	ea91 0f03 	teq	r1, r3
 800c42e:	bf58      	it	pl
 800c430:	4299      	cmppl	r1, r3
 800c432:	bf08      	it	eq
 800c434:	4290      	cmpeq	r0, r2
 800c436:	bf2c      	ite	cs
 800c438:	17d8      	asrcs	r0, r3, #31
 800c43a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800c43e:	f040 0001 	orr.w	r0, r0, #1
 800c442:	4770      	bx	lr
 800c444:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800c448:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c44c:	d102      	bne.n	800c454 <__cmpdf2+0x64>
 800c44e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800c452:	d107      	bne.n	800c464 <__cmpdf2+0x74>
 800c454:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800c458:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800c45c:	d1d6      	bne.n	800c40c <__cmpdf2+0x1c>
 800c45e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800c462:	d0d3      	beq.n	800c40c <__cmpdf2+0x1c>
 800c464:	f85d 0b04 	ldr.w	r0, [sp], #4
 800c468:	4770      	bx	lr
 800c46a:	bf00      	nop

0800c46c <__aeabi_cdrcmple>:
 800c46c:	4684      	mov	ip, r0
 800c46e:	4610      	mov	r0, r2
 800c470:	4662      	mov	r2, ip
 800c472:	468c      	mov	ip, r1
 800c474:	4619      	mov	r1, r3
 800c476:	4663      	mov	r3, ip
 800c478:	e000      	b.n	800c47c <__aeabi_cdcmpeq>
 800c47a:	bf00      	nop

0800c47c <__aeabi_cdcmpeq>:
 800c47c:	b501      	push	{r0, lr}
 800c47e:	f7ff ffb7 	bl	800c3f0 <__cmpdf2>
 800c482:	2800      	cmp	r0, #0
 800c484:	bf48      	it	mi
 800c486:	f110 0f00 	cmnmi.w	r0, #0
 800c48a:	bd01      	pop	{r0, pc}

0800c48c <__aeabi_dcmpeq>:
 800c48c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c490:	f7ff fff4 	bl	800c47c <__aeabi_cdcmpeq>
 800c494:	bf0c      	ite	eq
 800c496:	2001      	moveq	r0, #1
 800c498:	2000      	movne	r0, #0
 800c49a:	f85d fb08 	ldr.w	pc, [sp], #8
 800c49e:	bf00      	nop

0800c4a0 <__aeabi_dcmplt>:
 800c4a0:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c4a4:	f7ff ffea 	bl	800c47c <__aeabi_cdcmpeq>
 800c4a8:	bf34      	ite	cc
 800c4aa:	2001      	movcc	r0, #1
 800c4ac:	2000      	movcs	r0, #0
 800c4ae:	f85d fb08 	ldr.w	pc, [sp], #8
 800c4b2:	bf00      	nop

0800c4b4 <__aeabi_dcmple>:
 800c4b4:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c4b8:	f7ff ffe0 	bl	800c47c <__aeabi_cdcmpeq>
 800c4bc:	bf94      	ite	ls
 800c4be:	2001      	movls	r0, #1
 800c4c0:	2000      	movhi	r0, #0
 800c4c2:	f85d fb08 	ldr.w	pc, [sp], #8
 800c4c6:	bf00      	nop

0800c4c8 <__aeabi_dcmpge>:
 800c4c8:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c4cc:	f7ff ffce 	bl	800c46c <__aeabi_cdrcmple>
 800c4d0:	bf94      	ite	ls
 800c4d2:	2001      	movls	r0, #1
 800c4d4:	2000      	movhi	r0, #0
 800c4d6:	f85d fb08 	ldr.w	pc, [sp], #8
 800c4da:	bf00      	nop

0800c4dc <__aeabi_dcmpgt>:
 800c4dc:	f84d ed08 	str.w	lr, [sp, #-8]!
 800c4e0:	f7ff ffc4 	bl	800c46c <__aeabi_cdrcmple>
 800c4e4:	bf34      	ite	cc
 800c4e6:	2001      	movcc	r0, #1
 800c4e8:	2000      	movcs	r0, #0
 800c4ea:	f85d fb08 	ldr.w	pc, [sp], #8
 800c4ee:	bf00      	nop

0800c4f0 <__aeabi_d2iz>:
 800c4f0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800c4f4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800c4f8:	d215      	bcs.n	800c526 <__aeabi_d2iz+0x36>
 800c4fa:	d511      	bpl.n	800c520 <__aeabi_d2iz+0x30>
 800c4fc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800c500:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800c504:	d912      	bls.n	800c52c <__aeabi_d2iz+0x3c>
 800c506:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800c50a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c50e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800c512:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800c516:	fa23 f002 	lsr.w	r0, r3, r2
 800c51a:	bf18      	it	ne
 800c51c:	4240      	negne	r0, r0
 800c51e:	4770      	bx	lr
 800c520:	f04f 0000 	mov.w	r0, #0
 800c524:	4770      	bx	lr
 800c526:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800c52a:	d105      	bne.n	800c538 <__aeabi_d2iz+0x48>
 800c52c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800c530:	bf08      	it	eq
 800c532:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800c536:	4770      	bx	lr
 800c538:	f04f 0000 	mov.w	r0, #0
 800c53c:	4770      	bx	lr
 800c53e:	bf00      	nop

0800c540 <__aeabi_uldivmod>:
 800c540:	b94b      	cbnz	r3, 800c556 <__aeabi_uldivmod+0x16>
 800c542:	b942      	cbnz	r2, 800c556 <__aeabi_uldivmod+0x16>
 800c544:	2900      	cmp	r1, #0
 800c546:	bf08      	it	eq
 800c548:	2800      	cmpeq	r0, #0
 800c54a:	d002      	beq.n	800c552 <__aeabi_uldivmod+0x12>
 800c54c:	f04f 31ff 	mov.w	r1, #4294967295
 800c550:	4608      	mov	r0, r1
 800c552:	f7ff bb79 	b.w	800bc48 <__aeabi_idiv0>
 800c556:	b082      	sub	sp, #8
 800c558:	46ec      	mov	ip, sp
 800c55a:	e92d 5000 	stmdb	sp!, {ip, lr}
 800c55e:	f000 f81d 	bl	800c59c <__gnu_uldivmod_helper>
 800c562:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c566:	b002      	add	sp, #8
 800c568:	bc0c      	pop	{r2, r3}
 800c56a:	4770      	bx	lr

0800c56c <__gnu_ldivmod_helper>:
 800c56c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c570:	4690      	mov	r8, r2
 800c572:	4699      	mov	r9, r3
 800c574:	4606      	mov	r6, r0
 800c576:	460f      	mov	r7, r1
 800c578:	f000 f828 	bl	800c5cc <__divdi3>
 800c57c:	9b08      	ldr	r3, [sp, #32]
 800c57e:	fba8 4500 	umull	r4, r5, r8, r0
 800c582:	fb08 f801 	mul.w	r8, r8, r1
 800c586:	fb00 8209 	mla	r2, r0, r9, r8
 800c58a:	1955      	adds	r5, r2, r5
 800c58c:	1b34      	subs	r4, r6, r4
 800c58e:	eb67 0505 	sbc.w	r5, r7, r5
 800c592:	e9c3 4500 	strd	r4, r5, [r3]
 800c596:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c59a:	bf00      	nop

0800c59c <__gnu_uldivmod_helper>:
 800c59c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c5a0:	4690      	mov	r8, r2
 800c5a2:	4606      	mov	r6, r0
 800c5a4:	460f      	mov	r7, r1
 800c5a6:	461d      	mov	r5, r3
 800c5a8:	f000 f9c6 	bl	800c938 <__udivdi3>
 800c5ac:	fb00 f305 	mul.w	r3, r0, r5
 800c5b0:	fba0 4508 	umull	r4, r5, r0, r8
 800c5b4:	fb08 3801 	mla	r8, r8, r1, r3
 800c5b8:	9b06      	ldr	r3, [sp, #24]
 800c5ba:	4445      	add	r5, r8
 800c5bc:	1b34      	subs	r4, r6, r4
 800c5be:	eb67 0505 	sbc.w	r5, r7, r5
 800c5c2:	e9c3 4500 	strd	r4, r5, [r3]
 800c5c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c5ca:	bf00      	nop

0800c5cc <__divdi3>:
 800c5cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c5d0:	2500      	movs	r5, #0
 800c5d2:	2900      	cmp	r1, #0
 800c5d4:	b085      	sub	sp, #20
 800c5d6:	461c      	mov	r4, r3
 800c5d8:	f2c0 8149 	blt.w	800c86e <__divdi3+0x2a2>
 800c5dc:	2c00      	cmp	r4, #0
 800c5de:	f2c0 8141 	blt.w	800c864 <__divdi3+0x298>
 800c5e2:	468c      	mov	ip, r1
 800c5e4:	460f      	mov	r7, r1
 800c5e6:	4682      	mov	sl, r0
 800c5e8:	4691      	mov	r9, r2
 800c5ea:	4614      	mov	r4, r2
 800c5ec:	4606      	mov	r6, r0
 800c5ee:	4619      	mov	r1, r3
 800c5f0:	2b00      	cmp	r3, #0
 800c5f2:	d14b      	bne.n	800c68c <__divdi3+0xc0>
 800c5f4:	4562      	cmp	r2, ip
 800c5f6:	d959      	bls.n	800c6ac <__divdi3+0xe0>
 800c5f8:	fab2 f382 	clz	r3, r2
 800c5fc:	b143      	cbz	r3, 800c610 <__divdi3+0x44>
 800c5fe:	f1c3 0220 	rsb	r2, r3, #32
 800c602:	fa0c f703 	lsl.w	r7, ip, r3
 800c606:	fa20 f202 	lsr.w	r2, r0, r2
 800c60a:	409c      	lsls	r4, r3
 800c60c:	4317      	orrs	r7, r2
 800c60e:	409e      	lsls	r6, r3
 800c610:	ea4f 4814 	mov.w	r8, r4, lsr #16
 800c614:	4638      	mov	r0, r7
 800c616:	4641      	mov	r1, r8
 800c618:	fa1f f984 	uxth.w	r9, r4
 800c61c:	f7ff f9d8 	bl	800b9d0 <__aeabi_uidiv>
 800c620:	4641      	mov	r1, r8
 800c622:	4682      	mov	sl, r0
 800c624:	4638      	mov	r0, r7
 800c626:	f7ff fb01 	bl	800bc2c <__aeabi_uidivmod>
 800c62a:	0c33      	lsrs	r3, r6, #16
 800c62c:	fb09 f00a 	mul.w	r0, r9, sl
 800c630:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800c634:	4288      	cmp	r0, r1
 800c636:	d90a      	bls.n	800c64e <__divdi3+0x82>
 800c638:	1909      	adds	r1, r1, r4
 800c63a:	f10a 32ff 	add.w	r2, sl, #4294967295
 800c63e:	d205      	bcs.n	800c64c <__divdi3+0x80>
 800c640:	4288      	cmp	r0, r1
 800c642:	bf84      	itt	hi
 800c644:	f1aa 0a02 	subhi.w	sl, sl, #2
 800c648:	1909      	addhi	r1, r1, r4
 800c64a:	d800      	bhi.n	800c64e <__divdi3+0x82>
 800c64c:	4692      	mov	sl, r2
 800c64e:	ebc0 0b01 	rsb	fp, r0, r1
 800c652:	4641      	mov	r1, r8
 800c654:	4658      	mov	r0, fp
 800c656:	b2b6      	uxth	r6, r6
 800c658:	f7ff f9ba 	bl	800b9d0 <__aeabi_uidiv>
 800c65c:	4641      	mov	r1, r8
 800c65e:	4607      	mov	r7, r0
 800c660:	4658      	mov	r0, fp
 800c662:	f7ff fae3 	bl	800bc2c <__aeabi_uidivmod>
 800c666:	fb09 f907 	mul.w	r9, r9, r7
 800c66a:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 800c66e:	4589      	cmp	r9, r1
 800c670:	d907      	bls.n	800c682 <__divdi3+0xb6>
 800c672:	1e7b      	subs	r3, r7, #1
 800c674:	190c      	adds	r4, r1, r4
 800c676:	f080 8157 	bcs.w	800c928 <__divdi3+0x35c>
 800c67a:	3f02      	subs	r7, #2
 800c67c:	45a1      	cmp	r9, r4
 800c67e:	f240 8153 	bls.w	800c928 <__divdi3+0x35c>
 800c682:	ea47 400a 	orr.w	r0, r7, sl, lsl #16
 800c686:	f04f 0800 	mov.w	r8, #0
 800c68a:	e004      	b.n	800c696 <__divdi3+0xca>
 800c68c:	4563      	cmp	r3, ip
 800c68e:	d958      	bls.n	800c742 <__divdi3+0x176>
 800c690:	f04f 0800 	mov.w	r8, #0
 800c694:	4640      	mov	r0, r8
 800c696:	4602      	mov	r2, r0
 800c698:	4643      	mov	r3, r8
 800c69a:	b115      	cbz	r5, 800c6a2 <__divdi3+0xd6>
 800c69c:	4252      	negs	r2, r2
 800c69e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c6a2:	4610      	mov	r0, r2
 800c6a4:	4619      	mov	r1, r3
 800c6a6:	b005      	add	sp, #20
 800c6a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c6ac:	b922      	cbnz	r2, 800c6b8 <__divdi3+0xec>
 800c6ae:	2001      	movs	r0, #1
 800c6b0:	4611      	mov	r1, r2
 800c6b2:	f7ff f98d 	bl	800b9d0 <__aeabi_uidiv>
 800c6b6:	4604      	mov	r4, r0
 800c6b8:	fab4 f384 	clz	r3, r4
 800c6bc:	2b00      	cmp	r3, #0
 800c6be:	f040 80dc 	bne.w	800c87a <__divdi3+0x2ae>
 800c6c2:	1b3f      	subs	r7, r7, r4
 800c6c4:	ea4f 4914 	mov.w	r9, r4, lsr #16
 800c6c8:	fa1f fa84 	uxth.w	sl, r4
 800c6cc:	f04f 0801 	mov.w	r8, #1
 800c6d0:	4649      	mov	r1, r9
 800c6d2:	4638      	mov	r0, r7
 800c6d4:	f7ff f97c 	bl	800b9d0 <__aeabi_uidiv>
 800c6d8:	4649      	mov	r1, r9
 800c6da:	4683      	mov	fp, r0
 800c6dc:	4638      	mov	r0, r7
 800c6de:	f7ff faa5 	bl	800bc2c <__aeabi_uidivmod>
 800c6e2:	0c33      	lsrs	r3, r6, #16
 800c6e4:	fb0a f00b 	mul.w	r0, sl, fp
 800c6e8:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800c6ec:	4288      	cmp	r0, r1
 800c6ee:	d90b      	bls.n	800c708 <__divdi3+0x13c>
 800c6f0:	1909      	adds	r1, r1, r4
 800c6f2:	f10b 33ff 	add.w	r3, fp, #4294967295
 800c6f6:	f080 8115 	bcs.w	800c924 <__divdi3+0x358>
 800c6fa:	4288      	cmp	r0, r1
 800c6fc:	bf84      	itt	hi
 800c6fe:	f1ab 0b02 	subhi.w	fp, fp, #2
 800c702:	1909      	addhi	r1, r1, r4
 800c704:	f240 810e 	bls.w	800c924 <__divdi3+0x358>
 800c708:	1a0b      	subs	r3, r1, r0
 800c70a:	4649      	mov	r1, r9
 800c70c:	4618      	mov	r0, r3
 800c70e:	9301      	str	r3, [sp, #4]
 800c710:	f7ff f95e 	bl	800b9d0 <__aeabi_uidiv>
 800c714:	9b01      	ldr	r3, [sp, #4]
 800c716:	4649      	mov	r1, r9
 800c718:	b2b6      	uxth	r6, r6
 800c71a:	4607      	mov	r7, r0
 800c71c:	4618      	mov	r0, r3
 800c71e:	f7ff fa85 	bl	800bc2c <__aeabi_uidivmod>
 800c722:	fb0a fa07 	mul.w	sl, sl, r7
 800c726:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 800c72a:	458a      	cmp	sl, r1
 800c72c:	d906      	bls.n	800c73c <__divdi3+0x170>
 800c72e:	1e7b      	subs	r3, r7, #1
 800c730:	190c      	adds	r4, r1, r4
 800c732:	d202      	bcs.n	800c73a <__divdi3+0x16e>
 800c734:	3f02      	subs	r7, #2
 800c736:	45a2      	cmp	sl, r4
 800c738:	d800      	bhi.n	800c73c <__divdi3+0x170>
 800c73a:	461f      	mov	r7, r3
 800c73c:	ea47 400b 	orr.w	r0, r7, fp, lsl #16
 800c740:	e7a9      	b.n	800c696 <__divdi3+0xca>
 800c742:	fab3 f483 	clz	r4, r3
 800c746:	2c00      	cmp	r4, #0
 800c748:	f000 80e4 	beq.w	800c914 <__divdi3+0x348>
 800c74c:	f1c4 0320 	rsb	r3, r4, #32
 800c750:	fa01 f104 	lsl.w	r1, r1, r4
 800c754:	fa22 fa03 	lsr.w	sl, r2, r3
 800c758:	fa2c fb03 	lsr.w	fp, ip, r3
 800c75c:	ea4a 0a01 	orr.w	sl, sl, r1
 800c760:	fa20 f803 	lsr.w	r8, r0, r3
 800c764:	fa0c fc04 	lsl.w	ip, ip, r4
 800c768:	4658      	mov	r0, fp
 800c76a:	ea4f 471a 	mov.w	r7, sl, lsr #16
 800c76e:	ea48 080c 	orr.w	r8, r8, ip
 800c772:	4639      	mov	r1, r7
 800c774:	fa02 f904 	lsl.w	r9, r2, r4
 800c778:	f8cd 900c 	str.w	r9, [sp, #12]
 800c77c:	f7ff f928 	bl	800b9d0 <__aeabi_uidiv>
 800c780:	4639      	mov	r1, r7
 800c782:	4681      	mov	r9, r0
 800c784:	4658      	mov	r0, fp
 800c786:	f7ff fa51 	bl	800bc2c <__aeabi_uidivmod>
 800c78a:	fa1f fc8a 	uxth.w	ip, sl
 800c78e:	ea4f 4318 	mov.w	r3, r8, lsr #16
 800c792:	fb0c f009 	mul.w	r0, ip, r9
 800c796:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800c79a:	4298      	cmp	r0, r3
 800c79c:	d90c      	bls.n	800c7b8 <__divdi3+0x1ec>
 800c79e:	eb13 030a 	adds.w	r3, r3, sl
 800c7a2:	f109 31ff 	add.w	r1, r9, #4294967295
 800c7a6:	f080 80c3 	bcs.w	800c930 <__divdi3+0x364>
 800c7aa:	4298      	cmp	r0, r3
 800c7ac:	bf84      	itt	hi
 800c7ae:	f1a9 0902 	subhi.w	r9, r9, #2
 800c7b2:	4453      	addhi	r3, sl
 800c7b4:	f240 80bc 	bls.w	800c930 <__divdi3+0x364>
 800c7b8:	1a1b      	subs	r3, r3, r0
 800c7ba:	4639      	mov	r1, r7
 800c7bc:	4618      	mov	r0, r3
 800c7be:	f8cd c008 	str.w	ip, [sp, #8]
 800c7c2:	9301      	str	r3, [sp, #4]
 800c7c4:	f7ff f904 	bl	800b9d0 <__aeabi_uidiv>
 800c7c8:	9b01      	ldr	r3, [sp, #4]
 800c7ca:	4639      	mov	r1, r7
 800c7cc:	fa1f f888 	uxth.w	r8, r8
 800c7d0:	4683      	mov	fp, r0
 800c7d2:	4618      	mov	r0, r3
 800c7d4:	f7ff fa2a 	bl	800bc2c <__aeabi_uidivmod>
 800c7d8:	f8dd c008 	ldr.w	ip, [sp, #8]
 800c7dc:	fb0c f30b 	mul.w	r3, ip, fp
 800c7e0:	ea48 4101 	orr.w	r1, r8, r1, lsl #16
 800c7e4:	428b      	cmp	r3, r1
 800c7e6:	d90c      	bls.n	800c802 <__divdi3+0x236>
 800c7e8:	eb11 010a 	adds.w	r1, r1, sl
 800c7ec:	f10b 30ff 	add.w	r0, fp, #4294967295
 800c7f0:	f080 809c 	bcs.w	800c92c <__divdi3+0x360>
 800c7f4:	428b      	cmp	r3, r1
 800c7f6:	bf84      	itt	hi
 800c7f8:	f1ab 0b02 	subhi.w	fp, fp, #2
 800c7fc:	4451      	addhi	r1, sl
 800c7fe:	f240 8095 	bls.w	800c92c <__divdi3+0x360>
 800c802:	9f03      	ldr	r7, [sp, #12]
 800c804:	ea4b 4009 	orr.w	r0, fp, r9, lsl #16
 800c808:	1ac9      	subs	r1, r1, r3
 800c80a:	fa1f fc80 	uxth.w	ip, r0
 800c80e:	b2ba      	uxth	r2, r7
 800c810:	ea4f 4917 	mov.w	r9, r7, lsr #16
 800c814:	0c07      	lsrs	r7, r0, #16
 800c816:	fb02 f80c 	mul.w	r8, r2, ip
 800c81a:	fb02 f207 	mul.w	r2, r2, r7
 800c81e:	fb09 230c 	mla	r3, r9, ip, r2
 800c822:	fb09 f907 	mul.w	r9, r9, r7
 800c826:	eb03 4318 	add.w	r3, r3, r8, lsr #16
 800c82a:	429a      	cmp	r2, r3
 800c82c:	bf88      	it	hi
 800c82e:	f509 3980 	addhi.w	r9, r9, #65536	; 0x10000
 800c832:	eb09 4913 	add.w	r9, r9, r3, lsr #16
 800c836:	4549      	cmp	r1, r9
 800c838:	d310      	bcc.n	800c85c <__divdi3+0x290>
 800c83a:	fa1f f888 	uxth.w	r8, r8
 800c83e:	bf14      	ite	ne
 800c840:	2200      	movne	r2, #0
 800c842:	2201      	moveq	r2, #1
 800c844:	fa06 f404 	lsl.w	r4, r6, r4
 800c848:	eb08 4303 	add.w	r3, r8, r3, lsl #16
 800c84c:	429c      	cmp	r4, r3
 800c84e:	bf2c      	ite	cs
 800c850:	2300      	movcs	r3, #0
 800c852:	f002 0301 	andcc.w	r3, r2, #1
 800c856:	2b00      	cmp	r3, #0
 800c858:	f43f af15 	beq.w	800c686 <__divdi3+0xba>
 800c85c:	3801      	subs	r0, #1
 800c85e:	f04f 0800 	mov.w	r8, #0
 800c862:	e718      	b.n	800c696 <__divdi3+0xca>
 800c864:	4252      	negs	r2, r2
 800c866:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c86a:	43ed      	mvns	r5, r5
 800c86c:	e6b9      	b.n	800c5e2 <__divdi3+0x16>
 800c86e:	4240      	negs	r0, r0
 800c870:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c874:	f04f 35ff 	mov.w	r5, #4294967295
 800c878:	e6b0      	b.n	800c5dc <__divdi3+0x10>
 800c87a:	409c      	lsls	r4, r3
 800c87c:	f1c3 0b20 	rsb	fp, r3, #32
 800c880:	fa27 f80b 	lsr.w	r8, r7, fp
 800c884:	fa07 f703 	lsl.w	r7, r7, r3
 800c888:	ea4f 4914 	mov.w	r9, r4, lsr #16
 800c88c:	4640      	mov	r0, r8
 800c88e:	4649      	mov	r1, r9
 800c890:	fa26 fb0b 	lsr.w	fp, r6, fp
 800c894:	409e      	lsls	r6, r3
 800c896:	f7ff f89b 	bl	800b9d0 <__aeabi_uidiv>
 800c89a:	4649      	mov	r1, r9
 800c89c:	fa1f fa84 	uxth.w	sl, r4
 800c8a0:	ea4b 0b07 	orr.w	fp, fp, r7
 800c8a4:	4603      	mov	r3, r0
 800c8a6:	4640      	mov	r0, r8
 800c8a8:	9301      	str	r3, [sp, #4]
 800c8aa:	f7ff f9bf 	bl	800bc2c <__aeabi_uidivmod>
 800c8ae:	9b01      	ldr	r3, [sp, #4]
 800c8b0:	ea4f 421b 	mov.w	r2, fp, lsr #16
 800c8b4:	fb0a f003 	mul.w	r0, sl, r3
 800c8b8:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 800c8bc:	4288      	cmp	r0, r1
 800c8be:	d906      	bls.n	800c8ce <__divdi3+0x302>
 800c8c0:	1e5a      	subs	r2, r3, #1
 800c8c2:	1909      	adds	r1, r1, r4
 800c8c4:	d236      	bcs.n	800c934 <__divdi3+0x368>
 800c8c6:	4288      	cmp	r0, r1
 800c8c8:	d934      	bls.n	800c934 <__divdi3+0x368>
 800c8ca:	3b02      	subs	r3, #2
 800c8cc:	1909      	adds	r1, r1, r4
 800c8ce:	1a0f      	subs	r7, r1, r0
 800c8d0:	4649      	mov	r1, r9
 800c8d2:	4638      	mov	r0, r7
 800c8d4:	9301      	str	r3, [sp, #4]
 800c8d6:	f7ff f87b 	bl	800b9d0 <__aeabi_uidiv>
 800c8da:	4649      	mov	r1, r9
 800c8dc:	fa1f fb8b 	uxth.w	fp, fp
 800c8e0:	4680      	mov	r8, r0
 800c8e2:	4638      	mov	r0, r7
 800c8e4:	f7ff f9a2 	bl	800bc2c <__aeabi_uidivmod>
 800c8e8:	9b01      	ldr	r3, [sp, #4]
 800c8ea:	fb0a f708 	mul.w	r7, sl, r8
 800c8ee:	ea4b 4101 	orr.w	r1, fp, r1, lsl #16
 800c8f2:	428f      	cmp	r7, r1
 800c8f4:	d90a      	bls.n	800c90c <__divdi3+0x340>
 800c8f6:	1909      	adds	r1, r1, r4
 800c8f8:	f108 32ff 	add.w	r2, r8, #4294967295
 800c8fc:	d205      	bcs.n	800c90a <__divdi3+0x33e>
 800c8fe:	428f      	cmp	r7, r1
 800c900:	bf84      	itt	hi
 800c902:	f1a8 0802 	subhi.w	r8, r8, #2
 800c906:	1909      	addhi	r1, r1, r4
 800c908:	d800      	bhi.n	800c90c <__divdi3+0x340>
 800c90a:	4690      	mov	r8, r2
 800c90c:	1bcf      	subs	r7, r1, r7
 800c90e:	ea48 4803 	orr.w	r8, r8, r3, lsl #16
 800c912:	e6dd      	b.n	800c6d0 <__divdi3+0x104>
 800c914:	2001      	movs	r0, #1
 800c916:	4563      	cmp	r3, ip
 800c918:	bf28      	it	cs
 800c91a:	4552      	cmpcs	r2, sl
 800c91c:	46a0      	mov	r8, r4
 800c91e:	f67f aeba 	bls.w	800c696 <__divdi3+0xca>
 800c922:	e6b5      	b.n	800c690 <__divdi3+0xc4>
 800c924:	469b      	mov	fp, r3
 800c926:	e6ef      	b.n	800c708 <__divdi3+0x13c>
 800c928:	461f      	mov	r7, r3
 800c92a:	e6aa      	b.n	800c682 <__divdi3+0xb6>
 800c92c:	4683      	mov	fp, r0
 800c92e:	e768      	b.n	800c802 <__divdi3+0x236>
 800c930:	4689      	mov	r9, r1
 800c932:	e741      	b.n	800c7b8 <__divdi3+0x1ec>
 800c934:	4613      	mov	r3, r2
 800c936:	e7ca      	b.n	800c8ce <__divdi3+0x302>

0800c938 <__udivdi3>:
 800c938:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c93c:	4606      	mov	r6, r0
 800c93e:	b083      	sub	sp, #12
 800c940:	460d      	mov	r5, r1
 800c942:	4614      	mov	r4, r2
 800c944:	4607      	mov	r7, r0
 800c946:	4688      	mov	r8, r1
 800c948:	2b00      	cmp	r3, #0
 800c94a:	d14a      	bne.n	800c9e2 <__udivdi3+0xaa>
 800c94c:	428a      	cmp	r2, r1
 800c94e:	d955      	bls.n	800c9fc <__udivdi3+0xc4>
 800c950:	fab2 f382 	clz	r3, r2
 800c954:	b14b      	cbz	r3, 800c96a <__udivdi3+0x32>
 800c956:	f1c3 0220 	rsb	r2, r3, #32
 800c95a:	fa01 f803 	lsl.w	r8, r1, r3
 800c95e:	fa20 f202 	lsr.w	r2, r0, r2
 800c962:	409c      	lsls	r4, r3
 800c964:	ea42 0808 	orr.w	r8, r2, r8
 800c968:	409f      	lsls	r7, r3
 800c96a:	0c25      	lsrs	r5, r4, #16
 800c96c:	4640      	mov	r0, r8
 800c96e:	4629      	mov	r1, r5
 800c970:	fa1f fa84 	uxth.w	sl, r4
 800c974:	f7ff f82c 	bl	800b9d0 <__aeabi_uidiv>
 800c978:	4629      	mov	r1, r5
 800c97a:	4681      	mov	r9, r0
 800c97c:	4640      	mov	r0, r8
 800c97e:	f7ff f955 	bl	800bc2c <__aeabi_uidivmod>
 800c982:	0c3b      	lsrs	r3, r7, #16
 800c984:	fb0a f009 	mul.w	r0, sl, r9
 800c988:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800c98c:	4288      	cmp	r0, r1
 800c98e:	d90a      	bls.n	800c9a6 <__udivdi3+0x6e>
 800c990:	1909      	adds	r1, r1, r4
 800c992:	f109 32ff 	add.w	r2, r9, #4294967295
 800c996:	d205      	bcs.n	800c9a4 <__udivdi3+0x6c>
 800c998:	4288      	cmp	r0, r1
 800c99a:	bf84      	itt	hi
 800c99c:	f1a9 0902 	subhi.w	r9, r9, #2
 800c9a0:	1909      	addhi	r1, r1, r4
 800c9a2:	d800      	bhi.n	800c9a6 <__udivdi3+0x6e>
 800c9a4:	4691      	mov	r9, r2
 800c9a6:	ebc0 0801 	rsb	r8, r0, r1
 800c9aa:	4629      	mov	r1, r5
 800c9ac:	4640      	mov	r0, r8
 800c9ae:	b2bf      	uxth	r7, r7
 800c9b0:	f7ff f80e 	bl	800b9d0 <__aeabi_uidiv>
 800c9b4:	4629      	mov	r1, r5
 800c9b6:	4606      	mov	r6, r0
 800c9b8:	4640      	mov	r0, r8
 800c9ba:	f7ff f937 	bl	800bc2c <__aeabi_uidivmod>
 800c9be:	fb0a fa06 	mul.w	sl, sl, r6
 800c9c2:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
 800c9c6:	458a      	cmp	sl, r1
 800c9c8:	d907      	bls.n	800c9da <__udivdi3+0xa2>
 800c9ca:	1e73      	subs	r3, r6, #1
 800c9cc:	190c      	adds	r4, r1, r4
 800c9ce:	f080 8122 	bcs.w	800cc16 <__udivdi3+0x2de>
 800c9d2:	3e02      	subs	r6, #2
 800c9d4:	45a2      	cmp	sl, r4
 800c9d6:	f240 811e 	bls.w	800cc16 <__udivdi3+0x2de>
 800c9da:	ea46 4009 	orr.w	r0, r6, r9, lsl #16
 800c9de:	2600      	movs	r6, #0
 800c9e0:	e058      	b.n	800ca94 <__udivdi3+0x15c>
 800c9e2:	428b      	cmp	r3, r1
 800c9e4:	d854      	bhi.n	800ca90 <__udivdi3+0x158>
 800c9e6:	fab3 f483 	clz	r4, r3
 800c9ea:	2c00      	cmp	r4, #0
 800c9ec:	d156      	bne.n	800ca9c <__udivdi3+0x164>
 800c9ee:	428b      	cmp	r3, r1
 800c9f0:	bf28      	it	cs
 800c9f2:	4282      	cmpcs	r2, r0
 800c9f4:	d84c      	bhi.n	800ca90 <__udivdi3+0x158>
 800c9f6:	4626      	mov	r6, r4
 800c9f8:	2001      	movs	r0, #1
 800c9fa:	e04b      	b.n	800ca94 <__udivdi3+0x15c>
 800c9fc:	b922      	cbnz	r2, 800ca08 <__udivdi3+0xd0>
 800c9fe:	2001      	movs	r0, #1
 800ca00:	4611      	mov	r1, r2
 800ca02:	f7fe ffe5 	bl	800b9d0 <__aeabi_uidiv>
 800ca06:	4604      	mov	r4, r0
 800ca08:	fab4 f384 	clz	r3, r4
 800ca0c:	2b00      	cmp	r3, #0
 800ca0e:	f040 80b9 	bne.w	800cb84 <__udivdi3+0x24c>
 800ca12:	1b2d      	subs	r5, r5, r4
 800ca14:	ea4f 4814 	mov.w	r8, r4, lsr #16
 800ca18:	fa1f fa84 	uxth.w	sl, r4
 800ca1c:	2601      	movs	r6, #1
 800ca1e:	4641      	mov	r1, r8
 800ca20:	4628      	mov	r0, r5
 800ca22:	f7fe ffd5 	bl	800b9d0 <__aeabi_uidiv>
 800ca26:	4641      	mov	r1, r8
 800ca28:	4681      	mov	r9, r0
 800ca2a:	4628      	mov	r0, r5
 800ca2c:	f7ff f8fe 	bl	800bc2c <__aeabi_uidivmod>
 800ca30:	0c3b      	lsrs	r3, r7, #16
 800ca32:	fb0a f009 	mul.w	r0, sl, r9
 800ca36:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800ca3a:	4288      	cmp	r0, r1
 800ca3c:	d90b      	bls.n	800ca56 <__udivdi3+0x11e>
 800ca3e:	1909      	adds	r1, r1, r4
 800ca40:	f109 33ff 	add.w	r3, r9, #4294967295
 800ca44:	f080 80e9 	bcs.w	800cc1a <__udivdi3+0x2e2>
 800ca48:	4288      	cmp	r0, r1
 800ca4a:	bf84      	itt	hi
 800ca4c:	f1a9 0902 	subhi.w	r9, r9, #2
 800ca50:	1909      	addhi	r1, r1, r4
 800ca52:	f240 80e2 	bls.w	800cc1a <__udivdi3+0x2e2>
 800ca56:	ebc0 0b01 	rsb	fp, r0, r1
 800ca5a:	4641      	mov	r1, r8
 800ca5c:	4658      	mov	r0, fp
 800ca5e:	b2bf      	uxth	r7, r7
 800ca60:	f7fe ffb6 	bl	800b9d0 <__aeabi_uidiv>
 800ca64:	4641      	mov	r1, r8
 800ca66:	4605      	mov	r5, r0
 800ca68:	4658      	mov	r0, fp
 800ca6a:	f7ff f8df 	bl	800bc2c <__aeabi_uidivmod>
 800ca6e:	fb0a fa05 	mul.w	sl, sl, r5
 800ca72:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
 800ca76:	458a      	cmp	sl, r1
 800ca78:	d907      	bls.n	800ca8a <__udivdi3+0x152>
 800ca7a:	1e6b      	subs	r3, r5, #1
 800ca7c:	190c      	adds	r4, r1, r4
 800ca7e:	f080 80ce 	bcs.w	800cc1e <__udivdi3+0x2e6>
 800ca82:	3d02      	subs	r5, #2
 800ca84:	45a2      	cmp	sl, r4
 800ca86:	f240 80ca 	bls.w	800cc1e <__udivdi3+0x2e6>
 800ca8a:	ea45 4009 	orr.w	r0, r5, r9, lsl #16
 800ca8e:	e001      	b.n	800ca94 <__udivdi3+0x15c>
 800ca90:	2600      	movs	r6, #0
 800ca92:	4630      	mov	r0, r6
 800ca94:	4631      	mov	r1, r6
 800ca96:	b003      	add	sp, #12
 800ca98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ca9c:	f1c4 0120 	rsb	r1, r4, #32
 800caa0:	fa03 f304 	lsl.w	r3, r3, r4
 800caa4:	fa22 f801 	lsr.w	r8, r2, r1
 800caa8:	fa25 f701 	lsr.w	r7, r5, r1
 800caac:	ea48 0803 	orr.w	r8, r8, r3
 800cab0:	fa20 f101 	lsr.w	r1, r0, r1
 800cab4:	fa05 f504 	lsl.w	r5, r5, r4
 800cab8:	4638      	mov	r0, r7
 800caba:	ea4f 4918 	mov.w	r9, r8, lsr #16
 800cabe:	430d      	orrs	r5, r1
 800cac0:	4649      	mov	r1, r9
 800cac2:	fa02 f204 	lsl.w	r2, r2, r4
 800cac6:	9201      	str	r2, [sp, #4]
 800cac8:	f7fe ff82 	bl	800b9d0 <__aeabi_uidiv>
 800cacc:	4649      	mov	r1, r9
 800cace:	4682      	mov	sl, r0
 800cad0:	4638      	mov	r0, r7
 800cad2:	f7ff f8ab 	bl	800bc2c <__aeabi_uidivmod>
 800cad6:	fa1f f288 	uxth.w	r2, r8
 800cada:	0c2f      	lsrs	r7, r5, #16
 800cadc:	fb02 f00a 	mul.w	r0, r2, sl
 800cae0:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 800cae4:	42b8      	cmp	r0, r7
 800cae6:	d906      	bls.n	800caf6 <__udivdi3+0x1be>
 800cae8:	eb17 0708 	adds.w	r7, r7, r8
 800caec:	f10a 31ff 	add.w	r1, sl, #4294967295
 800caf0:	f0c0 809f 	bcc.w	800cc32 <__udivdi3+0x2fa>
 800caf4:	468a      	mov	sl, r1
 800caf6:	1a3f      	subs	r7, r7, r0
 800caf8:	4649      	mov	r1, r9
 800cafa:	4638      	mov	r0, r7
 800cafc:	9200      	str	r2, [sp, #0]
 800cafe:	f7fe ff67 	bl	800b9d0 <__aeabi_uidiv>
 800cb02:	4649      	mov	r1, r9
 800cb04:	b2ad      	uxth	r5, r5
 800cb06:	4683      	mov	fp, r0
 800cb08:	4638      	mov	r0, r7
 800cb0a:	f7ff f88f 	bl	800bc2c <__aeabi_uidivmod>
 800cb0e:	9a00      	ldr	r2, [sp, #0]
 800cb10:	fb02 f70b 	mul.w	r7, r2, fp
 800cb14:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 800cb18:	428f      	cmp	r7, r1
 800cb1a:	d905      	bls.n	800cb28 <__udivdi3+0x1f0>
 800cb1c:	eb11 0108 	adds.w	r1, r1, r8
 800cb20:	f10b 32ff 	add.w	r2, fp, #4294967295
 800cb24:	d37d      	bcc.n	800cc22 <__udivdi3+0x2ea>
 800cb26:	4693      	mov	fp, r2
 800cb28:	9b01      	ldr	r3, [sp, #4]
 800cb2a:	ea4b 400a 	orr.w	r0, fp, sl, lsl #16
 800cb2e:	1bc9      	subs	r1, r1, r7
 800cb30:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 800cb34:	b29d      	uxth	r5, r3
 800cb36:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 800cb3a:	b283      	uxth	r3, r0
 800cb3c:	fb05 f203 	mul.w	r2, r5, r3
 800cb40:	fb05 f50c 	mul.w	r5, r5, ip
 800cb44:	fb0a 5303 	mla	r3, sl, r3, r5
 800cb48:	fb0a fa0c 	mul.w	sl, sl, ip
 800cb4c:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 800cb50:	429d      	cmp	r5, r3
 800cb52:	bf88      	it	hi
 800cb54:	f50a 3a80 	addhi.w	sl, sl, #65536	; 0x10000
 800cb58:	eb0a 4a13 	add.w	sl, sl, r3, lsr #16
 800cb5c:	4551      	cmp	r1, sl
 800cb5e:	d30e      	bcc.n	800cb7e <__udivdi3+0x246>
 800cb60:	b292      	uxth	r2, r2
 800cb62:	bf14      	ite	ne
 800cb64:	2100      	movne	r1, #0
 800cb66:	2101      	moveq	r1, #1
 800cb68:	fa06 f604 	lsl.w	r6, r6, r4
 800cb6c:	eb02 4303 	add.w	r3, r2, r3, lsl #16
 800cb70:	429e      	cmp	r6, r3
 800cb72:	bf2c      	ite	cs
 800cb74:	2600      	movcs	r6, #0
 800cb76:	f001 0601 	andcc.w	r6, r1, #1
 800cb7a:	2e00      	cmp	r6, #0
 800cb7c:	d08a      	beq.n	800ca94 <__udivdi3+0x15c>
 800cb7e:	3801      	subs	r0, #1
 800cb80:	2600      	movs	r6, #0
 800cb82:	e787      	b.n	800ca94 <__udivdi3+0x15c>
 800cb84:	409c      	lsls	r4, r3
 800cb86:	f1c3 0220 	rsb	r2, r3, #32
 800cb8a:	fa25 fa02 	lsr.w	sl, r5, r2
 800cb8e:	fa26 f902 	lsr.w	r9, r6, r2
 800cb92:	ea4f 4814 	mov.w	r8, r4, lsr #16
 800cb96:	4650      	mov	r0, sl
 800cb98:	4641      	mov	r1, r8
 800cb9a:	fa05 f503 	lsl.w	r5, r5, r3
 800cb9e:	fa06 f703 	lsl.w	r7, r6, r3
 800cba2:	f7fe ff15 	bl	800b9d0 <__aeabi_uidiv>
 800cba6:	4641      	mov	r1, r8
 800cba8:	ea49 0905 	orr.w	r9, r9, r5
 800cbac:	4683      	mov	fp, r0
 800cbae:	4650      	mov	r0, sl
 800cbb0:	f7ff f83c 	bl	800bc2c <__aeabi_uidivmod>
 800cbb4:	fa1f fa84 	uxth.w	sl, r4
 800cbb8:	ea4f 4319 	mov.w	r3, r9, lsr #16
 800cbbc:	fb0a f00b 	mul.w	r0, sl, fp
 800cbc0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800cbc4:	4288      	cmp	r0, r1
 800cbc6:	d909      	bls.n	800cbdc <__udivdi3+0x2a4>
 800cbc8:	1909      	adds	r1, r1, r4
 800cbca:	f10b 33ff 	add.w	r3, fp, #4294967295
 800cbce:	d238      	bcs.n	800cc42 <__udivdi3+0x30a>
 800cbd0:	4288      	cmp	r0, r1
 800cbd2:	bf84      	itt	hi
 800cbd4:	f1ab 0b02 	subhi.w	fp, fp, #2
 800cbd8:	1909      	addhi	r1, r1, r4
 800cbda:	d932      	bls.n	800cc42 <__udivdi3+0x30a>
 800cbdc:	1a0d      	subs	r5, r1, r0
 800cbde:	4641      	mov	r1, r8
 800cbe0:	4628      	mov	r0, r5
 800cbe2:	fa1f f989 	uxth.w	r9, r9
 800cbe6:	f7fe fef3 	bl	800b9d0 <__aeabi_uidiv>
 800cbea:	4641      	mov	r1, r8
 800cbec:	4606      	mov	r6, r0
 800cbee:	4628      	mov	r0, r5
 800cbf0:	f7ff f81c 	bl	800bc2c <__aeabi_uidivmod>
 800cbf4:	fb0a f506 	mul.w	r5, sl, r6
 800cbf8:	ea49 4101 	orr.w	r1, r9, r1, lsl #16
 800cbfc:	428d      	cmp	r5, r1
 800cbfe:	d906      	bls.n	800cc0e <__udivdi3+0x2d6>
 800cc00:	1e73      	subs	r3, r6, #1
 800cc02:	1909      	adds	r1, r1, r4
 800cc04:	d21f      	bcs.n	800cc46 <__udivdi3+0x30e>
 800cc06:	428d      	cmp	r5, r1
 800cc08:	d91d      	bls.n	800cc46 <__udivdi3+0x30e>
 800cc0a:	3e02      	subs	r6, #2
 800cc0c:	1909      	adds	r1, r1, r4
 800cc0e:	1b4d      	subs	r5, r1, r5
 800cc10:	ea46 460b 	orr.w	r6, r6, fp, lsl #16
 800cc14:	e703      	b.n	800ca1e <__udivdi3+0xe6>
 800cc16:	461e      	mov	r6, r3
 800cc18:	e6df      	b.n	800c9da <__udivdi3+0xa2>
 800cc1a:	4699      	mov	r9, r3
 800cc1c:	e71b      	b.n	800ca56 <__udivdi3+0x11e>
 800cc1e:	461d      	mov	r5, r3
 800cc20:	e733      	b.n	800ca8a <__udivdi3+0x152>
 800cc22:	428f      	cmp	r7, r1
 800cc24:	bf84      	itt	hi
 800cc26:	f1ab 0b02 	subhi.w	fp, fp, #2
 800cc2a:	4441      	addhi	r1, r8
 800cc2c:	f63f af7c 	bhi.w	800cb28 <__udivdi3+0x1f0>
 800cc30:	e779      	b.n	800cb26 <__udivdi3+0x1ee>
 800cc32:	42b8      	cmp	r0, r7
 800cc34:	bf84      	itt	hi
 800cc36:	f1aa 0a02 	subhi.w	sl, sl, #2
 800cc3a:	4447      	addhi	r7, r8
 800cc3c:	f63f af5b 	bhi.w	800caf6 <__udivdi3+0x1be>
 800cc40:	e758      	b.n	800caf4 <__udivdi3+0x1bc>
 800cc42:	469b      	mov	fp, r3
 800cc44:	e7ca      	b.n	800cbdc <__udivdi3+0x2a4>
 800cc46:	461e      	mov	r6, r3
 800cc48:	e7e1      	b.n	800cc0e <__udivdi3+0x2d6>
 800cc4a:	bf00      	nop

0800cc4c <main>:
#include "gpio.h"
#include "delay.h"
#include "usart.h"
#include "adc3dma.h"

int main(void) {
 800cc4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cc50:	b0a2      	sub	sp, #136	; 0x88
	USART Serial;
	uint16 i;

	TIM2_timer_start();

	usart_begin(USART3, &Serial, PC11, PC10, 19200);
 800cc52:	ac03      	add	r4, sp, #12
	uint32_t tnow;
	char tmp[92];
	USART Serial;
	uint16 i;

	TIM2_timer_start();
 800cc54:	f7f8 fed8 	bl	8005a08 <TIM2_timer_start>

	usart_begin(USART3, &Serial, PC11, PC10, 19200);
 800cc58:	f44f 4396 	mov.w	r3, #19200	; 0x4b00
 800cc5c:	f240 320b 	movw	r2, #779	; 0x30b
 800cc60:	9300      	str	r3, [sp, #0]
 800cc62:	486d      	ldr	r0, [pc, #436]	; (800ce18 <main+0x1cc>)
	sprintf(tmp, "PCLK1 = %ld, ", RCC_Clocks.PCLK1_Frequency);
	usart_print(&Serial, tmp);
	sprintf(tmp, "PCLK2 = %ld\r\n", RCC_Clocks.PCLK2_Frequency);
	usart_print(&Serial, tmp);
	//
	sprintf(tmp, "ADC1 = %lx, ADC2 = %lx, ADC3 = %lx\r\n", (uint32_t)ADC1, (uint32_t)ADC2, (uint32_t)ADC3);
 800cc64:	4f6d      	ldr	r7, [pc, #436]	; (800ce1c <main+0x1d0>)
	USART Serial;
	uint16 i;

	TIM2_timer_start();

	usart_begin(USART3, &Serial, PC11, PC10, 19200);
 800cc66:	f240 330a 	movw	r3, #778	; 0x30a
 800cc6a:	4621      	mov	r1, r4
 800cc6c:	f7f9 fb4b 	bl	8006306 <usart_begin>
	usart_print(&Serial,
 800cc70:	496b      	ldr	r1, [pc, #428]	; (800ce20 <main+0x1d4>)
 800cc72:	4620      	mov	r0, r4
 800cc74:	f7f9 fc74 	bl	8006560 <usart_print>
			"Happy are those who know they are spiritually poor; \n");
	usart_print(&Serial, "The kingdom of heaven belongs to them!\n");
 800cc78:	496a      	ldr	r1, [pc, #424]	; (800ce24 <main+0x1d8>)
 800cc7a:	4620      	mov	r0, r4
 800cc7c:	f7f9 fc70 	bl	8006560 <usart_print>
	usart_print(&Serial, "How many eyes does Mississipi river have?\n");
 800cc80:	4969      	ldr	r1, [pc, #420]	; (800ce28 <main+0x1dc>)
 800cc82:	4620      	mov	r0, r4
 800cc84:	f7f9 fc6c 	bl	8006560 <usart_print>
	usart_print(&Serial, "Quick brown fox jumped over the lazy dog!\n");
 800cc88:	4968      	ldr	r1, [pc, #416]	; (800ce2c <main+0x1e0>)
 800cc8a:	4620      	mov	r0, r4
 800cc8c:	f7f9 fc68 	bl	8006560 <usart_print>
	usart_flush(&Serial);
 800cc90:	4620      	mov	r0, r4

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);

	sprintf(tmp, "SYSCLK = %ld, ", RCC_Clocks.SYSCLK_Frequency);
 800cc92:	ad0b      	add	r5, sp, #44	; 0x2c
	usart_print(&Serial,
			"Happy are those who know they are spiritually poor; \n");
	usart_print(&Serial, "The kingdom of heaven belongs to them!\n");
	usart_print(&Serial, "How many eyes does Mississipi river have?\n");
	usart_print(&Serial, "Quick brown fox jumped over the lazy dog!\n");
	usart_flush(&Serial);
 800cc94:	f7f9 fc7e 	bl	8006594 <usart_flush>

	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq(&RCC_Clocks);
 800cc98:	a807      	add	r0, sp, #28
 800cc9a:	f7f6 fcc3 	bl	8003624 <RCC_GetClocksFreq>

	sprintf(tmp, "SYSCLK = %ld, ", RCC_Clocks.SYSCLK_Frequency);
 800cc9e:	9a07      	ldr	r2, [sp, #28]
 800cca0:	4963      	ldr	r1, [pc, #396]	; (800ce30 <main+0x1e4>)
 800cca2:	4628      	mov	r0, r5
 800cca4:	f7f9 ffaa 	bl	8006bfc <sprintf>
	usart_print(&Serial, tmp);
 800cca8:	4629      	mov	r1, r5
 800ccaa:	4620      	mov	r0, r4
 800ccac:	f7f9 fc58 	bl	8006560 <usart_print>
	sprintf(tmp, "HCLK = %ld, ", RCC_Clocks.HCLK_Frequency);
 800ccb0:	9a08      	ldr	r2, [sp, #32]
 800ccb2:	4960      	ldr	r1, [pc, #384]	; (800ce34 <main+0x1e8>)
 800ccb4:	4628      	mov	r0, r5
 800ccb6:	f7f9 ffa1 	bl	8006bfc <sprintf>
	usart_print(&Serial, tmp);
 800ccba:	4629      	mov	r1, r5
 800ccbc:	4620      	mov	r0, r4
 800ccbe:	f7f9 fc4f 	bl	8006560 <usart_print>
	sprintf(tmp, "PCLK1 = %ld, ", RCC_Clocks.PCLK1_Frequency);
 800ccc2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ccc4:	495c      	ldr	r1, [pc, #368]	; (800ce38 <main+0x1ec>)
 800ccc6:	4628      	mov	r0, r5
 800ccc8:	f7f9 ff98 	bl	8006bfc <sprintf>
	usart_print(&Serial, tmp);
 800cccc:	4629      	mov	r1, r5
 800ccce:	4620      	mov	r0, r4
 800ccd0:	f7f9 fc46 	bl	8006560 <usart_print>
	sprintf(tmp, "PCLK2 = %ld\r\n", RCC_Clocks.PCLK2_Frequency);
 800ccd4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ccd6:	4959      	ldr	r1, [pc, #356]	; (800ce3c <main+0x1f0>)
 800ccd8:	4628      	mov	r0, r5
 800ccda:	f7f9 ff8f 	bl	8006bfc <sprintf>
	usart_print(&Serial, tmp);
 800ccde:	4629      	mov	r1, r5
 800cce0:	4620      	mov	r0, r4
 800cce2:	f7f9 fc3d 	bl	8006560 <usart_print>
	//
	sprintf(tmp, "ADC1 = %lx, ADC2 = %lx, ADC3 = %lx\r\n", (uint32_t)ADC1, (uint32_t)ADC2, (uint32_t)ADC3);
 800cce6:	4a56      	ldr	r2, [pc, #344]	; (800ce40 <main+0x1f4>)
 800cce8:	4b56      	ldr	r3, [pc, #344]	; (800ce44 <main+0x1f8>)
 800ccea:	9700      	str	r7, [sp, #0]
 800ccec:	4956      	ldr	r1, [pc, #344]	; (800ce48 <main+0x1fc>)
 800ccee:	4628      	mov	r0, r5
 800ccf0:	f7f9 ff84 	bl	8006bfc <sprintf>
	usart_print(&Serial, tmp);
 800ccf4:	4629      	mov	r1, r5
 800ccf6:	4620      	mov	r0, r4
 800ccf8:	f7f9 fc32 	bl	8006560 <usart_print>
//	usart_flush(USART2Serial);

	GPIOMode(PinPort(PD12),
 800ccfc:	f240 400c 	movw	r0, #1036	; 0x40c
 800cd00:	f7f8 ff18 	bl	8005b34 <PinPort>
 800cd04:	4680      	mov	r8, r0
			(PinBit(PD12) | PinBit(PD13) | PinBit(PD14) | PinBit(PD15)), OUTPUT,
 800cd06:	f240 400c 	movw	r0, #1036	; 0x40c
 800cd0a:	f7f8 ff1b 	bl	8005b44 <PinBit>
 800cd0e:	4606      	mov	r6, r0
 800cd10:	f240 400d 	movw	r0, #1037	; 0x40d
 800cd14:	f7f8 ff16 	bl	8005b44 <PinBit>
	//
	sprintf(tmp, "ADC1 = %lx, ADC2 = %lx, ADC3 = %lx\r\n", (uint32_t)ADC1, (uint32_t)ADC2, (uint32_t)ADC3);
	usart_print(&Serial, tmp);
//	usart_flush(USART2Serial);

	GPIOMode(PinPort(PD12),
 800cd18:	4330      	orrs	r0, r6
 800cd1a:	b286      	uxth	r6, r0
			(PinBit(PD12) | PinBit(PD13) | PinBit(PD14) | PinBit(PD15)), OUTPUT,
 800cd1c:	f240 400e 	movw	r0, #1038	; 0x40e
 800cd20:	f7f8 ff10 	bl	8005b44 <PinBit>
	//
	sprintf(tmp, "ADC1 = %lx, ADC2 = %lx, ADC3 = %lx\r\n", (uint32_t)ADC1, (uint32_t)ADC2, (uint32_t)ADC3);
	usart_print(&Serial, tmp);
//	usart_flush(USART2Serial);

	GPIOMode(PinPort(PD12),
 800cd24:	4330      	orrs	r0, r6
 800cd26:	b286      	uxth	r6, r0
			(PinBit(PD12) | PinBit(PD13) | PinBit(PD14) | PinBit(PD15)), OUTPUT,
 800cd28:	f240 400f 	movw	r0, #1039	; 0x40f
 800cd2c:	f7f8 ff0a 	bl	8005b44 <PinBit>
	//
	sprintf(tmp, "ADC1 = %lx, ADC2 = %lx, ADC3 = %lx\r\n", (uint32_t)ADC1, (uint32_t)ADC2, (uint32_t)ADC3);
	usart_print(&Serial, tmp);
//	usart_flush(USART2Serial);

	GPIOMode(PinPort(PD12),
 800cd30:	ea46 0100 	orr.w	r1, r6, r0
 800cd34:	2600      	movs	r6, #0
 800cd36:	2201      	movs	r2, #1
 800cd38:	2302      	movs	r3, #2
 800cd3a:	b289      	uxth	r1, r1
 800cd3c:	4640      	mov	r0, r8
 800cd3e:	9600      	str	r6, [sp, #0]
 800cd40:	9601      	str	r6, [sp, #4]
 800cd42:	f7f8 ff69 	bl	8005c18 <GPIOMode>
			(PinBit(PD12) | PinBit(PD13) | PinBit(PD14) | PinBit(PD15)), OUTPUT,
			FASTSPEED, PUSHPULL, NOPULL);

	ADC3_CH12_DMA_Config();
 800cd46:	f7f8 fded 	bl	8005924 <ADC3_CH12_DMA_Config>
	  ADC_SoftwareStartConv(ADC3);
 800cd4a:	4638      	mov	r0, r7
 800cd4c:	f7f3 fb55 	bl	80003fa <ADC_SoftwareStartConv>

	bits = GPIO_ReadOutputData(GPIOD );
 800cd50:	483e      	ldr	r0, [pc, #248]	; (800ce4c <main+0x200>)

	uint32_t sum;
	while (1) {
		sum = 0;
		for(i = 0; i < 8; i++) {
			sum += ADC3ConvertedValue; // *3300/0xFFF;
 800cd52:	f8df 8100 	ldr.w	r8, [pc, #256]	; 800ce54 <main+0x208>
			FASTSPEED, PUSHPULL, NOPULL);

	ADC3_CH12_DMA_Config();
	  ADC_SoftwareStartConv(ADC3);

	bits = GPIO_ReadOutputData(GPIOD );
 800cd56:	f7f5 fe4c 	bl	80029f2 <GPIO_ReadOutputData>
 800cd5a:	4607      	mov	r7, r0
	GPIOWrite(GPIOD, PinBit(PD13) | (bits & 0x0fff));
 800cd5c:	f240 400d 	movw	r0, #1037	; 0x40d
 800cd60:	f7f8 fef0 	bl	8005b44 <PinBit>
 800cd64:	053f      	lsls	r7, r7, #20
 800cd66:	ea40 5117 	orr.w	r1, r0, r7, lsr #20
 800cd6a:	b289      	uxth	r1, r1
 800cd6c:	4837      	ldr	r0, [pc, #220]	; (800ce4c <main+0x200>)
 800cd6e:	f7f8 ffa7 	bl	8005cc0 <GPIOWrite>
	delay_ms(intval);
 800cd72:	2028      	movs	r0, #40	; 0x28
 800cd74:	f7f8 fea2 	bl	8005abc <delay_ms>
	tnow = millis() / 1000;

	uint32_t sum;
	while (1) {
		sum = 0;
		for(i = 0; i < 8; i++) {
 800cd78:	4637      	mov	r7, r6
	  ADC_SoftwareStartConv(ADC3);

	bits = GPIO_ReadOutputData(GPIOD );
	GPIOWrite(GPIOD, PinBit(PD13) | (bits & 0x0fff));
	delay_ms(intval);
	tnow = millis() / 1000;
 800cd7a:	f7f8 fe99 	bl	8005ab0 <millis>
 800cd7e:	e009      	b.n	800cd94 <main+0x148>

	uint32_t sum;
	while (1) {
		sum = 0;
		for(i = 0; i < 8; i++) {
			sum += ADC3ConvertedValue; // *3300/0xFFF;
 800cd80:	f8b8 3000 	ldrh.w	r3, [r8]
			delay_us(333);
 800cd84:	f240 104d 	movw	r0, #333	; 0x14d

	uint32_t sum;
	while (1) {
		sum = 0;
		for(i = 0; i < 8; i++) {
			sum += ADC3ConvertedValue; // *3300/0xFFF;
 800cd88:	fa16 f683 	uxtah	r6, r6, r3
			delay_us(333);
 800cd8c:	f7f8 fea6 	bl	8005adc <delay_us>
	tnow = millis() / 1000;

	uint32_t sum;
	while (1) {
		sum = 0;
		for(i = 0; i < 8; i++) {
 800cd90:	3701      	adds	r7, #1
 800cd92:	b2bf      	uxth	r7, r7
 800cd94:	2f07      	cmp	r7, #7
 800cd96:	d9f3      	bls.n	800cd80 <main+0x134>
			sum += ADC3ConvertedValue; // *3300/0xFFF;
			delay_us(333);
		}
		sum /= 8;

		tmp[0] = 0;
 800cd98:	2300      	movs	r3, #0
		sum = 0;
		for(i = 0; i < 8; i++) {
			sum += ADC3ConvertedValue; // *3300/0xFFF;
			delay_us(333);
		}
		sum /= 8;
 800cd9a:	08f7      	lsrs	r7, r6, #3

		tmp[0] = 0;
		bits = 0;
		if ( sum>>9 ) {
 800cd9c:	0b36      	lsrs	r6, r6, #12
			sum += ADC3ConvertedValue; // *3300/0xFFF;
			delay_us(333);
		}
		sum /= 8;

		tmp[0] = 0;
 800cd9e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
		bits = 0;
		if ( sum>>9 ) {
 800cda2:	d004      	beq.n	800cdae <main+0x162>
			bits |= PinBit(PD13);
 800cda4:	f240 400d 	movw	r0, #1037	; 0x40d
 800cda8:	f7f8 fecc 	bl	8005b44 <PinBit>
 800cdac:	4606      	mov	r6, r0
		}
		if ( sum>>10 ) {
 800cdae:	0abb      	lsrs	r3, r7, #10
 800cdb0:	d005      	beq.n	800cdbe <main+0x172>
			bits |= PinBit(PD14);
 800cdb2:	f240 400e 	movw	r0, #1038	; 0x40e
 800cdb6:	f7f8 fec5 	bl	8005b44 <PinBit>
 800cdba:	4330      	orrs	r0, r6
 800cdbc:	b286      	uxth	r6, r0
		}
		if ( sum>>11 ) {
 800cdbe:	0afb      	lsrs	r3, r7, #11
 800cdc0:	d005      	beq.n	800cdce <main+0x182>
			bits |= PinBit(PD15);
 800cdc2:	f240 400f 	movw	r0, #1039	; 0x40f
 800cdc6:	f7f8 febd 	bl	8005b44 <PinBit>
 800cdca:	4330      	orrs	r0, r6
 800cdcc:	b286      	uxth	r6, r0
		}
		if ( sum>>12) {
 800cdce:	0b3b      	lsrs	r3, r7, #12
 800cdd0:	d005      	beq.n	800cdde <main+0x192>
			bits |= PinBit(PD12);
 800cdd2:	f240 400c 	movw	r0, #1036	; 0x40c
 800cdd6:	f7f8 feb5 	bl	8005b44 <PinBit>
 800cdda:	4330      	orrs	r0, r6
 800cddc:	b286      	uxth	r6, r0
		}
		//
		GPIOWrite(GPIOD, bits);
 800cdde:	481b      	ldr	r0, [pc, #108]	; (800ce4c <main+0x200>)
 800cde0:	4631      	mov	r1, r6
 800cde2:	f7f8 ff6d 	bl	8005cc0 <GPIOWrite>

		if ( (millis() % 1000) < 5 ) {
 800cde6:	f7f8 fe63 	bl	8005ab0 <millis>
 800cdea:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800cdee:	fbb0 f2f3 	udiv	r2, r0, r3
 800cdf2:	fb02 0013 	mls	r0, r2, r3, r0
 800cdf6:	2804      	cmp	r0, #4
 800cdf8:	d80b      	bhi.n	800ce12 <main+0x1c6>
			sprintf(tmp, " %06ld %06ld\n", millis(), sum);
 800cdfa:	f7f8 fe59 	bl	8005ab0 <millis>
 800cdfe:	4914      	ldr	r1, [pc, #80]	; (800ce50 <main+0x204>)
 800ce00:	4602      	mov	r2, r0
 800ce02:	463b      	mov	r3, r7
 800ce04:	4628      	mov	r0, r5
 800ce06:	f7f9 fef9 	bl	8006bfc <sprintf>
			usart_print(&Serial, tmp);
 800ce0a:	4620      	mov	r0, r4
 800ce0c:	4629      	mov	r1, r5
 800ce0e:	f7f9 fba7 	bl	8006560 <usart_print>
	delay_ms(intval);
	tnow = millis() / 1000;

	uint32_t sum;
	while (1) {
		sum = 0;
 800ce12:	2600      	movs	r6, #0
		for(i = 0; i < 8; i++) {
 800ce14:	4637      	mov	r7, r6
 800ce16:	e7b3      	b.n	800cd80 <main+0x134>
 800ce18:	40004800 	.word	0x40004800
 800ce1c:	40012200 	.word	0x40012200
 800ce20:	0800d018 	.word	0x0800d018
 800ce24:	0800d04e 	.word	0x0800d04e
 800ce28:	0800d076 	.word	0x0800d076
 800ce2c:	0800d0a1 	.word	0x0800d0a1
 800ce30:	0800d0cc 	.word	0x0800d0cc
 800ce34:	0800d0db 	.word	0x0800d0db
 800ce38:	0800d0e8 	.word	0x0800d0e8
 800ce3c:	0800d0f6 	.word	0x0800d0f6
 800ce40:	40012000 	.word	0x40012000
 800ce44:	40012100 	.word	0x40012100
 800ce48:	0800d104 	.word	0x0800d104
 800ce4c:	40020c00 	.word	0x40020c00
 800ce50:	0800d129 	.word	0x0800d129
 800ce54:	20000640 	.word	0x20000640

0800ce58 <Reset_Handler>:
 800ce58:	2100      	movs	r1, #0
 800ce5a:	f000 b804 	b.w	800ce66 <LoopCopyDataInit>

0800ce5e <CopyDataInit>:
 800ce5e:	4b0c      	ldr	r3, [pc, #48]	; (800ce90 <LoopFillZerobss+0x12>)
 800ce60:	585b      	ldr	r3, [r3, r1]
 800ce62:	5043      	str	r3, [r0, r1]
 800ce64:	3104      	adds	r1, #4

0800ce66 <LoopCopyDataInit>:
 800ce66:	480b      	ldr	r0, [pc, #44]	; (800ce94 <LoopFillZerobss+0x16>)
 800ce68:	4b0b      	ldr	r3, [pc, #44]	; (800ce98 <LoopFillZerobss+0x1a>)
 800ce6a:	1842      	adds	r2, r0, r1
 800ce6c:	429a      	cmp	r2, r3
 800ce6e:	f4ff aff6 	bcc.w	800ce5e <CopyDataInit>
 800ce72:	4a0a      	ldr	r2, [pc, #40]	; (800ce9c <LoopFillZerobss+0x1e>)
 800ce74:	f000 b803 	b.w	800ce7e <LoopFillZerobss>

0800ce78 <FillZerobss>:
 800ce78:	2300      	movs	r3, #0
 800ce7a:	f842 3b04 	str.w	r3, [r2], #4

0800ce7e <LoopFillZerobss>:
 800ce7e:	4b08      	ldr	r3, [pc, #32]	; (800cea0 <LoopFillZerobss+0x22>)
 800ce80:	429a      	cmp	r2, r3
 800ce82:	f4ff aff9 	bcc.w	800ce78 <FillZerobss>
 800ce86:	f7f9 fd5d 	bl	8006944 <SystemInit>
 800ce8a:	f7ff fedf 	bl	800cc4c <main>
 800ce8e:	4770      	bx	lr
 800ce90:	0800d1c4 	.word	0x0800d1c4
 800ce94:	20000000 	.word	0x20000000
 800ce98:	20000640 	.word	0x20000640
 800ce9c:	20000640 	.word	0x20000640
 800cea0:	200012e4 	.word	0x200012e4

0800cea4 <ADC_IRQHandler>:
 800cea4:	f7ff bffe 	b.w	800cea4 <ADC_IRQHandler>

0800cea8 <blanks.6735>:
 800cea8:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800ceb8 <zeroes.6736>:
 800ceb8:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

0800cec8 <_global_impure_ptr>:
 800cec8:	00c4 2000 0000 0000                         ... ....

0800ced0 <p05.5261>:
 800ced0:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0800cee0 <__mprec_tens>:
 800cee0:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 800cef0:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 800cf00:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 800cf10:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 800cf20:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 800cf30:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 800cf40:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 800cf50:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 800cf60:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 800cf70:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 800cf80:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 800cf90:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 800cfa0:	9db4 79d9 7843 44ea                         ...yCx.D

0800cfa8 <__mprec_tinytens>:
 800cfa8:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
 800cfb8:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
 800cfc8:	6f43 64ac 0628 0ac8                         Co.d(...

0800cfd0 <__mprec_bigtens>:
 800cfd0:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 800cfe0:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 800cff0:	bf3c 7f73 4fdd 7515                         <.s..O.u

0800cff8 <blanks.6679>:
 800cff8:	2020 2020 2020 2020 2020 2020 2020 2020                     

0800d008 <zeroes.6680>:
 800d008:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 800d018:	6148 7070 2079 7261 2065 6874 736f 2065     Happy are those 
 800d028:	6877 206f 6e6b 776f 7420 6568 2079 7261     who know they ar
 800d038:	2065 7073 7269 7469 6175 6c6c 2079 6f70     e spiritually po
 800d048:	726f 203b 000a 6854 2065 696b 676e 6f64     or; ..The kingdo
 800d058:	206d 666f 6820 6165 6576 206e 6562 6f6c     m of heaven belo
 800d068:	676e 2073 6f74 7420 6568 216d 000a 6f48     ngs to them!..Ho
 800d078:	2077 616d 796e 6520 6579 2073 6f64 7365     w many eyes does
 800d088:	4d20 7369 6973 7373 7069 2069 6972 6576      Mississipi rive
 800d098:	2072 6168 6576 0a3f 5100 6975 6b63 6220     r have?..Quick b
 800d0a8:	6f72 6e77 6620 786f 6a20 6d75 6570 2064     rown fox jumped 
 800d0b8:	766f 7265 7420 6568 6c20 7a61 2079 6f64     over the lazy do
 800d0c8:	2167 000a 5953 4353 4b4c 3d20 2520 646c     g!..SYSCLK = %ld
 800d0d8:	202c 4800 4c43 204b 203d 6c25 2c64 0020     , .HCLK = %ld, .
 800d0e8:	4350 4b4c 2031 203d 6c25 2c64 0020 4350     PCLK1 = %ld, .PC
 800d0f8:	4b4c 2032 203d 6c25 0d64 000a 4441 3143     LK2 = %ld...ADC1
 800d108:	3d20 2520 786c 202c 4441 3243 3d20 2520      = %lx, ADC2 = %
 800d118:	786c 202c 4441 3343 3d20 2520 786c 0a0d     lx, ADC3 = %lx..
 800d128:	2000 3025 6c36 2064 3025 6c36 0a64 4800     . %06ld %06ld..H
 800d138:	6165 2070 6e61 2064 7473 6361 206b 6f63     eap and stack co
 800d148:	6c6c 7369 6f69 0a6e 6500 6978 0074 0000     llision..exit...
 800d158:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
 800d168:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
 800d178:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
 800d188:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..
 800d198:	0030 0000 6e49 6966 696e 7974 0000 0000     0...Infinity....
 800d1a8:	614e 004e 0043 0000 4f50 4953 0058 0000     NaN.C...POSIX...
 800d1b8:	002e 0000                                   ....
